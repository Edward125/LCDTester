//
// File generated by HDevelop for HALCON/.NET (C#) Version 18.11.1.1
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp950).
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
//


using HalconDotNet;

public partial class HDevelopExport
{
  HTuple  gIsSinglePose;
  HTuple  gTerminationButtonLabel;
  HTuple  gInfoDecor;
  HTuple  gInfoPos;
  HTuple  gTitlePos;
  HTuple  gTitleDecor;
  HTuple  gAlphaDeselected;
  HTuple  gDispObjOffset;
  HTuple  gLabelsDecor;
  HTuple  gUsesOpenGL;
  HTuple ExpGetGlobalVar_gIsSinglePose()
  {
    return gIsSinglePose;
  }
  void ExpSetGlobalVar_gIsSinglePose(HTuple val)
  {
    if (gIsSinglePose!=null)
      gIsSinglePose.Dispose();
    gIsSinglePose = val;
  }

  HTuple ExpGetGlobalVar_gTerminationButtonLabel()
  {
    return gTerminationButtonLabel;
  }
  void ExpSetGlobalVar_gTerminationButtonLabel(HTuple val)
  {
    if (gTerminationButtonLabel!=null)
      gTerminationButtonLabel.Dispose();
    gTerminationButtonLabel = val;
  }

  HTuple ExpGetGlobalVar_gInfoDecor()
  {
    return gInfoDecor;
  }
  void ExpSetGlobalVar_gInfoDecor(HTuple val)
  {
    if (gInfoDecor!=null)
      gInfoDecor.Dispose();
    gInfoDecor = val;
  }

  HTuple ExpGetGlobalVar_gInfoPos()
  {
    return gInfoPos;
  }
  void ExpSetGlobalVar_gInfoPos(HTuple val)
  {
    if (gInfoPos!=null)
      gInfoPos.Dispose();
    gInfoPos = val;
  }

  HTuple ExpGetGlobalVar_gTitlePos()
  {
    return gTitlePos;
  }
  void ExpSetGlobalVar_gTitlePos(HTuple val)
  {
    if (gTitlePos!=null)
      gTitlePos.Dispose();
    gTitlePos = val;
  }

  HTuple ExpGetGlobalVar_gTitleDecor()
  {
    return gTitleDecor;
  }
  void ExpSetGlobalVar_gTitleDecor(HTuple val)
  {
    if (gTitleDecor!=null)
      gTitleDecor.Dispose();
    gTitleDecor = val;
  }

  HTuple ExpGetGlobalVar_gAlphaDeselected()
  {
    return gAlphaDeselected;
  }
  void ExpSetGlobalVar_gAlphaDeselected(HTuple val)
  {
    if (gAlphaDeselected!=null)
      gAlphaDeselected.Dispose();
    gAlphaDeselected = val;
  }

  HTuple ExpGetGlobalVar_gDispObjOffset()
  {
    return gDispObjOffset;
  }
  void ExpSetGlobalVar_gDispObjOffset(HTuple val)
  {
    if (gDispObjOffset!=null)
      gDispObjOffset.Dispose();
    gDispObjOffset = val;
  }

  HTuple ExpGetGlobalVar_gLabelsDecor()
  {
    return gLabelsDecor;
  }
  void ExpSetGlobalVar_gLabelsDecor(HTuple val)
  {
    if (gLabelsDecor!=null)
      gLabelsDecor.Dispose();
    gLabelsDecor = val;
  }

  HTuple ExpGetGlobalVar_gUsesOpenGL()
  {
    return gUsesOpenGL;
  }
  void ExpSetGlobalVar_gUsesOpenGL(HTuple val)
  {
    if (gUsesOpenGL!=null)
      gUsesOpenGL.Dispose();
    gUsesOpenGL = val;
  }

  // Procedures 
  // Chapter: Graphics / Output
  // Short Description: Reflect the pose change that was introduced by the user by moving the mouse 
  public void analyze_graph_event (HObject ho_BackgroundImage, HTuple hv_Parameters, 
      HTuple hv_MouseMapping, HTuple hv_Button, HTuple hv_Row, HTuple hv_Column, HTuple hv_WindowHandle, 
      HTuple hv_WindowHandleBuffer, HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, 
      HTuple hv_SelectedObjectIn, HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, 
      HTuple hv_CamParam, HTuple hv_Labels, HTuple hv_Title, HTuple hv_Information, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_PosesIn, HTuple hv_ButtonHoldIn, 
      HTuple hv_TBCenter, HTuple hv_TBSize, HTuple hv_WindowCenteredRotationlIn, HTuple hv_MaxNumModels, 
      HTuple hv_MessageQueue, out HTuple hv_PosesOut, out HTuple hv_SelectedObjectOut, 
      out HTuple hv_ButtonHoldOut, out HTuple hv_WindowCenteredRotationOut)
  {




    // Local iconic variables 

    HObject ho_ImageDump=null;

    // Local control variables 

    HTuple hv_VisualizeTB = new HTuple(), hv_InvLog2 = new HTuple();
    HTuple hv_Seconds = new HTuple(), hv_ModelIndex = new HTuple();
    HTuple hv_Exception1 = new HTuple(), hv_HomMat3DIdentity = new HTuple();
    HTuple hv_NumModels = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_MinImageSize = new HTuple();
    HTuple hv_TrackballRadiusPixel = new HTuple(), hv_TrackballCenterRow = new HTuple();
    HTuple hv_TrackballCenterCol = new HTuple(), hv_gIsSinglePose = new HTuple();
    HTuple hv_NumChannels = new HTuple(), hv_ColorImage = new HTuple();
    HTuple hv_BAnd = new HTuple(), hv_SensFactor = new HTuple();
    HTuple hv_IsButtonTrans = new HTuple(), hv_IsButtonRot = new HTuple();
    HTuple hv_IsButtonDist = new HTuple(), hv_MRow1 = new HTuple();
    HTuple hv_MCol1 = new HTuple(), hv_ButtonLoop = new HTuple();
    HTuple hv_MRow2 = new HTuple(), hv_MCol2 = new HTuple();
    HTuple hv_PX = new HTuple(), hv_PY = new HTuple(), hv_PZ = new HTuple();
    HTuple hv_QX1 = new HTuple(), hv_QY1 = new HTuple(), hv_QZ1 = new HTuple();
    HTuple hv_QX2 = new HTuple(), hv_QY2 = new HTuple(), hv_QZ2 = new HTuple();
    HTuple hv_Len = new HTuple(), hv_Dist = new HTuple(), hv_Translate = new HTuple();
    HTuple hv_Index = new HTuple(), hv_PoseIn = new HTuple();
    HTuple hv_HomMat3DIn = new HTuple(), hv_HomMat3DOut = new HTuple();
    HTuple hv_PoseOut = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_Sequence = new HTuple(), hv_Mod = new HTuple();
    HTuple hv_SequenceReal = new HTuple(), hv_Sequence2Int = new HTuple();
    HTuple hv_Selected = new HTuple(), hv_InvSelected = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_DRow = new HTuple();
    HTuple hv_TranslateZ = new HTuple(), hv_MX1 = new HTuple();
    HTuple hv_MY1 = new HTuple(), hv_MX2 = new HTuple(), hv_MY2 = new HTuple();
    HTuple hv_RelQuaternion = new HTuple(), hv_HomMat3DRotRel = new HTuple();
    HTuple hv_HomMat3DInTmp1 = new HTuple(), hv_HomMat3DInTmp = new HTuple();
    HTuple hv_PosesOut2 = new HTuple();
    HTuple   hv_Column_COPY_INP_TMP = new HTuple(hv_Column);
    HTuple   hv_PosesIn_COPY_INP_TMP = new HTuple(hv_PosesIn);
    HTuple   hv_Row_COPY_INP_TMP = new HTuple(hv_Row);
    HTuple   hv_TBCenter_COPY_INP_TMP = new HTuple(hv_TBCenter);
    HTuple   hv_TBSize_COPY_INP_TMP = new HTuple(hv_TBSize);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageDump);
    hv_PosesOut = new HTuple();
    hv_SelectedObjectOut = new HTuple();
    hv_ButtonHoldOut = new HTuple();
    hv_WindowCenteredRotationOut = new HTuple();
    //This procedure reflects
    //- the pose change that was introduced by the user by
    //  moving the mouse
    //- the selection of a single object
    //
    hv_ButtonHoldOut.Dispose();
    hv_ButtonHoldOut = new HTuple(hv_ButtonHoldIn);
    hv_PosesOut.Dispose();
    hv_PosesOut = new HTuple(hv_PosesIn_COPY_INP_TMP);
    hv_SelectedObjectOut.Dispose();
    hv_SelectedObjectOut = new HTuple(hv_SelectedObjectIn);
    hv_WindowCenteredRotationOut.Dispose();
    hv_WindowCenteredRotationOut = new HTuple(hv_WindowCenteredRotationlIn);
    hv_VisualizeTB.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_VisualizeTB = new HTuple(((hv_SelectedObjectOut.TupleMax()
        )).TupleNotEqual(0));
    }
    hv_InvLog2.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_InvLog2 = 1.0/((new HTuple(2)).TupleLog()
        );
    }
    //
    if ((int)(new HTuple(hv_Button.TupleEqual(hv_MouseMapping.TupleSelect(6)))) != 0)
    {
      if ((int)(hv_ButtonHoldOut) != 0)
      {
        ho_ImageDump.Dispose();

        hv_Column_COPY_INP_TMP.Dispose();
        hv_PosesIn_COPY_INP_TMP.Dispose();
        hv_Row_COPY_INP_TMP.Dispose();
        hv_TBCenter_COPY_INP_TMP.Dispose();
        hv_TBSize_COPY_INP_TMP.Dispose();
        hv_VisualizeTB.Dispose();
        hv_InvLog2.Dispose();
        hv_Seconds.Dispose();
        hv_ModelIndex.Dispose();
        hv_Exception1.Dispose();
        hv_HomMat3DIdentity.Dispose();
        hv_NumModels.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_MinImageSize.Dispose();
        hv_TrackballRadiusPixel.Dispose();
        hv_TrackballCenterRow.Dispose();
        hv_TrackballCenterCol.Dispose();
        hv_gIsSinglePose.Dispose();
        hv_NumChannels.Dispose();
        hv_ColorImage.Dispose();
        hv_BAnd.Dispose();
        hv_SensFactor.Dispose();
        hv_IsButtonTrans.Dispose();
        hv_IsButtonRot.Dispose();
        hv_IsButtonDist.Dispose();
        hv_MRow1.Dispose();
        hv_MCol1.Dispose();
        hv_ButtonLoop.Dispose();
        hv_MRow2.Dispose();
        hv_MCol2.Dispose();
        hv_PX.Dispose();
        hv_PY.Dispose();
        hv_PZ.Dispose();
        hv_QX1.Dispose();
        hv_QY1.Dispose();
        hv_QZ1.Dispose();
        hv_QX2.Dispose();
        hv_QY2.Dispose();
        hv_QZ2.Dispose();
        hv_Len.Dispose();
        hv_Dist.Dispose();
        hv_Translate.Dispose();
        hv_Index.Dispose();
        hv_PoseIn.Dispose();
        hv_HomMat3DIn.Dispose();
        hv_HomMat3DOut.Dispose();
        hv_PoseOut.Dispose();
        hv_Indices.Dispose();
        hv_Sequence.Dispose();
        hv_Mod.Dispose();
        hv_SequenceReal.Dispose();
        hv_Sequence2Int.Dispose();
        hv_Selected.Dispose();
        hv_InvSelected.Dispose();
        hv_Exception.Dispose();
        hv_DRow.Dispose();
        hv_TranslateZ.Dispose();
        hv_MX1.Dispose();
        hv_MY1.Dispose();
        hv_MX2.Dispose();
        hv_MY2.Dispose();
        hv_RelQuaternion.Dispose();
        hv_HomMat3DRotRel.Dispose();
        hv_HomMat3DInTmp1.Dispose();
        hv_HomMat3DInTmp.Dispose();
        hv_PosesOut2.Dispose();

        return;
      }
      //Ctrl (16) + Alt (32) + left mouse button (1) => Toggle rotation center position
      //If WindowCenteredRotation is not 1, set it to 1, otherwise, set it to 2
      hv_Seconds.Dispose();
      HOperatorSet.CountSeconds(out hv_Seconds);
      if ((int)(new HTuple(hv_WindowCenteredRotationOut.TupleEqual(1))) != 0)
      {
        hv_WindowCenteredRotationOut.Dispose();
        hv_WindowCenteredRotationOut = 2;
      }
      else
      {
        hv_WindowCenteredRotationOut.Dispose();
        hv_WindowCenteredRotationOut = 1;
      }
      hv_ButtonHoldOut.Dispose();
      hv_ButtonHoldOut = 1;
      ho_ImageDump.Dispose();

      hv_Column_COPY_INP_TMP.Dispose();
      hv_PosesIn_COPY_INP_TMP.Dispose();
      hv_Row_COPY_INP_TMP.Dispose();
      hv_TBCenter_COPY_INP_TMP.Dispose();
      hv_TBSize_COPY_INP_TMP.Dispose();
      hv_VisualizeTB.Dispose();
      hv_InvLog2.Dispose();
      hv_Seconds.Dispose();
      hv_ModelIndex.Dispose();
      hv_Exception1.Dispose();
      hv_HomMat3DIdentity.Dispose();
      hv_NumModels.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_MinImageSize.Dispose();
      hv_TrackballRadiusPixel.Dispose();
      hv_TrackballCenterRow.Dispose();
      hv_TrackballCenterCol.Dispose();
      hv_gIsSinglePose.Dispose();
      hv_NumChannels.Dispose();
      hv_ColorImage.Dispose();
      hv_BAnd.Dispose();
      hv_SensFactor.Dispose();
      hv_IsButtonTrans.Dispose();
      hv_IsButtonRot.Dispose();
      hv_IsButtonDist.Dispose();
      hv_MRow1.Dispose();
      hv_MCol1.Dispose();
      hv_ButtonLoop.Dispose();
      hv_MRow2.Dispose();
      hv_MCol2.Dispose();
      hv_PX.Dispose();
      hv_PY.Dispose();
      hv_PZ.Dispose();
      hv_QX1.Dispose();
      hv_QY1.Dispose();
      hv_QZ1.Dispose();
      hv_QX2.Dispose();
      hv_QY2.Dispose();
      hv_QZ2.Dispose();
      hv_Len.Dispose();
      hv_Dist.Dispose();
      hv_Translate.Dispose();
      hv_Index.Dispose();
      hv_PoseIn.Dispose();
      hv_HomMat3DIn.Dispose();
      hv_HomMat3DOut.Dispose();
      hv_PoseOut.Dispose();
      hv_Indices.Dispose();
      hv_Sequence.Dispose();
      hv_Mod.Dispose();
      hv_SequenceReal.Dispose();
      hv_Sequence2Int.Dispose();
      hv_Selected.Dispose();
      hv_InvSelected.Dispose();
      hv_Exception.Dispose();
      hv_DRow.Dispose();
      hv_TranslateZ.Dispose();
      hv_MX1.Dispose();
      hv_MY1.Dispose();
      hv_MX2.Dispose();
      hv_MY2.Dispose();
      hv_RelQuaternion.Dispose();
      hv_HomMat3DRotRel.Dispose();
      hv_HomMat3DInTmp1.Dispose();
      hv_HomMat3DInTmp.Dispose();
      hv_PosesOut2.Dispose();

      return;
    }
    if ((int)((new HTuple(hv_Button.TupleEqual(hv_MouseMapping.TupleSelect(5)))).TupleAnd(
        new HTuple((new HTuple(hv_ObjectModel3DID.TupleLength())).TupleLessEqual(
        hv_MaxNumModels)))) != 0)
    {
      if ((int)(hv_ButtonHoldOut) != 0)
      {
        ho_ImageDump.Dispose();

        hv_Column_COPY_INP_TMP.Dispose();
        hv_PosesIn_COPY_INP_TMP.Dispose();
        hv_Row_COPY_INP_TMP.Dispose();
        hv_TBCenter_COPY_INP_TMP.Dispose();
        hv_TBSize_COPY_INP_TMP.Dispose();
        hv_VisualizeTB.Dispose();
        hv_InvLog2.Dispose();
        hv_Seconds.Dispose();
        hv_ModelIndex.Dispose();
        hv_Exception1.Dispose();
        hv_HomMat3DIdentity.Dispose();
        hv_NumModels.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_MinImageSize.Dispose();
        hv_TrackballRadiusPixel.Dispose();
        hv_TrackballCenterRow.Dispose();
        hv_TrackballCenterCol.Dispose();
        hv_gIsSinglePose.Dispose();
        hv_NumChannels.Dispose();
        hv_ColorImage.Dispose();
        hv_BAnd.Dispose();
        hv_SensFactor.Dispose();
        hv_IsButtonTrans.Dispose();
        hv_IsButtonRot.Dispose();
        hv_IsButtonDist.Dispose();
        hv_MRow1.Dispose();
        hv_MCol1.Dispose();
        hv_ButtonLoop.Dispose();
        hv_MRow2.Dispose();
        hv_MCol2.Dispose();
        hv_PX.Dispose();
        hv_PY.Dispose();
        hv_PZ.Dispose();
        hv_QX1.Dispose();
        hv_QY1.Dispose();
        hv_QZ1.Dispose();
        hv_QX2.Dispose();
        hv_QY2.Dispose();
        hv_QZ2.Dispose();
        hv_Len.Dispose();
        hv_Dist.Dispose();
        hv_Translate.Dispose();
        hv_Index.Dispose();
        hv_PoseIn.Dispose();
        hv_HomMat3DIn.Dispose();
        hv_HomMat3DOut.Dispose();
        hv_PoseOut.Dispose();
        hv_Indices.Dispose();
        hv_Sequence.Dispose();
        hv_Mod.Dispose();
        hv_SequenceReal.Dispose();
        hv_Sequence2Int.Dispose();
        hv_Selected.Dispose();
        hv_InvSelected.Dispose();
        hv_Exception.Dispose();
        hv_DRow.Dispose();
        hv_TranslateZ.Dispose();
        hv_MX1.Dispose();
        hv_MY1.Dispose();
        hv_MX2.Dispose();
        hv_MY2.Dispose();
        hv_RelQuaternion.Dispose();
        hv_HomMat3DRotRel.Dispose();
        hv_HomMat3DInTmp1.Dispose();
        hv_HomMat3DInTmp.Dispose();
        hv_PosesOut2.Dispose();

        return;
      }
      //Ctrl (16) + left mouse button (1) => Select an object
      try
      {
        HOperatorSet.SetScene3dParam(hv_Scene3D, "object_index_persistence", "true");
        HOperatorSet.DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
        hv_ModelIndex.Dispose();
        HOperatorSet.GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Row_COPY_INP_TMP, 
            hv_Column_COPY_INP_TMP, "object_index", out hv_ModelIndex);
        HOperatorSet.SetScene3dParam(hv_Scene3D, "object_index_persistence", "false");
      }
      // catch (Exception1) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception1);
        //* NO OpenGL, no selection possible
        ho_ImageDump.Dispose();

        hv_Column_COPY_INP_TMP.Dispose();
        hv_PosesIn_COPY_INP_TMP.Dispose();
        hv_Row_COPY_INP_TMP.Dispose();
        hv_TBCenter_COPY_INP_TMP.Dispose();
        hv_TBSize_COPY_INP_TMP.Dispose();
        hv_VisualizeTB.Dispose();
        hv_InvLog2.Dispose();
        hv_Seconds.Dispose();
        hv_ModelIndex.Dispose();
        hv_Exception1.Dispose();
        hv_HomMat3DIdentity.Dispose();
        hv_NumModels.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_MinImageSize.Dispose();
        hv_TrackballRadiusPixel.Dispose();
        hv_TrackballCenterRow.Dispose();
        hv_TrackballCenterCol.Dispose();
        hv_gIsSinglePose.Dispose();
        hv_NumChannels.Dispose();
        hv_ColorImage.Dispose();
        hv_BAnd.Dispose();
        hv_SensFactor.Dispose();
        hv_IsButtonTrans.Dispose();
        hv_IsButtonRot.Dispose();
        hv_IsButtonDist.Dispose();
        hv_MRow1.Dispose();
        hv_MCol1.Dispose();
        hv_ButtonLoop.Dispose();
        hv_MRow2.Dispose();
        hv_MCol2.Dispose();
        hv_PX.Dispose();
        hv_PY.Dispose();
        hv_PZ.Dispose();
        hv_QX1.Dispose();
        hv_QY1.Dispose();
        hv_QZ1.Dispose();
        hv_QX2.Dispose();
        hv_QY2.Dispose();
        hv_QZ2.Dispose();
        hv_Len.Dispose();
        hv_Dist.Dispose();
        hv_Translate.Dispose();
        hv_Index.Dispose();
        hv_PoseIn.Dispose();
        hv_HomMat3DIn.Dispose();
        hv_HomMat3DOut.Dispose();
        hv_PoseOut.Dispose();
        hv_Indices.Dispose();
        hv_Sequence.Dispose();
        hv_Mod.Dispose();
        hv_SequenceReal.Dispose();
        hv_Sequence2Int.Dispose();
        hv_Selected.Dispose();
        hv_InvSelected.Dispose();
        hv_Exception.Dispose();
        hv_DRow.Dispose();
        hv_TranslateZ.Dispose();
        hv_MX1.Dispose();
        hv_MY1.Dispose();
        hv_MX2.Dispose();
        hv_MY2.Dispose();
        hv_RelQuaternion.Dispose();
        hv_HomMat3DRotRel.Dispose();
        hv_HomMat3DInTmp1.Dispose();
        hv_HomMat3DInTmp.Dispose();
        hv_PosesOut2.Dispose();

        return;
      }
      if ((int)(new HTuple(hv_ModelIndex.TupleEqual(-1))) != 0)
      {
        //Background click:
        if ((int)(new HTuple(((hv_SelectedObjectOut.TupleSum())).TupleEqual(new HTuple(hv_SelectedObjectOut.TupleLength()
            )))) != 0)
        {
          //If all objects are already selected, deselect all
          hv_SelectedObjectOut.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SelectedObjectOut = HTuple.TupleGenConst(
              new HTuple(hv_ObjectModel3DID.TupleLength()),0);
          }
        }
        else
        {
          //Otherwise select all
          hv_SelectedObjectOut.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SelectedObjectOut = HTuple.TupleGenConst(
              new HTuple(hv_ObjectModel3DID.TupleLength()),1);
          }
        }
      }
      else
      {
        //Object click:
        if (hv_SelectedObjectOut == null)
          hv_SelectedObjectOut = new HTuple();
        hv_SelectedObjectOut[hv_ModelIndex] = ((hv_SelectedObjectOut.TupleSelect(
            hv_ModelIndex))).TupleNot();
      }
      hv_ButtonHoldOut.Dispose();
      hv_ButtonHoldOut = 1;
    }
    else
    {
      //Change the pose
      hv_HomMat3DIdentity.Dispose();
      HOperatorSet.HomMat3dIdentity(out hv_HomMat3DIdentity);
      hv_NumModels.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumModels = new HTuple(hv_ObjectModel3DID.TupleLength()
          );
      }
      hv_Width.Dispose();
      get_cam_par_data(hv_CamParam, "image_width", out hv_Width);
      hv_Height.Dispose();
      get_cam_par_data(hv_CamParam, "image_height", out hv_Height);
      hv_MinImageSize.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinImageSize = ((hv_Width.TupleConcat(
          hv_Height))).TupleMin();
      }
      hv_TrackballRadiusPixel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize)/2.0;
      }
      //Set trackball fixed in the center of the window
      hv_TrackballCenterRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrackballCenterRow = hv_Height/2;
      }
      hv_TrackballCenterCol.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrackballCenterCol = hv_Width/2;
      }
      if ((int)(new HTuple((new HTuple(hv_ObjectModel3DID.TupleLength())).TupleLess(
          hv_MaxNumModels))) != 0)
      {
        if ((int)(new HTuple(hv_WindowCenteredRotationOut.TupleEqual(1))) != 0)
        {
          hv_TBCenter_COPY_INP_TMP.Dispose();hv_TBSize_COPY_INP_TMP.Dispose();
          get_trackball_center_fixed(hv_SelectedObjectIn, hv_TrackballCenterRow, 
              hv_TrackballCenterCol, hv_TrackballRadiusPixel, hv_Scene3D, hv_ObjectModel3DID, 
              hv_PosesIn_COPY_INP_TMP, hv_WindowHandleBuffer, hv_CamParam, hv_GenParamName, 
              hv_GenParamValue, out hv_TBCenter_COPY_INP_TMP, out hv_TBSize_COPY_INP_TMP);
        }
        else
        {
          hv_TBCenter_COPY_INP_TMP.Dispose();hv_TBSize_COPY_INP_TMP.Dispose();
          get_trackball_center(hv_SelectedObjectIn, hv_TrackballRadiusPixel, hv_ObjectModel3DID, 
              hv_PosesIn_COPY_INP_TMP, out hv_TBCenter_COPY_INP_TMP, out hv_TBSize_COPY_INP_TMP);
        }
      }
      if ((int)((new HTuple(((hv_SelectedObjectOut.TupleMin())).TupleEqual(0))).TupleAnd(
          new HTuple(((hv_SelectedObjectOut.TupleMax())).TupleEqual(1)))) != 0)
      {
        //At this point, multiple objects do not necessary have the same
        //pose any more. Consequently, we have to return a tuple of poses
        //as output of visualize_object_model_3d
        hv_gIsSinglePose.Dispose();
        hv_gIsSinglePose = 0;
        HOperatorSet.SetMessageTuple(hv_Parameters, "gIsSinglePose", hv_gIsSinglePose);
      }
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_BackgroundImage, out hv_NumChannels);
      hv_ColorImage.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColorImage = new HTuple(hv_NumChannels.TupleEqual(
          3));
      }
      //Alt (32) => lower sensitivity
      hv_BAnd.Dispose();
      HOperatorSet.TupleRsh(hv_Button, 5, out hv_BAnd);
      if ((int)(hv_BAnd%2) != 0)
      {
        hv_SensFactor.Dispose();
        hv_SensFactor = 0.1;
      }
      else
      {
        hv_SensFactor.Dispose();
        hv_SensFactor = 1.0;
      }
      hv_IsButtonTrans.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IsButtonTrans = (new HTuple(((hv_MouseMapping.TupleSelect(
          0))).TupleEqual(hv_Button))).TupleOr(new HTuple(((32+(hv_MouseMapping.TupleSelect(
          0)))).TupleEqual(hv_Button)));
      }
      hv_IsButtonRot.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IsButtonRot = (new HTuple(((hv_MouseMapping.TupleSelect(
          1))).TupleEqual(hv_Button))).TupleOr(new HTuple(((32+(hv_MouseMapping.TupleSelect(
          1)))).TupleEqual(hv_Button)));
      }
      hv_IsButtonDist.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IsButtonDist = (new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(((hv_MouseMapping.TupleSelect(
          2))).TupleEqual(hv_Button))).TupleOr(new HTuple(((32+(hv_MouseMapping.TupleSelect(
          2)))).TupleEqual(hv_Button))))).TupleOr(new HTuple(((hv_MouseMapping.TupleSelect(
          3))).TupleEqual(hv_Button))))).TupleOr(new HTuple(((32+(hv_MouseMapping.TupleSelect(
          3)))).TupleEqual(hv_Button))))).TupleOr(new HTuple(((hv_MouseMapping.TupleSelect(
          4))).TupleEqual(hv_Button))))).TupleOr(new HTuple(((32+(hv_MouseMapping.TupleSelect(
          4)))).TupleEqual(hv_Button)));
      }
      if ((int)(hv_IsButtonTrans) != 0)
      {
        //Translate in XY-direction
        hv_MRow1.Dispose();
        hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
        hv_MCol1.Dispose();
        hv_MCol1 = new HTuple(hv_Column_COPY_INP_TMP);
        while ((int)(hv_IsButtonTrans) != 0)
        {
          try
          {
            hv_Row_COPY_INP_TMP.Dispose();hv_Column_COPY_INP_TMP.Dispose();hv_ButtonLoop.Dispose();
            get_mouse_info(hv_WindowHandle, hv_MessageQueue, new HTuple(), out hv_Row_COPY_INP_TMP, 
                out hv_Column_COPY_INP_TMP, out hv_ButtonLoop);
            hv_IsButtonTrans.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_IsButtonTrans = new HTuple(hv_ButtonLoop.TupleEqual(
                hv_Button));
            }
            hv_MRow2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MRow2 = hv_MRow1+((hv_Row_COPY_INP_TMP-hv_MRow1)*hv_SensFactor);
            }
            hv_MCol2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MCol2 = hv_MCol1+((hv_Column_COPY_INP_TMP-hv_MCol1)*hv_SensFactor);
            }
            hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
            HOperatorSet.GetLineOfSight(hv_MRow1, hv_MCol1, hv_CamParam, out hv_PX, 
                out hv_PY, out hv_PZ, out hv_QX1, out hv_QY1, out hv_QZ1);
            hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX2.Dispose();hv_QY2.Dispose();hv_QZ2.Dispose();
            HOperatorSet.GetLineOfSight(hv_MRow2, hv_MCol2, hv_CamParam, out hv_PX, 
                out hv_PY, out hv_PZ, out hv_QX2, out hv_QY2, out hv_QZ2);
            hv_Len.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Len = ((((hv_QX1*hv_QX1)+(hv_QY1*hv_QY1))+(hv_QZ1*hv_QZ1))).TupleSqrt()
                ;
            }
            hv_Dist.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Dist = (((((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                0))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(0)))+((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                1))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(1))))+((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                2))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(2))))).TupleSqrt();
            }
            hv_Translate.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Translate = ((((((hv_QX2-hv_QX1)).TupleConcat(
                hv_QY2-hv_QY1))).TupleConcat(hv_QZ2-hv_QZ1))*hv_Dist)/hv_Len;
            }
            hv_PosesOut.Dispose();
            hv_PosesOut = new HTuple();
            if ((int)(new HTuple(hv_NumModels.TupleLessEqual(hv_MaxNumModels))) != 0)
            {
              HTuple end_val109 = hv_NumModels-1;
              HTuple step_val109 = 1;
              for (hv_Index=0; hv_Index.Continue(end_val109, step_val109); hv_Index = hv_Index.TupleAdd(step_val109))
              {
                hv_PoseIn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                    hv_Index*7,(hv_Index*7)+6);
                }
                if ((int)(hv_SelectedObjectOut.TupleSelect(hv_Index)) != 0)
                {
                  hv_HomMat3DIn.Dispose();
                  HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_HomMat3DOut.Dispose();
                  HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, hv_Translate.TupleSelect(
                      0), hv_Translate.TupleSelect(1), hv_Translate.TupleSelect(2), 
                      out hv_HomMat3DOut);
                  }
                  hv_PoseOut.Dispose();
                  HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
                  HOperatorSet.SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
                }
                else
                {
                  hv_PoseOut.Dispose();
                  hv_PoseOut = new HTuple(hv_PoseIn);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_PosesOut = hv_PosesOut.TupleConcat(
                    hv_PoseOut);
                hv_PosesOut.Dispose();
                hv_PosesOut = ExpTmpLocalVar_PosesOut;
                }
                }
              }
            }
            else
            {
              hv_Indices.Dispose();
              HOperatorSet.TupleFind(hv_SelectedObjectOut, 1, out hv_Indices);
              hv_PoseIn.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                  (hv_Indices.TupleSelect(0))*7,((hv_Indices.TupleSelect(0))*7)+6);
              }
              hv_HomMat3DIn.Dispose();
              HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_HomMat3DOut.Dispose();
              HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, hv_Translate.TupleSelect(
                  0), hv_Translate.TupleSelect(1), hv_Translate.TupleSelect(2), out hv_HomMat3DOut);
              }
              hv_PoseOut.Dispose();
              HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
              hv_Sequence.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence = HTuple.TupleGenSequence(
                  0,(hv_NumModels*7)-1,1);
              }
              hv_Mod.Dispose();
              HOperatorSet.TupleMod(hv_Sequence, 7, out hv_Mod);
              hv_SequenceReal.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SequenceReal = HTuple.TupleGenSequence(
                  0,hv_NumModels-(1.0/7.0),1.0/7.0);
              }
              hv_Sequence2Int.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence2Int = hv_SequenceReal.TupleInt()
                  ;
              }
              hv_Selected.Dispose();
              HOperatorSet.TupleSelect(hv_SelectedObjectOut, hv_Sequence2Int, out hv_Selected);
              hv_InvSelected.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_InvSelected = 1-hv_Selected;
              }
              hv_PosesOut.Dispose();
              HOperatorSet.TupleSelect(hv_PoseOut, hv_Mod, out hv_PosesOut);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_PosesOut = (hv_PosesOut*hv_Selected)+(hv_PosesIn_COPY_INP_TMP*hv_InvSelected);
              hv_PosesOut.Dispose();
              hv_PosesOut = ExpTmpLocalVar_PosesOut;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetScene3dInstancePose(hv_Scene3D, HTuple.TupleGenSequence(
                  0,hv_NumModels-1,1), hv_PosesOut);
              }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            dump_image_output(ho_BackgroundImage, hv_Parameters, hv_WindowHandleBuffer, 
                hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
                hv_CamParam, hv_PosesOut, hv_ColorImage, hv_Title, hv_Information, 
                hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
                hv_TBSize_COPY_INP_TMP, hv_SelectedObjectOut, new HTuple(hv_WindowCenteredRotationOut.TupleEqual(
                1)), hv_TBCenter_COPY_INP_TMP, new HTuple(), new HTuple(), new HTuple(), 
                new HTuple());
            }
            ho_ImageDump.Dispose();
            HOperatorSet.DumpWindowImage(out ho_ImageDump, hv_WindowHandleBuffer);
            //dev_set_window (WindowHandle)
            if (HDevWindowStack.IsOpen())
            {
              //dev_display (ImageDump)
            }
            HOperatorSet.DispObj(ho_ImageDump, hv_WindowHandle);
            send_pose_update(hv_Parameters, hv_PosesOut);
            //
            hv_MRow1.Dispose();
            hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
            hv_MCol1.Dispose();
            hv_MCol1 = new HTuple(hv_Column_COPY_INP_TMP);
            hv_PosesIn_COPY_INP_TMP.Dispose();
            hv_PosesIn_COPY_INP_TMP = new HTuple(hv_PosesOut);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            //Keep waiting
          }
        }
      }
      else if ((int)(hv_IsButtonDist) != 0)
      {
        //Change the Z distance
        hv_MRow1.Dispose();
        hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
        while ((int)(hv_IsButtonDist) != 0)
        {
          try
          {
            hv_Row_COPY_INP_TMP.Dispose();hv_Column_COPY_INP_TMP.Dispose();hv_ButtonLoop.Dispose();
            get_mouse_info(hv_WindowHandle, hv_MessageQueue, new HTuple(), out hv_Row_COPY_INP_TMP, 
                out hv_Column_COPY_INP_TMP, out hv_ButtonLoop);
            hv_IsButtonDist.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_IsButtonDist = new HTuple(hv_ButtonLoop.TupleEqual(
                hv_Button));
            }
            hv_MRow2.Dispose();
            hv_MRow2 = new HTuple(hv_Row_COPY_INP_TMP);
            hv_DRow.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_DRow = hv_MRow2-hv_MRow1;
            }
            hv_Dist.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Dist = (((((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                0))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(0)))+((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                1))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(1))))+((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                2))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(2))))).TupleSqrt();
            }
            hv_TranslateZ.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TranslateZ = (((-hv_Dist)*hv_DRow)*0.003)*hv_SensFactor;
            }
            if (hv_TBCenter_COPY_INP_TMP == null)
              hv_TBCenter_COPY_INP_TMP = new HTuple();
            hv_TBCenter_COPY_INP_TMP[2] = (hv_TBCenter_COPY_INP_TMP.TupleSelect(2))+hv_TranslateZ;
            hv_PosesOut.Dispose();
            hv_PosesOut = new HTuple();
            if ((int)(new HTuple(hv_NumModels.TupleLessEqual(hv_MaxNumModels))) != 0)
            {
              HTuple end_val165 = hv_NumModels-1;
              HTuple step_val165 = 1;
              for (hv_Index=0; hv_Index.Continue(end_val165, step_val165); hv_Index = hv_Index.TupleAdd(step_val165))
              {
                hv_PoseIn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                    hv_Index*7,(hv_Index*7)+6);
                }
                if ((int)(hv_SelectedObjectOut.TupleSelect(hv_Index)) != 0)
                {
                  //Transform the whole scene or selected object only
                  hv_HomMat3DIn.Dispose();
                  HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
                  hv_HomMat3DOut.Dispose();
                  HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, 
                      out hv_HomMat3DOut);
                  hv_PoseOut.Dispose();
                  HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
                  HOperatorSet.SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
                }
                else
                {
                  hv_PoseOut.Dispose();
                  hv_PoseOut = new HTuple(hv_PoseIn);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_PosesOut = hv_PosesOut.TupleConcat(
                    hv_PoseOut);
                hv_PosesOut.Dispose();
                hv_PosesOut = ExpTmpLocalVar_PosesOut;
                }
                }
              }
            }
            else
            {
              hv_Indices.Dispose();
              HOperatorSet.TupleFind(hv_SelectedObjectOut, 1, out hv_Indices);
              hv_PoseIn.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                  (hv_Indices.TupleSelect(0))*7,((hv_Indices.TupleSelect(0))*7)+6);
              }
              hv_HomMat3DIn.Dispose();
              HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
              hv_HomMat3DOut.Dispose();
              HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, 
                  out hv_HomMat3DOut);
              hv_PoseOut.Dispose();
              HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
              hv_Sequence.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence = HTuple.TupleGenSequence(
                  0,(hv_NumModels*7)-1,1);
              }
              hv_Mod.Dispose();
              HOperatorSet.TupleMod(hv_Sequence, 7, out hv_Mod);
              hv_SequenceReal.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SequenceReal = HTuple.TupleGenSequence(
                  0,hv_NumModels-(1.0/7.0),1.0/7.0);
              }
              hv_Sequence2Int.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence2Int = hv_SequenceReal.TupleInt()
                  ;
              }
              hv_Selected.Dispose();
              HOperatorSet.TupleSelect(hv_SelectedObjectOut, hv_Sequence2Int, out hv_Selected);
              hv_InvSelected.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_InvSelected = 1-hv_Selected;
              }
              hv_PosesOut.Dispose();
              HOperatorSet.TupleSelect(hv_PoseOut, hv_Mod, out hv_PosesOut);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_PosesOut = (hv_PosesOut*hv_Selected)+(hv_PosesIn_COPY_INP_TMP*hv_InvSelected);
              hv_PosesOut.Dispose();
              hv_PosesOut = ExpTmpLocalVar_PosesOut;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetScene3dInstancePose(hv_Scene3D, HTuple.TupleGenSequence(
                  0,hv_NumModels-1,1), hv_PosesOut);
              }
            }
            dump_image_output(ho_BackgroundImage, hv_Parameters, hv_WindowHandleBuffer, 
                hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
                hv_CamParam, hv_PosesOut, hv_ColorImage, hv_Title, hv_Information, 
                hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
                hv_TBSize_COPY_INP_TMP, hv_SelectedObjectOut, hv_WindowCenteredRotationOut, 
                hv_TBCenter_COPY_INP_TMP, new HTuple(), new HTuple(), new HTuple(), 
                new HTuple());
            ho_ImageDump.Dispose();
            HOperatorSet.DumpWindowImage(out ho_ImageDump, hv_WindowHandleBuffer);
            //dev_set_window (WindowHandle)
            if (HDevWindowStack.IsOpen())
            {
              //dev_display (ImageDump)
            }
            HOperatorSet.DispObj(ho_ImageDump, hv_WindowHandle);
            send_pose_update(hv_Parameters, hv_PosesOut);
            //
            hv_MRow1.Dispose();
            hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
            hv_PosesIn_COPY_INP_TMP.Dispose();
            hv_PosesIn_COPY_INP_TMP = new HTuple(hv_PosesOut);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            //Keep waiting
          }
        }
      }
      else if ((int)(hv_IsButtonRot) != 0)
      {
        //Rotate the object
        hv_MRow1.Dispose();
        hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
        hv_MCol1.Dispose();
        hv_MCol1 = new HTuple(hv_Column_COPY_INP_TMP);
        while ((int)(hv_IsButtonRot) != 0)
        {
          try
          {
            hv_Row_COPY_INP_TMP.Dispose();hv_Column_COPY_INP_TMP.Dispose();hv_ButtonLoop.Dispose();
            get_mouse_info(hv_WindowHandle, hv_MessageQueue, new HTuple(), out hv_Row_COPY_INP_TMP, 
                out hv_Column_COPY_INP_TMP, out hv_ButtonLoop);
            hv_IsButtonRot.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_IsButtonRot = new HTuple(hv_ButtonLoop.TupleEqual(
                hv_Button));
            }
            hv_MRow2.Dispose();
            hv_MRow2 = new HTuple(hv_Row_COPY_INP_TMP);
            hv_MCol2.Dispose();
            hv_MCol2 = new HTuple(hv_Column_COPY_INP_TMP);
            //Transform the pixel coordinates to relative image coordinates
            hv_MX1.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MX1 = (hv_TrackballCenterCol-hv_MCol1)/(0.5*hv_MinImageSize);
            }
            hv_MY1.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MY1 = (hv_TrackballCenterRow-hv_MRow1)/(0.5*hv_MinImageSize);
            }
            hv_MX2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MX2 = (hv_TrackballCenterCol-hv_MCol2)/(0.5*hv_MinImageSize);
            }
            hv_MY2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MY2 = (hv_TrackballCenterRow-hv_MRow2)/(0.5*hv_MinImageSize);
            }
            //Compute the quaternion rotation that corresponds to the mouse
            //movement
            hv_RelQuaternion.Dispose();
            trackball(hv_MX1, hv_MY1, hv_MX2, hv_MY2, hv_VirtualTrackball, hv_TrackballSize, 
                hv_SensFactor, out hv_RelQuaternion);
            //Transform the quaternion to a rotation matrix
            hv_HomMat3DRotRel.Dispose();
            HOperatorSet.QuatToHomMat3d(hv_RelQuaternion, out hv_HomMat3DRotRel);
            hv_PosesOut.Dispose();
            hv_PosesOut = new HTuple();
            if ((int)(new HTuple(hv_NumModels.TupleLessEqual(hv_MaxNumModels))) != 0)
            {
              HTuple end_val229 = hv_NumModels-1;
              HTuple step_val229 = 1;
              for (hv_Index=0; hv_Index.Continue(end_val229, step_val229); hv_Index = hv_Index.TupleAdd(step_val229))
              {
                hv_PoseIn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                    hv_Index*7,(hv_Index*7)+6);
                }
                if ((int)(hv_SelectedObjectOut.TupleSelect(hv_Index)) != 0)
                {
                  //Transform the whole scene or selected object only
                  hv_HomMat3DIn.Dispose();
                  HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  HTuple ExpTmpOutVar_0;
                  HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, -(hv_TBCenter_COPY_INP_TMP.TupleSelect(
                      0)), -(hv_TBCenter_COPY_INP_TMP.TupleSelect(1)), -(hv_TBCenter_COPY_INP_TMP.TupleSelect(
                      2)), out ExpTmpOutVar_0);
                  hv_HomMat3DIn.Dispose();
                  hv_HomMat3DIn = ExpTmpOutVar_0;
                  }
                  {
                  HTuple ExpTmpOutVar_0;
                  HOperatorSet.HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DIn, 
                      out ExpTmpOutVar_0);
                  hv_HomMat3DIn.Dispose();
                  hv_HomMat3DIn = ExpTmpOutVar_0;
                  }
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_HomMat3DOut.Dispose();
                  HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, hv_TBCenter_COPY_INP_TMP.TupleSelect(
                      0), hv_TBCenter_COPY_INP_TMP.TupleSelect(1), hv_TBCenter_COPY_INP_TMP.TupleSelect(
                      2), out hv_HomMat3DOut);
                  }
                  hv_PoseOut.Dispose();
                  HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
                  HOperatorSet.SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
                }
                else
                {
                  hv_PoseOut.Dispose();
                  hv_PoseOut = new HTuple(hv_PoseIn);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_PosesOut = hv_PosesOut.TupleConcat(
                    hv_PoseOut);
                hv_PosesOut.Dispose();
                hv_PosesOut = ExpTmpLocalVar_PosesOut;
                }
                }
              }
            }
            else
            {
              hv_Indices.Dispose();
              HOperatorSet.TupleFind(hv_SelectedObjectOut, 1, out hv_Indices);
              hv_PoseIn.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                  (hv_Indices.TupleSelect(0))*7,((hv_Indices.TupleSelect(0))*7)+6);
              }
              hv_HomMat3DIn.Dispose();
              HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_HomMat3DInTmp1.Dispose();
              HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, -(hv_TBCenter_COPY_INP_TMP.TupleSelect(
                  0)), -(hv_TBCenter_COPY_INP_TMP.TupleSelect(1)), -(hv_TBCenter_COPY_INP_TMP.TupleSelect(
                  2)), out hv_HomMat3DInTmp1);
              }
              hv_HomMat3DInTmp.Dispose();
              HOperatorSet.HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DInTmp1, 
                  out hv_HomMat3DInTmp);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_HomMat3DOut.Dispose();
              HOperatorSet.HomMat3dTranslate(hv_HomMat3DInTmp, hv_TBCenter_COPY_INP_TMP.TupleSelect(
                  0), hv_TBCenter_COPY_INP_TMP.TupleSelect(1), hv_TBCenter_COPY_INP_TMP.TupleSelect(
                  2), out hv_HomMat3DOut);
              }
              hv_PoseOut.Dispose();
              HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
              hv_Sequence.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence = HTuple.TupleGenSequence(
                  0,(hv_NumModels*7)-1,1);
              }
              hv_Mod.Dispose();
              HOperatorSet.TupleMod(hv_Sequence, 7, out hv_Mod);
              hv_SequenceReal.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SequenceReal = HTuple.TupleGenSequence(
                  0,hv_NumModels-(1.0/7.0),1.0/7.0);
              }
              hv_Sequence2Int.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence2Int = hv_SequenceReal.TupleInt()
                  ;
              }
              hv_Selected.Dispose();
              HOperatorSet.TupleSelect(hv_SelectedObjectOut, hv_Sequence2Int, out hv_Selected);
              hv_InvSelected.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_InvSelected = 1-hv_Selected;
              }
              hv_PosesOut.Dispose();
              HOperatorSet.TupleSelect(hv_PoseOut, hv_Mod, out hv_PosesOut);
              hv_PosesOut2.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PosesOut2 = (hv_PosesOut*hv_Selected)+(hv_PosesIn_COPY_INP_TMP*hv_InvSelected);
              }
              hv_PosesOut.Dispose();
              hv_PosesOut = new HTuple(hv_PosesOut2);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetScene3dInstancePose(hv_Scene3D, HTuple.TupleGenSequence(
                  0,hv_NumModels-1,1), hv_PosesOut);
              }
            }
            dump_image_output(ho_BackgroundImage, hv_Parameters, hv_WindowHandleBuffer, 
                hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
                hv_CamParam, hv_PosesOut, hv_ColorImage, hv_Title, hv_Information, 
                hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
                hv_TBSize_COPY_INP_TMP, hv_SelectedObjectOut, hv_WindowCenteredRotationOut, 
                hv_TBCenter_COPY_INP_TMP, new HTuple(), new HTuple(), new HTuple(), 
                new HTuple());
            ho_ImageDump.Dispose();
            HOperatorSet.DumpWindowImage(out ho_ImageDump, hv_WindowHandleBuffer);
            //dev_set_window (WindowHandle)
            if (HDevWindowStack.IsOpen())
            {
              //dev_display (ImageDump)
            }
            HOperatorSet.DispObj(ho_ImageDump, hv_WindowHandle);
            send_pose_update(hv_Parameters, hv_PosesOut);
            //
            hv_MRow1.Dispose();
            hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
            hv_MCol1.Dispose();
            hv_MCol1 = new HTuple(hv_Column_COPY_INP_TMP);
            hv_PosesIn_COPY_INP_TMP.Dispose();
            hv_PosesIn_COPY_INP_TMP = new HTuple(hv_PosesOut);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            //Keep waiting
          }
        }
      }
      hv_PosesOut.Dispose();
      hv_PosesOut = new HTuple(hv_PosesIn_COPY_INP_TMP);
    }
    ho_ImageDump.Dispose();

    hv_Column_COPY_INP_TMP.Dispose();
    hv_PosesIn_COPY_INP_TMP.Dispose();
    hv_Row_COPY_INP_TMP.Dispose();
    hv_TBCenter_COPY_INP_TMP.Dispose();
    hv_TBSize_COPY_INP_TMP.Dispose();
    hv_VisualizeTB.Dispose();
    hv_InvLog2.Dispose();
    hv_Seconds.Dispose();
    hv_ModelIndex.Dispose();
    hv_Exception1.Dispose();
    hv_HomMat3DIdentity.Dispose();
    hv_NumModels.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_MinImageSize.Dispose();
    hv_TrackballRadiusPixel.Dispose();
    hv_TrackballCenterRow.Dispose();
    hv_TrackballCenterCol.Dispose();
    hv_gIsSinglePose.Dispose();
    hv_NumChannels.Dispose();
    hv_ColorImage.Dispose();
    hv_BAnd.Dispose();
    hv_SensFactor.Dispose();
    hv_IsButtonTrans.Dispose();
    hv_IsButtonRot.Dispose();
    hv_IsButtonDist.Dispose();
    hv_MRow1.Dispose();
    hv_MCol1.Dispose();
    hv_ButtonLoop.Dispose();
    hv_MRow2.Dispose();
    hv_MCol2.Dispose();
    hv_PX.Dispose();
    hv_PY.Dispose();
    hv_PZ.Dispose();
    hv_QX1.Dispose();
    hv_QY1.Dispose();
    hv_QZ1.Dispose();
    hv_QX2.Dispose();
    hv_QY2.Dispose();
    hv_QZ2.Dispose();
    hv_Len.Dispose();
    hv_Dist.Dispose();
    hv_Translate.Dispose();
    hv_Index.Dispose();
    hv_PoseIn.Dispose();
    hv_HomMat3DIn.Dispose();
    hv_HomMat3DOut.Dispose();
    hv_PoseOut.Dispose();
    hv_Indices.Dispose();
    hv_Sequence.Dispose();
    hv_Mod.Dispose();
    hv_SequenceReal.Dispose();
    hv_Sequence2Int.Dispose();
    hv_Selected.Dispose();
    hv_InvSelected.Dispose();
    hv_Exception.Dispose();
    hv_DRow.Dispose();
    hv_TranslateZ.Dispose();
    hv_MX1.Dispose();
    hv_MY1.Dispose();
    hv_MX2.Dispose();
    hv_MY2.Dispose();
    hv_RelQuaternion.Dispose();
    hv_HomMat3DRotRel.Dispose();
    hv_HomMat3DInTmp1.Dispose();
    hv_HomMat3DInTmp.Dispose();
    hv_PosesOut2.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Reflect the pose change that was introduced by the user by moving the mouse 
  public void analyze_graph_event_visualize_object_model_3d (HObject ho_BackgroundImage, 
      HTuple hv_MouseMapping, HTuple hv_Button, HTuple hv_Row, HTuple hv_Column, HTuple hv_WindowHandle, 
      HTuple hv_WindowHandleBuffer, HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, 
      HTuple hv_SelectedObjectIn, HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, 
      HTuple hv_CamParam, HTuple hv_Labels, HTuple hv_Title, HTuple hv_Information, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_PosesIn, HTuple hv_ButtonHoldIn, 
      HTuple hv_TBCenter, HTuple hv_TBSize, HTuple hv_WindowCenteredRotationlIn, HTuple hv_MaxNumModels, 
      out HTuple hv_PosesOut, out HTuple hv_SelectedObjectOut, out HTuple hv_ButtonHoldOut, 
      out HTuple hv_WindowCenteredRotationOut)
  {




    // Local iconic variables 

    HObject ho_ImageDump=null;

    // Local control variables 

    HTuple ExpTmpLocalVar_gIsSinglePose = new HTuple();
    HTuple hv_VisualizeTB = new HTuple(), hv_InvLog2 = new HTuple();
    HTuple hv_Seconds = new HTuple(), hv_ModelIndex = new HTuple();
    HTuple hv_Exception1 = new HTuple(), hv_HomMat3DIdentity = new HTuple();
    HTuple hv_NumModels = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_MinImageSize = new HTuple();
    HTuple hv_TrackballRadiusPixel = new HTuple(), hv_TrackballCenterRow = new HTuple();
    HTuple hv_TrackballCenterCol = new HTuple(), hv_NumChannels = new HTuple();
    HTuple hv_ColorImage = new HTuple(), hv_BAnd = new HTuple();
    HTuple hv_SensFactor = new HTuple(), hv_IsButtonTrans = new HTuple();
    HTuple hv_IsButtonRot = new HTuple(), hv_IsButtonDist = new HTuple();
    HTuple hv_MRow1 = new HTuple(), hv_MCol1 = new HTuple();
    HTuple hv_ButtonLoop = new HTuple(), hv_MRow2 = new HTuple();
    HTuple hv_MCol2 = new HTuple(), hv_PX = new HTuple(), hv_PY = new HTuple();
    HTuple hv_PZ = new HTuple(), hv_QX1 = new HTuple(), hv_QY1 = new HTuple();
    HTuple hv_QZ1 = new HTuple(), hv_QX2 = new HTuple(), hv_QY2 = new HTuple();
    HTuple hv_QZ2 = new HTuple(), hv_Len = new HTuple(), hv_Dist = new HTuple();
    HTuple hv_Translate = new HTuple(), hv_Index = new HTuple();
    HTuple hv_PoseIn = new HTuple(), hv_HomMat3DIn = new HTuple();
    HTuple hv_HomMat3DOut = new HTuple(), hv_PoseOut = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_Sequence = new HTuple();
    HTuple hv_Mod = new HTuple(), hv_SequenceReal = new HTuple();
    HTuple hv_Sequence2Int = new HTuple(), hv_Selected = new HTuple();
    HTuple hv_InvSelected = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_DRow = new HTuple(), hv_TranslateZ = new HTuple();
    HTuple hv_MX1 = new HTuple(), hv_MY1 = new HTuple(), hv_MX2 = new HTuple();
    HTuple hv_MY2 = new HTuple(), hv_RelQuaternion = new HTuple();
    HTuple hv_HomMat3DRotRel = new HTuple(), hv_HomMat3DInTmp1 = new HTuple();
    HTuple hv_HomMat3DInTmp = new HTuple(), hv_PosesOut2 = new HTuple();
    HTuple   hv_Column_COPY_INP_TMP = new HTuple(hv_Column);
    HTuple   hv_PosesIn_COPY_INP_TMP = new HTuple(hv_PosesIn);
    HTuple   hv_Row_COPY_INP_TMP = new HTuple(hv_Row);
    HTuple   hv_TBCenter_COPY_INP_TMP = new HTuple(hv_TBCenter);
    HTuple   hv_TBSize_COPY_INP_TMP = new HTuple(hv_TBSize);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageDump);
    hv_PosesOut = new HTuple();
    hv_SelectedObjectOut = new HTuple();
    hv_ButtonHoldOut = new HTuple();
    hv_WindowCenteredRotationOut = new HTuple();
    //This procedure reflects
    //- the pose change that was introduced by the user by
    //  moving the mouse
    //- the selection of a single object
    //
    //global tuple gIsSinglePose
    //
    hv_ButtonHoldOut.Dispose();
    hv_ButtonHoldOut = new HTuple(hv_ButtonHoldIn);
    hv_PosesOut.Dispose();
    hv_PosesOut = new HTuple(hv_PosesIn_COPY_INP_TMP);
    hv_SelectedObjectOut.Dispose();
    hv_SelectedObjectOut = new HTuple(hv_SelectedObjectIn);
    hv_WindowCenteredRotationOut.Dispose();
    hv_WindowCenteredRotationOut = new HTuple(hv_WindowCenteredRotationlIn);
    hv_VisualizeTB.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_VisualizeTB = new HTuple(((hv_SelectedObjectOut.TupleMax()
        )).TupleNotEqual(0));
    }
    hv_InvLog2.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_InvLog2 = 1.0/((new HTuple(2)).TupleLog()
        );
    }
    //
    if ((int)(new HTuple(hv_Button.TupleEqual(hv_MouseMapping.TupleSelect(6)))) != 0)
    {
      if ((int)(hv_ButtonHoldOut) != 0)
      {
        ho_ImageDump.Dispose();

        hv_Column_COPY_INP_TMP.Dispose();
        hv_PosesIn_COPY_INP_TMP.Dispose();
        hv_Row_COPY_INP_TMP.Dispose();
        hv_TBCenter_COPY_INP_TMP.Dispose();
        hv_TBSize_COPY_INP_TMP.Dispose();
        hv_VisualizeTB.Dispose();
        hv_InvLog2.Dispose();
        hv_Seconds.Dispose();
        hv_ModelIndex.Dispose();
        hv_Exception1.Dispose();
        hv_HomMat3DIdentity.Dispose();
        hv_NumModels.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_MinImageSize.Dispose();
        hv_TrackballRadiusPixel.Dispose();
        hv_TrackballCenterRow.Dispose();
        hv_TrackballCenterCol.Dispose();
        hv_NumChannels.Dispose();
        hv_ColorImage.Dispose();
        hv_BAnd.Dispose();
        hv_SensFactor.Dispose();
        hv_IsButtonTrans.Dispose();
        hv_IsButtonRot.Dispose();
        hv_IsButtonDist.Dispose();
        hv_MRow1.Dispose();
        hv_MCol1.Dispose();
        hv_ButtonLoop.Dispose();
        hv_MRow2.Dispose();
        hv_MCol2.Dispose();
        hv_PX.Dispose();
        hv_PY.Dispose();
        hv_PZ.Dispose();
        hv_QX1.Dispose();
        hv_QY1.Dispose();
        hv_QZ1.Dispose();
        hv_QX2.Dispose();
        hv_QY2.Dispose();
        hv_QZ2.Dispose();
        hv_Len.Dispose();
        hv_Dist.Dispose();
        hv_Translate.Dispose();
        hv_Index.Dispose();
        hv_PoseIn.Dispose();
        hv_HomMat3DIn.Dispose();
        hv_HomMat3DOut.Dispose();
        hv_PoseOut.Dispose();
        hv_Indices.Dispose();
        hv_Sequence.Dispose();
        hv_Mod.Dispose();
        hv_SequenceReal.Dispose();
        hv_Sequence2Int.Dispose();
        hv_Selected.Dispose();
        hv_InvSelected.Dispose();
        hv_Exception.Dispose();
        hv_DRow.Dispose();
        hv_TranslateZ.Dispose();
        hv_MX1.Dispose();
        hv_MY1.Dispose();
        hv_MX2.Dispose();
        hv_MY2.Dispose();
        hv_RelQuaternion.Dispose();
        hv_HomMat3DRotRel.Dispose();
        hv_HomMat3DInTmp1.Dispose();
        hv_HomMat3DInTmp.Dispose();
        hv_PosesOut2.Dispose();

        return;
      }
      //Ctrl (16) + Alt (32) + left mouse button (1) => Toggle rotation center position
      //If WindowCenteredRotation is not 1, set it to 1, otherwise, set it to 2
      hv_Seconds.Dispose();
      HOperatorSet.CountSeconds(out hv_Seconds);
      if ((int)(new HTuple(hv_WindowCenteredRotationOut.TupleEqual(1))) != 0)
      {
        hv_WindowCenteredRotationOut.Dispose();
        hv_WindowCenteredRotationOut = 2;
      }
      else
      {
        hv_WindowCenteredRotationOut.Dispose();
        hv_WindowCenteredRotationOut = 1;
      }
      hv_ButtonHoldOut.Dispose();
      hv_ButtonHoldOut = 1;
      ho_ImageDump.Dispose();

      hv_Column_COPY_INP_TMP.Dispose();
      hv_PosesIn_COPY_INP_TMP.Dispose();
      hv_Row_COPY_INP_TMP.Dispose();
      hv_TBCenter_COPY_INP_TMP.Dispose();
      hv_TBSize_COPY_INP_TMP.Dispose();
      hv_VisualizeTB.Dispose();
      hv_InvLog2.Dispose();
      hv_Seconds.Dispose();
      hv_ModelIndex.Dispose();
      hv_Exception1.Dispose();
      hv_HomMat3DIdentity.Dispose();
      hv_NumModels.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_MinImageSize.Dispose();
      hv_TrackballRadiusPixel.Dispose();
      hv_TrackballCenterRow.Dispose();
      hv_TrackballCenterCol.Dispose();
      hv_NumChannels.Dispose();
      hv_ColorImage.Dispose();
      hv_BAnd.Dispose();
      hv_SensFactor.Dispose();
      hv_IsButtonTrans.Dispose();
      hv_IsButtonRot.Dispose();
      hv_IsButtonDist.Dispose();
      hv_MRow1.Dispose();
      hv_MCol1.Dispose();
      hv_ButtonLoop.Dispose();
      hv_MRow2.Dispose();
      hv_MCol2.Dispose();
      hv_PX.Dispose();
      hv_PY.Dispose();
      hv_PZ.Dispose();
      hv_QX1.Dispose();
      hv_QY1.Dispose();
      hv_QZ1.Dispose();
      hv_QX2.Dispose();
      hv_QY2.Dispose();
      hv_QZ2.Dispose();
      hv_Len.Dispose();
      hv_Dist.Dispose();
      hv_Translate.Dispose();
      hv_Index.Dispose();
      hv_PoseIn.Dispose();
      hv_HomMat3DIn.Dispose();
      hv_HomMat3DOut.Dispose();
      hv_PoseOut.Dispose();
      hv_Indices.Dispose();
      hv_Sequence.Dispose();
      hv_Mod.Dispose();
      hv_SequenceReal.Dispose();
      hv_Sequence2Int.Dispose();
      hv_Selected.Dispose();
      hv_InvSelected.Dispose();
      hv_Exception.Dispose();
      hv_DRow.Dispose();
      hv_TranslateZ.Dispose();
      hv_MX1.Dispose();
      hv_MY1.Dispose();
      hv_MX2.Dispose();
      hv_MY2.Dispose();
      hv_RelQuaternion.Dispose();
      hv_HomMat3DRotRel.Dispose();
      hv_HomMat3DInTmp1.Dispose();
      hv_HomMat3DInTmp.Dispose();
      hv_PosesOut2.Dispose();

      return;
    }
    if ((int)((new HTuple(hv_Button.TupleEqual(hv_MouseMapping.TupleSelect(5)))).TupleAnd(
        new HTuple((new HTuple(hv_ObjectModel3DID.TupleLength())).TupleLessEqual(
        hv_MaxNumModels)))) != 0)
    {
      if ((int)(hv_ButtonHoldOut) != 0)
      {
        ho_ImageDump.Dispose();

        hv_Column_COPY_INP_TMP.Dispose();
        hv_PosesIn_COPY_INP_TMP.Dispose();
        hv_Row_COPY_INP_TMP.Dispose();
        hv_TBCenter_COPY_INP_TMP.Dispose();
        hv_TBSize_COPY_INP_TMP.Dispose();
        hv_VisualizeTB.Dispose();
        hv_InvLog2.Dispose();
        hv_Seconds.Dispose();
        hv_ModelIndex.Dispose();
        hv_Exception1.Dispose();
        hv_HomMat3DIdentity.Dispose();
        hv_NumModels.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_MinImageSize.Dispose();
        hv_TrackballRadiusPixel.Dispose();
        hv_TrackballCenterRow.Dispose();
        hv_TrackballCenterCol.Dispose();
        hv_NumChannels.Dispose();
        hv_ColorImage.Dispose();
        hv_BAnd.Dispose();
        hv_SensFactor.Dispose();
        hv_IsButtonTrans.Dispose();
        hv_IsButtonRot.Dispose();
        hv_IsButtonDist.Dispose();
        hv_MRow1.Dispose();
        hv_MCol1.Dispose();
        hv_ButtonLoop.Dispose();
        hv_MRow2.Dispose();
        hv_MCol2.Dispose();
        hv_PX.Dispose();
        hv_PY.Dispose();
        hv_PZ.Dispose();
        hv_QX1.Dispose();
        hv_QY1.Dispose();
        hv_QZ1.Dispose();
        hv_QX2.Dispose();
        hv_QY2.Dispose();
        hv_QZ2.Dispose();
        hv_Len.Dispose();
        hv_Dist.Dispose();
        hv_Translate.Dispose();
        hv_Index.Dispose();
        hv_PoseIn.Dispose();
        hv_HomMat3DIn.Dispose();
        hv_HomMat3DOut.Dispose();
        hv_PoseOut.Dispose();
        hv_Indices.Dispose();
        hv_Sequence.Dispose();
        hv_Mod.Dispose();
        hv_SequenceReal.Dispose();
        hv_Sequence2Int.Dispose();
        hv_Selected.Dispose();
        hv_InvSelected.Dispose();
        hv_Exception.Dispose();
        hv_DRow.Dispose();
        hv_TranslateZ.Dispose();
        hv_MX1.Dispose();
        hv_MY1.Dispose();
        hv_MX2.Dispose();
        hv_MY2.Dispose();
        hv_RelQuaternion.Dispose();
        hv_HomMat3DRotRel.Dispose();
        hv_HomMat3DInTmp1.Dispose();
        hv_HomMat3DInTmp.Dispose();
        hv_PosesOut2.Dispose();

        return;
      }
      //Ctrl (16) + left mouse button (1) => Select an object
      try
      {
        HOperatorSet.SetScene3dParam(hv_Scene3D, "object_index_persistence", "true");
        HOperatorSet.DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
        hv_ModelIndex.Dispose();
        HOperatorSet.GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Row_COPY_INP_TMP, 
            hv_Column_COPY_INP_TMP, "object_index", out hv_ModelIndex);
        HOperatorSet.SetScene3dParam(hv_Scene3D, "object_index_persistence", "false");
      }
      // catch (Exception1) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception1);
        //* NO OpenGL, no selection possible
        ho_ImageDump.Dispose();

        hv_Column_COPY_INP_TMP.Dispose();
        hv_PosesIn_COPY_INP_TMP.Dispose();
        hv_Row_COPY_INP_TMP.Dispose();
        hv_TBCenter_COPY_INP_TMP.Dispose();
        hv_TBSize_COPY_INP_TMP.Dispose();
        hv_VisualizeTB.Dispose();
        hv_InvLog2.Dispose();
        hv_Seconds.Dispose();
        hv_ModelIndex.Dispose();
        hv_Exception1.Dispose();
        hv_HomMat3DIdentity.Dispose();
        hv_NumModels.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_MinImageSize.Dispose();
        hv_TrackballRadiusPixel.Dispose();
        hv_TrackballCenterRow.Dispose();
        hv_TrackballCenterCol.Dispose();
        hv_NumChannels.Dispose();
        hv_ColorImage.Dispose();
        hv_BAnd.Dispose();
        hv_SensFactor.Dispose();
        hv_IsButtonTrans.Dispose();
        hv_IsButtonRot.Dispose();
        hv_IsButtonDist.Dispose();
        hv_MRow1.Dispose();
        hv_MCol1.Dispose();
        hv_ButtonLoop.Dispose();
        hv_MRow2.Dispose();
        hv_MCol2.Dispose();
        hv_PX.Dispose();
        hv_PY.Dispose();
        hv_PZ.Dispose();
        hv_QX1.Dispose();
        hv_QY1.Dispose();
        hv_QZ1.Dispose();
        hv_QX2.Dispose();
        hv_QY2.Dispose();
        hv_QZ2.Dispose();
        hv_Len.Dispose();
        hv_Dist.Dispose();
        hv_Translate.Dispose();
        hv_Index.Dispose();
        hv_PoseIn.Dispose();
        hv_HomMat3DIn.Dispose();
        hv_HomMat3DOut.Dispose();
        hv_PoseOut.Dispose();
        hv_Indices.Dispose();
        hv_Sequence.Dispose();
        hv_Mod.Dispose();
        hv_SequenceReal.Dispose();
        hv_Sequence2Int.Dispose();
        hv_Selected.Dispose();
        hv_InvSelected.Dispose();
        hv_Exception.Dispose();
        hv_DRow.Dispose();
        hv_TranslateZ.Dispose();
        hv_MX1.Dispose();
        hv_MY1.Dispose();
        hv_MX2.Dispose();
        hv_MY2.Dispose();
        hv_RelQuaternion.Dispose();
        hv_HomMat3DRotRel.Dispose();
        hv_HomMat3DInTmp1.Dispose();
        hv_HomMat3DInTmp.Dispose();
        hv_PosesOut2.Dispose();

        return;
      }
      if ((int)(new HTuple(hv_ModelIndex.TupleEqual(-1))) != 0)
      {
        //Background click:
        if ((int)(new HTuple(((hv_SelectedObjectOut.TupleSum())).TupleEqual(new HTuple(hv_SelectedObjectOut.TupleLength()
            )))) != 0)
        {
          //If all objects are already selected, deselect all
          hv_SelectedObjectOut.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SelectedObjectOut = HTuple.TupleGenConst(
              new HTuple(hv_ObjectModel3DID.TupleLength()),0);
          }
        }
        else
        {
          //Otherwise select all
          hv_SelectedObjectOut.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SelectedObjectOut = HTuple.TupleGenConst(
              new HTuple(hv_ObjectModel3DID.TupleLength()),1);
          }
        }
      }
      else
      {
        //Object click:
        if (hv_SelectedObjectOut == null)
          hv_SelectedObjectOut = new HTuple();
        hv_SelectedObjectOut[hv_ModelIndex] = ((hv_SelectedObjectOut.TupleSelect(
            hv_ModelIndex))).TupleNot();
      }
      hv_ButtonHoldOut.Dispose();
      hv_ButtonHoldOut = 1;
    }
    else
    {
      //Change the pose
      hv_HomMat3DIdentity.Dispose();
      HOperatorSet.HomMat3dIdentity(out hv_HomMat3DIdentity);
      hv_NumModels.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumModels = new HTuple(hv_ObjectModel3DID.TupleLength()
          );
      }
      hv_Width.Dispose();
      get_cam_par_data(hv_CamParam, "image_width", out hv_Width);
      hv_Height.Dispose();
      get_cam_par_data(hv_CamParam, "image_height", out hv_Height);
      hv_MinImageSize.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinImageSize = ((hv_Width.TupleConcat(
          hv_Height))).TupleMin();
      }
      hv_TrackballRadiusPixel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize)/2.0;
      }
      //Set trackball fixed in the center of the window
      hv_TrackballCenterRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrackballCenterRow = hv_Height/2;
      }
      hv_TrackballCenterCol.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrackballCenterCol = hv_Width/2;
      }
      if ((int)(new HTuple((new HTuple(hv_ObjectModel3DID.TupleLength())).TupleLess(
          hv_MaxNumModels))) != 0)
      {
        if ((int)(new HTuple(hv_WindowCenteredRotationOut.TupleEqual(1))) != 0)
        {
          hv_TBCenter_COPY_INP_TMP.Dispose();hv_TBSize_COPY_INP_TMP.Dispose();
          get_trackball_center_fixed_visualize_object_model_3d(hv_SelectedObjectIn, 
              hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TrackballRadiusPixel, 
              hv_Scene3D, hv_ObjectModel3DID, hv_PosesIn_COPY_INP_TMP, hv_WindowHandleBuffer, 
              hv_CamParam, hv_GenParamName, hv_GenParamValue, out hv_TBCenter_COPY_INP_TMP, 
              out hv_TBSize_COPY_INP_TMP);
        }
        else
        {
          hv_TBCenter_COPY_INP_TMP.Dispose();hv_TBSize_COPY_INP_TMP.Dispose();
          get_trackball_center_visualize_object_model_3d(hv_SelectedObjectIn, hv_TrackballRadiusPixel, 
              hv_ObjectModel3DID, hv_PosesIn_COPY_INP_TMP, out hv_TBCenter_COPY_INP_TMP, 
              out hv_TBSize_COPY_INP_TMP);
        }
      }
      if ((int)((new HTuple(((hv_SelectedObjectOut.TupleMin())).TupleEqual(0))).TupleAnd(
          new HTuple(((hv_SelectedObjectOut.TupleMax())).TupleEqual(1)))) != 0)
      {
        //At this point, multiple objects do not necessary have the same
        //pose any more. Consequently, we have to return a tuple of poses
        //as output of visualize_object_model_3d
        ExpTmpLocalVar_gIsSinglePose = 0;
        ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
      }
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_BackgroundImage, out hv_NumChannels);
      hv_ColorImage.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColorImage = new HTuple(hv_NumChannels.TupleEqual(
          3));
      }
      //Alt (32) => lower sensitivity
      hv_BAnd.Dispose();
      HOperatorSet.TupleRsh(hv_Button, 5, out hv_BAnd);
      if ((int)(hv_BAnd%2) != 0)
      {
        hv_SensFactor.Dispose();
        hv_SensFactor = 0.1;
      }
      else
      {
        hv_SensFactor.Dispose();
        hv_SensFactor = 1.0;
      }
      hv_IsButtonTrans.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IsButtonTrans = (new HTuple(((hv_MouseMapping.TupleSelect(
          0))).TupleEqual(hv_Button))).TupleOr(new HTuple(((32+(hv_MouseMapping.TupleSelect(
          0)))).TupleEqual(hv_Button)));
      }
      hv_IsButtonRot.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IsButtonRot = (new HTuple(((hv_MouseMapping.TupleSelect(
          1))).TupleEqual(hv_Button))).TupleOr(new HTuple(((32+(hv_MouseMapping.TupleSelect(
          1)))).TupleEqual(hv_Button)));
      }
      hv_IsButtonDist.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IsButtonDist = (new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(((hv_MouseMapping.TupleSelect(
          2))).TupleEqual(hv_Button))).TupleOr(new HTuple(((32+(hv_MouseMapping.TupleSelect(
          2)))).TupleEqual(hv_Button))))).TupleOr(new HTuple(((hv_MouseMapping.TupleSelect(
          3))).TupleEqual(hv_Button))))).TupleOr(new HTuple(((32+(hv_MouseMapping.TupleSelect(
          3)))).TupleEqual(hv_Button))))).TupleOr(new HTuple(((hv_MouseMapping.TupleSelect(
          4))).TupleEqual(hv_Button))))).TupleOr(new HTuple(((32+(hv_MouseMapping.TupleSelect(
          4)))).TupleEqual(hv_Button)));
      }
      if ((int)(hv_IsButtonTrans) != 0)
      {
        //Translate in XY-direction
        hv_MRow1.Dispose();
        hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
        hv_MCol1.Dispose();
        hv_MCol1 = new HTuple(hv_Column_COPY_INP_TMP);
        while ((int)(hv_IsButtonTrans) != 0)
        {
          try
          {
            hv_Row_COPY_INP_TMP.Dispose();hv_Column_COPY_INP_TMP.Dispose();hv_ButtonLoop.Dispose();
            HOperatorSet.GetMpositionSubPix(hv_WindowHandle, out hv_Row_COPY_INP_TMP, 
                out hv_Column_COPY_INP_TMP, out hv_ButtonLoop);
            hv_IsButtonTrans.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_IsButtonTrans = new HTuple(hv_ButtonLoop.TupleEqual(
                hv_Button));
            }
            hv_MRow2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MRow2 = hv_MRow1+((hv_Row_COPY_INP_TMP-hv_MRow1)*hv_SensFactor);
            }
            hv_MCol2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MCol2 = hv_MCol1+((hv_Column_COPY_INP_TMP-hv_MCol1)*hv_SensFactor);
            }
            hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
            HOperatorSet.GetLineOfSight(hv_MRow1, hv_MCol1, hv_CamParam, out hv_PX, 
                out hv_PY, out hv_PZ, out hv_QX1, out hv_QY1, out hv_QZ1);
            hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX2.Dispose();hv_QY2.Dispose();hv_QZ2.Dispose();
            HOperatorSet.GetLineOfSight(hv_MRow2, hv_MCol2, hv_CamParam, out hv_PX, 
                out hv_PY, out hv_PZ, out hv_QX2, out hv_QY2, out hv_QZ2);
            hv_Len.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Len = ((((hv_QX1*hv_QX1)+(hv_QY1*hv_QY1))+(hv_QZ1*hv_QZ1))).TupleSqrt()
                ;
            }
            hv_Dist.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Dist = (((((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                0))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(0)))+((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                1))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(1))))+((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                2))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(2))))).TupleSqrt();
            }
            hv_Translate.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Translate = ((((((hv_QX2-hv_QX1)).TupleConcat(
                hv_QY2-hv_QY1))).TupleConcat(hv_QZ2-hv_QZ1))*hv_Dist)/hv_Len;
            }
            hv_PosesOut.Dispose();
            hv_PosesOut = new HTuple();
            if ((int)(new HTuple(hv_NumModels.TupleLessEqual(hv_MaxNumModels))) != 0)
            {
              HTuple end_val110 = hv_NumModels-1;
              HTuple step_val110 = 1;
              for (hv_Index=0; hv_Index.Continue(end_val110, step_val110); hv_Index = hv_Index.TupleAdd(step_val110))
              {
                hv_PoseIn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                    hv_Index*7,(hv_Index*7)+6);
                }
                if ((int)(hv_SelectedObjectOut.TupleSelect(hv_Index)) != 0)
                {
                  hv_HomMat3DIn.Dispose();
                  HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_HomMat3DOut.Dispose();
                  HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, hv_Translate.TupleSelect(
                      0), hv_Translate.TupleSelect(1), hv_Translate.TupleSelect(2), 
                      out hv_HomMat3DOut);
                  }
                  hv_PoseOut.Dispose();
                  HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
                  HOperatorSet.SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
                }
                else
                {
                  hv_PoseOut.Dispose();
                  hv_PoseOut = new HTuple(hv_PoseIn);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_PosesOut = hv_PosesOut.TupleConcat(
                    hv_PoseOut);
                hv_PosesOut.Dispose();
                hv_PosesOut = ExpTmpLocalVar_PosesOut;
                }
                }
              }
            }
            else
            {
              hv_Indices.Dispose();
              HOperatorSet.TupleFind(hv_SelectedObjectOut, 1, out hv_Indices);
              hv_PoseIn.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                  (hv_Indices.TupleSelect(0))*7,((hv_Indices.TupleSelect(0))*7)+6);
              }
              hv_HomMat3DIn.Dispose();
              HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_HomMat3DOut.Dispose();
              HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, hv_Translate.TupleSelect(
                  0), hv_Translate.TupleSelect(1), hv_Translate.TupleSelect(2), out hv_HomMat3DOut);
              }
              hv_PoseOut.Dispose();
              HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
              hv_Sequence.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence = HTuple.TupleGenSequence(
                  0,(hv_NumModels*7)-1,1);
              }
              hv_Mod.Dispose();
              HOperatorSet.TupleMod(hv_Sequence, 7, out hv_Mod);
              hv_SequenceReal.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SequenceReal = HTuple.TupleGenSequence(
                  0,hv_NumModels-(1.0/7.0),1.0/7.0);
              }
              hv_Sequence2Int.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence2Int = hv_SequenceReal.TupleInt()
                  ;
              }
              hv_Selected.Dispose();
              HOperatorSet.TupleSelect(hv_SelectedObjectOut, hv_Sequence2Int, out hv_Selected);
              hv_InvSelected.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_InvSelected = 1-hv_Selected;
              }
              hv_PosesOut.Dispose();
              HOperatorSet.TupleSelect(hv_PoseOut, hv_Mod, out hv_PosesOut);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_PosesOut = (hv_PosesOut*hv_Selected)+(hv_PosesIn_COPY_INP_TMP*hv_InvSelected);
              hv_PosesOut.Dispose();
              hv_PosesOut = ExpTmpLocalVar_PosesOut;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetScene3dInstancePose(hv_Scene3D, HTuple.TupleGenSequence(
                  0,hv_NumModels-1,1), hv_PosesOut);
              }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            dump_image_output_visualize_object_model_3d(ho_BackgroundImage, hv_WindowHandleBuffer, 
                hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
                hv_CamParam, hv_PosesOut, hv_ColorImage, hv_Title, hv_Information, 
                hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
                hv_TBSize_COPY_INP_TMP, hv_SelectedObjectOut, new HTuple(hv_WindowCenteredRotationOut.TupleEqual(
                1)), hv_TBCenter_COPY_INP_TMP);
            }
            ho_ImageDump.Dispose();
            HOperatorSet.DumpWindowImage(out ho_ImageDump, hv_WindowHandleBuffer);
            HDevWindowStack.SetActive(hv_WindowHandle);
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ImageDump, HDevWindowStack.GetActive());
            }
            //
            hv_MRow1.Dispose();
            hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
            hv_MCol1.Dispose();
            hv_MCol1 = new HTuple(hv_Column_COPY_INP_TMP);
            hv_PosesIn_COPY_INP_TMP.Dispose();
            hv_PosesIn_COPY_INP_TMP = new HTuple(hv_PosesOut);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            //Keep waiting
          }
        }
      }
      else if ((int)(hv_IsButtonDist) != 0)
      {
        //Change the Z distance
        hv_MRow1.Dispose();
        hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
        while ((int)(hv_IsButtonDist) != 0)
        {
          try
          {
            hv_Row_COPY_INP_TMP.Dispose();hv_Column_COPY_INP_TMP.Dispose();hv_ButtonLoop.Dispose();
            HOperatorSet.GetMpositionSubPix(hv_WindowHandle, out hv_Row_COPY_INP_TMP, 
                out hv_Column_COPY_INP_TMP, out hv_ButtonLoop);
            hv_IsButtonDist.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_IsButtonDist = new HTuple(hv_ButtonLoop.TupleEqual(
                hv_Button));
            }
            hv_MRow2.Dispose();
            hv_MRow2 = new HTuple(hv_Row_COPY_INP_TMP);
            hv_DRow.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_DRow = hv_MRow2-hv_MRow1;
            }
            hv_Dist.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Dist = (((((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                0))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(0)))+((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                1))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(1))))+((hv_TBCenter_COPY_INP_TMP.TupleSelect(
                2))*(hv_TBCenter_COPY_INP_TMP.TupleSelect(2))))).TupleSqrt();
            }
            hv_TranslateZ.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TranslateZ = (((-hv_Dist)*hv_DRow)*0.003)*hv_SensFactor;
            }
            if (hv_TBCenter_COPY_INP_TMP == null)
              hv_TBCenter_COPY_INP_TMP = new HTuple();
            hv_TBCenter_COPY_INP_TMP[2] = (hv_TBCenter_COPY_INP_TMP.TupleSelect(2))+hv_TranslateZ;
            hv_PosesOut.Dispose();
            hv_PosesOut = new HTuple();
            if ((int)(new HTuple(hv_NumModels.TupleLessEqual(hv_MaxNumModels))) != 0)
            {
              HTuple end_val164 = hv_NumModels-1;
              HTuple step_val164 = 1;
              for (hv_Index=0; hv_Index.Continue(end_val164, step_val164); hv_Index = hv_Index.TupleAdd(step_val164))
              {
                hv_PoseIn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                    hv_Index*7,(hv_Index*7)+6);
                }
                if ((int)(hv_SelectedObjectOut.TupleSelect(hv_Index)) != 0)
                {
                  //Transform the whole scene or selected object only
                  hv_HomMat3DIn.Dispose();
                  HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
                  hv_HomMat3DOut.Dispose();
                  HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, 
                      out hv_HomMat3DOut);
                  hv_PoseOut.Dispose();
                  HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
                  HOperatorSet.SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
                }
                else
                {
                  hv_PoseOut.Dispose();
                  hv_PoseOut = new HTuple(hv_PoseIn);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_PosesOut = hv_PosesOut.TupleConcat(
                    hv_PoseOut);
                hv_PosesOut.Dispose();
                hv_PosesOut = ExpTmpLocalVar_PosesOut;
                }
                }
              }
            }
            else
            {
              hv_Indices.Dispose();
              HOperatorSet.TupleFind(hv_SelectedObjectOut, 1, out hv_Indices);
              hv_PoseIn.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                  (hv_Indices.TupleSelect(0))*7,((hv_Indices.TupleSelect(0))*7)+6);
              }
              hv_HomMat3DIn.Dispose();
              HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
              hv_HomMat3DOut.Dispose();
              HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, 
                  out hv_HomMat3DOut);
              hv_PoseOut.Dispose();
              HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
              hv_Sequence.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence = HTuple.TupleGenSequence(
                  0,(hv_NumModels*7)-1,1);
              }
              hv_Mod.Dispose();
              HOperatorSet.TupleMod(hv_Sequence, 7, out hv_Mod);
              hv_SequenceReal.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SequenceReal = HTuple.TupleGenSequence(
                  0,hv_NumModels-(1.0/7.0),1.0/7.0);
              }
              hv_Sequence2Int.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence2Int = hv_SequenceReal.TupleInt()
                  ;
              }
              hv_Selected.Dispose();
              HOperatorSet.TupleSelect(hv_SelectedObjectOut, hv_Sequence2Int, out hv_Selected);
              hv_InvSelected.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_InvSelected = 1-hv_Selected;
              }
              hv_PosesOut.Dispose();
              HOperatorSet.TupleSelect(hv_PoseOut, hv_Mod, out hv_PosesOut);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_PosesOut = (hv_PosesOut*hv_Selected)+(hv_PosesIn_COPY_INP_TMP*hv_InvSelected);
              hv_PosesOut.Dispose();
              hv_PosesOut = ExpTmpLocalVar_PosesOut;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetScene3dInstancePose(hv_Scene3D, HTuple.TupleGenSequence(
                  0,hv_NumModels-1,1), hv_PosesOut);
              }
            }
            dump_image_output_visualize_object_model_3d(ho_BackgroundImage, hv_WindowHandleBuffer, 
                hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
                hv_CamParam, hv_PosesOut, hv_ColorImage, hv_Title, hv_Information, 
                hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
                hv_TBSize_COPY_INP_TMP, hv_SelectedObjectOut, hv_WindowCenteredRotationOut, 
                hv_TBCenter_COPY_INP_TMP);
            ho_ImageDump.Dispose();
            HOperatorSet.DumpWindowImage(out ho_ImageDump, hv_WindowHandleBuffer);
            HDevWindowStack.SetActive(hv_WindowHandle);
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ImageDump, HDevWindowStack.GetActive());
            }
            //
            hv_MRow1.Dispose();
            hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
            hv_PosesIn_COPY_INP_TMP.Dispose();
            hv_PosesIn_COPY_INP_TMP = new HTuple(hv_PosesOut);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            //Keep waiting
          }
        }
      }
      else if ((int)(hv_IsButtonRot) != 0)
      {
        //Rotate the object
        hv_MRow1.Dispose();
        hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
        hv_MCol1.Dispose();
        hv_MCol1 = new HTuple(hv_Column_COPY_INP_TMP);
        while ((int)(hv_IsButtonRot) != 0)
        {
          try
          {
            hv_Row_COPY_INP_TMP.Dispose();hv_Column_COPY_INP_TMP.Dispose();hv_ButtonLoop.Dispose();
            HOperatorSet.GetMpositionSubPix(hv_WindowHandle, out hv_Row_COPY_INP_TMP, 
                out hv_Column_COPY_INP_TMP, out hv_ButtonLoop);
            hv_IsButtonRot.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_IsButtonRot = new HTuple(hv_ButtonLoop.TupleEqual(
                hv_Button));
            }
            hv_MRow2.Dispose();
            hv_MRow2 = new HTuple(hv_Row_COPY_INP_TMP);
            hv_MCol2.Dispose();
            hv_MCol2 = new HTuple(hv_Column_COPY_INP_TMP);
            //Transform the pixel coordinates to relative image coordinates
            hv_MX1.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MX1 = (hv_TrackballCenterCol-hv_MCol1)/(0.5*hv_MinImageSize);
            }
            hv_MY1.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MY1 = (hv_TrackballCenterRow-hv_MRow1)/(0.5*hv_MinImageSize);
            }
            hv_MX2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MX2 = (hv_TrackballCenterCol-hv_MCol2)/(0.5*hv_MinImageSize);
            }
            hv_MY2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MY2 = (hv_TrackballCenterRow-hv_MRow2)/(0.5*hv_MinImageSize);
            }
            //Compute the quaternion rotation that corresponds to the mouse
            //movement
            hv_RelQuaternion.Dispose();
            trackball_visualize_object_model_3d(hv_MX1, hv_MY1, hv_MX2, hv_MY2, hv_VirtualTrackball, 
                hv_TrackballSize, hv_SensFactor, out hv_RelQuaternion);
            //Transform the quaternion to a rotation matrix
            hv_HomMat3DRotRel.Dispose();
            HOperatorSet.QuatToHomMat3d(hv_RelQuaternion, out hv_HomMat3DRotRel);
            hv_PosesOut.Dispose();
            hv_PosesOut = new HTuple();
            if ((int)(new HTuple(hv_NumModels.TupleLessEqual(hv_MaxNumModels))) != 0)
            {
              HTuple end_val226 = hv_NumModels-1;
              HTuple step_val226 = 1;
              for (hv_Index=0; hv_Index.Continue(end_val226, step_val226); hv_Index = hv_Index.TupleAdd(step_val226))
              {
                hv_PoseIn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                    hv_Index*7,(hv_Index*7)+6);
                }
                if ((int)(hv_SelectedObjectOut.TupleSelect(hv_Index)) != 0)
                {
                  //Transform the whole scene or selected object only
                  hv_HomMat3DIn.Dispose();
                  HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  HTuple ExpTmpOutVar_0;
                  HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, -(hv_TBCenter_COPY_INP_TMP.TupleSelect(
                      0)), -(hv_TBCenter_COPY_INP_TMP.TupleSelect(1)), -(hv_TBCenter_COPY_INP_TMP.TupleSelect(
                      2)), out ExpTmpOutVar_0);
                  hv_HomMat3DIn.Dispose();
                  hv_HomMat3DIn = ExpTmpOutVar_0;
                  }
                  {
                  HTuple ExpTmpOutVar_0;
                  HOperatorSet.HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DIn, 
                      out ExpTmpOutVar_0);
                  hv_HomMat3DIn.Dispose();
                  hv_HomMat3DIn = ExpTmpOutVar_0;
                  }
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_HomMat3DOut.Dispose();
                  HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, hv_TBCenter_COPY_INP_TMP.TupleSelect(
                      0), hv_TBCenter_COPY_INP_TMP.TupleSelect(1), hv_TBCenter_COPY_INP_TMP.TupleSelect(
                      2), out hv_HomMat3DOut);
                  }
                  hv_PoseOut.Dispose();
                  HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
                  HOperatorSet.SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
                }
                else
                {
                  hv_PoseOut.Dispose();
                  hv_PoseOut = new HTuple(hv_PoseIn);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_PosesOut = hv_PosesOut.TupleConcat(
                    hv_PoseOut);
                hv_PosesOut.Dispose();
                hv_PosesOut = ExpTmpLocalVar_PosesOut;
                }
                }
              }
            }
            else
            {
              hv_Indices.Dispose();
              HOperatorSet.TupleFind(hv_SelectedObjectOut, 1, out hv_Indices);
              hv_PoseIn.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PoseIn = hv_PosesIn_COPY_INP_TMP.TupleSelectRange(
                  (hv_Indices.TupleSelect(0))*7,((hv_Indices.TupleSelect(0))*7)+6);
              }
              hv_HomMat3DIn.Dispose();
              HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_HomMat3DInTmp1.Dispose();
              HOperatorSet.HomMat3dTranslate(hv_HomMat3DIn, -(hv_TBCenter_COPY_INP_TMP.TupleSelect(
                  0)), -(hv_TBCenter_COPY_INP_TMP.TupleSelect(1)), -(hv_TBCenter_COPY_INP_TMP.TupleSelect(
                  2)), out hv_HomMat3DInTmp1);
              }
              hv_HomMat3DInTmp.Dispose();
              HOperatorSet.HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DInTmp1, 
                  out hv_HomMat3DInTmp);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_HomMat3DOut.Dispose();
              HOperatorSet.HomMat3dTranslate(hv_HomMat3DInTmp, hv_TBCenter_COPY_INP_TMP.TupleSelect(
                  0), hv_TBCenter_COPY_INP_TMP.TupleSelect(1), hv_TBCenter_COPY_INP_TMP.TupleSelect(
                  2), out hv_HomMat3DOut);
              }
              hv_PoseOut.Dispose();
              HOperatorSet.HomMat3dToPose(hv_HomMat3DOut, out hv_PoseOut);
              hv_Sequence.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence = HTuple.TupleGenSequence(
                  0,(hv_NumModels*7)-1,1);
              }
              hv_Mod.Dispose();
              HOperatorSet.TupleMod(hv_Sequence, 7, out hv_Mod);
              hv_SequenceReal.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SequenceReal = HTuple.TupleGenSequence(
                  0,hv_NumModels-(1.0/7.0),1.0/7.0);
              }
              hv_Sequence2Int.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Sequence2Int = hv_SequenceReal.TupleInt()
                  ;
              }
              hv_Selected.Dispose();
              HOperatorSet.TupleSelect(hv_SelectedObjectOut, hv_Sequence2Int, out hv_Selected);
              hv_InvSelected.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_InvSelected = 1-hv_Selected;
              }
              hv_PosesOut.Dispose();
              HOperatorSet.TupleSelect(hv_PoseOut, hv_Mod, out hv_PosesOut);
              hv_PosesOut2.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PosesOut2 = (hv_PosesOut*hv_Selected)+(hv_PosesIn_COPY_INP_TMP*hv_InvSelected);
              }
              hv_PosesOut.Dispose();
              hv_PosesOut = new HTuple(hv_PosesOut2);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetScene3dInstancePose(hv_Scene3D, HTuple.TupleGenSequence(
                  0,hv_NumModels-1,1), hv_PosesOut);
              }
            }
            dump_image_output_visualize_object_model_3d(ho_BackgroundImage, hv_WindowHandleBuffer, 
                hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
                hv_CamParam, hv_PosesOut, hv_ColorImage, hv_Title, hv_Information, 
                hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
                hv_TBSize_COPY_INP_TMP, hv_SelectedObjectOut, hv_WindowCenteredRotationOut, 
                hv_TBCenter_COPY_INP_TMP);
            ho_ImageDump.Dispose();
            HOperatorSet.DumpWindowImage(out ho_ImageDump, hv_WindowHandleBuffer);
            HDevWindowStack.SetActive(hv_WindowHandle);
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ImageDump, HDevWindowStack.GetActive());
            }
            //
            hv_MRow1.Dispose();
            hv_MRow1 = new HTuple(hv_Row_COPY_INP_TMP);
            hv_MCol1.Dispose();
            hv_MCol1 = new HTuple(hv_Column_COPY_INP_TMP);
            hv_PosesIn_COPY_INP_TMP.Dispose();
            hv_PosesIn_COPY_INP_TMP = new HTuple(hv_PosesOut);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            //Keep waiting
          }
        }
      }
      hv_PosesOut.Dispose();
      hv_PosesOut = new HTuple(hv_PosesIn_COPY_INP_TMP);
    }
    ho_ImageDump.Dispose();

    hv_Column_COPY_INP_TMP.Dispose();
    hv_PosesIn_COPY_INP_TMP.Dispose();
    hv_Row_COPY_INP_TMP.Dispose();
    hv_TBCenter_COPY_INP_TMP.Dispose();
    hv_TBSize_COPY_INP_TMP.Dispose();
    hv_VisualizeTB.Dispose();
    hv_InvLog2.Dispose();
    hv_Seconds.Dispose();
    hv_ModelIndex.Dispose();
    hv_Exception1.Dispose();
    hv_HomMat3DIdentity.Dispose();
    hv_NumModels.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_MinImageSize.Dispose();
    hv_TrackballRadiusPixel.Dispose();
    hv_TrackballCenterRow.Dispose();
    hv_TrackballCenterCol.Dispose();
    hv_NumChannels.Dispose();
    hv_ColorImage.Dispose();
    hv_BAnd.Dispose();
    hv_SensFactor.Dispose();
    hv_IsButtonTrans.Dispose();
    hv_IsButtonRot.Dispose();
    hv_IsButtonDist.Dispose();
    hv_MRow1.Dispose();
    hv_MCol1.Dispose();
    hv_ButtonLoop.Dispose();
    hv_MRow2.Dispose();
    hv_MCol2.Dispose();
    hv_PX.Dispose();
    hv_PY.Dispose();
    hv_PZ.Dispose();
    hv_QX1.Dispose();
    hv_QY1.Dispose();
    hv_QZ1.Dispose();
    hv_QX2.Dispose();
    hv_QY2.Dispose();
    hv_QZ2.Dispose();
    hv_Len.Dispose();
    hv_Dist.Dispose();
    hv_Translate.Dispose();
    hv_Index.Dispose();
    hv_PoseIn.Dispose();
    hv_HomMat3DIn.Dispose();
    hv_HomMat3DOut.Dispose();
    hv_PoseOut.Dispose();
    hv_Indices.Dispose();
    hv_Sequence.Dispose();
    hv_Mod.Dispose();
    hv_SequenceReal.Dispose();
    hv_Sequence2Int.Dispose();
    hv_Selected.Dispose();
    hv_InvSelected.Dispose();
    hv_Exception.Dispose();
    hv_DRow.Dispose();
    hv_TranslateZ.Dispose();
    hv_MX1.Dispose();
    hv_MY1.Dispose();
    hv_MX2.Dispose();
    hv_MY2.Dispose();
    hv_RelQuaternion.Dispose();
    hv_HomMat3DRotRel.Dispose();
    hv_HomMat3DInTmp1.Dispose();
    hv_HomMat3DInTmp.Dispose();
    hv_PosesOut2.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Auxiliary procedure for get_custom_features and get_features. 
  public void append_length_or_values (HTuple hv_Mode, HTuple hv_Feature, HTuple hv_AccumulatedResults, 
      out HTuple hv_ExtendedResults)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_ExtendedResults = new HTuple();
    //
    //Auxiliary procedure used only by get_features and get_custom_features
    //
    if ((int)(new HTuple(hv_Mode.TupleEqual("get_lengths"))) != 0)
    {
      //Output in 'get_lengths' mode is the length of the feature
      hv_ExtendedResults.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ExtendedResults = new HTuple();
      hv_ExtendedResults = hv_ExtendedResults.TupleConcat(hv_AccumulatedResults);
      hv_ExtendedResults = hv_ExtendedResults.TupleConcat(new HTuple(hv_Feature.TupleLength()
          ));
      }
    }
    else if ((int)(new HTuple(hv_Mode.TupleEqual("calculate"))) != 0)
    {
      //Output in 'calculate' mode is the feature vector
      hv_ExtendedResults.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ExtendedResults = new HTuple();
      hv_ExtendedResults = hv_ExtendedResults.TupleConcat(hv_AccumulatedResults, hv_Feature);
      }
    }
    else
    {
      hv_ExtendedResults.Dispose();
      hv_ExtendedResults = new HTuple(hv_AccumulatedResults);
    }


    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Auxiliary procedure for get_custom_features and get_features. 
  public void append_names_or_groups (HTuple hv_Mode, HTuple hv_Name, HTuple hv_Groups, 
      HTuple hv_CurrentName, HTuple hv_AccumulatedResults, out HTuple hv_ExtendedResults)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_FirstOccurrence = new HTuple(), hv_BelongsToGroup = new HTuple();
    // Initialize local and output iconic variables 
    hv_ExtendedResults = new HTuple();
    //
    //Auxiliary procedure used only by get_features and get_custom_features
    //
    hv_ExtendedResults.Dispose();
    hv_ExtendedResults = new HTuple(hv_AccumulatedResults);
    if ((int)(new HTuple(hv_Mode.TupleEqual("get_names"))) != 0)
    {
      hv_FirstOccurrence.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FirstOccurrence = (new HTuple((new HTuple(hv_AccumulatedResults.TupleLength()
          )).TupleEqual(0))).TupleOr(new HTuple(((hv_AccumulatedResults.TupleFind(
          hv_Name))).TupleEqual(-1)));
      }
      hv_BelongsToGroup.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BelongsToGroup = (new HTuple(((((hv_Name.TupleConcat(
          hv_Groups))).TupleFind(hv_CurrentName))).TupleNotEqual(-1))).TupleOr(new HTuple(hv_CurrentName.TupleEqual(
          "all")));
      }
      if ((int)(hv_FirstOccurrence.TupleAnd(hv_BelongsToGroup)) != 0)
      {
        //Output in 'get_names' mode is the name of the feature
        hv_ExtendedResults.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ExtendedResults = new HTuple();
        hv_ExtendedResults = hv_ExtendedResults.TupleConcat(hv_AccumulatedResults, hv_Name);
        }
      }
    }
    else if ((int)(new HTuple(hv_Mode.TupleEqual("get_groups"))) != 0)
    {
      hv_ExtendedResults.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ExtendedResults = new HTuple();
      hv_ExtendedResults = hv_ExtendedResults.TupleConcat(hv_AccumulatedResults, hv_Groups);
      }
    }

    hv_FirstOccurrence.Dispose();
    hv_BelongsToGroup.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Auxiliary procedure for get_features. 
  public void append_names_or_groups_pyramid (HTuple hv_Mode, HTuple hv_Groups, HTuple hv_CurrentName, 
      HTuple hv_Names, HTuple hv_NameRegExp, HTuple hv_AccumulatedResults, out HTuple hv_ExtendedResults)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_BelongsToGroup = new HTuple(), hv_TmpNames = new HTuple();
    HTuple hv_J = new HTuple(), hv_FirstOccurrence = new HTuple();
    HTuple   hv_Names_COPY_INP_TMP = new HTuple(hv_Names);

    // Initialize local and output iconic variables 
    hv_ExtendedResults = new HTuple();
    //
    //Auxiliary procedure used only by get_features and get_custom_features
    //
    hv_ExtendedResults.Dispose();
    hv_ExtendedResults = new HTuple(hv_AccumulatedResults);
    if ((int)(new HTuple(hv_Mode.TupleEqual("get_names"))) != 0)
    {
      hv_BelongsToGroup.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BelongsToGroup = (new HTuple(((hv_Groups.TupleFind(
          hv_CurrentName))).TupleNotEqual(-1))).TupleOr(new HTuple(hv_CurrentName.TupleEqual(
          "all")));
      }
      if ((int)(hv_CurrentName.TupleRegexpTest(hv_NameRegExp)) != 0)
      {
        hv_Names_COPY_INP_TMP.Dispose();
        hv_Names_COPY_INP_TMP = new HTuple(hv_CurrentName);
      }
      else if ((int)(hv_BelongsToGroup.TupleNot()) != 0)
      {
        hv_Names_COPY_INP_TMP.Dispose();
        hv_Names_COPY_INP_TMP = new HTuple();
      }
      hv_TmpNames.Dispose();
      hv_TmpNames = new HTuple();
      for (hv_J=0; (int)hv_J<=(int)((new HTuple(hv_Names_COPY_INP_TMP.TupleLength()
          ))-1); hv_J = (int)hv_J + 1)
      {
        hv_FirstOccurrence.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FirstOccurrence = (new HTuple((new HTuple(hv_AccumulatedResults.TupleLength()
            )).TupleEqual(0))).TupleOr(new HTuple(((hv_AccumulatedResults.TupleFind(
            hv_Names_COPY_INP_TMP.TupleSelect(hv_J)))).TupleEqual(-1)));
        }
        if ((int)(hv_FirstOccurrence) != 0)
        {
          //Output in 'get_names' mode is the name of the feature
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_TmpNames = hv_TmpNames.TupleConcat(
              hv_Names_COPY_INP_TMP.TupleSelect(hv_J));
          hv_TmpNames.Dispose();
          hv_TmpNames = ExpTmpLocalVar_TmpNames;
          }
          }
        }
      }
      hv_ExtendedResults.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ExtendedResults = new HTuple();
      hv_ExtendedResults = hv_ExtendedResults.TupleConcat(hv_AccumulatedResults, hv_TmpNames);
      }
    }
    else if ((int)(new HTuple(hv_Mode.TupleEqual("get_groups"))) != 0)
    {
      hv_ExtendedResults.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ExtendedResults = new HTuple();
      hv_ExtendedResults = hv_ExtendedResults.TupleConcat(hv_AccumulatedResults, hv_Groups);
      }
    }

    hv_Names_COPY_INP_TMP.Dispose();
    hv_BelongsToGroup.Dispose();
    hv_TmpNames.Dispose();
    hv_J.Dispose();
    hv_FirstOccurrence.Dispose();

    return;
  }

  // Chapter: Image / Manipulation
  public void apply_brightness_variation_spot (HObject ho_Image, out HObject ho_ImageSpot, 
      HTuple hv_SpotSize, HTuple hv_SpotRow, HTuple hv_SpotColumn, HTuple hv_BrightnessVariation)
  {




      // Stack for temporary objects 
      HObject[] OTemp = new HObject[20];

      // Local iconic variables 

      HObject ho_Filter, ho_GaussImage, ho_GaussFilter;
      HObject ho_Gauss, ho_GaussTargetType, ho_AddImage;

      // Local control variables 

      HTuple hv_Direction = new HTuple(), hv_Width = new HTuple();
      HTuple hv_Height = new HTuple(), hv_ShiftRow = new HTuple();
      HTuple hv_ShiftCol = new HTuple(), hv_Type = new HTuple();
      HTuple hv_NChannels = new HTuple(), hv_Index1 = new HTuple();
      HTuple   hv_BrightnessVariation_COPY_INP_TMP = new HTuple(hv_BrightnessVariation);

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_ImageSpot);
      HOperatorSet.GenEmptyObj(out ho_Filter);
      HOperatorSet.GenEmptyObj(out ho_GaussImage);
      HOperatorSet.GenEmptyObj(out ho_GaussFilter);
      HOperatorSet.GenEmptyObj(out ho_Gauss);
      HOperatorSet.GenEmptyObj(out ho_GaussTargetType);
      HOperatorSet.GenEmptyObj(out ho_AddImage);
    //This procedure applies a brightness spot
    //of a given intensity and size at a given location
    //to the input image.
    //The modified image is returned in ImageSpot.
    //
    if ((int)(new HTuple(hv_BrightnessVariation_COPY_INP_TMP.TupleLess(0))) != 0)
    {
      hv_Direction.Dispose();
      hv_Direction = 0;
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_BrightnessVariation = -hv_BrightnessVariation_COPY_INP_TMP;
      hv_BrightnessVariation_COPY_INP_TMP.Dispose();
      hv_BrightnessVariation_COPY_INP_TMP = ExpTmpLocalVar_BrightnessVariation;
      }
      }
    }
    else
    {
      hv_Direction.Dispose();
      hv_Direction = 1;
    }
    hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
    //Generate Gauss filter that simulates an illumination spot of size 'SpotSize'.
    ho_Filter.Dispose();
    HOperatorSet.GenGaussFilter(out ho_Filter, 1, 1, 0, "none", "dc_center", hv_SpotSize, 
        hv_SpotSize);
    //Shift the filter image to the given position.
    hv_ShiftRow.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ShiftRow = -((hv_SpotSize/2)-hv_SpotRow);
    }
    hv_ShiftCol.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ShiftCol = -((hv_SpotSize/2)-hv_SpotColumn);
    }
    ho_GaussImage.Dispose();
    HOperatorSet.TileImagesOffset(ho_Filter, out ho_GaussImage, hv_ShiftRow, hv_ShiftCol, 
        -1, -1, -1, -1, hv_Width, hv_Height);
    ho_GaussFilter.Dispose();
    HOperatorSet.FullDomain(ho_GaussImage, out ho_GaussFilter);
    //Convert Gauss filter to target image type and apply brightness variation.
    hv_Type.Dispose();
    HOperatorSet.GetImageType(ho_Image, out hv_Type);
    ho_Gauss.Dispose();
    HOperatorSet.ScaleImage(ho_GaussFilter, out ho_Gauss, hv_BrightnessVariation_COPY_INP_TMP, 
        0);
    ho_GaussTargetType.Dispose();
    HOperatorSet.ConvertImageType(ho_Gauss, out ho_GaussTargetType, hv_Type);
    //Add channels to fit input image.
    hv_NChannels.Dispose();
    HOperatorSet.CountChannels(ho_Image, out hv_NChannels);
    ho_AddImage.Dispose();
    HOperatorSet.CopyObj(ho_GaussTargetType, out ho_AddImage, 1, 1);
    HTuple end_val26 = hv_NChannels-1;
    HTuple step_val26 = 1;
    for (hv_Index1=1; hv_Index1.Continue(end_val26, step_val26); hv_Index1 = hv_Index1.TupleAdd(step_val26))
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.AppendChannel(ho_AddImage, ho_GaussTargetType, out ExpTmpOutVar_0
          );
      ho_AddImage.Dispose();
      ho_AddImage = ExpTmpOutVar_0;
      }
    }
    //Apply on image.
    if ((int)(hv_Direction) != 0)
    {
      ho_ImageSpot.Dispose();
      HOperatorSet.AddImage(ho_Image, ho_AddImage, out ho_ImageSpot, 1, 0);
    }
    else
    {
      ho_ImageSpot.Dispose();
      HOperatorSet.SubImage(ho_Image, ho_AddImage, out ho_ImageSpot, 1, 0);
    }
    ho_Filter.Dispose();
    ho_GaussImage.Dispose();
    ho_GaussFilter.Dispose();
    ho_Gauss.Dispose();
    ho_GaussTargetType.Dispose();
    ho_AddImage.Dispose();

    hv_BrightnessVariation_COPY_INP_TMP.Dispose();
    hv_Direction.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_ShiftRow.Dispose();
    hv_ShiftCol.Dispose();
    hv_Type.Dispose();
    hv_NChannels.Dispose();
    hv_Index1.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Return the classification results for the given images. 
  public void apply_dl_classifier_batchwise (HTuple hv_ImageFiles, HTuple hv_DLClassifierHandle, 
      out HTuple hv_DLClassifierResultIDs, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_PredictedClasses, 
      out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_Confidences)
  {



    // Local iconic variables 

    HObject ho_BatchImages=null;

    // Local control variables 

    HTuple hv_BatchSize = new HTuple(), hv_NumImages = new HTuple();
    HTuple hv_Sequence = new HTuple(), hv_BatchStartIndex = new HTuple();
    HTuple hv_BatchIndices = new HTuple(), hv_BatchImageFiles = new HTuple();
    HTuple hv_DLClassifierResultID = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_NumImagesInBatch = new HTuple(), hv_Index = new HTuple();
    HTuple hv_PredictedClass = new HTuple(), hv_ClassConfidence = new HTuple();
    HTuple hv_VectorIndex = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_BatchImages);
    hv_DLClassifierResultIDs = new HTuple();
    hvec_PredictedClasses = new HTupleVector(1);
    hvec_Confidences = new HTupleVector(1);
    //This procedure classifies the images given as paths
    //by ImageFiles using the operator apply_dl_classifier.
    //To avoid that the main memory is overloaded, the images
    //are classified batchwise, according to the hyperparameter 'batch_size',
    //which is stored in the DLClassifierHandle.
    //As result, the classification result handles for every batch
    //are returned in DLClassifierResultIDs.
    //Additionally, for every image the descending sorted
    //Confidences and corresponding PredictedClasses
    //are returned as vectors.
    //
    //Get batch size from handle.
    hv_BatchSize.Dispose();
    HOperatorSet.GetDlClassifierParam(hv_DLClassifierHandle, "batch_size", out hv_BatchSize);
    //
    //Check the input parameters.
    if ((int)(new HTuple((new HTuple(hv_ImageFiles.TupleLength())).TupleLess(1))) != 0)
    {
      throw new HalconException("ImageFiles must not be empty.");
    }
    //
    //Sequence is used for easier indexing of the images.
    hv_NumImages.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumImages = new HTuple(hv_ImageFiles.TupleLength()
        );
    }
    hv_Sequence.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Sequence = HTuple.TupleGenSequence(
        0,hv_NumImages-1,1);
    }
    //
    //Loop through all selected images.
    hvec_PredictedClasses.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_PredictedClasses = dh.Take(dh.Add(new HTupleVector(1)));
    }
    hvec_Confidences.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Confidences = dh.Take(dh.Add(new HTupleVector(1)));
    }
    hv_DLClassifierResultIDs.Dispose();
    hv_DLClassifierResultIDs = new HTuple();
    HTuple end_val27 = hv_NumImages-1;
    HTuple step_val27 = hv_BatchSize;
    for (hv_BatchStartIndex=0; hv_BatchStartIndex.Continue(end_val27, step_val27); hv_BatchStartIndex = hv_BatchStartIndex.TupleAdd(step_val27))
    {
      //Select the data for the current batch.
      hv_BatchIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BatchIndices = hv_Sequence.TupleSelectRange(
          hv_BatchStartIndex,(((hv_BatchStartIndex+hv_BatchSize)-1)).TupleMin2(hv_NumImages-1));
      }
      hv_BatchImageFiles.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BatchImageFiles = hv_ImageFiles.TupleSelect(
          hv_BatchIndices);
      }
      //Read the current batch images.
      ho_BatchImages.Dispose();
      HOperatorSet.ReadImage(out ho_BatchImages, hv_BatchImageFiles);
      //Apply the classifier for this batch.
      try
      {
        hv_DLClassifierResultID.Dispose();
        HOperatorSet.ApplyDlClassifier(ho_BatchImages, hv_DLClassifierHandle, out hv_DLClassifierResultID);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        if ((int)(((((hv_Exception.TupleSelect(0))).TupleEqualElem(((((new HTuple(2106)).TupleConcat(
            2107)).TupleConcat(3122)).TupleConcat(9001)).TupleConcat(9003)))).TupleSum()
            ) != 0)
        {
          throw new HalconException(new HTuple("Images need to fulfill the network requirements, please provide preprocessed images."));
        }
        else
        {
          throw new HalconException(hv_Exception);
        }
      }
      //Get results from result handle.
      hv_NumImagesInBatch.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumImagesInBatch = new HTuple(hv_BatchImageFiles.TupleLength()
          );
      }
      HTuple end_val45 = hv_NumImagesInBatch-1;
      HTuple step_val45 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val45, step_val45); hv_Index = hv_Index.TupleAdd(step_val45))
      {
        hv_PredictedClass.Dispose();
        HOperatorSet.GetDlClassifierResult(hv_DLClassifierResultID, hv_Index, "predicted_classes", 
            out hv_PredictedClass);
        hv_ClassConfidence.Dispose();
        HOperatorSet.GetDlClassifierResult(hv_DLClassifierResultID, hv_Index, "confidences", 
            out hv_ClassConfidence);
        //Store the classification results.
        hv_VectorIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_VectorIndex = hv_BatchStartIndex+hv_Index;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hvec_PredictedClasses[hv_VectorIndex] = dh.Add(new HTupleVector(hv_PredictedClass));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hvec_Confidences[hv_VectorIndex] = dh.Add(new HTupleVector(hv_ClassConfidence));
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DLClassifierResultIDs = hv_DLClassifierResultIDs.TupleConcat(
          hv_DLClassifierResultID);
      hv_DLClassifierResultIDs.Dispose();
      hv_DLClassifierResultIDs = ExpTmpLocalVar_DLClassifierResultIDs;
      }
      }
    }
    ho_BatchImages.Dispose();

    hv_BatchSize.Dispose();
    hv_NumImages.Dispose();
    hv_Sequence.Dispose();
    hv_BatchStartIndex.Dispose();
    hv_BatchIndices.Dispose();
    hv_BatchImageFiles.Dispose();
    hv_DLClassifierResultID.Dispose();
    hv_Exception.Dispose();
    hv_NumImagesInBatch.Dispose();
    hv_Index.Dispose();
    hv_PredictedClass.Dispose();
    hv_ClassConfidence.Dispose();
    hv_VectorIndex.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  public void area_iou (HTuple hv_Sample, HTuple hv_Result, HTuple hv_InstanceType, 
      HTuple hv_ResultSortIndices, out HTuple hv_SampleArea, out HTuple hv_ResultArea, 
      out HTuple hv_IoU)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_GtRow1 = new HTuple(), hv_GtCol1 = new HTuple();
    HTuple hv_GtRow2 = new HTuple(), hv_GtCol2 = new HTuple();
    HTuple hv_ResRow1 = new HTuple(), hv_ResCol1 = new HTuple();
    HTuple hv_ResRow2 = new HTuple(), hv_ResCol2 = new HTuple();
    HTuple hv_GtIdx = new HTuple(), hv_Height = new HTuple();
    HTuple hv_Width = new HTuple(), hv_ValidIdxs = new HTuple();
    HTuple hv_Intersection = new HTuple(), hv_Union = new HTuple();
    // Initialize local and output iconic variables 
    hv_SampleArea = new HTuple();
    hv_ResultArea = new HTuple();
    hv_IoU = new HTuple();
    //
    //Compute the intersection over union (IoU) between
    //the ground truths and the results,
    //whereby the instances are bounding boxes.
    //
    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
    {
      //Get bounding box coordinates.
      hv_GtRow1.Dispose();
      HOperatorSet.GetDictTuple(hv_Sample, "bbox_row1", out hv_GtRow1);
      hv_GtCol1.Dispose();
      HOperatorSet.GetDictTuple(hv_Sample, "bbox_col1", out hv_GtCol1);
      hv_GtRow2.Dispose();
      HOperatorSet.GetDictTuple(hv_Sample, "bbox_row2", out hv_GtRow2);
      hv_GtCol2.Dispose();
      HOperatorSet.GetDictTuple(hv_Sample, "bbox_col2", out hv_GtCol2);
      hv_ResRow1.Dispose();
      HOperatorSet.GetDictTuple(hv_Result, "bbox_row1", out hv_ResRow1);
      hv_ResCol1.Dispose();
      HOperatorSet.GetDictTuple(hv_Result, "bbox_col1", out hv_ResCol1);
      hv_ResRow2.Dispose();
      HOperatorSet.GetDictTuple(hv_Result, "bbox_row2", out hv_ResRow2);
      hv_ResCol2.Dispose();
      HOperatorSet.GetDictTuple(hv_Result, "bbox_col2", out hv_ResCol2);
      //
      //Sort the results.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ResRow1 = hv_ResRow1.TupleSelect(
          hv_ResultSortIndices);
      hv_ResRow1.Dispose();
      hv_ResRow1 = ExpTmpLocalVar_ResRow1;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ResCol1 = hv_ResCol1.TupleSelect(
          hv_ResultSortIndices);
      hv_ResCol1.Dispose();
      hv_ResCol1 = ExpTmpLocalVar_ResCol1;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ResRow2 = hv_ResRow2.TupleSelect(
          hv_ResultSortIndices);
      hv_ResRow2.Dispose();
      hv_ResRow2 = ExpTmpLocalVar_ResRow2;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ResCol2 = hv_ResCol2.TupleSelect(
          hv_ResultSortIndices);
      hv_ResCol2.Dispose();
      hv_ResCol2 = ExpTmpLocalVar_ResCol2;
      }
      }
      //
      //Compute areas.
      hv_SampleArea.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SampleArea = (hv_GtRow2-hv_GtRow1)*(hv_GtCol2-hv_GtCol1);
      }
      hv_ResultArea.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ResultArea = (hv_ResRow2-hv_ResRow1)*(hv_ResCol2-hv_ResCol1);
      }
      //
      //Compute IoUs.
      hv_IoU.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IoU = HTuple.TupleGenConst(
          (new HTuple(hv_GtRow1.TupleLength()))*(new HTuple(hv_ResRow1.TupleLength()
          )),0);
      }
      if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
      {
        for (hv_GtIdx=0; (int)hv_GtIdx<=(int)((new HTuple(hv_GtRow1.TupleLength()
            ))-1); hv_GtIdx = (int)hv_GtIdx + 1)
        {
          hv_Height.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Height = (((hv_GtRow2.TupleSelect(
              hv_GtIdx))).TupleMin2(hv_ResRow2))-(((hv_GtRow1.TupleSelect(hv_GtIdx))).TupleMax2(
              hv_ResRow1));
          }
          hv_Width.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Width = (((hv_GtCol2.TupleSelect(
              hv_GtIdx))).TupleMin2(hv_ResCol2))-(((hv_GtCol1.TupleSelect(hv_GtIdx))).TupleMax2(
              hv_ResCol1));
          }
          hv_ValidIdxs.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ValidIdxs = (new HTuple(((hv_Height.TupleGreaterElem(
              0))).TupleAnd(hv_Width.TupleGreaterElem(0)))).TupleFind(1);
          }
          if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
          {
            hv_Intersection.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Intersection = (hv_Height.TupleSelect(
                hv_ValidIdxs))*(hv_Width.TupleSelect(hv_ValidIdxs));
            }
            hv_Union.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Union = ((hv_SampleArea.TupleSelect(
                hv_GtIdx))+(hv_ResultArea.TupleSelect(hv_ValidIdxs)))-hv_Intersection;
            }
            if (hv_IoU == null)
              hv_IoU = new HTuple();
            hv_IoU[(hv_GtIdx*(new HTuple(hv_ResRow1.TupleLength())))+hv_ValidIdxs] = (hv_Intersection.TupleReal()
                )/hv_Union;
          }
        }
      }
    }
    else
    {
      throw new HalconException(("Instance type '"+hv_InstanceType)+"' is not supported");
    }

    hv_GtRow1.Dispose();
    hv_GtCol1.Dispose();
    hv_GtRow2.Dispose();
    hv_GtCol2.Dispose();
    hv_ResRow1.Dispose();
    hv_ResCol1.Dispose();
    hv_ResRow2.Dispose();
    hv_ResCol2.Dispose();
    hv_GtIdx.Dispose();
    hv_Height.Dispose();
    hv_Width.Dispose();
    hv_ValidIdxs.Dispose();
    hv_Intersection.Dispose();
    hv_Union.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Distort the given samples to augment the dataset. 
  public void augment_dl_samples (HTuple hv_DLSampleBatch, HTuple hv_GenParam)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image=null, ho_SegmentationImage=null;
    HObject ho_WeightImage=null, ho_ImageRotate=null;

    // Local control variables 

    HTuple hv_AugmentationPercentage = new HTuple();
    HTuple hv_Rotation = new HTuple(), hv_Mirror = new HTuple();
    HTuple hv_KeysExist = new HTuple(), hv_CurrentParamValue = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_NumSamples = new HTuple();
    HTuple hv_NumAvailableDistortions = new HTuple(), hv_SampleIndex = new HTuple();
    HTuple hv_SelectedDistortion = new HTuple(), hv_CurrentDistortion = new HTuple();
    HTuple hv_DLSample = new HTuple(), hv_BBoxRow1 = new HTuple();
    HTuple hv_BBoxCol1 = new HTuple(), hv_BBoxRow2 = new HTuple();
    HTuple hv_BBoxCol2 = new HTuple(), hv_RotationStep = new HTuple();
    HTuple hv_NumPossibleRotations = new HTuple(), hv_CurrentRotation = new HTuple();
    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DTmp = new HTuple();
    HTuple hv_HomMat2DAdapted = new HTuple(), hv_Offset = new HTuple();
    HTuple hv_HomMat2DRotate = new HTuple(), hv_RowTrans1 = new HTuple();
    HTuple hv_ColTrans1 = new HTuple(), hv_RowTrans2 = new HTuple();
    HTuple hv_ColTrans2 = new HTuple(), hv_NumMirrorMethods = new HTuple();
    HTuple hv_ProbabilityMethods = new HTuple(), hv_StrMirror = new HTuple();
    HTuple hv_StrIdx = new HTuple(), hv_SelectedChar = new HTuple();
    HTuple hv_BBoxCol1Mirror = new HTuple(), hv_BBoxCol2Mirror = new HTuple();
    HTuple hv_BBoxRow1Mirror = new HTuple(), hv_BBoxRow2Mirror = new HTuple();

    HTupleVector hvec_AvailableDistortions = new HTupleVector(1);
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_SegmentationImage);
    HOperatorSet.GenEmptyObj(out ho_WeightImage);
    HOperatorSet.GenEmptyObj(out ho_ImageRotate);
    //
    //This procedure chooses random samples in the DLSampleBatch
    //and modifies them in order to augment the dataset.
    //The augmentation method has to be specified
    //using the dictionary GenParam.
    //
    //If no augmentation parameter is given we return directly and the samples stay unchanged.
    if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleEqual(0))) != 0)
    {
      ho_Image.Dispose();
      ho_SegmentationImage.Dispose();
      ho_WeightImage.Dispose();
      ho_ImageRotate.Dispose();

      hv_AugmentationPercentage.Dispose();
      hv_Rotation.Dispose();
      hv_Mirror.Dispose();
      hv_KeysExist.Dispose();
      hv_CurrentParamValue.Dispose();
      hv_Exception.Dispose();
      hv_NumSamples.Dispose();
      hv_NumAvailableDistortions.Dispose();
      hv_SampleIndex.Dispose();
      hv_SelectedDistortion.Dispose();
      hv_CurrentDistortion.Dispose();
      hv_DLSample.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxCol2.Dispose();
      hv_RotationStep.Dispose();
      hv_NumPossibleRotations.Dispose();
      hv_CurrentRotation.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DTmp.Dispose();
      hv_HomMat2DAdapted.Dispose();
      hv_Offset.Dispose();
      hv_HomMat2DRotate.Dispose();
      hv_RowTrans1.Dispose();
      hv_ColTrans1.Dispose();
      hv_RowTrans2.Dispose();
      hv_ColTrans2.Dispose();
      hv_NumMirrorMethods.Dispose();
      hv_ProbabilityMethods.Dispose();
      hv_StrMirror.Dispose();
      hv_StrIdx.Dispose();
      hv_SelectedChar.Dispose();
      hv_BBoxCol1Mirror.Dispose();
      hv_BBoxCol2Mirror.Dispose();
      hv_BBoxRow1Mirror.Dispose();
      hv_BBoxRow2Mirror.Dispose();
      hvec_AvailableDistortions.Dispose();

      return;
    }
    //
    //** Set the default values: ***
    //
    //The percentage of the images that are to be augmented.
    hv_AugmentationPercentage.Dispose();
    hv_AugmentationPercentage = new HTuple();
    hv_AugmentationPercentage[0] = "augmentation_percentage";
    hv_AugmentationPercentage[1] = 50;
    //Step size for possible rotations.
    hv_Rotation.Dispose();
    hv_Rotation = new HTuple();
    hv_Rotation[0] = "rotate";
    hv_Rotation[1] = 0;
    //Allowed mirroring types are coded by 'r' (row), 'c' (column).
    hv_Mirror.Dispose();
    hv_Mirror = new HTuple();
    hv_Mirror[0] = "mirror";
    hv_Mirror[1] = "off";
    //
    //** Set user-defined parameters: ***
    //
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_KeysExist.Dispose();
    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", ((((hv_AugmentationPercentage.TupleSelect(
        0))).TupleConcat(hv_Mirror.TupleSelect(0)))).TupleConcat(hv_Rotation.TupleSelect(
        0)), out hv_KeysExist);
    }
    if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
    {
      //Set augmentation percentage.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentParamValue.Dispose();
      HOperatorSet.GetDictTuple(hv_GenParam, hv_AugmentationPercentage.TupleSelect(
          0), out hv_CurrentParamValue);
      }
      if (hv_AugmentationPercentage == null)
        hv_AugmentationPercentage = new HTuple();
      hv_AugmentationPercentage[1] = hv_CurrentParamValue;
      //Check if input value is in range of 0-100 %.
      hv_Exception.Dispose();
      hv_Exception = "The given value for augmentation_percentage has to be in the range 0-100.";
      if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
      {
        if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(0))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
            100)))) != 0)
        {
          throw new HalconException(hv_Exception);
        }
      }
      else
      {
        throw new HalconException(hv_Exception);
      }
    }
    //If nothing should be augmented we return immediately.
    if ((int)(new HTuple(((hv_AugmentationPercentage.TupleSelect(1))).TupleEqual(
        0))) != 0)
    {
      ho_Image.Dispose();
      ho_SegmentationImage.Dispose();
      ho_WeightImage.Dispose();
      ho_ImageRotate.Dispose();

      hv_AugmentationPercentage.Dispose();
      hv_Rotation.Dispose();
      hv_Mirror.Dispose();
      hv_KeysExist.Dispose();
      hv_CurrentParamValue.Dispose();
      hv_Exception.Dispose();
      hv_NumSamples.Dispose();
      hv_NumAvailableDistortions.Dispose();
      hv_SampleIndex.Dispose();
      hv_SelectedDistortion.Dispose();
      hv_CurrentDistortion.Dispose();
      hv_DLSample.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxCol2.Dispose();
      hv_RotationStep.Dispose();
      hv_NumPossibleRotations.Dispose();
      hv_CurrentRotation.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DTmp.Dispose();
      hv_HomMat2DAdapted.Dispose();
      hv_Offset.Dispose();
      hv_HomMat2DRotate.Dispose();
      hv_RowTrans1.Dispose();
      hv_ColTrans1.Dispose();
      hv_RowTrans2.Dispose();
      hv_ColTrans2.Dispose();
      hv_NumMirrorMethods.Dispose();
      hv_ProbabilityMethods.Dispose();
      hv_StrMirror.Dispose();
      hv_StrIdx.Dispose();
      hv_SelectedChar.Dispose();
      hv_BBoxCol1Mirror.Dispose();
      hv_BBoxCol2Mirror.Dispose();
      hv_BBoxRow1Mirror.Dispose();
      hv_BBoxRow2Mirror.Dispose();
      hvec_AvailableDistortions.Dispose();

      return;
    }
    if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
    {
      //Set mirroring.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentParamValue.Dispose();
      HOperatorSet.GetDictTuple(hv_GenParam, hv_Mirror.TupleSelect(0), out hv_CurrentParamValue);
      }
      if (hv_Mirror == null)
        hv_Mirror = new HTuple();
      hv_Mirror[1] = hv_CurrentParamValue;
      //Check if the input is a string and contains either 'off' or the mirroring code.
      if ((int)(((hv_CurrentParamValue.TupleIsNumber())).TupleOr((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(hv_CurrentParamValue.TupleEqual(
          "off"))).TupleOr(new HTuple(hv_CurrentParamValue.TupleEqual("c"))))).TupleOr(
          new HTuple(hv_CurrentParamValue.TupleEqual("r"))))).TupleOr(new HTuple(hv_CurrentParamValue.TupleEqual(
          "cr"))))).TupleOr(new HTuple(hv_CurrentParamValue.TupleEqual("rc"))))).TupleNot()
          )) != 0)
      {
        throw new HalconException("Unknown type for mirroring.");
      }
    }
    if ((int)(hv_KeysExist.TupleSelect(2)) != 0)
    {
      //Set rotation.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentParamValue.Dispose();
      HOperatorSet.GetDictTuple(hv_GenParam, hv_Rotation.TupleSelect(0), out hv_CurrentParamValue);
      }
      if (hv_Rotation == null)
        hv_Rotation = new HTuple();
      hv_Rotation[1] = hv_CurrentParamValue;
      //Check if the input value is either 0, 90, or 180.
      hv_Exception.Dispose();
      hv_Exception = new HTuple("The value given for rotation has to be either 0, 90, or 180.");
      if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
      {
        if ((int)(new HTuple((new HTuple((((new HTuple(0)).TupleConcat(90)).TupleConcat(
            180)).TupleFind(hv_CurrentParamValue))).TupleEqual(-1))) != 0)
        {
          throw new HalconException(hv_Exception);
        }
      }
      else
      {
        throw new HalconException(hv_Exception);
      }
    }
    //
    //Aggregate all possible distortions and parameter values into a vector.
    //
    hvec_AvailableDistortions.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_AvailableDistortions = dh.Take(dh.Add(new HTupleVector(1)));
    }
    //Rotation with a given angular step size.
    if ((int)(new HTuple(((hv_Rotation.TupleSelect(1))).TupleGreater(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_Rotation));
      }
    }
    //Mirroring is allowed in row and column direction.
    if ((int)((new HTuple(((hv_Mirror.TupleSelect(1))).TupleRegexpTest("r"))).TupleOr(
        ((hv_Mirror.TupleSelect(1))).TupleRegexpTest("c"))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_Mirror));
      }
    }
    //
    //** Choose random samples and augmentation methods: ***
    //
    //Number of samples to be augmented.
    hv_NumSamples.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumSamples = new HTuple(hv_DLSampleBatch.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumSamples.TupleEqual(0))) != 0)
    {
      throw new HalconException("There are no DLSamples to be processed.");
    }
    //Check number of selected distortions.
    hv_NumAvailableDistortions.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumAvailableDistortions = new HTuple(hvec_AvailableDistortions.Length);
    }
    if ((int)(new HTuple(hv_NumAvailableDistortions.TupleEqual(0))) != 0)
    {
      ho_Image.Dispose();
      ho_SegmentationImage.Dispose();
      ho_WeightImage.Dispose();
      ho_ImageRotate.Dispose();

      hv_AugmentationPercentage.Dispose();
      hv_Rotation.Dispose();
      hv_Mirror.Dispose();
      hv_KeysExist.Dispose();
      hv_CurrentParamValue.Dispose();
      hv_Exception.Dispose();
      hv_NumSamples.Dispose();
      hv_NumAvailableDistortions.Dispose();
      hv_SampleIndex.Dispose();
      hv_SelectedDistortion.Dispose();
      hv_CurrentDistortion.Dispose();
      hv_DLSample.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxCol2.Dispose();
      hv_RotationStep.Dispose();
      hv_NumPossibleRotations.Dispose();
      hv_CurrentRotation.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DTmp.Dispose();
      hv_HomMat2DAdapted.Dispose();
      hv_Offset.Dispose();
      hv_HomMat2DRotate.Dispose();
      hv_RowTrans1.Dispose();
      hv_ColTrans1.Dispose();
      hv_RowTrans2.Dispose();
      hv_ColTrans2.Dispose();
      hv_NumMirrorMethods.Dispose();
      hv_ProbabilityMethods.Dispose();
      hv_StrMirror.Dispose();
      hv_StrIdx.Dispose();
      hv_SelectedChar.Dispose();
      hv_BBoxCol1Mirror.Dispose();
      hv_BBoxCol2Mirror.Dispose();
      hv_BBoxRow1Mirror.Dispose();
      hv_BBoxRow2Mirror.Dispose();
      hvec_AvailableDistortions.Dispose();

      return;
    }
    //Select a random distortion type for each sample.
    //
    //Augment (distort) the samples.
    //
    HTuple end_val93 = hv_NumSamples-1;
    HTuple step_val93 = 1;
    for (hv_SampleIndex=0; hv_SampleIndex.Continue(end_val93, step_val93); hv_SampleIndex = hv_SampleIndex.TupleAdd(step_val93))
    {
      if ((int)(new HTuple((new HTuple(HTuple.TupleRand(1)*100)).TupleGreater(hv_AugmentationPercentage.TupleSelect(
          1)))) != 0)
      {
        //Only augment the given percentage of samples.
        continue;
      }
      //Select the distortion type.
      hv_SelectedDistortion.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SelectedDistortion = ((HTuple.TupleRand(
          1)*hv_NumAvailableDistortions)).TupleInt();
      }
      hv_CurrentDistortion.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentDistortion = new HTuple(hvec_AvailableDistortions[hv_SelectedDistortion].T);
      }
      //
      //Select the image to be augmented.
      hv_DLSample.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLSample = hv_DLSampleBatch.TupleSelect(
          hv_SampleIndex);
      }
      ho_Image.Dispose();
      HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
      hv_KeysExist.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "key_exists", ((new HTuple("bbox_label_id")).TupleConcat(
          "segmentation_image")).TupleConcat("weight_image"), out hv_KeysExist);
      //Check which keys have to be modified as well.
      if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
      {
        hv_BBoxRow1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BBoxRow1);
        hv_BBoxCol1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BBoxCol1);
        hv_BBoxRow2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BBoxRow2);
        hv_BBoxCol2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BBoxCol2);
      }
      if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
      {
        ho_SegmentationImage.Dispose();
        HOperatorSet.GetDictObject(out ho_SegmentationImage, hv_DLSample, "segmentation_image");
      }
      if ((int)(hv_KeysExist.TupleSelect(2)) != 0)
      {
        ho_WeightImage.Dispose();
        HOperatorSet.GetDictObject(out ho_WeightImage, hv_DLSample, "weight_image");
      }
      //
      if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(hv_Rotation.TupleSelect(
          0)))) != 0)
      {
        //
        //Rotation
        //
        //Determine rotation angle for distortion type 'rotate' (angle in range (0:CurrentDistortion[1]:360)).
        hv_RotationStep.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RotationStep = hv_CurrentDistortion.TupleSelect(
            1);
        }
        hv_NumPossibleRotations.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumPossibleRotations = (360.0/hv_RotationStep)-1;
        }
        hv_CurrentRotation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentRotation = hv_RotationStep*((((hv_NumPossibleRotations*HTuple.TupleRand(
            1))).TupleInt())+1);
        }
        //
        if ((int)(new HTuple(hv_CurrentRotation.TupleNotEqual(0))) != 0)
        {
          hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
          if ((int)((new HTuple(hv_ImageWidth.TupleNotEqual(hv_ImageHeight))).TupleAnd(
              new HTuple(hv_CurrentRotation.TupleNotEqual(180.0)))) != 0)
          {
            //If an image is not quadratic, a rotation by 90 or 270 degrees is ignored.
            continue;
          }
          //
          ho_ImageRotate.Dispose();
          HOperatorSet.RotateImage(ho_Image, out ho_ImageRotate, hv_CurrentRotation, 
              "constant");
          HOperatorSet.SetDictObject(ho_ImageRotate, hv_DLSample, "image");
          //
          if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
          {
            //Create a transformation matrix for the rotation of the bounding boxes.
            hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
            HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
            hv_HomMat2DIdentity.Dispose();
            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
            hv_HomMat2DTmp.Dispose();
            HOperatorSet.HomMat2dTranslate(hv_HomMat2DIdentity, 0.5, 0.5, out hv_HomMat2DTmp);
            hv_HomMat2DAdapted.Dispose();
            HOperatorSet.HomMat2dTranslateLocal(hv_HomMat2DTmp, -0.5, -0.5, out hv_HomMat2DAdapted);
            hv_Offset.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Offset = ((hv_ImageHeight-hv_ImageWidth)*0.5)*(((hv_CurrentRotation.TupleRad()
                )).TupleSin());
            }
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.HomMat2dTranslate(hv_HomMat2DAdapted, hv_Offset, hv_Offset, 
                out ExpTmpOutVar_0);
            hv_HomMat2DAdapted.Dispose();
            hv_HomMat2DAdapted = ExpTmpOutVar_0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HomMat2DRotate.Dispose();
            HOperatorSet.HomMat2dRotate(hv_HomMat2DAdapted, hv_CurrentRotation.TupleRad()
                , hv_ImageHeight*0.5, hv_ImageWidth*0.5, out hv_HomMat2DRotate);
            }
            //Get the coordinates of the rotated bounding box.
            hv_RowTrans1.Dispose();hv_ColTrans1.Dispose();
            HOperatorSet.AffineTransPixel(hv_HomMat2DRotate, hv_BBoxRow1, hv_BBoxCol1, 
                out hv_RowTrans1, out hv_ColTrans1);
            hv_RowTrans2.Dispose();hv_ColTrans2.Dispose();
            HOperatorSet.AffineTransPixel(hv_HomMat2DRotate, hv_BBoxRow2, hv_BBoxCol2, 
                out hv_RowTrans2, out hv_ColTrans2);
            if ((int)(new HTuple(hv_CurrentRotation.TupleEqual(90))) != 0)
            {
              hv_BBoxRow1.Dispose();
              hv_BBoxRow1 = new HTuple(hv_RowTrans2);
              hv_BBoxCol1.Dispose();
              hv_BBoxCol1 = new HTuple(hv_ColTrans1);
              hv_BBoxRow2.Dispose();
              hv_BBoxRow2 = new HTuple(hv_RowTrans1);
              hv_BBoxCol2.Dispose();
              hv_BBoxCol2 = new HTuple(hv_ColTrans2);
            }
            else if ((int)(new HTuple(hv_CurrentRotation.TupleEqual(
                180))) != 0)
            {
              hv_BBoxRow1.Dispose();
              hv_BBoxRow1 = new HTuple(hv_RowTrans2);
              hv_BBoxCol1.Dispose();
              hv_BBoxCol1 = new HTuple(hv_ColTrans2);
              hv_BBoxRow2.Dispose();
              hv_BBoxRow2 = new HTuple(hv_RowTrans1);
              hv_BBoxCol2.Dispose();
              hv_BBoxCol2 = new HTuple(hv_ColTrans1);
            }
            else if ((int)(new HTuple(hv_CurrentRotation.TupleEqual(
                270))) != 0)
            {
              hv_BBoxRow1.Dispose();
              hv_BBoxRow1 = new HTuple(hv_RowTrans1);
              hv_BBoxCol1.Dispose();
              hv_BBoxCol1 = new HTuple(hv_ColTrans2);
              hv_BBoxRow2.Dispose();
              hv_BBoxRow2 = new HTuple(hv_RowTrans2);
              hv_BBoxCol2.Dispose();
              hv_BBoxCol2 = new HTuple(hv_ColTrans1);
            }
            //
            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_BBoxRow1);
            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_BBoxCol1);
            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_BBoxRow2);
            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_BBoxCol2);
          }
          if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.RotateImage(ho_SegmentationImage, out ExpTmpOutVar_0, hv_CurrentRotation.TupleInt()
                , "constant");
            ho_SegmentationImage.Dispose();
            ho_SegmentationImage = ExpTmpOutVar_0;
            }
            HOperatorSet.SetDictObject(ho_SegmentationImage, hv_DLSample, "segmentation_image");
          }
          if ((int)(hv_KeysExist.TupleSelect(2)) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.RotateImage(ho_WeightImage, out ExpTmpOutVar_0, hv_CurrentRotation.TupleInt()
                , "constant");
            ho_WeightImage.Dispose();
            ho_WeightImage = ExpTmpOutVar_0;
            }
            HOperatorSet.SetDictObject(ho_WeightImage, hv_DLSample, "weight_image");
          }
        }
      }
      else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
          hv_Mirror.TupleSelect(0)))) != 0)
      {
        //
        //Mirroring
        //
        //If more than one axis is allowed,
        //choose mirror axis/axes to be applied.
        hv_NumMirrorMethods.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumMirrorMethods = ((hv_CurrentDistortion.TupleSelect(
            1))).TupleStrlen();
        }
        hv_ProbabilityMethods.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ProbabilityMethods = 1.0/hv_NumMirrorMethods;
        }
        hv_StrMirror.Dispose();
        hv_StrMirror = "";
        while ((int)(new HTuple(hv_StrMirror.TupleEqual(""))) != 0)
        {
          HTuple end_val192 = hv_NumMirrorMethods-1;
          HTuple step_val192 = 1;
          for (hv_StrIdx=0; hv_StrIdx.Continue(end_val192, step_val192); hv_StrIdx = hv_StrIdx.TupleAdd(step_val192))
          {
            hv_SelectedChar.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_SelectedChar = ((hv_CurrentDistortion.TupleSelect(
                1))).TupleStrBitSelect(hv_StrIdx);
            }
            if ((int)(new HTuple((HTuple.TupleRand(1)).TupleLess(hv_ProbabilityMethods))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_StrMirror = hv_StrMirror+hv_SelectedChar;
              hv_StrMirror.Dispose();
              hv_StrMirror = ExpTmpLocalVar_StrMirror;
              }
              }
            }
          }
        }
        //Apply the chosen mirror axis/axes to the given sample data.
        hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
        if ((int)(hv_StrMirror.TupleRegexpTest("c")) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.MirrorImage(ho_Image, out ExpTmpOutVar_0, "column");
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
          {
            hv_BBoxCol1Mirror.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BBoxCol1Mirror = (hv_ImageWidth-hv_BBoxCol2)-1;
            }
            hv_BBoxCol2Mirror.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BBoxCol2Mirror = (hv_ImageWidth-hv_BBoxCol1)-1;
            }
            hv_BBoxCol1.Dispose();
            hv_BBoxCol1 = new HTuple(hv_BBoxCol1Mirror);
            hv_BBoxCol2.Dispose();
            hv_BBoxCol2 = new HTuple(hv_BBoxCol2Mirror);
          }
          if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.MirrorImage(ho_SegmentationImage, out ExpTmpOutVar_0, "column");
            ho_SegmentationImage.Dispose();
            ho_SegmentationImage = ExpTmpOutVar_0;
            }
          }
          if ((int)(hv_KeysExist.TupleSelect(2)) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.MirrorImage(ho_WeightImage, out ExpTmpOutVar_0, "column");
            ho_WeightImage.Dispose();
            ho_WeightImage = ExpTmpOutVar_0;
            }
          }
        }
        //
        if ((int)(hv_StrMirror.TupleRegexpTest("r")) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.MirrorImage(ho_Image, out ExpTmpOutVar_0, "row");
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
          {
            hv_BBoxRow1Mirror.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BBoxRow1Mirror = (hv_ImageHeight-hv_BBoxRow2)-1;
            }
            hv_BBoxRow2Mirror.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BBoxRow2Mirror = (hv_ImageHeight-hv_BBoxRow1)-1;
            }
            hv_BBoxRow1.Dispose();
            hv_BBoxRow1 = new HTuple(hv_BBoxRow1Mirror);
            hv_BBoxRow2.Dispose();
            hv_BBoxRow2 = new HTuple(hv_BBoxRow2Mirror);
          }
          if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.MirrorImage(ho_SegmentationImage, out ExpTmpOutVar_0, "row");
            ho_SegmentationImage.Dispose();
            ho_SegmentationImage = ExpTmpOutVar_0;
            }
          }
          if ((int)(hv_KeysExist.TupleSelect(2)) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.MirrorImage(ho_WeightImage, out ExpTmpOutVar_0, "row");
            ho_WeightImage.Dispose();
            ho_WeightImage = ExpTmpOutVar_0;
            }
          }
        }
        //
        //Set the mirrored data to DLSample.
        HOperatorSet.SetDictObject(ho_Image, hv_DLSample, "image");
        if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
        {
          HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_BBoxCol1);
          HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_BBoxRow1);
          HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_BBoxCol2);
          HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_BBoxRow2);
        }
        if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
        {
          HOperatorSet.SetDictObject(ho_SegmentationImage, hv_DLSample, "segmentation_image");
        }
        if ((int)(hv_KeysExist.TupleSelect(2)) != 0)
        {
          HOperatorSet.SetDictObject(ho_WeightImage, hv_DLSample, "weight_image");
        }
      }
    }
    ho_Image.Dispose();
    ho_SegmentationImage.Dispose();
    ho_WeightImage.Dispose();
    ho_ImageRotate.Dispose();

    hv_AugmentationPercentage.Dispose();
    hv_Rotation.Dispose();
    hv_Mirror.Dispose();
    hv_KeysExist.Dispose();
    hv_CurrentParamValue.Dispose();
    hv_Exception.Dispose();
    hv_NumSamples.Dispose();
    hv_NumAvailableDistortions.Dispose();
    hv_SampleIndex.Dispose();
    hv_SelectedDistortion.Dispose();
    hv_CurrentDistortion.Dispose();
    hv_DLSample.Dispose();
    hv_BBoxRow1.Dispose();
    hv_BBoxCol1.Dispose();
    hv_BBoxRow2.Dispose();
    hv_BBoxCol2.Dispose();
    hv_RotationStep.Dispose();
    hv_NumPossibleRotations.Dispose();
    hv_CurrentRotation.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_HomMat2DIdentity.Dispose();
    hv_HomMat2DTmp.Dispose();
    hv_HomMat2DAdapted.Dispose();
    hv_Offset.Dispose();
    hv_HomMat2DRotate.Dispose();
    hv_RowTrans1.Dispose();
    hv_ColTrans1.Dispose();
    hv_RowTrans2.Dispose();
    hv_ColTrans2.Dispose();
    hv_NumMirrorMethods.Dispose();
    hv_ProbabilityMethods.Dispose();
    hv_StrMirror.Dispose();
    hv_StrIdx.Dispose();
    hv_SelectedChar.Dispose();
    hv_BBoxCol1Mirror.Dispose();
    hv_BBoxCol2Mirror.Dispose();
    hv_BBoxRow1Mirror.Dispose();
    hv_BBoxRow2Mirror.Dispose();
    hvec_AvailableDistortions.Dispose();

    return;
  }

  // Chapter: Image / Manipulation
  // Short Description: Augment/distort the given images. 
  public void augment_images (HObject ho_Images, out HObject ho_ImagesAugmented, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ImageSelected=null, ho_ImagePart=null;
    HObject ho_ImageRotated=null, ho_DomainRotated=null, ho_ImageScaled=null;
    HObject ho_ImageSpot=null;

    // Local control variables 

    HTuple hv_AugmentationPercentage = new HTuple();
    HTuple hv_CropPercentage = new HTuple(), hv_CropPixel = new HTuple();
    HTuple hv_Rotation = new HTuple(), hv_RotationRange = new HTuple();
    HTuple hv_Mirror = new HTuple(), hv_BrightnessVariation = new HTuple();
    HTuple hv_BrightnessVariationSpot = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_CurrentParamName = new HTuple(), hv_CurrentParamValue = new HTuple();
    HTuple hv_NumAvailableDistortions = new HTuple(), hv_NumImages = new HTuple();
    HTuple hv_AugmentationRate = new HTuple(), hv_NumAugmentations = new HTuple();
    HTuple hv_ImageIndices = new HTuple(), hv_SelectedImages = new HTuple();
    HTuple hv_SelectedDistortions = new HTuple(), hv_IndexDistortion = new HTuple();
    HTuple hv_Index = new HTuple(), hv_ImageIndex = new HTuple();
    HTuple hv_CurrentDistortion = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_CropRate = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Row2 = new HTuple();
    HTuple hv_Column1 = new HTuple(), hv_Column2 = new HTuple();
    HTuple hv_Length = new HTuple(), hv_RotationStep = new HTuple();
    HTuple hv_NumPossibleRotations = new HTuple(), hv_CurrentRotation = new HTuple();
    HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DRotate = new HTuple();
    HTuple hv_NumMirrorMethods = new HTuple(), hv_PropabilityMethods = new HTuple();
    HTuple hv_StrMirror = new HTuple(), hv_StrIdx = new HTuple();
    HTuple hv_SelectedChar = new HTuple(), hv_BrightnessVariationValue = new HTuple();
    HTuple hv_SpotSize = new HTuple(), hv_SpotRow = new HTuple();
    HTuple hv_SpotColumn = new HTuple();

    HTupleVector hvec_AvailableDistortions = new HTupleVector(1);
    HTupleVector hvec_Distortions = new HTupleVector(1);
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImagesAugmented);
    HOperatorSet.GenEmptyObj(out ho_ImageSelected);
    HOperatorSet.GenEmptyObj(out ho_ImagePart);
    HOperatorSet.GenEmptyObj(out ho_ImageRotated);
    HOperatorSet.GenEmptyObj(out ho_DomainRotated);
    HOperatorSet.GenEmptyObj(out ho_ImageScaled);
    HOperatorSet.GenEmptyObj(out ho_ImageSpot);
    //This procedure can be used to augment given input Images
    //using different methods, which can be specified using
    //GenParamName and GenParamValue. The augmented images are returned
    //in ImagesAugmented.
    //
    //Set default parameters.
    //
    //The percentages of the images that are to be augmented.
    hv_AugmentationPercentage.Dispose();
    hv_AugmentationPercentage = new HTuple();
    hv_AugmentationPercentage[0] = "augmentation_percentage";
    hv_AugmentationPercentage[1] = 50;
    //Fraction of image length and width that remains after cropping (in %).
    hv_CropPercentage.Dispose();
    hv_CropPercentage = new HTuple();
    hv_CropPercentage[0] = "crop_percentage";
    hv_CropPercentage[1] = "off";
    //Image length and width that remains after cropping (in pixel).
    hv_CropPixel.Dispose();
    hv_CropPixel = new HTuple();
    hv_CropPixel[0] = "crop_pixel";
    hv_CropPixel[1] = "off";
    //Step size for possible rotations.
    hv_Rotation.Dispose();
    hv_Rotation = new HTuple();
    hv_Rotation[0] = "rotate";
    hv_Rotation[1] = 0;
    //Step range for rotations with step size 1.
    hv_RotationRange.Dispose();
    hv_RotationRange = new HTuple();
    hv_RotationRange[0] = "rotate_range";
    hv_RotationRange[1] = 0;
    //Allowed mirroring methods coded by 'r' (row), 'c' (column).
    hv_Mirror.Dispose();
    hv_Mirror = new HTuple();
    hv_Mirror[0] = "mirror";
    hv_Mirror[1] = "off";
    //The absolute brightness change can vary in the range[-value, +value].
    hv_BrightnessVariation.Dispose();
    hv_BrightnessVariation = new HTuple();
    hv_BrightnessVariation[0] = "brightness_variation";
    hv_BrightnessVariation[1] = 0;
    //The absolute brightness peak of a randomly positioned spot can vary in the range[-value, +value].
    hv_BrightnessVariationSpot.Dispose();
    hv_BrightnessVariationSpot = new HTuple();
    hv_BrightnessVariationSpot[0] = "brightness_variation_spot";
    hv_BrightnessVariationSpot[1] = 0;
    //
    //Parse the generic parameters.
    //
    //Check if GenParamName matches GenParamValue.
    if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleNotEqual(
        new HTuple(hv_GenParamValue.TupleLength())))) != 0)
    {
      throw new HalconException("Number of generic parameters does not match number of generic parameter values");
    }
    //Check for generic parameter names and overwrite defaults.
    for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
        ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
    {
      hv_CurrentParamName.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentParamName = hv_GenParamName.TupleSelect(
          hv_GenParamIndex);
      }
      hv_CurrentParamValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentParamValue = hv_GenParamValue.TupleSelect(
          hv_GenParamIndex);
      }
      //
      if ((int)(new HTuple(hv_CurrentParamName.TupleEqual(hv_AugmentationPercentage.TupleSelect(
          0)))) != 0)
      {
        //Set augmentation percentage.
        if (hv_AugmentationPercentage == null)
          hv_AugmentationPercentage = new HTuple();
        hv_AugmentationPercentage[1] = hv_CurrentParamValue;
        //Check if input value is in range of 1-100 %.
        if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
        {
          if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(1))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
              100)))) != 0)
          {
            throw new HalconException("The given value for augmentation_percentage has to be in the range 1-100.");
          }
        }
        else
        {
          throw new HalconException("The given value for augmentation_percentage has to be in the range 1-100.");
        }
      }
      else if ((int)(new HTuple(hv_CurrentParamName.TupleEqual(hv_Rotation.TupleSelect(
          0)))) != 0)
      {
        //Set rotation.
        if (hv_Rotation == null)
          hv_Rotation = new HTuple();
        hv_Rotation[1] = hv_CurrentParamValue;
        //Check if input value is in range of 0-180 deg.
        if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
        {
          if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(0))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
              180)))) != 0)
          {
            throw new HalconException("The given value for rotate has to be in the range 0-180.");
          }
        }
        else
        {
          throw new HalconException("The given value for rotate has to be in the range 0-180.");
        }
      }
      else if ((int)(new HTuple(hv_CurrentParamName.TupleEqual(hv_RotationRange.TupleSelect(
          0)))) != 0)
      {
        //Set rotation.
        if (hv_RotationRange == null)
          hv_RotationRange = new HTuple();
        hv_RotationRange[1] = hv_CurrentParamValue;
        //Check if input value is in range of 0-180 deg.
        if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
        {
          if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(0))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
              180)))) != 0)
          {
            throw new HalconException("The given value for rotate_range has to be in the range 0-180.\"");
          }
        }
        else
        {
          throw new HalconException("The given value for rotate_range has to be in the range 0-180.");
        }
      }
      else if ((int)(new HTuple(hv_CurrentParamName.TupleEqual(hv_Mirror.TupleSelect(
          0)))) != 0)
      {
        //Set mirroring.
        if (hv_Mirror == null)
          hv_Mirror = new HTuple();
        hv_Mirror[1] = hv_CurrentParamValue;
        //Check if input is string and is 'off' or contains the wanted strings.
        if ((int)(((hv_CurrentParamValue.TupleIsNumber())).TupleOr((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(hv_CurrentParamValue.TupleEqual(
            "off"))).TupleOr(new HTuple(hv_CurrentParamValue.TupleEqual("c"))))).TupleOr(
            new HTuple(hv_CurrentParamValue.TupleEqual("r"))))).TupleOr(new HTuple(hv_CurrentParamValue.TupleEqual(
            "cr"))))).TupleOr(new HTuple(hv_CurrentParamValue.TupleEqual("rc"))))).TupleNot()
            )) != 0)
        {
          throw new HalconException("Unknown mirror method.");
        }
      }
      else if ((int)(new HTuple(hv_CurrentParamName.TupleEqual(hv_CropPercentage.TupleSelect(
          0)))) != 0)
      {
        //Set cropping with percentage.
        if (hv_CropPercentage == null)
          hv_CropPercentage = new HTuple();
        hv_CropPercentage[1] = hv_CurrentParamValue;
        //Check if input value is in range of 1-100 %.
        if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
        {
          if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(1))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
              100)))) != 0)
          {
            throw new HalconException("The given value for crop_percentage has to be in the range 1-100.");
          }
        }
        else
        {
          throw new HalconException("The given value for crop_percentage has to be in the range 1-100.");
        }
      }
      else if ((int)(new HTuple(hv_CurrentParamName.TupleEqual(hv_CropPixel.TupleSelect(
          0)))) != 0)
      {
        //Set cropping with pixels.
        if (hv_CropPixel == null)
          hv_CropPixel = new HTuple();
        hv_CropPixel[1] = hv_CurrentParamValue;
        //Check if input value is greater 0.
        if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
        {
          if ((int)(new HTuple(hv_CurrentParamValue.TupleLess(1))) != 0)
          {
            throw new HalconException("The given value for crop_pixel has to be greater then or equal to 1.");
          }
        }
        else
        {
          throw new HalconException("The given value for crop_pixel has to be a string.");
        }
      }
      else if ((int)(new HTuple(hv_CurrentParamName.TupleEqual(hv_BrightnessVariation.TupleSelect(
          0)))) != 0)
      {
        //Set brightness variation.
        if (hv_BrightnessVariation == null)
          hv_BrightnessVariation = new HTuple();
        hv_BrightnessVariation[1] = hv_CurrentParamValue;
        //Check if input value is in range of 0-255.
        if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
        {
          if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(0))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
              255)))) != 0)
          {
            throw new HalconException("The given value for brightness_variation has to be in the range 0-255.");
          }
        }
        else
        {
          throw new HalconException("The given value for brightness_variation has to be in the range 0-255.");
        }
      }
      else if ((int)(new HTuple(hv_CurrentParamName.TupleEqual(hv_BrightnessVariationSpot.TupleSelect(
          0)))) != 0)
      {
        //Set brightness variation of spot.
        if (hv_BrightnessVariationSpot == null)
          hv_BrightnessVariationSpot = new HTuple();
        hv_BrightnessVariationSpot[1] = hv_CurrentParamValue;
        //Check if input value is in range of 0-255.
        if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
        {
          if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(0))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
              255)))) != 0)
          {
            throw new HalconException("The given value for brightness_variation_spot has to be in the range 0-255.");
          }
        }
        else
        {
          throw new HalconException("The given value for brightness_variation_spot has to be in the range 0-255.");
        }
      }
      else
      {
        throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
            hv_GenParamIndex)))+"'");
      }
    }
    //
    //Aggregate all possible distortions and parameter values into a vector.
    //
    hvec_AvailableDistortions.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_AvailableDistortions = dh.Take(dh.Add(new HTupleVector(1)));
    }
    //Cropping percentage.
    if ((int)(((hv_CropPercentage.TupleSelect(1))).TupleIsNumber()) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_CropPercentage));
      }
    }
    //Cropping pixel.
    if ((int)(((hv_CropPixel.TupleSelect(1))).TupleIsNumber()) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_CropPixel));
      }
    }
    //Rotation with a given angular step size.
    if ((int)(new HTuple(((hv_Rotation.TupleSelect(1))).TupleGreater(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_Rotation));
      }
    }
    //Rotation within a given range (step size 1).
    if ((int)(new HTuple(((hv_RotationRange.TupleSelect(1))).TupleGreater(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_RotationRange));
      }
    }
    //Mirroring: in row and column direction are allowed.
    if ((int)((new HTuple(((hv_Mirror.TupleSelect(1))).TupleRegexpTest("r"))).TupleOr(
        ((hv_Mirror.TupleSelect(1))).TupleRegexpTest("c"))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_Mirror));
      }
    }
    //Brightness variation.
    if ((int)(new HTuple(((hv_BrightnessVariation.TupleSelect(1))).TupleGreater(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_BrightnessVariation));
      }
    }
    //Brightness variation spot.
    if ((int)(new HTuple(((hv_BrightnessVariationSpot.TupleSelect(1))).TupleGreater(
        0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_BrightnessVariationSpot));
      }
    }
    //Check number of available distortions
    hv_NumAvailableDistortions.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumAvailableDistortions = new HTuple(hvec_AvailableDistortions.Length);
    }
    if ((int)(new HTuple(hv_NumAvailableDistortions.TupleEqual(0))) != 0)
    {
      ho_ImagesAugmented.Dispose();
      ho_ImagesAugmented = new HObject(ho_Images);
      ho_ImageSelected.Dispose();
      ho_ImagePart.Dispose();
      ho_ImageRotated.Dispose();
      ho_DomainRotated.Dispose();
      ho_ImageScaled.Dispose();
      ho_ImageSpot.Dispose();

      hv_AugmentationPercentage.Dispose();
      hv_CropPercentage.Dispose();
      hv_CropPixel.Dispose();
      hv_Rotation.Dispose();
      hv_RotationRange.Dispose();
      hv_Mirror.Dispose();
      hv_BrightnessVariation.Dispose();
      hv_BrightnessVariationSpot.Dispose();
      hv_GenParamIndex.Dispose();
      hv_CurrentParamName.Dispose();
      hv_CurrentParamValue.Dispose();
      hv_NumAvailableDistortions.Dispose();
      hv_NumImages.Dispose();
      hv_AugmentationRate.Dispose();
      hv_NumAugmentations.Dispose();
      hv_ImageIndices.Dispose();
      hv_SelectedImages.Dispose();
      hv_SelectedDistortions.Dispose();
      hv_IndexDistortion.Dispose();
      hv_Index.Dispose();
      hv_ImageIndex.Dispose();
      hv_CurrentDistortion.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_CropRate.Dispose();
      hv_Row1.Dispose();
      hv_Row2.Dispose();
      hv_Column1.Dispose();
      hv_Column2.Dispose();
      hv_Length.Dispose();
      hv_RotationStep.Dispose();
      hv_NumPossibleRotations.Dispose();
      hv_CurrentRotation.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DRotate.Dispose();
      hv_NumMirrorMethods.Dispose();
      hv_PropabilityMethods.Dispose();
      hv_StrMirror.Dispose();
      hv_StrIdx.Dispose();
      hv_SelectedChar.Dispose();
      hv_BrightnessVariationValue.Dispose();
      hv_SpotSize.Dispose();
      hv_SpotRow.Dispose();
      hv_SpotColumn.Dispose();
      hvec_AvailableDistortions.Dispose();
      hvec_Distortions.Dispose();

      return;
    }
    //
    //Randomly choose images and augmentation methods.
    //
    //Number of images to be augmented.
    hv_NumImages.Dispose();
    HOperatorSet.CountObj(ho_Images, out hv_NumImages);
    if ((int)(new HTuple(hv_NumImages.TupleEqual(0))) != 0)
    {
      throw new HalconException("There are no images to be processed.");
    }
    //Calculate how many images are to be augmented.
    hv_AugmentationRate.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_AugmentationRate = (hv_AugmentationPercentage.TupleSelect(
        1))*0.01;
    }
    hv_NumAugmentations.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumAugmentations = ((((hv_AugmentationRate*hv_NumImages)).TupleCeil()
        )).TupleInt();
    }
    //Select a random subset of images
    //that are to be augmented.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ImageIndices.Dispose();
    tuple_shuffle(HTuple.TupleGenSequence(0,hv_NumImages-1,1), out hv_ImageIndices);
    }
    hv_SelectedImages.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SelectedImages = hv_ImageIndices.TupleSelectRange(
        0,hv_NumAugmentations-1);
    }
    //Select a random distortion method for each image.
    hv_SelectedDistortions.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SelectedDistortions = ((((HTuple.TupleRand(
        hv_NumAugmentations)*hv_NumAvailableDistortions)).TupleFloor())).TupleInt()
        ;
    }
    //Fill up vector of distortions for all input images.
    hvec_Distortions.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Distortions = dh.Take(dh.Add(new HTupleVector(1)));
    }
    hv_IndexDistortion.Dispose();
    hv_IndexDistortion = 0;
    HTuple end_val181 = hv_NumImages-1;
    HTuple step_val181 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val181, step_val181); hv_Index = hv_Index.TupleAdd(step_val181))
    {
      //Check if Index corresponds to a selected image.
      if ((int)(new HTuple(((((hv_SelectedImages.TupleEqualElem(hv_Index))).TupleSum()
          )).TupleGreater(0))) != 0)
      {
        //Add a distortion method.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hvec_Distortions[hv_Index] = hvec_AvailableDistortions[hv_SelectedDistortions.TupleSelect(
            hv_IndexDistortion)];
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_IndexDistortion = hv_IndexDistortion+1;
        hv_IndexDistortion.Dispose();
        hv_IndexDistortion = ExpTmpLocalVar_IndexDistortion;
        }
        }
      }
      else
      {
        //Image will not be distorted.
        hvec_Distortions[hv_Index] = new HTupleVector((new HTuple("none")).TupleConcat(
            0));
      }
    }
    //
    //Augment (distort) the images.
    //
    //Generate output image array.
    ho_ImagesAugmented.Dispose();
    HOperatorSet.GenEmptyObj(out ho_ImagesAugmented);
    //Loop over all images and apply distortions.
    HTuple end_val198 = hv_NumImages-1;
    HTuple step_val198 = 1;
    for (hv_ImageIndex=0; hv_ImageIndex.Continue(end_val198, step_val198); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val198))
    {
      //Get distortion method.
      hv_CurrentDistortion.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentDistortion = new HTuple(hvec_Distortions[hv_ImageIndex].T);
      }
      //Get image to be processed.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ImageSelected.Dispose();
      HOperatorSet.SelectObj(ho_Images, out ho_ImageSelected, hv_ImageIndex+1);
      }
      hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetImageSize(ho_ImageSelected, out hv_Width, out hv_Height);
      if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(hv_CropPercentage.TupleSelect(
          0)))) != 0)
      {
        //Cropping:
        //Define cropping rectangle.
        hv_CropRate.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CropRate = (hv_CurrentDistortion.TupleSelect(
            1))*0.01;
        }
        hv_Row1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row1 = ((((1-hv_CropRate)*hv_Height)*HTuple.TupleRand(
            1))).TupleFloor();
        }
        hv_Row2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row2 = hv_Row1+(hv_CropRate*hv_Height);
        }
        hv_Column1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column1 = ((((1-hv_CropRate)*hv_Width)*HTuple.TupleRand(
            1))).TupleFloor();
        }
        hv_Column2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column2 = hv_Column1+(hv_CropRate*hv_Width);
        }
        //Crop the image and add to output.
        ho_ImagePart.Dispose();
        HOperatorSet.CropRectangle1(ho_ImageSelected, out ho_ImagePart, hv_Row1, 
            hv_Column1, hv_Row2, hv_Column2);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ImagesAugmented, ho_ImagePart, out ExpTmpOutVar_0
            );
        ho_ImagesAugmented.Dispose();
        ho_ImagesAugmented = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
          hv_CropPixel.TupleSelect(0)))) != 0)
      {
        //Cropping:
        //Define cropping rectangle.
        hv_Length.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Length = hv_CurrentDistortion.TupleSelect(
            1);
        }
        hv_Row1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row1 = HTuple.TupleRand(
            1)*(hv_Height-hv_Length);
        }
        hv_Row2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row2 = (hv_Row1+hv_Length)-1;
        }
        hv_Column1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column1 = HTuple.TupleRand(
            1)*(hv_Width-hv_Length);
        }
        hv_Column2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column2 = (hv_Column1+hv_Length)-1;
        }
        //Crop the image and add to output.
        ho_ImagePart.Dispose();
        HOperatorSet.CropRectangle1(ho_ImageSelected, out ho_ImagePart, hv_Row1, 
            hv_Column1, hv_Row2, hv_Column2);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ImagesAugmented, ho_ImagePart, out ExpTmpOutVar_0
            );
        ho_ImagesAugmented.Dispose();
        ho_ImagesAugmented = ExpTmpOutVar_0;
        }
      }
      else if ((int)((new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
          hv_Rotation.TupleSelect(0)))).TupleOr(new HTuple(((hv_CurrentDistortion.TupleSelect(
          0))).TupleEqual(hv_RotationRange.TupleSelect(0))))) != 0)
      {
        //Rotation:
        if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(hv_Rotation.TupleSelect(
            0)))) != 0)
        {
          //Determine rotation angle for method 'rotate' (angle in range [0:CurrentDistortion[1]:360)).
          hv_RotationStep.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_RotationStep = hv_CurrentDistortion.TupleSelect(
              1);
          }
          hv_NumPossibleRotations.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_NumPossibleRotations = 360.0/hv_RotationStep;
          }
          hv_CurrentRotation.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentRotation = hv_RotationStep*((((hv_NumPossibleRotations*HTuple.TupleRand(
              1))).TupleInt())+1);
          }
        }
        else
        {
          //Determine rotation angle for method 'rotate_range' (angle in range [0:1:CurrentDistortion[1])).
          hv_RotationStep.Dispose();
          hv_RotationStep = 1;
          hv_NumPossibleRotations.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_NumPossibleRotations = hv_CurrentDistortion.TupleSelect(
              1);
          }
          hv_CurrentRotation.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentRotation = hv_RotationStep*((((hv_NumPossibleRotations*HTuple.TupleRand(
              1))).TupleInt())+1);
          }
          //Select direction of rotation randomly.
          if ((int)(new HTuple((new HTuple((HTuple.TupleRand(1)).TupleRound())).TupleGreater(
              0.5))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_CurrentRotation = 360.0-hv_CurrentRotation;
            hv_CurrentRotation.Dispose();
            hv_CurrentRotation = ExpTmpLocalVar_CurrentRotation;
            }
            }
          }
        }
        if ((int)((new HTuple(((hv_CurrentRotation.TupleInt())).TupleEqual(hv_CurrentRotation))).TupleAnd(
            new HTuple((((hv_CurrentRotation.TupleInt())%90)).TupleEqual(0)))) != 0)
        {
          //Rotations around 90 degrees are faster with rotate_image
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ImagePart.Dispose();
          HOperatorSet.RotateImage(ho_ImageSelected, out ho_ImagePart, hv_CurrentRotation.TupleInt()
              , "constant");
          }
        }
        else
        {
          //Create rotation matrix.
          hv_HomMat2DIdentity.Dispose();
          HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_HomMat2DRotate.Dispose();
          HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, hv_CurrentRotation.TupleRad()
              , hv_Height/2.0, hv_Width/2.0, out hv_HomMat2DRotate);
          }
          //Apply rotation.
          ho_ImageRotated.Dispose();
          HOperatorSet.AffineTransImage(ho_ImageSelected, out ho_ImageRotated, hv_HomMat2DRotate, 
              "constant", "false");
          //Remove potential undefined domain.
          ho_DomainRotated.Dispose();
          HOperatorSet.GetDomain(ho_ImageRotated, out ho_DomainRotated);
          hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
          HOperatorSet.InnerRectangle1(ho_DomainRotated, out hv_Row1, out hv_Column1, 
              out hv_Row2, out hv_Column2);
          ho_ImagePart.Dispose();
          HOperatorSet.CropRectangle1(ho_ImageRotated, out ho_ImagePart, hv_Row1, 
              hv_Column1, hv_Row2, hv_Column2);
        }
        //Add the image to the output.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ImagesAugmented, ho_ImagePart, out ExpTmpOutVar_0
            );
        ho_ImagesAugmented.Dispose();
        ho_ImagesAugmented = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
          hv_Mirror.TupleSelect(0)))) != 0)
      {
        //Mirroring:
        //If more than one method is allowed, chose mirroring method(s) to be applied.
        hv_NumMirrorMethods.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumMirrorMethods = ((hv_CurrentDistortion.TupleSelect(
            1))).TupleStrlen();
        }
        hv_PropabilityMethods.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PropabilityMethods = 1.0/hv_NumMirrorMethods;
        }
        hv_StrMirror.Dispose();
        hv_StrMirror = "";
        while ((int)(new HTuple(hv_StrMirror.TupleEqual(""))) != 0)
        {
          HTuple end_val266 = hv_NumMirrorMethods-1;
          HTuple step_val266 = 1;
          for (hv_StrIdx=0; hv_StrIdx.Continue(end_val266, step_val266); hv_StrIdx = hv_StrIdx.TupleAdd(step_val266))
          {
            hv_SelectedChar.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_SelectedChar = ((hv_CurrentDistortion.TupleSelect(
                1))).TupleStrBitSelect(hv_StrIdx);
            }
            if ((int)(new HTuple((HTuple.TupleRand(1)).TupleLess(hv_PropabilityMethods))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_StrMirror = hv_StrMirror+hv_SelectedChar;
              hv_StrMirror.Dispose();
              hv_StrMirror = ExpTmpLocalVar_StrMirror;
              }
              }
            }
          }
        }
        //Apply the chosen mirroring method(s).
        if ((int)(hv_StrMirror.TupleRegexpTest("c")) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.MirrorImage(ho_ImageSelected, out ExpTmpOutVar_0, "column");
          ho_ImageSelected.Dispose();
          ho_ImageSelected = ExpTmpOutVar_0;
          }
        }
        if ((int)(hv_StrMirror.TupleRegexpTest("r")) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.MirrorImage(ho_ImageSelected, out ExpTmpOutVar_0, "row");
          ho_ImageSelected.Dispose();
          ho_ImageSelected = ExpTmpOutVar_0;
          }
        }
        //Add the image to the output.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ImagesAugmented, ho_ImageSelected, out ExpTmpOutVar_0
            );
        ho_ImagesAugmented.Dispose();
        ho_ImagesAugmented = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
          hv_BrightnessVariation.TupleSelect(0)))) != 0)
      {
        //Brightness variation:
        //Add random brightness variation.
        hv_BrightnessVariationValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BrightnessVariationValue = ((HTuple.TupleRand(
            1)*2)-1)*(hv_CurrentDistortion.TupleSelect(1));
        }
        ho_ImageScaled.Dispose();
        HOperatorSet.ScaleImage(ho_ImageSelected, out ho_ImageScaled, 1.0, hv_BrightnessVariationValue);
        //Add the image to the output.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ImagesAugmented, ho_ImageScaled, out ExpTmpOutVar_0
            );
        ho_ImagesAugmented.Dispose();
        ho_ImagesAugmented = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
          hv_BrightnessVariationSpot.TupleSelect(0)))) != 0)
      {
        //Determine random brightness variation.
        hv_BrightnessVariationValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BrightnessVariationValue = ((HTuple.TupleRand(
            1)*2)-1)*(hv_CurrentDistortion.TupleSelect(1));
        }
        //Determine random spot size between [0.5*Width, Width].
        hv_SpotSize.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SpotSize = hv_Width*((HTuple.TupleRand(
            1)/2)+.5);
        }
        //Determine random spot position.
        hv_SpotRow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SpotRow = HTuple.TupleRand(
            1)*hv_Height;
        }
        hv_SpotColumn.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SpotColumn = HTuple.TupleRand(
            1)*hv_Width;
        }
        ho_ImageSpot.Dispose();
        apply_brightness_variation_spot(ho_ImageSelected, out ho_ImageSpot, hv_SpotSize, 
            hv_SpotRow, hv_SpotColumn, hv_BrightnessVariationValue);
        //Add the image to the output.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ImagesAugmented, ho_ImageSpot, out ExpTmpOutVar_0
            );
        ho_ImagesAugmented.Dispose();
        ho_ImagesAugmented = ExpTmpOutVar_0;
        }
      }
      else
      {
        //Add unchanged image to the output.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ImagesAugmented, ho_ImageSelected, out ExpTmpOutVar_0
            );
        ho_ImagesAugmented.Dispose();
        ho_ImagesAugmented = ExpTmpOutVar_0;
        }
      }
    }
    ho_ImageSelected.Dispose();
    ho_ImagePart.Dispose();
    ho_ImageRotated.Dispose();
    ho_DomainRotated.Dispose();
    ho_ImageScaled.Dispose();
    ho_ImageSpot.Dispose();

    hv_AugmentationPercentage.Dispose();
    hv_CropPercentage.Dispose();
    hv_CropPixel.Dispose();
    hv_Rotation.Dispose();
    hv_RotationRange.Dispose();
    hv_Mirror.Dispose();
    hv_BrightnessVariation.Dispose();
    hv_BrightnessVariationSpot.Dispose();
    hv_GenParamIndex.Dispose();
    hv_CurrentParamName.Dispose();
    hv_CurrentParamValue.Dispose();
    hv_NumAvailableDistortions.Dispose();
    hv_NumImages.Dispose();
    hv_AugmentationRate.Dispose();
    hv_NumAugmentations.Dispose();
    hv_ImageIndices.Dispose();
    hv_SelectedImages.Dispose();
    hv_SelectedDistortions.Dispose();
    hv_IndexDistortion.Dispose();
    hv_Index.Dispose();
    hv_ImageIndex.Dispose();
    hv_CurrentDistortion.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_CropRate.Dispose();
    hv_Row1.Dispose();
    hv_Row2.Dispose();
    hv_Column1.Dispose();
    hv_Column2.Dispose();
    hv_Length.Dispose();
    hv_RotationStep.Dispose();
    hv_NumPossibleRotations.Dispose();
    hv_CurrentRotation.Dispose();
    hv_HomMat2DIdentity.Dispose();
    hv_HomMat2DRotate.Dispose();
    hv_NumMirrorMethods.Dispose();
    hv_PropabilityMethods.Dispose();
    hv_StrMirror.Dispose();
    hv_StrIdx.Dispose();
    hv_SelectedChar.Dispose();
    hv_BrightnessVariationValue.Dispose();
    hv_SpotSize.Dispose();
    hv_SpotRow.Dispose();
    hv_SpotColumn.Dispose();
    hvec_AvailableDistortions.Dispose();
    hvec_Distortions.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Calculate color intensity features. 
  public void calc_feature_color_intensity (HObject ho_Region, HObject ho_Image, 
      HTuple hv_ColorSpace, HTuple hv_Mode, out HTuple hv_Feature)
  {




    // Local iconic variables 

    HObject ho_R, ho_G, ho_B, ho_I1=null, ho_I2=null;
    HObject ho_I3=null;

    // Local control variables 

    HTuple hv_Channels = new HTuple(), hv_Mean1 = new HTuple();
    HTuple hv_Deviation1 = new HTuple(), hv_Mean2 = new HTuple();
    HTuple hv_Deviation2 = new HTuple(), hv_Mean3 = new HTuple();
    HTuple hv_Deviation3 = new HTuple(), hv_Tmp1 = new HTuple();
    HTuple hv_Tmp2 = new HTuple(), hv_Tmp3 = new HTuple();
    HTuple hv_NumRegions = new HTuple(), hv_Index = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_R);
    HOperatorSet.GenEmptyObj(out ho_G);
    HOperatorSet.GenEmptyObj(out ho_B);
    HOperatorSet.GenEmptyObj(out ho_I1);
    HOperatorSet.GenEmptyObj(out ho_I2);
    HOperatorSet.GenEmptyObj(out ho_I3);
    hv_Feature = new HTuple();
    //
    //Calculate color features
    //
    //Transform an RGB image into the given ColorSpace
    //and calculate the mean gray value and the deviation
    //for all three channels.
    //
    hv_Channels.Dispose();
    HOperatorSet.CountChannels(ho_Image, out hv_Channels);
    if ((int)(new HTuple(hv_Channels.TupleNotEqual(3))) != 0)
    {
      throw new HalconException((((("Error when calculating feature "+hv_ColorSpace)+"_")+hv_Mode)).TupleConcat(
          "Please use a 3-channel RGB image or remove color feature from the list."));
    }
    ho_R.Dispose();ho_G.Dispose();ho_B.Dispose();
    HOperatorSet.Decompose3(ho_Image, out ho_R, out ho_G, out ho_B);
    if ((int)(new HTuple(hv_ColorSpace.TupleEqual("rgb"))) != 0)
    {
      hv_Mean1.Dispose();hv_Deviation1.Dispose();
      HOperatorSet.Intensity(ho_Region, ho_R, out hv_Mean1, out hv_Deviation1);
      hv_Mean2.Dispose();hv_Deviation2.Dispose();
      HOperatorSet.Intensity(ho_Region, ho_G, out hv_Mean2, out hv_Deviation2);
      hv_Mean3.Dispose();hv_Deviation3.Dispose();
      HOperatorSet.Intensity(ho_Region, ho_B, out hv_Mean3, out hv_Deviation3);
    }
    else
    {
      ho_I1.Dispose();ho_I2.Dispose();ho_I3.Dispose();
      HOperatorSet.TransFromRgb(ho_R, ho_G, ho_B, out ho_I1, out ho_I2, out ho_I3, 
          hv_ColorSpace);
      hv_Mean1.Dispose();hv_Deviation1.Dispose();
      HOperatorSet.Intensity(ho_Region, ho_I1, out hv_Mean1, out hv_Deviation1);
      hv_Mean2.Dispose();hv_Deviation2.Dispose();
      HOperatorSet.Intensity(ho_Region, ho_I2, out hv_Mean2, out hv_Deviation2);
      hv_Mean3.Dispose();hv_Deviation3.Dispose();
      HOperatorSet.Intensity(ho_Region, ho_I3, out hv_Mean3, out hv_Deviation3);
    }
    if ((int)(new HTuple(hv_Mode.TupleEqual("mean"))) != 0)
    {
      hv_Tmp1.Dispose();
      hv_Tmp1 = new HTuple(hv_Mean1);
      hv_Tmp2.Dispose();
      hv_Tmp2 = new HTuple(hv_Mean2);
      hv_Tmp3.Dispose();
      hv_Tmp3 = new HTuple(hv_Mean3);
    }
    else if ((int)(new HTuple(hv_Mode.TupleEqual("deviation"))) != 0)
    {
      hv_Tmp1.Dispose();
      hv_Tmp1 = new HTuple(hv_Deviation1);
      hv_Tmp2.Dispose();
      hv_Tmp2 = new HTuple(hv_Deviation2);
      hv_Tmp3.Dispose();
      hv_Tmp3 = new HTuple(hv_Deviation3);
    }
    hv_NumRegions.Dispose();
    HOperatorSet.CountObj(ho_Region, out hv_NumRegions);
    if ((int)(new HTuple(hv_NumRegions.TupleGreater(0))) != 0)
    {
      hv_Index.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Index = HTuple.TupleGenSequence(
          0,(3*hv_NumRegions)-1,3);
      }
      if (hv_Feature == null)
        hv_Feature = new HTuple();
      hv_Feature[hv_Index] = hv_Tmp1;
      if (hv_Feature == null)
        hv_Feature = new HTuple();
      hv_Feature[1+hv_Index] = hv_Tmp2;
      if (hv_Feature == null)
        hv_Feature = new HTuple();
      hv_Feature[2+hv_Index] = hv_Tmp3;
    }
    else
    {
      hv_Feature.Dispose();
      hv_Feature = new HTuple();
    }
    ho_R.Dispose();
    ho_G.Dispose();
    ho_B.Dispose();
    ho_I1.Dispose();
    ho_I2.Dispose();
    ho_I3.Dispose();

    hv_Channels.Dispose();
    hv_Mean1.Dispose();
    hv_Deviation1.Dispose();
    hv_Mean2.Dispose();
    hv_Deviation2.Dispose();
    hv_Mean3.Dispose();
    hv_Deviation3.Dispose();
    hv_Tmp1.Dispose();
    hv_Tmp2.Dispose();
    hv_Tmp3.Dispose();
    hv_NumRegions.Dispose();
    hv_Index.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Calculate edge density. 
  public void calc_feature_edge_density (HObject ho_Region, HObject ho_Image, out HTuple hv_Feature)
  {



    // Local iconic variables 

    HObject ho_RegionUnion, ho_ImageReduced, ho_EdgeAmplitude=null;

    // Local control variables 

    HTuple hv_Area = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_AreaGray = new HTuple();
    HTuple hv_ZeroIndex = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_RegionUnion);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_EdgeAmplitude);
    hv_Feature = new HTuple();
    //
    //Calculate the edge density, i.e.
    //the ratio of the edge amplitudes to the area of the region.
    //
    ho_RegionUnion.Dispose();
    HOperatorSet.Union1(ho_Region, out ho_RegionUnion);
    ho_ImageReduced.Dispose();
    HOperatorSet.ReduceDomain(ho_Image, ho_RegionUnion, out ho_ImageReduced);
    hv_Area.Dispose();hv_Row.Dispose();hv_Column.Dispose();
    HOperatorSet.AreaCenter(ho_Region, out hv_Area, out hv_Row, out hv_Column);
    hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetImageSize(ho_ImageReduced, out hv_Width, out hv_Height);
    if ((int)((new HTuple(hv_Width.TupleGreater(1))).TupleAnd(new HTuple(hv_Height.TupleGreater(
        1)))) != 0)
    {
      ho_EdgeAmplitude.Dispose();
      HOperatorSet.SobelAmp(ho_ImageReduced, out ho_EdgeAmplitude, "sum_abs", 3);
      hv_AreaGray.Dispose();hv_Row.Dispose();hv_Column.Dispose();
      HOperatorSet.AreaCenterGray(ho_Region, ho_EdgeAmplitude, out hv_AreaGray, out hv_Row, 
          out hv_Column);
      hv_ZeroIndex.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ZeroIndex = hv_Area.TupleFind(
          0);
      }
      if ((int)(new HTuple(hv_ZeroIndex.TupleNotEqual(-1))) != 0)
      {
        if (hv_Area == null)
          hv_Area = new HTuple();
        hv_Area[hv_ZeroIndex] = 1;
        if (hv_AreaGray == null)
          hv_AreaGray = new HTuple();
        hv_AreaGray[hv_ZeroIndex] = 0;
      }
      hv_Feature.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Feature = hv_AreaGray/hv_Area;
      }
    }
    else
    {
      hv_Feature.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Feature = HTuple.TupleGenConst(
          new HTuple(hv_Area.TupleLength()),0.0);
      }
    }
    ho_RegionUnion.Dispose();
    ho_ImageReduced.Dispose();
    ho_EdgeAmplitude.Dispose();

    hv_Area.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_AreaGray.Dispose();
    hv_ZeroIndex.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Calculate edge density histogram feature. 
  public void calc_feature_edge_density_histogram (HObject ho_Region, HObject ho_Image, 
      HTuple hv_NumBins, out HTuple hv_Feature)
  {




    // Local iconic variables 

    HObject ho_Channel1=null, ho_EdgeAmplitude=null;
    HObject ho_RegionSelected=null;

    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_NumRegions = new HTuple(), hv_J = new HTuple();
    HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Histo = new HTuple(), hv_BinSize = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Channel1);
    HOperatorSet.GenEmptyObj(out ho_EdgeAmplitude);
    HOperatorSet.GenEmptyObj(out ho_RegionSelected);
    hv_Feature = new HTuple();
    //
    //Calculate the edge density histogram, i.e.
    //the ratio of the edge amplitude histogram to the area of the region.
    //
    hv_Feature.Dispose();
    hv_Feature = new HTuple();
    hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    hv_NumRegions.Dispose();
    HOperatorSet.CountObj(ho_Region, out hv_NumRegions);
    if ((int)((new HTuple(hv_ImageWidth.TupleGreater(1))).TupleAnd(new HTuple(hv_ImageHeight.TupleGreater(
        1)))) != 0)
    {
      ho_Channel1.Dispose();
      HOperatorSet.AccessChannel(ho_Image, out ho_Channel1, 1);
      ho_EdgeAmplitude.Dispose();
      HOperatorSet.SobelAmp(ho_Channel1, out ho_EdgeAmplitude, "sum_abs", 3);
      HTuple end_val10 = hv_NumRegions;
      HTuple step_val10 = 1;
      for (hv_J=1; hv_J.Continue(end_val10, step_val10); hv_J = hv_J.TupleAdd(step_val10))
      {
        ho_RegionSelected.Dispose();
        HOperatorSet.SelectObj(ho_Region, out ho_RegionSelected, hv_J);
        hv_Area.Dispose();hv_Row.Dispose();hv_Column.Dispose();
        HOperatorSet.AreaCenter(ho_RegionSelected, out hv_Area, out hv_Row, out hv_Column);
        if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
        {
          hv_Histo.Dispose();hv_BinSize.Dispose();
          HOperatorSet.GrayHistoRange(ho_RegionSelected, ho_EdgeAmplitude, 0, 255, 
              hv_NumBins, out hv_Histo, out hv_BinSize);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Feature = hv_Feature.TupleConcat(
              (hv_Histo.TupleReal())/(hv_Histo.TupleSum()));
          hv_Feature.Dispose();
          hv_Feature = ExpTmpLocalVar_Feature;
          }
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Feature = ((hv_Feature.TupleConcat(
              1.0))).TupleConcat(HTuple.TupleGenConst(hv_NumBins-1,0.0));
          hv_Feature.Dispose();
          hv_Feature = ExpTmpLocalVar_Feature;
          }
          }
        }
      }
    }
    else
    {
      hv_Feature.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Feature = HTuple.TupleGenConst(
          hv_NumRegions*hv_NumBins,0.0);
      }
    }
    ho_Channel1.Dispose();
    ho_EdgeAmplitude.Dispose();
    ho_RegionSelected.Dispose();

    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_NumRegions.Dispose();
    hv_J.Dispose();
    hv_Area.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Histo.Dispose();
    hv_BinSize.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Calculate the gradient direction histogram. 
  public void calc_feature_grad_dir_histo (HObject ho_Region, HObject ho_Image, HTuple hv_NumBins, 
      out HTuple hv_Feature)
  {




    // Local iconic variables 

    HObject ho_Channel1, ho_RegionSelected=null;
    HObject ho_ImageReduced=null, ho_EdgeAmplitude=null, ho_EdgeDirection=null;

    // Local control variables 

    HTuple hv_NumRegions = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Histo = new HTuple(), hv_BinSize = new HTuple();
    HTuple hv_Sum = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Channel1);
    HOperatorSet.GenEmptyObj(out ho_RegionSelected);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_EdgeAmplitude);
    HOperatorSet.GenEmptyObj(out ho_EdgeDirection);
    hv_Feature = new HTuple();
    //
    //Calculate gradient direction histogram
    //
    ho_Channel1.Dispose();
    HOperatorSet.AccessChannel(ho_Image, out ho_Channel1, 1);
    hv_NumRegions.Dispose();
    HOperatorSet.CountObj(ho_Region, out hv_NumRegions);
    hv_Feature.Dispose();
    hv_Feature = new HTuple();
    HTuple end_val6 = hv_NumRegions;
    HTuple step_val6 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val6, step_val6); hv_Index = hv_Index.TupleAdd(step_val6))
    {
      ho_RegionSelected.Dispose();
      HOperatorSet.SelectObj(ho_Region, out ho_RegionSelected, hv_Index);
      ho_ImageReduced.Dispose();
      HOperatorSet.ReduceDomain(ho_Channel1, ho_RegionSelected, out ho_ImageReduced
          );
      ho_EdgeAmplitude.Dispose();ho_EdgeDirection.Dispose();
      HOperatorSet.SobelDir(ho_ImageReduced, out ho_EdgeAmplitude, out ho_EdgeDirection, 
          "sum_abs_binomial", 3);
      hv_Histo.Dispose();hv_BinSize.Dispose();
      HOperatorSet.GrayHistoRange(ho_RegionSelected, ho_EdgeDirection, 0, 179, hv_NumBins, 
          out hv_Histo, out hv_BinSize);
      hv_Sum.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Sum = hv_Histo.TupleSum()
          ;
      }
      if ((int)(new HTuple(hv_Sum.TupleNotEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Feature = hv_Feature.TupleConcat(
            (hv_Histo.TupleReal())/hv_Sum);
        hv_Feature.Dispose();
        hv_Feature = ExpTmpLocalVar_Feature;
        }
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Feature = hv_Feature.TupleConcat(
            hv_Histo);
        hv_Feature.Dispose();
        hv_Feature = ExpTmpLocalVar_Feature;
        }
        }
      }
    }
    ho_Channel1.Dispose();
    ho_RegionSelected.Dispose();
    ho_ImageReduced.Dispose();
    ho_EdgeAmplitude.Dispose();
    ho_EdgeDirection.Dispose();

    hv_NumRegions.Dispose();
    hv_Index.Dispose();
    hv_Histo.Dispose();
    hv_BinSize.Dispose();
    hv_Sum.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Calculate gray-value projections and their histograms. 
  public void calc_feature_gray_proj (HObject ho_Region, HObject ho_Image, HTuple hv_Mode, 
      HTuple hv_Size, out HTuple hv_Feature)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_RegionTmp=null, ho_RegionMoved=null;
    HObject ho_ImageTmp=null;

    // Local control variables 

    HTuple hv_NumRegions = new HTuple(), hv_Index = new HTuple();
    HTuple hv_RowsTmp = new HTuple(), hv_ColumnsTmp = new HTuple();
    HTuple hv_HorProjectionFilledUp = new HTuple(), hv_VertProjectionFilledUp = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
    HTuple hv_ScaleHeight = new HTuple(), hv_ScaleWidth = new HTuple();
    HTuple hv_HorProjection = new HTuple(), hv_VertProjection = new HTuple();
    HTuple hv_HorProjectionFilledUpFront = new HTuple(), hv_VertProjectionFilledUpFront = new HTuple();
    HTuple hv_Histo = new HTuple(), hv_BinSize = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_RegionTmp);
    HOperatorSet.GenEmptyObj(out ho_RegionMoved);
    HOperatorSet.GenEmptyObj(out ho_ImageTmp);
    hv_Feature = new HTuple();
    //
    //Calculate gray-value projections and their histograms
    //
    hv_NumRegions.Dispose();
    HOperatorSet.CountObj(ho_Region, out hv_NumRegions);
    hv_Feature.Dispose();
    hv_Feature = new HTuple();
    //
    HTuple end_val6 = hv_NumRegions;
    HTuple step_val6 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val6, step_val6); hv_Index = hv_Index.TupleAdd(step_val6))
    {
      ho_RegionTmp.Dispose();
      HOperatorSet.SelectObj(ho_Region, out ho_RegionTmp, hv_Index);
      //Test empty region
      hv_RowsTmp.Dispose();hv_ColumnsTmp.Dispose();
      HOperatorSet.GetRegionPoints(ho_RegionTmp, out hv_RowsTmp, out hv_ColumnsTmp);
      if ((int)(new HTuple((new HTuple(hv_RowsTmp.TupleLength())).TupleEqual(0))) != 0)
      {
        hv_HorProjectionFilledUp.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HorProjectionFilledUp = HTuple.TupleGenConst(
            hv_Size,-1.0);
        }
        hv_VertProjectionFilledUp.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_VertProjectionFilledUp = HTuple.TupleGenConst(
            hv_Size,-1.0);
        }
      }
      else
      {
        //Zoom image and region to Size x Size pixels
        hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
        HOperatorSet.SmallestRectangle1(ho_RegionTmp, out hv_Row1, out hv_Column1, 
            out hv_Row2, out hv_Column2);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_RegionMoved.Dispose();
        HOperatorSet.MoveRegion(ho_RegionTmp, out ho_RegionMoved, -hv_Row1, -hv_Column1);
        }
        ho_ImageTmp.Dispose();
        HOperatorSet.CropRectangle1(ho_Image, out ho_ImageTmp, hv_Row1, hv_Column1, 
            hv_Row2, hv_Column2);
        hv_ScaleHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ScaleHeight = (hv_Size.TupleReal()
            )/((hv_Row2-hv_Row1)+1);
        }
        hv_ScaleWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ScaleWidth = (hv_Size.TupleReal()
            )/((hv_Column2-hv_Column1)+1);
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomImageFactor(ho_ImageTmp, out ExpTmpOutVar_0, hv_ScaleWidth, 
            hv_ScaleHeight, "constant");
        ho_ImageTmp.Dispose();
        ho_ImageTmp = ExpTmpOutVar_0;
        }
        ho_RegionTmp.Dispose();
        HOperatorSet.ZoomRegion(ho_RegionMoved, out ho_RegionTmp, hv_ScaleWidth, 
            hv_ScaleHeight);
        //Calculate gray value projection
        hv_HorProjection.Dispose();hv_VertProjection.Dispose();
        HOperatorSet.GrayProjections(ho_RegionTmp, ho_ImageTmp, "simple", out hv_HorProjection, 
            out hv_VertProjection);
        //Fill up projection in case the zoomed region is smaller than
        //Size x Size pixels due to interpolation effects
        hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
        HOperatorSet.SmallestRectangle1(ho_RegionTmp, out hv_Row1, out hv_Column1, 
            out hv_Row2, out hv_Column2);
        hv_HorProjectionFilledUpFront.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HorProjectionFilledUpFront = new HTuple();
        hv_HorProjectionFilledUpFront = hv_HorProjectionFilledUpFront.TupleConcat(HTuple.TupleGenConst(
            (new HTuple(0)).TupleMax2(hv_Row1),-1.0));
        hv_HorProjectionFilledUpFront = hv_HorProjectionFilledUpFront.TupleConcat(hv_HorProjection);
        }
        hv_HorProjectionFilledUp.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HorProjectionFilledUp = new HTuple();
        hv_HorProjectionFilledUp = hv_HorProjectionFilledUp.TupleConcat(hv_HorProjectionFilledUpFront);
        hv_HorProjectionFilledUp = hv_HorProjectionFilledUp.TupleConcat(HTuple.TupleGenConst(
            hv_Size-(new HTuple(hv_HorProjectionFilledUpFront.TupleLength())),-1.0));
        }
        hv_VertProjectionFilledUpFront.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_VertProjectionFilledUpFront = new HTuple();
        hv_VertProjectionFilledUpFront = hv_VertProjectionFilledUpFront.TupleConcat(HTuple.TupleGenConst(
            (new HTuple(0)).TupleMax2(hv_Column1),-1.0));
        hv_VertProjectionFilledUpFront = hv_VertProjectionFilledUpFront.TupleConcat(hv_VertProjection);
        }
        hv_VertProjectionFilledUp.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_VertProjectionFilledUp = new HTuple();
        hv_VertProjectionFilledUp = hv_VertProjectionFilledUp.TupleConcat(hv_VertProjectionFilledUpFront);
        hv_VertProjectionFilledUp = hv_VertProjectionFilledUp.TupleConcat(HTuple.TupleGenConst(
            hv_Size-(new HTuple(hv_VertProjectionFilledUpFront.TupleLength())),-1.0));
        }
      }
      if ((int)(new HTuple(hv_Mode.TupleEqual("hor"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Feature = hv_Feature.TupleConcat(
            hv_HorProjectionFilledUp);
        hv_Feature.Dispose();
        hv_Feature = ExpTmpLocalVar_Feature;
        }
        }
      }
      else if ((int)(new HTuple(hv_Mode.TupleEqual("vert"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Feature = hv_Feature.TupleConcat(
            hv_VertProjectionFilledUp);
        hv_Feature.Dispose();
        hv_Feature = ExpTmpLocalVar_Feature;
        }
        }
      }
      else if ((int)(new HTuple(hv_Mode.TupleEqual("hor_histo"))) != 0)
      {
        hv_Histo.Dispose();hv_BinSize.Dispose();
        HOperatorSet.TupleHistoRange(hv_HorProjectionFilledUp, 0, 255, hv_Size, out hv_Histo, 
            out hv_BinSize);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Feature = hv_Feature.TupleConcat(
            hv_Histo);
        hv_Feature.Dispose();
        hv_Feature = ExpTmpLocalVar_Feature;
        }
        }
      }
      else if ((int)(new HTuple(hv_Mode.TupleEqual("vert_histo"))) != 0)
      {
        hv_Histo.Dispose();hv_BinSize.Dispose();
        HOperatorSet.TupleHistoRange(hv_VertProjectionFilledUp, 0, 255, hv_Size, 
            out hv_Histo, out hv_BinSize);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Feature = hv_Feature.TupleConcat(
            hv_Histo);
        hv_Feature.Dispose();
        hv_Feature = ExpTmpLocalVar_Feature;
        }
        }
      }
    }
    ho_RegionTmp.Dispose();
    ho_RegionMoved.Dispose();
    ho_ImageTmp.Dispose();

    hv_NumRegions.Dispose();
    hv_Index.Dispose();
    hv_RowsTmp.Dispose();
    hv_ColumnsTmp.Dispose();
    hv_HorProjectionFilledUp.Dispose();
    hv_VertProjectionFilledUp.Dispose();
    hv_Row1.Dispose();
    hv_Column1.Dispose();
    hv_Row2.Dispose();
    hv_Column2.Dispose();
    hv_ScaleHeight.Dispose();
    hv_ScaleWidth.Dispose();
    hv_HorProjection.Dispose();
    hv_VertProjection.Dispose();
    hv_HorProjectionFilledUpFront.Dispose();
    hv_VertProjectionFilledUpFront.Dispose();
    hv_Histo.Dispose();
    hv_BinSize.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Calculate gray-value projections of polar-transformed image regions. 
  public void calc_feature_polar_gray_proj (HObject ho_Region, HObject ho_Image, 
      HTuple hv_Mode, HTuple hv_Width, HTuple hv_Height, out HTuple hv_Features)
  {




    // Local iconic variables 

    HObject ho_RegionSelected=null, ho_PolarTransImage=null;
    HObject ho_EdgeAmplitude=null, ho_ImageAbs=null;

    // Local control variables 

    HTuple hv_NumRegions = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Radius = new HTuple(), hv_HorProjection = new HTuple();
    HTuple hv_VertProjection = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_RegionSelected);
    HOperatorSet.GenEmptyObj(out ho_PolarTransImage);
    HOperatorSet.GenEmptyObj(out ho_EdgeAmplitude);
    HOperatorSet.GenEmptyObj(out ho_ImageAbs);
    hv_Features = new HTuple();
    //
    //Calculate gray-value projections of
    //polar-transformed image regions.
    //
    hv_NumRegions.Dispose();
    HOperatorSet.CountObj(ho_Region, out hv_NumRegions);
    hv_Features.Dispose();
    hv_Features = new HTuple();
    HTuple end_val6 = hv_NumRegions;
    HTuple step_val6 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val6, step_val6); hv_Index = hv_Index.TupleAdd(step_val6))
    {
      ho_RegionSelected.Dispose();
      HOperatorSet.SelectObj(ho_Region, out ho_RegionSelected, hv_Index);
      hv_Row.Dispose();hv_Column.Dispose();hv_Radius.Dispose();
      HOperatorSet.SmallestCircle(ho_RegionSelected, out hv_Row, out hv_Column, out hv_Radius);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_PolarTransImage.Dispose();
      HOperatorSet.PolarTransImageExt(ho_Image, out ho_PolarTransImage, hv_Row, hv_Column, 
          0, (new HTuple(360)).TupleRad(), 0, ((hv_Radius.TupleConcat(1))).TupleMax()
          , hv_Width, hv_Height, "bilinear");
      }
      //
      if ((int)(new HTuple(hv_Mode.TupleEqual("hor_gray"))) != 0)
      {
        hv_HorProjection.Dispose();hv_VertProjection.Dispose();
        HOperatorSet.GrayProjections(ho_PolarTransImage, ho_PolarTransImage, "simple", 
            out hv_HorProjection, out hv_VertProjection);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Features = hv_Features.TupleConcat(
            hv_HorProjection);
        hv_Features.Dispose();
        hv_Features = ExpTmpLocalVar_Features;
        }
        }
      }
      else if ((int)(new HTuple(hv_Mode.TupleEqual("vert_gray"))) != 0)
      {
        hv_HorProjection.Dispose();hv_VertProjection.Dispose();
        HOperatorSet.GrayProjections(ho_PolarTransImage, ho_PolarTransImage, "simple", 
            out hv_HorProjection, out hv_VertProjection);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Features = hv_Features.TupleConcat(
            hv_VertProjection);
        hv_Features.Dispose();
        hv_Features = ExpTmpLocalVar_Features;
        }
        }
      }
      else if ((int)(new HTuple(hv_Mode.TupleEqual("hor_sobel_amp"))) != 0)
      {
        ho_EdgeAmplitude.Dispose();
        HOperatorSet.SobelAmp(ho_PolarTransImage, out ho_EdgeAmplitude, "sum_abs", 
            3);
        ho_ImageAbs.Dispose();
        HOperatorSet.AbsImage(ho_EdgeAmplitude, out ho_ImageAbs);
        hv_HorProjection.Dispose();hv_VertProjection.Dispose();
        HOperatorSet.GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", out hv_HorProjection, 
            out hv_VertProjection);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Features = hv_Features.TupleConcat(
            hv_HorProjection);
        hv_Features.Dispose();
        hv_Features = ExpTmpLocalVar_Features;
        }
        }
      }
      else if ((int)(new HTuple(hv_Mode.TupleEqual("vert_sobel_amp"))) != 0)
      {
        ho_EdgeAmplitude.Dispose();
        HOperatorSet.SobelAmp(ho_PolarTransImage, out ho_EdgeAmplitude, "sum_abs", 
            3);
        ho_ImageAbs.Dispose();
        HOperatorSet.AbsImage(ho_EdgeAmplitude, out ho_ImageAbs);
        hv_HorProjection.Dispose();hv_VertProjection.Dispose();
        HOperatorSet.GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", out hv_HorProjection, 
            out hv_VertProjection);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Features = hv_Features.TupleConcat(
            hv_VertProjection);
        hv_Features.Dispose();
        hv_Features = ExpTmpLocalVar_Features;
        }
        }
      }
      else if ((int)(new HTuple(hv_Mode.TupleEqual("hor_sobel_x"))) != 0)
      {
        ho_EdgeAmplitude.Dispose();
        HOperatorSet.SobelAmp(ho_PolarTransImage, out ho_EdgeAmplitude, "x_binomial", 
            3);
        ho_ImageAbs.Dispose();
        HOperatorSet.AbsImage(ho_EdgeAmplitude, out ho_ImageAbs);
        hv_HorProjection.Dispose();hv_VertProjection.Dispose();
        HOperatorSet.GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", out hv_HorProjection, 
            out hv_VertProjection);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Features = hv_Features.TupleConcat(
            hv_HorProjection);
        hv_Features.Dispose();
        hv_Features = ExpTmpLocalVar_Features;
        }
        }
      }
      else if ((int)(new HTuple(hv_Mode.TupleEqual("vert_sobel_x"))) != 0)
      {
        ho_EdgeAmplitude.Dispose();
        HOperatorSet.SobelAmp(ho_PolarTransImage, out ho_EdgeAmplitude, "x_binomial", 
            3);
        ho_ImageAbs.Dispose();
        HOperatorSet.AbsImage(ho_EdgeAmplitude, out ho_ImageAbs);
        hv_HorProjection.Dispose();hv_VertProjection.Dispose();
        HOperatorSet.GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", out hv_HorProjection, 
            out hv_VertProjection);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Features = hv_Features.TupleConcat(
            hv_VertProjection);
        hv_Features.Dispose();
        hv_Features = ExpTmpLocalVar_Features;
        }
        }
      }
      else if ((int)(new HTuple(hv_Mode.TupleEqual("hor_sobel_y"))) != 0)
      {
        ho_EdgeAmplitude.Dispose();
        HOperatorSet.SobelAmp(ho_PolarTransImage, out ho_EdgeAmplitude, "y_binomial", 
            3);
        ho_ImageAbs.Dispose();
        HOperatorSet.AbsImage(ho_EdgeAmplitude, out ho_ImageAbs);
        hv_HorProjection.Dispose();hv_VertProjection.Dispose();
        HOperatorSet.GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", out hv_HorProjection, 
            out hv_VertProjection);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Features = hv_Features.TupleConcat(
            hv_HorProjection);
        hv_Features.Dispose();
        hv_Features = ExpTmpLocalVar_Features;
        }
        }
      }
      else if ((int)(new HTuple(hv_Mode.TupleEqual("vert_sobel_y"))) != 0)
      {
        ho_EdgeAmplitude.Dispose();
        HOperatorSet.SobelAmp(ho_PolarTransImage, out ho_EdgeAmplitude, "y_binomial", 
            3);
        ho_ImageAbs.Dispose();
        HOperatorSet.AbsImage(ho_EdgeAmplitude, out ho_ImageAbs);
        hv_HorProjection.Dispose();hv_VertProjection.Dispose();
        HOperatorSet.GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", out hv_HorProjection, 
            out hv_VertProjection);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Features = hv_Features.TupleConcat(
            hv_VertProjection);
        hv_Features.Dispose();
        hv_Features = ExpTmpLocalVar_Features;
        }
        }
      }
      else
      {
        throw new HalconException(("Unknown Mode: "+hv_Mode)+" in calc_feature_polar_proj");
      }
    }
    ho_RegionSelected.Dispose();
    ho_PolarTransImage.Dispose();
    ho_EdgeAmplitude.Dispose();
    ho_ImageAbs.Dispose();

    hv_NumRegions.Dispose();
    hv_Index.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Radius.Dispose();
    hv_HorProjection.Dispose();
    hv_VertProjection.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Calculate a feature on different image pyramid levels. 
  public void calc_feature_pyramid (HObject ho_Region, HObject ho_Image, HTuple hv_FeatureName, 
      HTuple hv_NumLevels, out HTuple hv_Feature)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ImageZoom=null, ho_RegionZoom=null;

    // Local control variables 

    HTuple hv_Zoom = new HTuple(), hv_NumRegions = new HTuple();
    HTuple hv_I = new HTuple(), hv_Features = new HTuple();
    HTuple hv_FeatureLength = new HTuple(), hv_Step = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_J = new HTuple();
    HTuple hv_Start = new HTuple(), hv_End = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageZoom);
    HOperatorSet.GenEmptyObj(out ho_RegionZoom);
    hv_Feature = new HTuple();
    //
    //Calculate a feature for different pyramid levels
    //
    hv_Zoom.Dispose();
    hv_Zoom = 0.5;
    hv_Feature.Dispose();
    hv_Feature = new HTuple();
    hv_NumRegions.Dispose();
    HOperatorSet.CountObj(ho_Region, out hv_NumRegions);
    if ((int)(new HTuple(hv_NumRegions.TupleGreater(0))) != 0)
    {
      HTuple end_val7 = hv_NumLevels;
      HTuple step_val7 = 1;
      for (hv_I=1; hv_I.Continue(end_val7, step_val7); hv_I = hv_I.TupleAdd(step_val7))
      {
        if ((int)(new HTuple(hv_I.TupleGreater(1))) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ZoomImageFactor(ho_ImageZoom, out ExpTmpOutVar_0, hv_Zoom, 
              hv_Zoom, "constant");
          ho_ImageZoom.Dispose();
          ho_ImageZoom = ExpTmpOutVar_0;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ZoomRegion(ho_RegionZoom, out ExpTmpOutVar_0, hv_Zoom, hv_Zoom);
          ho_RegionZoom.Dispose();
          ho_RegionZoom = ExpTmpOutVar_0;
          }
          hv_Features.Dispose();
          calculate_features(ho_RegionZoom, ho_ImageZoom, hv_FeatureName, out hv_Features);
        }
        else
        {
          ho_ImageZoom.Dispose();
          HOperatorSet.CopyObj(ho_Image, out ho_ImageZoom, 1, 1);
          ho_RegionZoom.Dispose();
          HOperatorSet.CopyObj(ho_Region, out ho_RegionZoom, 1, hv_NumRegions);
          hv_Features.Dispose();
          calculate_features(ho_RegionZoom, ho_ImageZoom, hv_FeatureName, out hv_Features);
          hv_FeatureLength.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_FeatureLength = (new HTuple(hv_Features.TupleLength()
              ))/hv_NumRegions;
          }
          hv_Step.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Step = hv_NumLevels*hv_FeatureLength;
          }
        }
        hv_Indices.Dispose();
        hv_Indices = new HTuple();
        HTuple end_val20 = hv_NumRegions-1;
        HTuple step_val20 = 1;
        for (hv_J=0; hv_J.Continue(end_val20, step_val20); hv_J = hv_J.TupleAdd(step_val20))
        {
          hv_Start.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Start = (hv_J*hv_Step)+((hv_I-1)*hv_FeatureLength);
          }
          hv_End.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_End = (hv_Start+hv_FeatureLength)-1;
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Indices = hv_Indices.TupleConcat(
              HTuple.TupleGenSequence(hv_Start,hv_End,1));
          hv_Indices.Dispose();
          hv_Indices = ExpTmpLocalVar_Indices;
          }
          }
        }
        if (hv_Feature == null)
          hv_Feature = new HTuple();
        hv_Feature[hv_Indices] = hv_Features;
      }
    }
    ho_ImageZoom.Dispose();
    ho_RegionZoom.Dispose();

    hv_Zoom.Dispose();
    hv_NumRegions.Dispose();
    hv_I.Dispose();
    hv_Features.Dispose();
    hv_FeatureLength.Dispose();
    hv_Step.Dispose();
    hv_Indices.Dispose();
    hv_J.Dispose();
    hv_Start.Dispose();
    hv_End.Dispose();

    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Calculate the class weights for a semantic segmentation dataset. 
  public void calculate_dl_segmentation_class_weights (HTuple hv_DLDataset, HTuple hv_MaxWeight, 
      HTuple hv_IgnoreClassIDs, out HTuple hv_ClassWeights)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_SegmentationImage=null;

    // Local control variables 

    HTuple hv_KeysExists = new HTuple(), hv_DLSamples = new HTuple();
    HTuple hv_SampleIndices = new HTuple(), hv_ClassIDs = new HTuple();
    HTuple hv_NumClasses = new HTuple(), hv_ClassIDsToClassIdx = new HTuple();
    HTuple hv_ClassAreas = new HTuple(), hv_SampleIndex = new HTuple();
    HTuple hv_DLSample = new HTuple(), hv_ImageType = new HTuple();
    HTuple hv_AbsoluteHisto = new HTuple(), hv_TotalArea = new HTuple();
    HTuple hv_ValidClasses = new HTuple(), hv_ClassFreq = new HTuple();
    HTuple hv_IndicesToClip = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationImage);
    hv_ClassWeights = new HTuple();
    //
    //This procedure calculates a weight for each class that is present in the Dataset.
    //The class weights are calculated according to the inverse class frequencies
    //in the training dataset.
    //Therefore, the dataset has to be split before calling this procedure.
    //
    //Check if the input is correct.
    hv_KeysExists.Dispose();
    HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", (new HTuple("samples")).TupleConcat(
        "class_ids"), out hv_KeysExists);
    if ((int)(((hv_KeysExists.TupleSelect(0))).TupleNot()) != 0)
    {
      throw new HalconException("DLDataset must contain a key-value pair for 'samples'");
    }
    if ((int)(((hv_KeysExists.TupleSelect(1))).TupleNot()) != 0)
    {
      throw new HalconException("DLDataset must contain a key-value pair for 'class_ids'");
    }
    if ((int)(new HTuple(hv_MaxWeight.TupleLessEqual(0))) != 0)
    {
      throw new HalconException("MaxWeight must be greater than 0");
    }
    //
    //Get the samples of the dataset.
    hv_DLSamples.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
    //Get the train samples.
    hv_SampleIndices.Dispose();
    find_dl_samples(hv_DLSamples, "split", "train", "match", out hv_SampleIndices);
    if ((int)(new HTuple((new HTuple(hv_SampleIndices.TupleLength())).TupleEqual(
        0))) != 0)
    {
      throw new HalconException("The DLDataset does not contain any samples with value 'train' for key 'split'");
    }
    //
    //Get the class IDs of the dataset.
    hv_ClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
    hv_NumClasses.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumClasses = new HTuple(hv_ClassIDs.TupleLength()
        );
    }
    //
    //Define mapping from class ID to class index.
    hv_ClassIDsToClassIdx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ClassIDsToClassIdx = HTuple.TupleGenConst(
        (hv_ClassIDs.TupleMax())+1,-1);
    }
    if (hv_ClassIDsToClassIdx == null)
      hv_ClassIDsToClassIdx = new HTuple();
    hv_ClassIDsToClassIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0,(new HTuple(hv_ClassIDs.TupleLength()
        ))-1,1);
    //
    //We want to collect the number of pixels for each class.
    hv_ClassAreas.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ClassAreas = HTuple.TupleGenConst(
        new HTuple(hv_ClassIDs.TupleLength()),0);
    }
    //
    //Loop over the samples.
    for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_SampleIndices.TupleLength()
        ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
    {
      //
      //Read the sample.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLSample.Dispose();
      read_dl_samples(hv_DLDataset, hv_SampleIndices.TupleSelect(hv_SampleIndex), 
          out hv_DLSample);
      }
      //
      //Get the segmentation image.
      ho_SegmentationImage.Dispose();
      HOperatorSet.GetDictObject(out ho_SegmentationImage, hv_DLSample, "segmentation_image");
      //
      //Convert the segmentation image if necessary.
      hv_ImageType.Dispose();
      HOperatorSet.GetImageType(ho_SegmentationImage, out hv_ImageType);
      if ((int)(new HTuple((new HTuple(((((new HTuple("int1")).TupleConcat("int2")).TupleConcat(
          "uint2")).TupleConcat("byte")).TupleFind(hv_ImageType))).TupleEqual(-1))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_SegmentationImage, out ExpTmpOutVar_0, "uint2");
        ho_SegmentationImage.Dispose();
        ho_SegmentationImage = ExpTmpOutVar_0;
        }
      }
      //
      //Get the number of pixels for each class.
      hv_AbsoluteHisto.Dispose();
      HOperatorSet.GrayHistoAbs(ho_SegmentationImage, ho_SegmentationImage, 1, out hv_AbsoluteHisto);
      //
      //Accumulate the areas.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ClassAreas = hv_ClassAreas+(hv_AbsoluteHisto.TupleSelect(
          hv_ClassIDs));
      hv_ClassAreas.Dispose();
      hv_ClassAreas = ExpTmpLocalVar_ClassAreas;
      }
      }
    }
    //
    //Get the total number of pixels without the area of ignore classes.
    if (hv_ClassAreas == null)
      hv_ClassAreas = new HTuple();
    hv_ClassAreas[hv_ClassIDsToClassIdx.TupleSelect(hv_IgnoreClassIDs)] = 0;
    hv_TotalArea.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TotalArea = hv_ClassAreas.TupleSum()
        ;
    }
    //
    //Calculate the inverse class frequencies.
    hv_ClassWeights.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ClassWeights = HTuple.TupleGenConst(
        new HTuple(hv_ClassIDs.TupleLength()),0.0);
    }
    hv_ValidClasses.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ValidClasses = ((hv_ClassAreas.TupleNotEqualElem(
        0))).TupleFind(1);
    }
    hv_ClassFreq.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ClassFreq = hv_ClassAreas/(hv_TotalArea.TupleReal()
        );
    }
    if (hv_ClassWeights == null)
      hv_ClassWeights = new HTuple();
    hv_ClassWeights[hv_ValidClasses] = 1.0/((hv_ClassFreq.TupleSelect(hv_ValidClasses))+0.0001);
    //
    //Scale the weights to obtain a final output of 1.0 for the most frequent class.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_ClassWeights = hv_ClassWeights/(((hv_ClassWeights.TupleSelect(
        hv_ValidClasses))).TupleMin());
    hv_ClassWeights.Dispose();
    hv_ClassWeights = ExpTmpLocalVar_ClassWeights;
    }
    }
    //Clip the weights.
    hv_IndicesToClip.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IndicesToClip = ((hv_ClassWeights.TupleGreaterElem(
        hv_MaxWeight))).TupleFind(1);
    }
    if ((int)(new HTuple(hv_IndicesToClip.TupleNotEqual(-1))) != 0)
    {
      if (hv_ClassWeights == null)
        hv_ClassWeights = new HTuple();
      hv_ClassWeights[hv_IndicesToClip] = hv_MaxWeight;
    }

    ho_SegmentationImage.Dispose();

    hv_KeysExists.Dispose();
    hv_DLSamples.Dispose();
    hv_SampleIndices.Dispose();
    hv_ClassIDs.Dispose();
    hv_NumClasses.Dispose();
    hv_ClassIDsToClassIdx.Dispose();
    hv_ClassAreas.Dispose();
    hv_SampleIndex.Dispose();
    hv_DLSample.Dispose();
    hv_ImageType.Dispose();
    hv_AbsoluteHisto.Dispose();
    hv_TotalArea.Dispose();
    hv_ValidClasses.Dispose();
    hv_ClassFreq.Dispose();
    hv_IndicesToClip.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Calculate evaluation measures based on the values of RunningMeasures and the settings in EvalParams. 
  public void calculate_evaluation_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
      out HTuple hv_EvaluationResult)
  {



    // Local control variables 

    HTuple hv_EvalInstances = new HTuple();
    // Initialize local and output iconic variables 
    hv_EvaluationResult = new HTuple();
    //
    //This procedure calculates the final measures depending on the evaluation type.
    hv_EvalInstances.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "evaluate_instances", out hv_EvalInstances);
    if ((int)(hv_EvalInstances) != 0)
    {
      hv_EvaluationResult.Dispose();
      calculate_instance_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
    }
    else
    {
      hv_EvaluationResult.Dispose();
      calculate_pixel_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
    }
    //

    hv_EvalInstances.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Calculate one or more features of a given image and/or region. 
  public void calculate_features (HObject ho_Region, HObject ho_Image, HTuple hv_FeatureNames, 
      out HTuple hv_Features)
  {



    // Initialize local and output iconic variables 
    hv_Features = new HTuple();
    //
    //Calculate features given in FeatureNames
    //for the input regions in Region
    //(if needed supported by the underlying
    //gray-value or color image Image).
    //
    hv_Features.Dispose();
    get_features(ho_Region, ho_Image, hv_FeatureNames, "calculate", out hv_Features);


    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Calculate instance measures based on RunningMeasures. 
  public void calculate_instance_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
      out HTuple hv_EvaluationResult)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CalcClassAP = new HTuple(), hv_CalcMeanAP = new HTuple();
    HTuple hv_Measures = new HTuple(), hv_M = new HTuple();
    HTuple hv_ClassIDs = new HTuple(), hv_NumClasses = new HTuple();
    HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRanges = new HTuple();
    HTuple hv_IoUThresholds = new HTuple(), hv_DetailedEvaluation = new HTuple();
    HTuple hv_KeyExists = new HTuple(), hv_AreaNames = new HTuple();
    HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
    HTuple hv_RecThreshs = new HTuple(), hv_MDIdx = new HTuple();
    HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
    HTuple hv_CurrentRunningMeasures = new HTuple(), hv_PerMaxNumEvaluationResult = new HTuple();
    HTuple hv_AreaIdx = new HTuple(), hv_MinArea = new HTuple();
    HTuple hv_MaxArea = new HTuple(), hv_AreaName = new HTuple();
    HTuple hv_AreaRunningMeasures = new HTuple(), hv_PerClassNumGt = new HTuple();
    HTuple hv_PerClassNumPred = new HTuple(), hv_PerClassConfidence = new HTuple();
    HTuple hv_PerClassNumGtIgnore = new HTuple(), hv_CurrentEvaluationResult = new HTuple();
    HTuple hv_ITIdx = new HTuple(), hv_PerIoUAP = new HTuple();
    HTuple hv_PerIoUDetailedEvaluation = new HTuple(), hv_ClsIdx = new HTuple();
    HTuple hv_PerClassDetailedEvaluation = new HTuple(), hv_DetectionConfusionMatrix = new HTuple();
    HTuple hv_PerIoUMeasure = new HTuple(), hv_NumImgIDsWithFN = new HTuple();
    HTuple hv_NumImgIDsWithFP = new HTuple(), hv_ImgIDsWithFN = new HTuple();
    HTuple hv_ImgIDsWithFP = new HTuple(), hv_ClassMAPDict = new HTuple();
    HTuple hv_ClassesWithGt = new HTuple(), hv_PerClassMAP = new HTuple();
    HTuple hv_PerIoUMAP = new HTuple(), hv_PerIoUTP = new HTuple();
    HTuple hv_PerIoUFN = new HTuple(), hv_PerIoUFP = new HTuple();
    HTuple hv_PerIoUFPClass = new HTuple(), hv_PerIoUFPBackground = new HTuple();
    HTuple hv_PerIoUFPLocalization = new HTuple(), hv_PerIoUFPDuplicate = new HTuple();
    HTuple hv_PerIoUFPMultiple = new HTuple(), hv_ClassAPPerIoU = new HTuple();
    HTuple hv_NumGt = new HTuple(), hv_NumGtIgnore = new HTuple();
    HTuple hv_NumPred = new HTuple(), hv_Confidences = new HTuple();
    HTuple hv_SortIdxs = new HTuple(), hv_CurrentClassMeasures = new HTuple();
    HTuple hv_IsTP = new HTuple(), hv_Ignore = new HTuple();
    HTuple hv_NoIgnoreIdxs = new HTuple(), hv_IsFP = new HTuple();
    HTuple hv_AccumulatedIsTP = new HTuple(), hv_AccumulatedIsFP = new HTuple();
    HTuple hv_Recall = new HTuple(), hv_Precision = new HTuple();
    HTuple hv_InterpolatedPrecision = new HTuple(), hv_PIdx = new HTuple();
    HTuple hv_PrecisionAtRecThreshs = new HTuple(), hv_RTIdx = new HTuple();
    HTuple hv_RecQuantile = new HTuple(), hv_IsFPClass = new HTuple();
    HTuple hv_IsFPBackground = new HTuple(), hv_IsFPLocalization = new HTuple();
    HTuple hv_IsFPDuplicate = new HTuple(), hv_IsFPMultiple = new HTuple();
    HTuple hv_NumTP = new HTuple(), hv_NumFP = new HTuple();
    HTuple hv_NumFN = new HTuple(), hv_NumFPClass = new HTuple();
    HTuple hv_NumFPBackground = new HTuple(), hv_NumFPLocalization = new HTuple();
    HTuple hv_NumFPDuplicate = new HTuple(), hv_NumFPMultiple = new HTuple();
    HTuple hv_IndicesWithClassConfusion = new HTuple(), hv_IsFPClassIdxs = new HTuple();
    HTuple hv_ClassIdxsConfused = new HTuple(), hv_Idx = new HTuple();
    HTuple hv_NumConfusedThisIdx = new HTuple(), hv_MeanClassAP = new HTuple();
    HTuple hv_MAP = new HTuple();
    // Initialize local and output iconic variables 
    hv_EvaluationResult = new HTuple();
    //
    //This procedure calculates the final summarizing instance measures based on the running measures.
    //
    hv_CalcClassAP.Dispose();
    hv_CalcClassAP = 0;
    hv_CalcMeanAP.Dispose();
    hv_CalcMeanAP = 0;
    //Check which measures are to be calculated.
    hv_Measures.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
    hv_EvaluationResult.Dispose();
    HOperatorSet.CreateDict(out hv_EvaluationResult);
    for (hv_M=0; (int)hv_M<=(int)((new HTuple(hv_Measures.TupleLength()))-1); hv_M = (int)hv_M + 1)
    {
      if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("mean_ap"))) != 0)
      {
        hv_CalcMeanAP.Dispose();
        hv_CalcMeanAP = 1;
        //As we need to calculate the class APs anyway, we also write them out.
        hv_CalcClassAP.Dispose();
        hv_CalcClassAP = 1;
      }
      else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
          "all"))) != 0)
      {
        hv_CalcClassAP.Dispose();
        hv_CalcClassAP = 1;
        hv_CalcMeanAP.Dispose();
        hv_CalcMeanAP = 1;
      }
      else
      {
        throw new HalconException("Unknown Instance Measure: "+(hv_Measures.TupleSelect(
            hv_M)));
      }
    }
    //*
    //Dependencies of measures:
    //
    //Recall (per-class)       *                   --> AP per class --> mAP
    //Precision (per-class)  /
    //
    //*
    //Initialize output dictionary and get necessary evaluation parameters.
    hv_EvaluationResult.Dispose();
    HOperatorSet.CreateDict(out hv_EvaluationResult);
    hv_ClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
    hv_NumClasses.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
    hv_MaxNumDetections.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
    hv_AreaRanges.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
    hv_IoUThresholds.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
    //Check if a detailed evaluation should be done.
    hv_DetailedEvaluation.Dispose();
    hv_DetailedEvaluation = 0;
    hv_KeyExists.Dispose();
    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation", 
        out hv_KeyExists);
    if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
    {
      hv_DetailedEvaluation.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
    }
    //
    //Get information about area ranges.
    hv_AreaNames.Dispose();
    HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
    hv_MinAreas.Dispose();
    HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
    hv_MaxAreas.Dispose();
    HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
    //
    //Equidistant thresholds used to approximate the area under the Precision-Recall curve.
    hv_RecThreshs.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RecThreshs = HTuple.TupleGenSequence(
        0.0,1.0,0.01);
    }
    //Start with calculation.
    if ((int)(hv_CalcClassAP.TupleOr(hv_CalcMeanAP)) != 0)
    {
      //Loop over maximal number of detections.
      for (hv_MDIdx=0; (int)hv_MDIdx<=(int)((new HTuple(hv_MaxNumDetections.TupleLength()
          ))-1); hv_MDIdx = (int)hv_MDIdx + 1)
      {
        //
        //Get corresponding running measures.
        hv_MaxNum.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxNum = hv_MaxNumDetections.TupleSelect(
            hv_MDIdx);
        }
        hv_MaxNumStr.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxNumStr = ""+hv_MaxNum;
        }
        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
        {
          hv_MaxNumStr.Dispose();
          hv_MaxNumStr = "all";
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentRunningMeasures.Dispose();
        HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_"+hv_MaxNumStr, 
            out hv_CurrentRunningMeasures);
        }
        //
        //Initialize output dictionary.
        hv_PerMaxNumEvaluationResult.Dispose();
        HOperatorSet.CreateDict(out hv_PerMaxNumEvaluationResult);
        //
        //Loop over area ranges.
        for (hv_AreaIdx=0; (int)hv_AreaIdx<=(int)((new HTuple(hv_AreaNames.TupleLength()
            ))-1); hv_AreaIdx = (int)hv_AreaIdx + 1)
        {
          //Get area thresholds.
          hv_MinArea.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MinArea = hv_MinAreas.TupleSelect(
              hv_AreaIdx);
          }
          hv_MaxArea.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MaxArea = hv_MaxAreas.TupleSelect(
              hv_AreaIdx);
          }
          hv_AreaName.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AreaName = hv_AreaNames.TupleSelect(
              hv_AreaIdx);
          }
          //
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AreaRunningMeasures.Dispose();
          HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_"+hv_AreaName, 
              out hv_AreaRunningMeasures);
          }
          //
          hv_PerClassNumGt.Dispose();
          HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
          hv_PerClassNumPred.Dispose();
          HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
          hv_PerClassConfidence.Dispose();
          HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidence);
          hv_PerClassNumGtIgnore.Dispose();
          HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
          //
          //Initialize output dictionary.
          hv_CurrentEvaluationResult.Dispose();
          HOperatorSet.CreateDict(out hv_CurrentEvaluationResult);
          for (hv_ITIdx=0; (int)hv_ITIdx<=(int)((new HTuple(hv_IoUThresholds.TupleLength()
              ))-1); hv_ITIdx = (int)hv_ITIdx + 1)
          {
            hv_PerIoUAP.Dispose();
            HOperatorSet.CreateDict(out hv_PerIoUAP);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "ap_iou_"+(((""+(hv_IoUThresholds.TupleSelect(
                hv_ITIdx)))).TupleRegexpReplace("\\.","")), hv_PerIoUAP);
            }
            if ((int)(hv_DetailedEvaluation) != 0)
            {
              //Initialize detailed measures.
              hv_PerIoUDetailedEvaluation.Dispose();
              HOperatorSet.CreateDict(out hv_PerIoUDetailedEvaluation);
              HTuple end_val86 = hv_NumClasses-1;
              HTuple step_val86 = 1;
              for (hv_ClsIdx=0; hv_ClsIdx.Continue(end_val86, step_val86); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val86))
              {
                hv_PerClassDetailedEvaluation.Dispose();
                HOperatorSet.CreateDict(out hv_PerClassDetailedEvaluation);
                //Initialize with zeros in case there is no ground truth for this class.
                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp", 
                    0);
                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn", 
                    0);
                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp", 
                    0);
                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class", 
                    0);
                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background", 
                    0);
                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate", 
                    0);
                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization", 
                    0);
                HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple", 
                    0);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "class_"+(hv_ClassIDs.TupleSelect(
                    hv_ClsIdx)), hv_PerClassDetailedEvaluation);
                }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_DetectionConfusionMatrix.Dispose();
              HOperatorSet.CreateMatrix(hv_NumClasses+1, hv_NumClasses+4, 0, out hv_DetectionConfusionMatrix);
              }
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix", 
                  hv_DetectionConfusionMatrix);
              //
              //Get and set image IDs with false negatives and false positives.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PerIoUMeasure.Dispose();
              HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_"+(((""+(hv_IoUThresholds.TupleSelect(
                  hv_ITIdx)))).TupleRegexpReplace("\\.","")), out hv_PerIoUMeasure);
              }
              //Get image IDs with false negatives and false positives, respectively.
              hv_NumImgIDsWithFN.Dispose();
              HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives", 
                  out hv_NumImgIDsWithFN);
              hv_NumImgIDsWithFP.Dispose();
              HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives", 
                  out hv_NumImgIDsWithFP);
              hv_ImgIDsWithFN.Dispose();
              HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives", 
                  out hv_ImgIDsWithFN);
              hv_ImgIDsWithFP.Dispose();
              HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives", 
                  out hv_ImgIDsWithFP);
              //Set in current output.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_negatives", 
                  hv_ImgIDsWithFN.TupleSelectRange(0,hv_NumImgIDsWithFN-1));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_positives", 
                  hv_ImgIDsWithFP.TupleSelectRange(0,hv_NumImgIDsWithFP-1));
              }
              //
              //Set output for this IoU.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_"+(((""+(hv_IoUThresholds.TupleSelect(
                  hv_ITIdx)))).TupleRegexpReplace("\\.","")), hv_PerIoUDetailedEvaluation);
              }
            }
          }
          hv_ClassMAPDict.Dispose();
          HOperatorSet.CreateDict(out hv_ClassMAPDict);
          HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap", hv_ClassMAPDict);
          //
          //Check which classes have ground truth annotations.
          hv_ClassesWithGt.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassesWithGt = ((((hv_PerClassNumGt-hv_PerClassNumGtIgnore)).TupleGreaterElem(
              0))).TupleFind(1);
          }
          if ((int)(new HTuple(hv_ClassesWithGt.TupleEqual(-1))) != 0)
          {
            hv_ClassesWithGt.Dispose();
            hv_ClassesWithGt = new HTuple();
          }
          //
          //Initialize PerClassMAP, i.e. mean over IoU-thresholds per class.
          hv_PerClassMAP.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PerClassMAP = HTuple.TupleGenConst(
              hv_NumClasses,-1.0);
          }
          //
          //Initialize PerIoUMAP, i.e. mean average precision over classes per IoU-threshold.
          hv_PerIoUMAP.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PerIoUMAP = HTuple.TupleGenConst(
              new HTuple(hv_IoUThresholds.TupleLength()),0.0);
          }
          //
          if ((int)(hv_DetailedEvaluation) != 0)
          {
            //Initialize overall num_fn, num_tp, ...
            hv_PerIoUTP.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_PerIoUTP = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),0);
            }
            hv_PerIoUFN.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_PerIoUFN = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),0);
            }
            hv_PerIoUFP.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_PerIoUFP = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),0);
            }
            hv_PerIoUFPClass.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_PerIoUFPClass = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),0);
            }
            hv_PerIoUFPBackground.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_PerIoUFPBackground = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),0);
            }
            hv_PerIoUFPLocalization.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_PerIoUFPLocalization = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),0);
            }
            hv_PerIoUFPDuplicate.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_PerIoUFPDuplicate = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),0);
            }
            hv_PerIoUFPMultiple.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_PerIoUFPMultiple = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),0);
            }
          }
          //Loop over all classes.
          HTuple end_val144 = hv_NumClasses-1;
          HTuple step_val144 = 1;
          for (hv_ClsIdx=0; hv_ClsIdx.Continue(end_val144, step_val144); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val144))
          {
            //
            //Initialize per-class AP per IoU-threshold (only for one class).
            hv_ClassAPPerIoU.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ClassAPPerIoU = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),-1.0);
            }
            //
            //Get results for this class.
            hv_NumGt.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_NumGt = hv_PerClassNumGt.TupleSelect(
                hv_ClsIdx);
            }
            hv_NumGtIgnore.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_NumGtIgnore = hv_PerClassNumGtIgnore.TupleSelect(
                hv_ClsIdx);
            }
            if ((int)(new HTuple(((hv_NumGt-hv_NumGtIgnore)).TupleGreater(0))) != 0)
            {
              hv_NumPred.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_NumPred = hv_PerClassNumPred.TupleSelect(
                  hv_ClsIdx);
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Confidences.Dispose();
              HOperatorSet.GetDictTuple(hv_PerClassConfidence, "class_"+(hv_ClassIDs.TupleSelect(
                  hv_ClsIdx)), out hv_Confidences);
              }
              //
              //Sort the confidences in descending order and
              //only take the first NumPred ones due to block allocation.
              hv_SortIdxs.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SortIdxs = ((-(hv_Confidences.TupleSelectRange(
                  0,hv_NumPred-1)))).TupleSortIndex();
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                  hv_SortIdxs);
              hv_Confidences.Dispose();
              hv_Confidences = ExpTmpLocalVar_Confidences;
              }
              }
            }
            //
            //Loop over IoU thresholds.
            for (hv_ITIdx=0; (int)hv_ITIdx<=(int)((new HTuple(hv_IoUThresholds.TupleLength()
                ))-1); hv_ITIdx = (int)hv_ITIdx + 1)
            {
              //
              //Check if there are ground truth labels for this class.
              if ((int)(new HTuple(((hv_NumGt-hv_NumGtIgnore)).TupleGreater(0))) != 0)
              {
                //
                //Get results for this class and IoU-threshold.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_PerIoUMeasure.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_"+(((""+(hv_IoUThresholds.TupleSelect(
                    hv_ITIdx)))).TupleRegexpReplace("\\.","")), out hv_PerIoUMeasure);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_CurrentClassMeasures.Dispose();
                HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_"+(hv_ClassIDs.TupleSelect(
                    hv_ClsIdx)), out hv_CurrentClassMeasures);
                }
                hv_IsTP.Dispose();
                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_tp", out hv_IsTP);
                hv_Ignore.Dispose();
                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "ignore", out hv_Ignore);
                //
                //Sort IsTP and Ignore such that it fits to the confidences.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                    hv_SortIdxs);
                hv_IsTP.Dispose();
                hv_IsTP = ExpTmpLocalVar_IsTP;
                }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_Ignore = hv_Ignore.TupleSelect(
                    hv_SortIdxs);
                hv_Ignore.Dispose();
                hv_Ignore = ExpTmpLocalVar_Ignore;
                }
                }
                //
                //Sort out the ignored results.
                if ((int)(new HTuple((new HTuple(hv_IsTP.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                  hv_NoIgnoreIdxs.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_NoIgnoreIdxs = hv_Ignore.TupleFind(
                      0);
                  }
                  if ((int)(new HTuple(hv_NoIgnoreIdxs.TupleNotEqual(-1))) != 0)
                  {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    {
                    HTuple 
                      ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                        hv_NoIgnoreIdxs);
                    hv_IsTP.Dispose();
                    hv_IsTP = ExpTmpLocalVar_IsTP;
                    }
                    }
                    hv_IsFP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_IsFP = hv_IsTP.TupleNot()
                        ;
                    }
                  }
                  else
                  {
                    hv_IsTP.Dispose();
                    hv_IsTP = new HTuple();
                    hv_IsFP.Dispose();
                    hv_IsFP = new HTuple();
                  }
                }
                else
                {
                  hv_IsFP.Dispose();
                  hv_IsFP = new HTuple();
                }
                //
                //Accumulate IsTP and IsFP.
                hv_AccumulatedIsTP.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_AccumulatedIsTP = hv_IsTP.TupleCumul()
                    ;
                }
                hv_AccumulatedIsFP.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_AccumulatedIsFP = hv_IsFP.TupleCumul()
                    ;
                }
                //
                //Compute recall.
                //The recall is computed with respect to all ground truth instances,
                //independent of MaxNum.
                hv_Recall.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Recall = (hv_AccumulatedIsTP.TupleReal()
                    )/(hv_NumGt-hv_NumGtIgnore);
                }
                //
                //Compute precision.
                hv_Precision.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Precision = (hv_AccumulatedIsTP.TupleReal()
                    )/(hv_AccumulatedIsTP+hv_AccumulatedIsFP);
                }
                //
                //Smooth precision-curve.
                hv_InterpolatedPrecision.Dispose();
                hv_InterpolatedPrecision = new HTuple(hv_Precision);
                for (hv_PIdx=(new HTuple(hv_NumPred.TupleLength()))-2; (int)hv_PIdx>=0; hv_PIdx = (int)hv_PIdx + -1)
                {
                  if (hv_InterpolatedPrecision == null)
                    hv_InterpolatedPrecision = new HTuple();
                  hv_InterpolatedPrecision[hv_PIdx] = ((hv_Precision.TupleSelect(
                      hv_PIdx))).TupleMax2(hv_Precision.TupleSelect(hv_PIdx+1));
                }
                //Compute approximated area under the Precision-Recall curve using Recall-Thresholds.
                hv_PrecisionAtRecThreshs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_PrecisionAtRecThreshs = HTuple.TupleGenConst(
                    new HTuple(hv_RecThreshs.TupleLength()),0.0);
                }
                for (hv_RTIdx=0; (int)hv_RTIdx<=(int)((new HTuple(hv_RecThreshs.TupleLength()
                    ))-1); hv_RTIdx = (int)hv_RTIdx + 1)
                {
                  hv_RecQuantile.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_RecQuantile = ((hv_Recall.TupleGreaterEqualElem(
                      hv_RecThreshs.TupleSelect(hv_RTIdx)))).TupleFindFirst(1);
                  }
                  if ((int)(new HTuple(hv_RecQuantile.TupleGreater(-1))) != 0)
                  {
                    if (hv_PrecisionAtRecThreshs == null)
                      hv_PrecisionAtRecThreshs = new HTuple();
                    hv_PrecisionAtRecThreshs[hv_RTIdx] = hv_InterpolatedPrecision.TupleSelect(
                        hv_RecQuantile);
                  }
                }
                //
                //Calculate AP as mean of precision at equidistant recall values.
                if (hv_ClassAPPerIoU == null)
                  hv_ClassAPPerIoU = new HTuple();
                hv_ClassAPPerIoU[hv_ITIdx] = hv_PrecisionAtRecThreshs.TupleMean()
                    ;
                //
                //Accumulate AP over classes.
                if (hv_PerIoUMAP == null)
                  hv_PerIoUMAP = new HTuple();
                hv_PerIoUMAP[hv_ITIdx] = (hv_PerIoUMAP.TupleSelect(hv_ITIdx))+(hv_ClassAPPerIoU.TupleSelect(
                    hv_ITIdx));
                //
                if ((int)(hv_DetailedEvaluation) != 0)
                {
                  //Summarize detailed evaluation running measures, set matrix-values and update overall detailed measures.
                  //
                  //Get the necessary running measures.
                  hv_IsFPClass.Dispose();
                  HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_class", 
                      out hv_IsFPClass);
                  hv_IsFPBackground.Dispose();
                  HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_background", 
                      out hv_IsFPBackground);
                  hv_IsFPLocalization.Dispose();
                  HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_localization", 
                      out hv_IsFPLocalization);
                  hv_IsFPDuplicate.Dispose();
                  HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_duplicate", 
                      out hv_IsFPDuplicate);
                  hv_IsFPMultiple.Dispose();
                  HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_multiple", 
                      out hv_IsFPMultiple);
                  //
                  //We use the values with maximal recall,
                  //in case a higher precision is desired, increase 'min_confidence'.
                  if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                      )).TupleGreater(0))) != 0)
                  {
                    hv_NumTP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_NumTP = hv_AccumulatedIsTP.TupleSelect(
                        (new HTuple(hv_AccumulatedIsTP.TupleLength()))-1);
                    }
                  }
                  else
                  {
                    hv_NumTP.Dispose();
                    hv_NumTP = 0;
                  }
                  if ((int)(new HTuple((new HTuple(hv_AccumulatedIsFP.TupleLength()
                      )).TupleGreater(0))) != 0)
                  {
                    hv_NumFP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_NumFP = hv_AccumulatedIsFP.TupleSelect(
                        (new HTuple(hv_AccumulatedIsFP.TupleLength()))-1);
                    }
                  }
                  else
                  {
                    hv_NumFP.Dispose();
                    hv_NumFP = 0;
                  }
                  hv_NumFN.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_NumFN = (hv_NumGt-hv_NumGtIgnore)-hv_NumTP;
                  }
                  hv_NumFPClass.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_NumFPClass = ((((hv_IsFPClass.TupleSelect(
                      hv_SortIdxs))).TupleGreaterElem(-1))).TupleSum();
                  }
                  hv_NumFPBackground.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_NumFPBackground = ((((hv_IsFPBackground.TupleSelect(
                      hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                  }
                  hv_NumFPLocalization.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_NumFPLocalization = ((((hv_IsFPLocalization.TupleSelect(
                      hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                  }
                  hv_NumFPDuplicate.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_NumFPDuplicate = ((((hv_IsFPDuplicate.TupleSelect(
                      hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                  }
                  hv_NumFPMultiple.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_NumFPMultiple = ((((hv_IsFPMultiple.TupleSelect(
                      hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                  }
                  if ((int)(new HTuple((new HTuple(hv_SortIdxs.TupleLength())).TupleEqual(
                      0))) != 0)
                  {
                    hv_NumFPClass.Dispose();
                    hv_NumFPClass = 0;
                    hv_NumFPBackground.Dispose();
                    hv_NumFPBackground = 0;
                    hv_NumFPLocalization.Dispose();
                    hv_NumFPLocalization = 0;
                    hv_NumFPDuplicate.Dispose();
                    hv_NumFPDuplicate = 0;
                    hv_NumFPMultiple.Dispose();
                    hv_NumFPMultiple = 0;
                  }
                  //Consistency checks.
                  if ((int)(new HTuple(((((((((((((((((hv_NumTP.TupleConcat(hv_NumFN))).TupleConcat(
                      hv_NumFP))).TupleConcat(hv_NumFPClass))).TupleConcat(hv_NumFPBackground))).TupleConcat(
                      hv_NumFPLocalization))).TupleConcat(hv_NumFPDuplicate))).TupleConcat(
                      hv_NumFPMultiple))).TupleMin())).TupleLess(0))) != 0)
                  {
                    throw new HalconException("Fatal error while calculating instance measures.");
                  }
                  if ((int)(new HTuple(hv_NumFP.TupleNotEqual((((hv_NumFPClass+hv_NumFPBackground)+hv_NumFPLocalization)+hv_NumFPDuplicate)+hv_NumFPMultiple))) != 0)
                  {
                    throw new HalconException("Fatal error while calculating instance measures.");
                  }
                  //
                  //Set per-class measures.
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_PerIoUDetailedEvaluation.Dispose();
                  HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_"+(((""+(hv_IoUThresholds.TupleSelect(
                      hv_ITIdx)))).TupleRegexpReplace("\\.","")), out hv_PerIoUDetailedEvaluation);
                  }
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_PerClassDetailedEvaluation.Dispose();
                  HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "class_"+(hv_ClassIDs.TupleSelect(
                      hv_ClsIdx)), out hv_PerClassDetailedEvaluation);
                  }
                  HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp", 
                      hv_NumTP);
                  HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn", 
                      hv_NumFN);
                  HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp", 
                      hv_NumFP);
                  HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class", 
                      hv_NumFPClass);
                  HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background", 
                      hv_NumFPBackground);
                  HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate", 
                      hv_NumFPDuplicate);
                  HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization", 
                      hv_NumFPLocalization);
                  HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple", 
                      hv_NumFPMultiple);
                  //
                  //Set detection confusion matrix values.
                  hv_DetectionConfusionMatrix.Dispose();
                  HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix", 
                      out hv_DetectionConfusionMatrix);
                  HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, 
                      hv_ClsIdx, hv_NumTP);
                  HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_NumClasses, 
                      hv_ClsIdx, hv_NumFN);
                  HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, 
                      hv_NumClasses, hv_NumFPBackground);
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, 
                      hv_NumClasses+1, hv_NumFPLocalization);
                  }
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, 
                      hv_NumClasses+2, hv_NumFPDuplicate);
                  }
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, 
                      hv_NumClasses+3, hv_NumFPMultiple);
                  }
                  //
                  //Go over IsFPClass and set confusions in matrix.
                  hv_IndicesWithClassConfusion.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_IndicesWithClassConfusion = ((((hv_IsFPClass.TupleSelect(
                      hv_SortIdxs))).TupleGreaterElem(-1))).TupleFind(1);
                  }
                  hv_IsFPClassIdxs.Dispose();
                  hv_IsFPClassIdxs = new HTuple();
                  if ((int)(new HTuple(hv_IndicesWithClassConfusion.TupleGreater(
                      -1))) != 0)
                  {
                    hv_IsFPClassIdxs.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_IsFPClassIdxs = hv_IsFPClass.TupleSelect(
                        hv_SortIdxs.TupleSelect(hv_IndicesWithClassConfusion));
                    }
                  }
                  hv_ClassIdxsConfused.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_ClassIdxsConfused = ((hv_IsFPClassIdxs.TupleSort()
                      )).TupleUniq();
                  }
                  for (hv_Idx=0; (int)hv_Idx<=(int)((new HTuple(hv_ClassIdxsConfused.TupleLength()
                      ))-1); hv_Idx = (int)hv_Idx + 1)
                  {
                    hv_NumConfusedThisIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_NumConfusedThisIdx = ((((hv_IsFPClassIdxs.TupleFind(
                        hv_ClassIdxsConfused.TupleSelect(hv_Idx)))).TupleGreaterElem(
                        -1))).TupleSum();
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx, 
                        hv_ClassIdxsConfused.TupleSelect(hv_Idx), hv_NumConfusedThisIdx);
                    }
                  }
                  //
                  //Update overall measures.
                  if (hv_PerIoUFN == null)
                    hv_PerIoUFN = new HTuple();
                  hv_PerIoUFN[hv_ITIdx] = (hv_PerIoUFN.TupleSelect(hv_ITIdx))+hv_NumFN;
                  if (hv_PerIoUTP == null)
                    hv_PerIoUTP = new HTuple();
                  hv_PerIoUTP[hv_ITIdx] = (hv_PerIoUTP.TupleSelect(hv_ITIdx))+hv_NumTP;
                  if (hv_PerIoUFP == null)
                    hv_PerIoUFP = new HTuple();
                  hv_PerIoUFP[hv_ITIdx] = (hv_PerIoUFP.TupleSelect(hv_ITIdx))+hv_NumFP;
                  if (hv_PerIoUFPClass == null)
                    hv_PerIoUFPClass = new HTuple();
                  hv_PerIoUFPClass[hv_ITIdx] = (hv_PerIoUFPClass.TupleSelect(hv_ITIdx))+hv_NumFPClass;
                  if (hv_PerIoUFPBackground == null)
                    hv_PerIoUFPBackground = new HTuple();
                  hv_PerIoUFPBackground[hv_ITIdx] = (hv_PerIoUFPBackground.TupleSelect(
                      hv_ITIdx))+hv_NumFPBackground;
                  if (hv_PerIoUFPLocalization == null)
                    hv_PerIoUFPLocalization = new HTuple();
                  hv_PerIoUFPLocalization[hv_ITIdx] = (hv_PerIoUFPLocalization.TupleSelect(
                      hv_ITIdx))+hv_NumFPLocalization;
                  if (hv_PerIoUFPDuplicate == null)
                    hv_PerIoUFPDuplicate = new HTuple();
                  hv_PerIoUFPDuplicate[hv_ITIdx] = (hv_PerIoUFPDuplicate.TupleSelect(
                      hv_ITIdx))+hv_NumFPDuplicate;
                  if (hv_PerIoUFPMultiple == null)
                    hv_PerIoUFPMultiple = new HTuple();
                  hv_PerIoUFPMultiple[hv_ITIdx] = (hv_PerIoUFPMultiple.TupleSelect(
                      hv_ITIdx))+hv_NumFPMultiple;
                }
              }
              //
              //Write to output.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PerIoUAP.Dispose();
              HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_"+(((""+(hv_IoUThresholds.TupleSelect(
                  hv_ITIdx)))).TupleRegexpReplace("\\.","")), out hv_PerIoUAP);
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUAP, "class_"+(hv_ClassIDs.TupleSelect(
                  hv_ClsIdx)), hv_ClassAPPerIoU.TupleSelect(hv_ITIdx));
              }
            }
            //
            //Class mAP is the mean over IoU-thresholds.
            if (hv_PerClassMAP == null)
              hv_PerClassMAP = new HTuple();
            hv_PerClassMAP[hv_ClsIdx] = hv_ClassAPPerIoU.TupleMean();
            hv_ClassMAPDict.Dispose();
            HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap", 
                out hv_ClassMAPDict);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_ClassMAPDict, "class_"+(hv_ClassIDs.TupleSelect(
                hv_ClsIdx)), hv_PerClassMAP.TupleSelect(hv_ClsIdx));
            }
          }
          //
          //Calculate the mean AP (over classes) per IoU-threshold.
          for (hv_ITIdx=0; (int)hv_ITIdx<=(int)((new HTuple(hv_IoUThresholds.TupleLength()
              ))-1); hv_ITIdx = (int)hv_ITIdx + 1)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_PerIoUAP.Dispose();
            HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_"+(((""+(hv_IoUThresholds.TupleSelect(
                hv_ITIdx)))).TupleRegexpReplace("\\.","")), out hv_PerIoUAP);
            }
            //
            //Consider only present classes.
            hv_MeanClassAP.Dispose();
            hv_MeanClassAP = -1.0;
            if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                0))) != 0)
            {
              hv_MeanClassAP.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_MeanClassAP = (hv_PerIoUMAP.TupleSelect(
                  hv_ITIdx))/(new HTuple(hv_ClassesWithGt.TupleLength()));
              }
            }
            HOperatorSet.SetDictTuple(hv_PerIoUAP, "mean_class_ap", hv_MeanClassAP);
            //
            if ((int)(hv_DetailedEvaluation) != 0)
            {
              //Add overall measures for TP, FN, FP, ...
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PerIoUDetailedEvaluation.Dispose();
              HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_"+(((""+(hv_IoUThresholds.TupleSelect(
                  hv_ITIdx)))).TupleRegexpReplace("\\.","")), out hv_PerIoUDetailedEvaluation);
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_tp", hv_PerIoUTP.TupleSelect(
                  hv_ITIdx));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fn", hv_PerIoUFN.TupleSelect(
                  hv_ITIdx));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp", hv_PerIoUFP.TupleSelect(
                  hv_ITIdx));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_class", 
                  hv_PerIoUFPClass.TupleSelect(hv_ITIdx));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_background", 
                  hv_PerIoUFPBackground.TupleSelect(hv_ITIdx));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_duplicate", 
                  hv_PerIoUFPDuplicate.TupleSelect(hv_ITIdx));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_localization", 
                  hv_PerIoUFPLocalization.TupleSelect(hv_ITIdx));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_multiple", 
                  hv_PerIoUFPMultiple.TupleSelect(hv_ITIdx));
              }
            }
          }
          //
          //Calculate overall mean AP (over classes and IoU-thresholds).
          //Also here only classes with ground truth annotations are taken into account.
          hv_MAP.Dispose();
          hv_MAP = -1.0;
          if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
              0))) != 0)
          {
            hv_MAP.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MAP = (((hv_PerClassMAP.TupleSelect(
                hv_ClassesWithGt))).TupleSum())/(new HTuple(hv_ClassesWithGt.TupleLength()
                ));
            }
          }
          HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_ap", hv_MAP);
          //
          //Add CurrentEvaluationResult to output.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_PerMaxNumEvaluationResult, "area_"+hv_AreaName, 
              hv_CurrentEvaluationResult);
          }
        }
        //Add PerMaxNumEvaluationResult to output.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_EvaluationResult, "max_num_detections_"+hv_MaxNumStr, 
            hv_PerMaxNumEvaluationResult);
        }
      }
    }
    //

    hv_CalcClassAP.Dispose();
    hv_CalcMeanAP.Dispose();
    hv_Measures.Dispose();
    hv_M.Dispose();
    hv_ClassIDs.Dispose();
    hv_NumClasses.Dispose();
    hv_MaxNumDetections.Dispose();
    hv_AreaRanges.Dispose();
    hv_IoUThresholds.Dispose();
    hv_DetailedEvaluation.Dispose();
    hv_KeyExists.Dispose();
    hv_AreaNames.Dispose();
    hv_MinAreas.Dispose();
    hv_MaxAreas.Dispose();
    hv_RecThreshs.Dispose();
    hv_MDIdx.Dispose();
    hv_MaxNum.Dispose();
    hv_MaxNumStr.Dispose();
    hv_CurrentRunningMeasures.Dispose();
    hv_PerMaxNumEvaluationResult.Dispose();
    hv_AreaIdx.Dispose();
    hv_MinArea.Dispose();
    hv_MaxArea.Dispose();
    hv_AreaName.Dispose();
    hv_AreaRunningMeasures.Dispose();
    hv_PerClassNumGt.Dispose();
    hv_PerClassNumPred.Dispose();
    hv_PerClassConfidence.Dispose();
    hv_PerClassNumGtIgnore.Dispose();
    hv_CurrentEvaluationResult.Dispose();
    hv_ITIdx.Dispose();
    hv_PerIoUAP.Dispose();
    hv_PerIoUDetailedEvaluation.Dispose();
    hv_ClsIdx.Dispose();
    hv_PerClassDetailedEvaluation.Dispose();
    hv_DetectionConfusionMatrix.Dispose();
    hv_PerIoUMeasure.Dispose();
    hv_NumImgIDsWithFN.Dispose();
    hv_NumImgIDsWithFP.Dispose();
    hv_ImgIDsWithFN.Dispose();
    hv_ImgIDsWithFP.Dispose();
    hv_ClassMAPDict.Dispose();
    hv_ClassesWithGt.Dispose();
    hv_PerClassMAP.Dispose();
    hv_PerIoUMAP.Dispose();
    hv_PerIoUTP.Dispose();
    hv_PerIoUFN.Dispose();
    hv_PerIoUFP.Dispose();
    hv_PerIoUFPClass.Dispose();
    hv_PerIoUFPBackground.Dispose();
    hv_PerIoUFPLocalization.Dispose();
    hv_PerIoUFPDuplicate.Dispose();
    hv_PerIoUFPMultiple.Dispose();
    hv_ClassAPPerIoU.Dispose();
    hv_NumGt.Dispose();
    hv_NumGtIgnore.Dispose();
    hv_NumPred.Dispose();
    hv_Confidences.Dispose();
    hv_SortIdxs.Dispose();
    hv_CurrentClassMeasures.Dispose();
    hv_IsTP.Dispose();
    hv_Ignore.Dispose();
    hv_NoIgnoreIdxs.Dispose();
    hv_IsFP.Dispose();
    hv_AccumulatedIsTP.Dispose();
    hv_AccumulatedIsFP.Dispose();
    hv_Recall.Dispose();
    hv_Precision.Dispose();
    hv_InterpolatedPrecision.Dispose();
    hv_PIdx.Dispose();
    hv_PrecisionAtRecThreshs.Dispose();
    hv_RTIdx.Dispose();
    hv_RecQuantile.Dispose();
    hv_IsFPClass.Dispose();
    hv_IsFPBackground.Dispose();
    hv_IsFPLocalization.Dispose();
    hv_IsFPDuplicate.Dispose();
    hv_IsFPMultiple.Dispose();
    hv_NumTP.Dispose();
    hv_NumFP.Dispose();
    hv_NumFN.Dispose();
    hv_NumFPClass.Dispose();
    hv_NumFPBackground.Dispose();
    hv_NumFPLocalization.Dispose();
    hv_NumFPDuplicate.Dispose();
    hv_NumFPMultiple.Dispose();
    hv_IndicesWithClassConfusion.Dispose();
    hv_IsFPClassIdxs.Dispose();
    hv_ClassIdxsConfused.Dispose();
    hv_Idx.Dispose();
    hv_NumConfusedThisIdx.Dispose();
    hv_MeanClassAP.Dispose();
    hv_MAP.Dispose();

    return;
  }

  // Chapter: Filters / Lines
  // Short Description: Calculates the parameters Sigma, Low, and High for lines_gauss from the maximum width and the contrast of the lines to be extracted. 
  public void calculate_lines_gauss_parameters (HTuple hv_MaxLineWidth, HTuple hv_Contrast, 
      out HTuple hv_Sigma, out HTuple hv_Low, out HTuple hv_High)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ContrastHigh = new HTuple(), hv_ContrastLow = new HTuple();
    HTuple hv_HalfWidth = new HTuple(), hv_Help = new HTuple();
    HTuple   hv_MaxLineWidth_COPY_INP_TMP = new HTuple(hv_MaxLineWidth);

    // Initialize local and output iconic variables 
    hv_Sigma = new HTuple();
    hv_Low = new HTuple();
    hv_High = new HTuple();
    //Check control parameters
    if ((int)(new HTuple((new HTuple(hv_MaxLineWidth_COPY_INP_TMP.TupleLength())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("Wrong number of values of control parameter: 1");
    }
    if ((int)(((hv_MaxLineWidth_COPY_INP_TMP.TupleIsNumber())).TupleNot()) != 0)
    {
      throw new HalconException("Wrong type of control parameter: 1");
    }
    if ((int)(new HTuple(hv_MaxLineWidth_COPY_INP_TMP.TupleLessEqual(0))) != 0)
    {
      throw new HalconException("Wrong value of control parameter: 1");
    }
    if ((int)((new HTuple((new HTuple(hv_Contrast.TupleLength())).TupleNotEqual(1))).TupleAnd(
        new HTuple((new HTuple(hv_Contrast.TupleLength())).TupleNotEqual(2)))) != 0)
    {
      throw new HalconException("Wrong number of values of control parameter: 2");
    }
    if ((int)(new HTuple(((((hv_Contrast.TupleIsNumber())).TupleMin())).TupleEqual(
        0))) != 0)
    {
      throw new HalconException("Wrong type of control parameter: 2");
    }
    //Set and check ContrastHigh
    hv_ContrastHigh.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ContrastHigh = hv_Contrast.TupleSelect(
        0);
    }
    if ((int)(new HTuple(hv_ContrastHigh.TupleLess(0))) != 0)
    {
      throw new HalconException("Wrong value of control parameter: 2");
    }
    //Set or derive ContrastLow
    if ((int)(new HTuple((new HTuple(hv_Contrast.TupleLength())).TupleEqual(2))) != 0)
    {
      hv_ContrastLow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ContrastLow = hv_Contrast.TupleSelect(
          1);
      }
    }
    else
    {
      hv_ContrastLow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ContrastLow = hv_ContrastHigh/3.0;
      }
    }
    //Check ContrastLow
    if ((int)(new HTuple(hv_ContrastLow.TupleLess(0))) != 0)
    {
      throw new HalconException("Wrong value of control parameter: 2");
    }
    if ((int)(new HTuple(hv_ContrastLow.TupleGreater(hv_ContrastHigh))) != 0)
    {
      throw new HalconException("Wrong value of control parameter: 2");
    }
    //
    //Calculate the parameters Sigma, Low, and High for lines_gauss
    if ((int)(new HTuple(hv_MaxLineWidth_COPY_INP_TMP.TupleLess((new HTuple(3.0)).TupleSqrt()
        ))) != 0)
    {
      //Note that LineWidthMax < sqrt(3.0) would result in a Sigma < 0.5,
      //which does not make any sense, because the corresponding smoothing
      //filter mask would be of size 1x1.
      //To avoid this, LineWidthMax is restricted to values greater or equal
      //to sqrt(3.0) and the contrast values are adapted to reflect the fact
      //that lines that are thinner than sqrt(3.0) pixels have a lower contrast
      //in the smoothed image (compared to lines that are sqrt(3.0) pixels wide).
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ContrastLow = (hv_ContrastLow*hv_MaxLineWidth_COPY_INP_TMP)/((new HTuple(3.0)).TupleSqrt()
          );
      hv_ContrastLow.Dispose();
      hv_ContrastLow = ExpTmpLocalVar_ContrastLow;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ContrastHigh = (hv_ContrastHigh*hv_MaxLineWidth_COPY_INP_TMP)/((new HTuple(3.0)).TupleSqrt()
          );
      hv_ContrastHigh.Dispose();
      hv_ContrastHigh = ExpTmpLocalVar_ContrastHigh;
      }
      }
      hv_MaxLineWidth_COPY_INP_TMP.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxLineWidth_COPY_INP_TMP = (new HTuple(3.0)).TupleSqrt()
          ;
      }
    }
    //Convert LineWidthMax and the given contrast values into the input parameters
    //Sigma, Low, and High required by lines_gauss
    hv_HalfWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HalfWidth = hv_MaxLineWidth_COPY_INP_TMP/2.0;
    }
    hv_Sigma.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Sigma = hv_HalfWidth/((new HTuple(3.0)).TupleSqrt()
        );
    }
    hv_Help.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Help = ((-2.0*hv_HalfWidth)/(((new HTuple(6.283185307178)).TupleSqrt()
        )*(hv_Sigma.TuplePow(3.0))))*(((-0.5*(((hv_HalfWidth/hv_Sigma)).TuplePow(
        2.0)))).TupleExp());
    }
    hv_High.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_High = ((hv_ContrastHigh*hv_Help)).TupleFabs()
        ;
    }
    hv_Low.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Low = ((hv_ContrastLow*hv_Help)).TupleFabs()
        ;
    }

    hv_MaxLineWidth_COPY_INP_TMP.Dispose();
    hv_ContrastHigh.Dispose();
    hv_ContrastLow.Dispose();
    hv_HalfWidth.Dispose();
    hv_Help.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Calculate pixel measures based on RunningMeasures. 
  public void calculate_pixel_measures (HTuple hv_RunningMeasures, HTuple hv_EvalParams, 
      out HTuple hv_EvaluationResult)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CalcClassPixelAccuracy = new HTuple();
    HTuple hv_CalcPixelAccuracy = new HTuple(), hv_CalcPixelConfusionMatrix = new HTuple();
    HTuple hv_CalcMeanAccuracy = new HTuple(), hv_CalcMeanIou = new HTuple();
    HTuple hv_CalcClassIou = new HTuple(), hv_CalcFWIou = new HTuple();
    HTuple hv_Measures = new HTuple(), hv_M = new HTuple();
    HTuple hv_ConfMatrix = new HTuple(), hv_TPMat = new HTuple();
    HTuple hv_TP = new HTuple(), hv_SumRowMat = new HTuple();
    HTuple hv_RowSum = new HTuple(), hv_FP = new HTuple();
    HTuple hv_SumColMat = new HTuple(), hv_ColSum = new HTuple();
    HTuple hv_FN = new HTuple(), hv_IgnoreClassIDs = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
    HTuple hv_FPIgnore = new HTuple(), hv_GT = new HTuple();
    HTuple hv_ClsIdxValid = new HTuple(), hv_ClassPixelAccuracy = new HTuple();
    HTuple hv_MeanAccuracy = new HTuple(), hv_PixelAccuracy = new HTuple();
    HTuple hv_ClassIoU = new HTuple(), hv_MeanIoU = new HTuple();
    HTuple hv_FWIoU = new HTuple(), hv_FwWeights = new HTuple();
    // Initialize local and output iconic variables 
    hv_EvaluationResult = new HTuple();
    //
    //This procedure calculates the pixel-wise measures based on the values in running measures.
    //
    hv_CalcClassPixelAccuracy.Dispose();
    hv_CalcClassPixelAccuracy = 0;
    hv_CalcPixelAccuracy.Dispose();
    hv_CalcPixelAccuracy = 0;
    hv_CalcPixelConfusionMatrix.Dispose();
    hv_CalcPixelConfusionMatrix = 0;
    hv_CalcMeanAccuracy.Dispose();
    hv_CalcMeanAccuracy = 0;
    hv_CalcMeanIou.Dispose();
    hv_CalcMeanIou = 0;
    hv_CalcClassIou.Dispose();
    hv_CalcClassIou = 0;
    hv_CalcFWIou.Dispose();
    hv_CalcFWIou = 0;
    //Check which measures are to be calculated.
    hv_Measures.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
    hv_EvaluationResult.Dispose();
    HOperatorSet.CreateDict(out hv_EvaluationResult);
    for (hv_M=0; (int)hv_M<=(int)((new HTuple(hv_Measures.TupleLength()))-1); hv_M = (int)hv_M + 1)
    {
      if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("pixel_accuracy"))) != 0)
      {
        hv_CalcPixelAccuracy.Dispose();
        hv_CalcPixelAccuracy = 1;
      }
      else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
          "class_pixel_accuracy"))) != 0)
      {
        hv_CalcClassPixelAccuracy.Dispose();
        hv_CalcClassPixelAccuracy = 1;
      }
      else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
          "pixel_confusion_matrix"))) != 0)
      {
        hv_CalcPixelConfusionMatrix.Dispose();
        hv_CalcPixelConfusionMatrix = 1;
      }
      else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
          "mean_accuracy"))) != 0)
      {
        hv_CalcMeanAccuracy.Dispose();
        hv_CalcMeanAccuracy = 1;
      }
      else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
          "mean_iou"))) != 0)
      {
        hv_CalcMeanIou.Dispose();
        hv_CalcMeanIou = 1;
      }
      else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
          "class_iou"))) != 0)
      {
        hv_CalcClassIou.Dispose();
        hv_CalcClassIou = 1;
      }
      else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
          "frequency_weighted_iou"))) != 0)
      {
        hv_CalcFWIou.Dispose();
        hv_CalcFWIou = 1;
      }
      else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
          "all"))) != 0)
      {
        hv_CalcPixelAccuracy.Dispose();
        hv_CalcPixelAccuracy = 1;
        hv_CalcClassPixelAccuracy.Dispose();
        hv_CalcClassPixelAccuracy = 1;
        hv_CalcPixelConfusionMatrix.Dispose();
        hv_CalcPixelConfusionMatrix = 1;
        hv_CalcMeanAccuracy.Dispose();
        hv_CalcMeanAccuracy = 1;
        hv_CalcMeanIou.Dispose();
        hv_CalcMeanIou = 1;
        hv_CalcClassIou.Dispose();
        hv_CalcClassIou = 1;
        hv_CalcFWIou.Dispose();
        hv_CalcFWIou = 1;
      }
      else
      {
        throw new HalconException("Unknown Segmentation Measure: "+(hv_Measures.TupleSelect(
            hv_M)));
      }
    }
    //
    //Depending on the running measure values (ConfusionMatrix or TP/FP/FN),
    //we first calculate TP/FP/FN from the ConfusionMatrix.
    if ((int)(hv_CalcPixelConfusionMatrix) != 0)
    {
      //Get the running measures.
      hv_ConfMatrix.Dispose();
      HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
      //Get the per-class true positives as the diagonal of the matrix.
      hv_TPMat.Dispose();
      HOperatorSet.GetDiagonalMatrix(hv_ConfMatrix, 0, out hv_TPMat);
      hv_TP.Dispose();
      HOperatorSet.GetFullMatrix(hv_TPMat, out hv_TP);
      //For the confusion matrix, the row determines the predicted class-IDs,
      //the column determines the ground truth class-IDs.
      //Get the per-class false positives (FP) as the sum over the rows minus the diagonal (TP).
      hv_SumRowMat.Dispose();
      HOperatorSet.SumMatrix(hv_ConfMatrix, "rows", out hv_SumRowMat);
      hv_RowSum.Dispose();
      HOperatorSet.GetFullMatrix(hv_SumRowMat, out hv_RowSum);
      hv_FP.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FP = hv_RowSum-hv_TP;
      }
      //Get the per-class false negatives (FN) as the sum over the columns minus the diagonal (TP).
      hv_SumColMat.Dispose();
      HOperatorSet.SumMatrix(hv_ConfMatrix, "columns", out hv_SumColMat);
      hv_ColSum.Dispose();
      HOperatorSet.GetFullMatrix(hv_SumColMat, out hv_ColSum);
      hv_FN.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FN = hv_ColSum-hv_TP;
      }
      //We do not want to count the false positives (FP) in the ignore region.
      //The false negatives (FN) are not affected, since the model does not predict the ignore class.
      hv_IgnoreClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
      if ((int)(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
          0))) != 0)
      {
        //The ignore class corresponds to the last row/column in the confusion matrix.
        hv_Rows.Dispose();hv_Columns.Dispose();
        HOperatorSet.GetSizeMatrix(hv_ConfMatrix, out hv_Rows, out hv_Columns);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FPIgnore.Dispose();
        HOperatorSet.GetValueMatrix(hv_ConfMatrix, HTuple.TupleGenSequence(0,hv_Rows-1,1), 
            HTuple.TupleGenConst(hv_Rows,hv_Columns-1), out hv_FPIgnore);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_FP = hv_FP-hv_FPIgnore;
        hv_FP.Dispose();
        hv_FP = ExpTmpLocalVar_FP;
        }
        }
        //Remove last entries of TP, FP, FN (those related to the ignore class).
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TP = hv_TP.TupleSelectRange(
            0,(new HTuple(hv_TP.TupleLength()))-2);
        hv_TP.Dispose();
        hv_TP = ExpTmpLocalVar_TP;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_FP = hv_FP.TupleSelectRange(
            0,(new HTuple(hv_FP.TupleLength()))-2);
        hv_FP.Dispose();
        hv_FP = ExpTmpLocalVar_FP;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_FN = hv_FN.TupleSelectRange(
            0,(new HTuple(hv_FN.TupleLength()))-2);
        hv_FN.Dispose();
        hv_FN = ExpTmpLocalVar_FN;
        }
        }
        //Remove last row/column from confusion matrix.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.GetSubMatrix(hv_ConfMatrix, 0, 0, hv_Rows-1, hv_Columns-1, out ExpTmpOutVar_0);
        hv_ConfMatrix.Dispose();
        hv_ConfMatrix = ExpTmpOutVar_0;
        }
      }
      //Paste the confusion matrix to the output.
      HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_confusion_matrix", hv_ConfMatrix);
    }
    else
    {
      //Get the running measure values.
      hv_TP.Dispose();
      HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
      hv_FP.Dispose();
      HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
      hv_FN.Dispose();
      HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
    }
    //
    //It might be the case, that some of the classes are not present in the set of validation images.
    //--> Exclude these classes (they are indirectly present as they reduce the number of TP for other classes).
    hv_GT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_GT = hv_TP+hv_FN;
    }
    hv_ClsIdxValid.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ClsIdxValid = ((hv_GT.TupleGreaterElem(
        0))).TupleFind(1);
    }
    //
    //Mean Accuracy, Class Pixel Accuracy.
    //-> If one of 'mean_accuracy', 'class_pixel_accuracy' is specified, we give back both of them
    //   as they have to be calculated anyway (to the most part).
    if ((int)(hv_CalcClassPixelAccuracy.TupleOr(hv_CalcMeanAccuracy)) != 0)
    {
      //Compute pixel accuracy per class (although we might only use it for the overall pixel accuracy).
      hv_ClassPixelAccuracy.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassPixelAccuracy = HTuple.TupleGenConst(
          new HTuple(hv_GT.TupleLength()),-1);
      }
      hv_MeanAccuracy.Dispose();
      hv_MeanAccuracy = -1;
      if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
      {
        if (hv_ClassPixelAccuracy == null)
          hv_ClassPixelAccuracy = new HTuple();
        hv_ClassPixelAccuracy[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
            )/(hv_GT.TupleSelect(hv_ClsIdxValid));
        hv_MeanAccuracy.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MeanAccuracy = ((hv_ClassPixelAccuracy.TupleSelect(
            hv_ClsIdxValid))).TupleMean();
        }
      }
      HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_pixel_accuracy", hv_ClassPixelAccuracy);
      HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_accuracy", hv_MeanAccuracy);
    }
    //Pixel Accuracy
    if ((int)(hv_CalcPixelAccuracy) != 0)
    {
      //Compute pixel accuracy as the total ratio of pixels that have been correctly predicted.
      hv_PixelAccuracy.Dispose();
      hv_PixelAccuracy = -1;
      if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
      {
        hv_PixelAccuracy.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PixelAccuracy = (((((hv_TP.TupleSelect(
            hv_ClsIdxValid))).TupleSum())).TupleReal())/(((hv_GT.TupleSelect(hv_ClsIdxValid))).TupleSum()
            );
        }
      }
      HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_accuracy", hv_PixelAccuracy);
    }
    //Mean IoU, class IoU, frequency weighted IoU:
    //-> If the measures 'class_iou', 'mean_iou' or 'frequency_weighted_iou' is specified,
    //   we return all three of them as they have to be calculated anyway (to the most part).
    if ((int)((new HTuple(hv_CalcMeanIou.TupleOr(hv_CalcClassIou))).TupleOr(hv_CalcFWIou)) != 0)
    {
      hv_ClassIoU.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassIoU = HTuple.TupleGenConst(
          new HTuple(hv_GT.TupleLength()),-1);
      }
      hv_MeanIoU.Dispose();
      hv_MeanIoU = -1;
      hv_FWIoU.Dispose();
      hv_FWIoU = -1;
      if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
      {
        if (hv_ClassIoU == null)
          hv_ClassIoU = new HTuple();
        hv_ClassIoU[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
            )/((hv_GT.TupleSelect(hv_ClsIdxValid))+(hv_FP.TupleSelect(hv_ClsIdxValid)));
        hv_MeanIoU.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MeanIoU = ((hv_ClassIoU.TupleSelect(
            hv_ClsIdxValid))).TupleMean();
        }
        hv_FwWeights.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FwWeights = (hv_GT.TupleReal()
            )/(hv_GT.TupleSum());
        }
        hv_FWIoU.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FWIoU = (((hv_FwWeights.TupleSelect(
            hv_ClsIdxValid))*(hv_ClassIoU.TupleSelect(hv_ClsIdxValid)))).TupleSum()
            ;
        }
      }
      HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_iou", hv_ClassIoU);
      HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_iou", hv_MeanIoU);
      HOperatorSet.SetDictTuple(hv_EvaluationResult, "frequency_weighted_iou", hv_FWIoU);
    }
    //

    hv_CalcClassPixelAccuracy.Dispose();
    hv_CalcPixelAccuracy.Dispose();
    hv_CalcPixelConfusionMatrix.Dispose();
    hv_CalcMeanAccuracy.Dispose();
    hv_CalcMeanIou.Dispose();
    hv_CalcClassIou.Dispose();
    hv_CalcFWIou.Dispose();
    hv_Measures.Dispose();
    hv_M.Dispose();
    hv_ConfMatrix.Dispose();
    hv_TPMat.Dispose();
    hv_TP.Dispose();
    hv_SumRowMat.Dispose();
    hv_RowSum.Dispose();
    hv_FP.Dispose();
    hv_SumColMat.Dispose();
    hv_ColSum.Dispose();
    hv_FN.Dispose();
    hv_IgnoreClassIDs.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_FPIgnore.Dispose();
    hv_GT.Dispose();
    hv_ClsIdxValid.Dispose();
    hv_ClassPixelAccuracy.Dispose();
    hv_MeanAccuracy.Dispose();
    hv_PixelAccuracy.Dispose();
    hv_ClassIoU.Dispose();
    hv_MeanIoU.Dispose();
    hv_FWIoU.Dispose();
    hv_FwWeights.Dispose();

    return;
  }

  // Chapter: Transformations / Poses
  // Short Description: Calculate the poses to grasp an object. 
  public void calculate_tool_in_base_robot_path_poses (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInModelRobotPathPoses, 
      HTuple hv_ModelInBasePose, HTuple hv_Poses, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBaseRobotPathPoses)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OrderOfTransform = new HTuple();
    HTuple hv_OrderOfRotation = new HTuple(), hv_ViewOfTransform = new HTuple();
    HTuple hv_Index1 = new HTuple(), hv_ToolInBaseRobotPathPose = new HTuple();
    // Initialize local and output iconic variables 
    hvec_ToolInBaseRobotPathPoses = new HTupleVector(1);
    //
    hv_OrderOfTransform.Dispose();
    read_dict_tuple(hv_Poses, "OrderOfTransform", out hv_OrderOfTransform);
    hv_OrderOfRotation.Dispose();
    read_dict_tuple(hv_Poses, "OrderOfRotation", out hv_OrderOfRotation);
    hv_ViewOfTransform.Dispose();
    read_dict_tuple(hv_Poses, "ViewOfTransform", out hv_ViewOfTransform);
    //
    HTuple end_val5 = new HTuple(hvec_ToolInModelRobotPathPoses.Length)-1;
    HTuple step_val5 = 1;
    for (hv_Index1=0; hv_Index1.Continue(end_val5, step_val5); hv_Index1 = hv_Index1.TupleAdd(step_val5))
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ToolInBaseRobotPathPose.Dispose();
      HOperatorSet.PoseCompose(hv_ModelInBasePose, hvec_ToolInModelRobotPathPoses[hv_Index1].T, 
          out hv_ToolInBaseRobotPathPose);
      }
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.ConvertPoseType(hv_ToolInBaseRobotPathPose, hv_OrderOfTransform, 
          hv_OrderOfRotation, hv_ViewOfTransform, out ExpTmpOutVar_0);
      hv_ToolInBaseRobotPathPose.Dispose();
      hv_ToolInBaseRobotPathPose = ExpTmpOutVar_0;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_ToolInBaseRobotPathPoses[hv_Index1] = dh.Add(new HTupleVector(hv_ToolInBaseRobotPathPose));
      }
    }

    hv_OrderOfTransform.Dispose();
    hv_OrderOfRotation.Dispose();
    hv_ViewOfTransform.Dispose();
    hv_Index1.Dispose();
    hv_ToolInBaseRobotPathPose.Dispose();

    return;
  }

  // Chapter: Calibration / Monocular
  // Short Description: Calibrate a camera with a single image. 
  public void calibrate_camera_and_plane_single_image (HTuple hv_CalibObjectData)
  {



    // Local iconic variables 

    HObject ho_ImageCaltab;

    // Local control variables 

    HTuple hv_CalPlateDescr = new HTuple(), hv_CalPlateThickness = new HTuple();
    HTuple hv_StartCamParam = new HTuple(), hv_CalibDataID = new HTuple();
    HTuple hv_ErrorCamCalibInPixel = new HTuple(), hv_CamParam = new HTuple();
    HTuple hv_PlaneInCamPose0 = new HTuple(), hv_PlaneInCamPose = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageCaltab);
    ho_ImageCaltab.Dispose();
    read_dict_object(out ho_ImageCaltab, hv_CalibObjectData, "ImageCaltab");
    hv_CalPlateDescr.Dispose();
    read_dict_tuple(hv_CalibObjectData, "CalPlateDescr", out hv_CalPlateDescr);
    hv_CalPlateThickness.Dispose();
    read_dict_tuple(hv_CalibObjectData, "CalPlateThickness", out hv_CalPlateThickness);
    hv_StartCamParam.Dispose();
    read_dict_tuple(hv_CalibObjectData, "StartCamParam", out hv_StartCamParam);
    //
    //Check input
    if ((int)(new HTuple(((hv_StartCamParam.TupleSelect(0))).TupleEqual("line_scan"))) != 0)
    {
      throw new HalconException("Line-scan cameras are not supported");
    }
    //
    //Create a HALCON calibration data model.
    hv_CalibDataID.Dispose();
    HOperatorSet.CreateCalibData("calibration_object", 1, 1, out hv_CalibDataID);
    //Set the needed calibration information.
    HOperatorSet.SetCalibDataCamParam(hv_CalibDataID, 0, new HTuple(), hv_StartCamParam);
    HOperatorSet.SetCalibDataCalibObject(hv_CalibDataID, 0, hv_CalPlateDescr);
    //Find the calibration plate.
    HOperatorSet.FindCalibObject(ho_ImageCaltab, hv_CalibDataID, 0, 0, 0, new HTuple(), 
        new HTuple());
    //Calibrating from only one view requires some parameter to be excluded
    //from the optimization.
    HOperatorSet.SetCalibData(hv_CalibDataID, "camera", 0, "excluded_settings", "focus");
    //Calibrate the camera.
    hv_ErrorCamCalibInPixel.Dispose();
    HOperatorSet.CalibrateCameras(hv_CalibDataID, out hv_ErrorCamCalibInPixel);
    //Get the calibration results.
    hv_CamParam.Dispose();
    HOperatorSet.GetCalibData(hv_CalibDataID, "camera", 0, "params", out hv_CamParam);
    hv_PlaneInCamPose0.Dispose();
    HOperatorSet.GetCalibData(hv_CalibDataID, "calib_obj_pose", (new HTuple(0)).TupleConcat(
        0), "pose", out hv_PlaneInCamPose0);
    hv_PlaneInCamPose.Dispose();
    HOperatorSet.SetOriginPose(hv_PlaneInCamPose0, 0, 0, hv_CalPlateThickness, out hv_PlaneInCamPose);
    //Convert pose to standard pose type.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInCamPose, "Rp+T", "gba", "point", out ExpTmpOutVar_0);
    hv_PlaneInCamPose.Dispose();
    hv_PlaneInCamPose = ExpTmpOutVar_0;
    }
    //
    //Add data to output dict.
    HOperatorSet.SetDictTuple(hv_CalibObjectData, "ErrorCamCalibInPixel", hv_ErrorCamCalibInPixel);
    HOperatorSet.SetDictTuple(hv_CalibObjectData, "CamParam", hv_CamParam);
    HOperatorSet.SetDictTuple(hv_CalibObjectData, "PlaneInCamPose", hv_PlaneInCamPose);
    //Clean up.
    HOperatorSet.ClearCalibData(hv_CalibDataID);
    ho_ImageCaltab.Dispose();

    hv_CalPlateDescr.Dispose();
    hv_CalPlateThickness.Dispose();
    hv_StartCamParam.Dispose();
    hv_CalibDataID.Dispose();
    hv_ErrorCamCalibInPixel.Dispose();
    hv_CamParam.Dispose();
    hv_PlaneInCamPose0.Dispose();
    hv_PlaneInCamPose.Dispose();

    return;
  }

  // Chapter: Calibration / Hand-Eye
  // Short Description: Perform a hand-eye calibration with a stationary camera. 
  public void calibrate_hand_eye_stationary_cam_approx (HTuple hv_RobotTouchingPointInToolCoordinates, 
      HTuple hv_RowsTouchingPointInPlane, HTuple hv_ColumnsTouchingPointInPlane, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePoses, 
      HTuple hv_CalibObjectData, out HTuple hv_HandEyeCalibData)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CamParam = new HTuple(), hv_CalPlateThickness = new HTuple();
    HTuple hv_PlaneInCamPose = new HTuple(), hv_OrderOfTransform0 = new HTuple();
    HTuple hv_OrderOfRotation0 = new HTuple(), hv_ViewOfTransform0 = new HTuple();
    HTuple hv_Index = new HTuple(), hv_OrderOfTransform = new HTuple();
    HTuple hv_OrderOfRotation = new HTuple(), hv_ViewOfTransform = new HTuple();
    HTuple hv_TouchingPointInToolPose = new HTuple(), hv_XBase = new HTuple();
    HTuple hv_YBase = new HTuple(), hv_ZBase = new HTuple();
    HTuple hv_TouchingPointInBasePose = new HTuple(), hv_XPlane = new HTuple();
    HTuple hv_YPlane = new HTuple(), hv_ZPlane = new HTuple();
    HTuple hv_HomMat3DPlaneToBase = new HTuple(), hv_PlaneInBasePose = new HTuple();
    HTuple hv_BaseInPlanePose = new HTuple(), hv_BaseInCamPose = new HTuple();
    HTuple hv_XPlaneBase = new HTuple(), hv_YPlaneBase = new HTuple();
    HTuple hv_ZPlaneBase = new HTuple(), hv_DiffX = new HTuple();
    HTuple hv_DiffY = new HTuple(), hv_DiffZ = new HTuple();
    HTuple hv_SqrDiff = new HTuple(), hv_PlanePointsRMS = new HTuple();
    HTuple hv_PlanePointsMaxDiff = new HTuple();
    HTupleVector  hvec_ToolInBasePoses_COPY_INP_TMP = new HTupleVector(hvec_ToolInBasePoses);

    // Initialize local and output iconic variables 
    hv_HandEyeCalibData = new HTuple();
    //
    hv_CamParam.Dispose();
    read_dict_tuple(hv_CalibObjectData, "CamParam", out hv_CamParam);
    hv_CalPlateThickness.Dispose();
    read_dict_tuple(hv_CalibObjectData, "CalPlateThickness", out hv_CalPlateThickness);
    hv_PlaneInCamPose.Dispose();
    read_dict_tuple(hv_CalibObjectData, "PlaneInCamPose", out hv_PlaneInCamPose);
    //
    //Check input
    if ((int)((new HTuple((new HTuple((new HTuple(hv_RowsTouchingPointInPlane.TupleLength()
        )).TupleLess(3))).TupleOr(new HTuple((new HTuple(hv_ColumnsTouchingPointInPlane.TupleLength()
        )).TupleLess(3))))).TupleOr(new HTuple((new HTuple(hvec_ToolInBasePoses_COPY_INP_TMP.Length)).TupleLess(
        3)))) != 0)
    {
      throw new HalconException("Please specify at least three image coordinates and robot poses.");
    }
    if ((int)((new HTuple((new HTuple(hv_RowsTouchingPointInPlane.TupleLength())).TupleNotEqual(
        new HTuple(hv_ColumnsTouchingPointInPlane.TupleLength())))).TupleOr(new HTuple((new HTuple(hv_RowsTouchingPointInPlane.TupleLength()
        )).TupleNotEqual(new HTuple(hvec_ToolInBasePoses_COPY_INP_TMP.Length))))) != 0)
    {
      throw new HalconException("The number of image coordinates and robot poses have to be equal.");
    }
    if ((int)(new HTuple(((hv_CamParam.TupleSelect(0))).TupleEqual("line_scan"))) != 0)
    {
      throw new HalconException("Line-scan cameras are not supported");
    }
    //
    //If points on top of the calibration plate are approached, we have to adapt the PlaneInCamPose accordingly.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.SetOriginPose(hv_PlaneInCamPose, 0, 0, -hv_CalPlateThickness, out ExpTmpOutVar_0);
    hv_PlaneInCamPose.Dispose();
    hv_PlaneInCamPose = ExpTmpOutVar_0;
    }
    //Keep track of the pose type used by the robot.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OrderOfTransform0.Dispose();hv_OrderOfRotation0.Dispose();hv_ViewOfTransform0.Dispose();
    HOperatorSet.GetPoseType(hvec_ToolInBasePoses_COPY_INP_TMP[0].T, out hv_OrderOfTransform0, 
        out hv_OrderOfRotation0, out hv_ViewOfTransform0);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hvec_ToolInBasePoses_COPY_INP_TMP[0].T, "Rp+T", 
        "gba", "point", out ExpTmpOutVar_0);
    hvec_ToolInBasePoses_COPY_INP_TMP[0].T = ExpTmpOutVar_0;
    ExpTmpOutVar_0.Dispose();
    }
    HTuple end_val21 = new HTuple(hvec_ToolInBasePoses_COPY_INP_TMP.Length)-1;
    HTuple step_val21 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val21, step_val21); hv_Index = hv_Index.TupleAdd(step_val21))
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_OrderOfTransform.Dispose();hv_OrderOfRotation.Dispose();hv_ViewOfTransform.Dispose();
      HOperatorSet.GetPoseType(hvec_ToolInBasePoses_COPY_INP_TMP[hv_Index].T, out hv_OrderOfTransform, 
          out hv_OrderOfRotation, out hv_ViewOfTransform);
      }
      if ((int)((new HTuple((new HTuple(hv_OrderOfTransform0.TupleNotEqual(hv_OrderOfTransform))).TupleOr(
          new HTuple(hv_OrderOfRotation0.TupleNotEqual(hv_OrderOfRotation))))).TupleOr(
          new HTuple(hv_ViewOfTransform0.TupleNotEqual(hv_ViewOfTransform)))) != 0)
      {
        throw new HalconException("ToolInBasePoses have different pose types.");
      }
      //Convert to default pose type.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.ConvertPoseType(hvec_ToolInBasePoses_COPY_INP_TMP[hv_Index].T, 
          "Rp+T", "gba", "point", out ExpTmpOutVar_0);
      hvec_ToolInBasePoses_COPY_INP_TMP[hv_Index].T = ExpTmpOutVar_0;
      ExpTmpOutVar_0.Dispose();
      }
    }
    //
    //Collect the robot translations.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TouchingPointInToolPose.Dispose();
    HOperatorSet.CreatePose(hv_RobotTouchingPointInToolCoordinates.TupleSelect(0), 
        hv_RobotTouchingPointInToolCoordinates.TupleSelect(1), hv_RobotTouchingPointInToolCoordinates.TupleSelect(
        2), 0, 0, 0, "Rp+T", "gba", "point", out hv_TouchingPointInToolPose);
    }
    hv_XBase.Dispose();
    hv_XBase = new HTuple();
    hv_YBase.Dispose();
    hv_YBase = new HTuple();
    hv_ZBase.Dispose();
    hv_ZBase = new HTuple();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_RowsTouchingPointInPlane.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TouchingPointInBasePose.Dispose();
      HOperatorSet.PoseCompose(hvec_ToolInBasePoses_COPY_INP_TMP[hv_Index].T, hv_TouchingPointInToolPose, 
          out hv_TouchingPointInBasePose);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_XBase = hv_XBase.TupleConcat(
          hv_TouchingPointInBasePose.TupleSelect(0));
      hv_XBase.Dispose();
      hv_XBase = ExpTmpLocalVar_XBase;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_YBase = hv_YBase.TupleConcat(
          hv_TouchingPointInBasePose.TupleSelect(1));
      hv_YBase.Dispose();
      hv_YBase = ExpTmpLocalVar_YBase;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ZBase = hv_ZBase.TupleConcat(
          hv_TouchingPointInBasePose.TupleSelect(2));
      hv_ZBase.Dispose();
      hv_ZBase = ExpTmpLocalVar_ZBase;
      }
      }
    }
    //
    //Get the plane coordinates of the input image points.
    hv_XPlane.Dispose();hv_YPlane.Dispose();
    HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_PlaneInCamPose, hv_RowsTouchingPointInPlane, 
        hv_ColumnsTouchingPointInPlane, "m", out hv_XPlane, out hv_YPlane);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ZPlane.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_XPlane.TupleLength()), 0, out hv_ZPlane);
    }
    hv_HomMat3DPlaneToBase.Dispose();
    HOperatorSet.VectorToHomMat3d("rigid", hv_XPlane, hv_YPlane, hv_ZPlane, hv_XBase, 
        hv_YBase, hv_ZBase, out hv_HomMat3DPlaneToBase);
    hv_PlaneInBasePose.Dispose();
    HOperatorSet.HomMat3dToPose(hv_HomMat3DPlaneToBase, out hv_PlaneInBasePose);
    //If points on top of the calibration plate are approached, we have to readapt the Plane accordingly.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.SetOriginPose(hv_PlaneInCamPose, 0, 0, hv_CalPlateThickness, out ExpTmpOutVar_0);
    hv_PlaneInCamPose.Dispose();
    hv_PlaneInCamPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.SetOriginPose(hv_PlaneInBasePose, 0, 0, hv_CalPlateThickness, out ExpTmpOutVar_0);
    hv_PlaneInBasePose.Dispose();
    hv_PlaneInBasePose = ExpTmpOutVar_0;
    }
    hv_BaseInPlanePose.Dispose();
    HOperatorSet.PoseInvert(hv_PlaneInBasePose, out hv_BaseInPlanePose);
    hv_BaseInCamPose.Dispose();
    HOperatorSet.PoseCompose(hv_PlaneInCamPose, hv_BaseInPlanePose, out hv_BaseInCamPose);
    //
    //Get the BaseInCamPose.
    hv_BaseInPlanePose.Dispose();
    HOperatorSet.PoseInvert(hv_PlaneInBasePose, out hv_BaseInPlanePose);
    hv_BaseInCamPose.Dispose();
    HOperatorSet.PoseCompose(hv_PlaneInCamPose, hv_BaseInPlanePose, out hv_BaseInCamPose);
    //Convert to output pose type.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_BaseInCamPose, hv_OrderOfTransform0, hv_OrderOfRotation0, 
        hv_ViewOfTransform0, out ExpTmpOutVar_0);
    hv_BaseInCamPose.Dispose();
    hv_BaseInCamPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInBasePose, hv_OrderOfTransform0, hv_OrderOfRotation0, 
        hv_ViewOfTransform0, out ExpTmpOutVar_0);
    hv_PlaneInBasePose.Dispose();
    hv_PlaneInBasePose = ExpTmpOutVar_0;
    }

    //Get the difference of the points in the plane as seen by the camera
    //to the points in the plane as approached by the robot.
    hv_XPlaneBase.Dispose();hv_YPlaneBase.Dispose();hv_ZPlaneBase.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3DPlaneToBase, hv_XPlane, hv_YPlane, 
        hv_ZPlane, out hv_XPlaneBase, out hv_YPlaneBase, out hv_ZPlaneBase);
    hv_DiffX.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffX = hv_XPlaneBase-hv_XBase;
    }
    hv_DiffY.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffY = hv_YPlaneBase-hv_YBase;
    }
    hv_DiffZ.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffZ = hv_ZPlaneBase-hv_ZBase;
    }
    hv_SqrDiff.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SqrDiff = ((hv_DiffX*hv_DiffX)+(hv_DiffY*hv_DiffY))+(hv_DiffZ*hv_DiffZ);
    }
    hv_PlanePointsRMS.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PlanePointsRMS = (((hv_SqrDiff.TupleSum()
        )/(new HTuple(hv_DiffX.TupleLength())))).TupleSqrt();
    }
    hv_PlanePointsMaxDiff.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PlanePointsMaxDiff = ((hv_SqrDiff.TupleSqrt()
        )).TupleMax();
    }
    //
    //Create output dict.
    hv_HandEyeCalibData.Dispose();
    HOperatorSet.CreateDict(out hv_HandEyeCalibData);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "CamParam", hv_CamParam);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "BaseInCamPose", hv_BaseInCamPose);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "PlaneInBasePose", hv_PlaneInBasePose);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "PlaneInCamPose0", hv_PlaneInCamPose);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "PlanePointsRMS", hv_PlanePointsRMS);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "PlanePointsMaxDiff", hv_PlanePointsMaxDiff);

    hv_CamParam.Dispose();
    hv_CalPlateThickness.Dispose();
    hv_PlaneInCamPose.Dispose();
    hv_OrderOfTransform0.Dispose();
    hv_OrderOfRotation0.Dispose();
    hv_ViewOfTransform0.Dispose();
    hv_Index.Dispose();
    hv_OrderOfTransform.Dispose();
    hv_OrderOfRotation.Dispose();
    hv_ViewOfTransform.Dispose();
    hv_TouchingPointInToolPose.Dispose();
    hv_XBase.Dispose();
    hv_YBase.Dispose();
    hv_ZBase.Dispose();
    hv_TouchingPointInBasePose.Dispose();
    hv_XPlane.Dispose();
    hv_YPlane.Dispose();
    hv_ZPlane.Dispose();
    hv_HomMat3DPlaneToBase.Dispose();
    hv_PlaneInBasePose.Dispose();
    hv_BaseInPlanePose.Dispose();
    hv_BaseInCamPose.Dispose();
    hv_XPlaneBase.Dispose();
    hv_YPlaneBase.Dispose();
    hv_ZPlaneBase.Dispose();
    hv_DiffX.Dispose();
    hv_DiffY.Dispose();
    hv_DiffZ.Dispose();
    hv_SqrDiff.Dispose();
    hv_PlanePointsRMS.Dispose();
    hv_PlanePointsMaxDiff.Dispose();

    return;
  }

  // Chapter: Calibration / Hand-Eye
  // Short Description: Perform a hand-eye calibration with a stationary camera. 
  public void calibrate_hand_eye_stationary_cam_approx_without_calib_plate (HTuple hv_RowsTouchingPointInPlane, 
      HTuple hv_ColumnsTouchingPointInPlane, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePoses, 
      HTuple hv_RobotTouchingPointInToolCoordinates, HTuple hv_DistanceObjectTouchingPointToPlane, 
      HTuple hv_DistancePlaneToCamera, HTuple hv_Width, HTuple hv_Height, out HTuple hv_HandEyeCalibData)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OrderOfTransform0 = new HTuple();
    HTuple hv_OrderOfRotation0 = new HTuple(), hv_ViewOfTransform0 = new HTuple();
    HTuple hv_Index = new HTuple(), hv_OrderOfTransform = new HTuple();
    HTuple hv_OrderOfRotation = new HTuple(), hv_ViewOfTransform = new HTuple();
    HTuple hv_RobotTouchingPointToToolXYZPose = new HTuple();
    HTuple hv_XBase = new HTuple(), hv_YBase = new HTuple();
    HTuple hv_ZBase = new HTuple(), hv_TouchingPointInBasePose = new HTuple();
    HTuple hv_OM3DPlanePoints = new HTuple(), hv_OM3DPlane = new HTuple();
    HTuple hv_TouchingPointPlaneInBasePose = new HTuple();
    HTuple hv_FocusOrig = new HTuple(), hv_DiffRow = new HTuple();
    HTuple hv_DiffCol = new HTuple(), hv_DistPixel = new HTuple();
    HTuple hv_DiffX = new HTuple(), hv_DiffY = new HTuple();
    HTuple hv_DiffZ = new HTuple(), hv_DistWorld = new HTuple();
    HTuple hv_Quotient = new HTuple(), hv_SX = new HTuple();
    HTuple hv_SY = new HTuple(), hv_FocusShift = new HTuple();
    HTuple hv_BestIndex = new HTuple(), hv_ErrorBasePoseInPixel = new HTuple();
    HTuple hv_NumFocus = new HTuple(), hv_Focus = new HTuple();
    HTuple hv_CamParam0 = new HTuple(), hv_BaseInCamPose0 = new HTuple();
    HTuple hv_ErrorBasePoseInPixelTmp = new HTuple(), hv_BaseInCamPose = new HTuple();
    HTuple hv_CamParam = new HTuple(), hv_TouchingPointPlaneInCamPose = new HTuple();
    HTuple hv_TouchingPointPlaneInCamPose0Rot = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_Qx = new HTuple();
    HTuple hv_Qy = new HTuple(), hv_CosAngleBetweenZAxis = new HTuple();
    HTuple hv_SwitchZDirection = new HTuple(), hv_TouchingPointPlaneInCamPose1 = new HTuple();
    HTuple hv_CamInBasePose = new HTuple(), hv_TouchingPointPlanePointsCamX = new HTuple();
    HTuple hv_TouchingPointPlanePointsCamY = new HTuple();
    HTuple hv_TouchingPointPlanePointsCamZ = new HTuple();
    HTuple hv_BaseInTouchingPointPlanePose = new HTuple();
    HTuple hv_HomMat3D1 = new HTuple(), hv_TouchingPointPlanePointsToolX = new HTuple();
    HTuple hv_TouchingPointPlanePointsToolY = new HTuple();
    HTuple hv_TouchingPointPlanePointsToolZ = new HTuple();
    HTuple hv_SqrDiff = new HTuple(), hv_PlanePointsRMS = new HTuple();
    HTuple hv_PlanePointsMaxDiff = new HTuple(), hv_PlaneInBasePose = new HTuple();
    HTuple hv_PlaneInCamPose = new HTuple();
    HTupleVector  hvec_ToolInBasePoses_COPY_INP_TMP = new HTupleVector(hvec_ToolInBasePoses);

    // Initialize local and output iconic variables 
    hv_HandEyeCalibData = new HTuple();
    //Check input.
    if ((int)((new HTuple((new HTuple((new HTuple(hv_RowsTouchingPointInPlane.TupleLength()
        )).TupleLess(4))).TupleOr(new HTuple((new HTuple(hv_ColumnsTouchingPointInPlane.TupleLength()
        )).TupleLess(4))))).TupleOr(new HTuple((new HTuple(hvec_ToolInBasePoses_COPY_INP_TMP.Length)).TupleLess(
        4)))) != 0)
    {
      throw new HalconException("Please specify at least four image coordinates and robot poses.");
    }
    if ((int)((new HTuple((new HTuple(hv_RowsTouchingPointInPlane.TupleLength())).TupleNotEqual(
        new HTuple(hv_ColumnsTouchingPointInPlane.TupleLength())))).TupleOr(new HTuple((new HTuple(hv_RowsTouchingPointInPlane.TupleLength()
        )).TupleNotEqual(new HTuple(hvec_ToolInBasePoses_COPY_INP_TMP.Length))))) != 0)
    {
      throw new HalconException("The number of image coordinates and robot poses have to be equal.");
    }
    if ((int)((new HTuple(hv_Width.TupleLessEqual(0))).TupleOr(new HTuple(hv_Height.TupleLessEqual(
        0)))) != 0)
    {
      throw new HalconException("Width or Height must be greater than 0.");
    }
    if ((int)(new HTuple(hv_DistancePlaneToCamera.TupleLessEqual(0))) != 0)
    {
      throw new HalconException("DistancePlaneToCamera must be greater than 0.");
    }
    if ((int)(new HTuple(hv_DistancePlaneToCamera.TupleLessEqual(0))) != 0)
    {
      throw new HalconException("DistanceObjectTouchingPointToPlane must be greater than 0.");
    }
    //
    //Keep track of the pose type used by the robot.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OrderOfTransform0.Dispose();hv_OrderOfRotation0.Dispose();hv_ViewOfTransform0.Dispose();
    HOperatorSet.GetPoseType(hvec_ToolInBasePoses_COPY_INP_TMP[0].T, out hv_OrderOfTransform0, 
        out hv_OrderOfRotation0, out hv_ViewOfTransform0);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hvec_ToolInBasePoses_COPY_INP_TMP[0].T, "Rp+T", 
        "gba", "point", out ExpTmpOutVar_0);
    hvec_ToolInBasePoses_COPY_INP_TMP[0].T = ExpTmpOutVar_0;
    ExpTmpOutVar_0.Dispose();
    }
    HTuple end_val20 = new HTuple(hvec_ToolInBasePoses_COPY_INP_TMP.Length)-1;
    HTuple step_val20 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val20, step_val20); hv_Index = hv_Index.TupleAdd(step_val20))
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_OrderOfTransform.Dispose();hv_OrderOfRotation.Dispose();hv_ViewOfTransform.Dispose();
      HOperatorSet.GetPoseType(hvec_ToolInBasePoses_COPY_INP_TMP[hv_Index].T, out hv_OrderOfTransform, 
          out hv_OrderOfRotation, out hv_ViewOfTransform);
      }
      if ((int)((new HTuple((new HTuple(hv_OrderOfTransform0.TupleNotEqual(hv_OrderOfTransform))).TupleOr(
          new HTuple(hv_OrderOfRotation0.TupleNotEqual(hv_OrderOfRotation))))).TupleOr(
          new HTuple(hv_ViewOfTransform0.TupleNotEqual(hv_ViewOfTransform)))) != 0)
      {
        throw new HalconException("ToolInBasePoses have different pose types.");
      }
      //Convert to default pose type.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.ConvertPoseType(hvec_ToolInBasePoses_COPY_INP_TMP[hv_Index].T, 
          "Rp+T", "gba", "point", out ExpTmpOutVar_0);
      hvec_ToolInBasePoses_COPY_INP_TMP[hv_Index].T = ExpTmpOutVar_0;
      ExpTmpOutVar_0.Dispose();
      }
    }
    //
    //Collect the robot translations.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RobotTouchingPointToToolXYZPose.Dispose();
    HOperatorSet.CreatePose(hv_RobotTouchingPointInToolCoordinates.TupleSelect(0), 
        hv_RobotTouchingPointInToolCoordinates.TupleSelect(1), hv_RobotTouchingPointInToolCoordinates.TupleSelect(
        2), 0, 0, 0, "Rp+T", "gba", "point", out hv_RobotTouchingPointToToolXYZPose);
    }
    hv_XBase.Dispose();
    hv_XBase = new HTuple();
    hv_YBase.Dispose();
    hv_YBase = new HTuple();
    hv_ZBase.Dispose();
    hv_ZBase = new HTuple();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_RowsTouchingPointInPlane.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TouchingPointInBasePose.Dispose();
      HOperatorSet.PoseCompose(hvec_ToolInBasePoses_COPY_INP_TMP[hv_Index].T, hv_RobotTouchingPointToToolXYZPose, 
          out hv_TouchingPointInBasePose);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_XBase = hv_XBase.TupleConcat(
          hv_TouchingPointInBasePose.TupleSelect(0));
      hv_XBase.Dispose();
      hv_XBase = ExpTmpLocalVar_XBase;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_YBase = hv_YBase.TupleConcat(
          hv_TouchingPointInBasePose.TupleSelect(1));
      hv_YBase.Dispose();
      hv_YBase = ExpTmpLocalVar_YBase;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ZBase = hv_ZBase.TupleConcat(
          hv_TouchingPointInBasePose.TupleSelect(2));
      hv_ZBase.Dispose();
      hv_ZBase = ExpTmpLocalVar_ZBase;
      }
      }
    }
    //
    // Use the specified robot translations to obtain the PlaneInBasePose.
    hv_OM3DPlanePoints.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(hv_XBase, hv_YBase, hv_ZBase, out hv_OM3DPlanePoints);
    hv_OM3DPlane.Dispose();
    HOperatorSet.FitPrimitivesObjectModel3d(hv_OM3DPlanePoints, "primitive_type", 
        "plane", out hv_OM3DPlane);
    hv_TouchingPointPlaneInBasePose.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_OM3DPlane, "primitive_pose", out hv_TouchingPointPlaneInBasePose);
    //
    //Obtain fictitious camera parameters.
    hv_FocusOrig.Dispose();
    hv_FocusOrig = 0.008;
    hv_DiffRow.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffRow = (hv_RowsTouchingPointInPlane.TupleSelectRange(
        0,(new HTuple(hv_RowsTouchingPointInPlane.TupleLength()))-2))-(hv_RowsTouchingPointInPlane.TupleSelectRange(
        1,(new HTuple(hv_RowsTouchingPointInPlane.TupleLength()))-1));
    }
    hv_DiffCol.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffCol = (hv_ColumnsTouchingPointInPlane.TupleSelectRange(
        0,(new HTuple(hv_ColumnsTouchingPointInPlane.TupleLength()))-2))-(hv_ColumnsTouchingPointInPlane.TupleSelectRange(
        1,(new HTuple(hv_ColumnsTouchingPointInPlane.TupleLength()))-1));
    }
    hv_DistPixel.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DistPixel = (((hv_DiffRow*hv_DiffRow)+(hv_DiffCol*hv_DiffCol))).TupleSqrt()
        ;
    }
    hv_DiffX.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffX = (hv_XBase.TupleSelectRange(
        0,(new HTuple(hv_XBase.TupleLength()))-2))-(hv_XBase.TupleSelectRange(1,(new HTuple(hv_XBase.TupleLength()
        ))-1));
    }
    hv_DiffY.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffY = (hv_YBase.TupleSelectRange(
        0,(new HTuple(hv_YBase.TupleLength()))-2))-(hv_YBase.TupleSelectRange(1,(new HTuple(hv_YBase.TupleLength()
        ))-1));
    }
    hv_DiffZ.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffZ = (hv_ZBase.TupleSelectRange(
        0,(new HTuple(hv_ZBase.TupleLength()))-2))-(hv_ZBase.TupleSelectRange(1,(new HTuple(hv_ZBase.TupleLength()
        ))-1));
    }
    hv_DistWorld.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DistWorld = ((((hv_DiffX*hv_DiffX)+(hv_DiffY*hv_DiffY))+(hv_DiffZ*hv_DiffZ))).TupleSqrt()
        ;
    }
    hv_Quotient.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Quotient = ((hv_DistWorld/hv_DistPixel)).TupleMedian()
        ;
    }
    //Camera parameter will be generated in the following form:
    //SX := Quotient * FocusOrig / DistancePlaneToCamera
    //SY := SX
    //gen_cam_par_area_scan_division (FocusOrig, 0, SX, SY, Width / 2.0, Height / 2.0, Width, Height, HandEyeCalibData)
    //
    //Use the specified image points and robot translations to obtain the BaseInCamPose.
    hv_FocusShift.Dispose();
    hv_FocusShift = new HTuple();
    hv_FocusShift[0] = 0.1;
    hv_FocusShift[1] = 0.2;
    hv_FocusShift[2] = 0.33;
    hv_FocusShift[3] = 0.5;
    hv_FocusShift[4] = 0.75;
    hv_FocusShift[5] = 1.0;
    hv_FocusShift[6] = 1.5;
    hv_FocusShift[7] = 2;
    hv_FocusShift[8] = 3;
    hv_FocusShift[9] = 3.125;
    hv_FocusShift[10] = 3.5;
    hv_FocusShift[11] = 4;
    hv_BestIndex.Dispose();
    hv_BestIndex = -1;
    //The value of focus should not have much influence when camera and plane are parallel,
    //but just in case, check different values.
    hv_ErrorBasePoseInPixel.Dispose();
    hv_ErrorBasePoseInPixel = 1e9;
    for (hv_NumFocus=0; (int)hv_NumFocus<=(int)((new HTuple(hv_FocusShift.TupleLength()
        ))-1); hv_NumFocus = (int)hv_NumFocus + 1)
    {
      hv_Focus.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Focus = hv_FocusOrig*(hv_FocusShift.TupleSelect(
          hv_NumFocus));
      }
      hv_SX.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SX = (hv_Quotient*hv_Focus)/hv_DistancePlaneToCamera;
      }
      hv_SY.Dispose();
      hv_SY = new HTuple(hv_SX);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CamParam0.Dispose();
      gen_cam_par_area_scan_division(hv_Focus, 0, hv_SX, hv_SY, hv_Width/2.0, hv_Height/2.0, 
          hv_Width, hv_Height, out hv_CamParam0);
      }
      hv_BaseInCamPose0.Dispose();hv_ErrorBasePoseInPixelTmp.Dispose();
      HOperatorSet.VectorToPose(hv_XBase, hv_YBase, hv_ZBase, hv_RowsTouchingPointInPlane, 
          hv_ColumnsTouchingPointInPlane, hv_CamParam0, "iterative", "error", out hv_BaseInCamPose0, 
          out hv_ErrorBasePoseInPixelTmp);
      if ((int)(new HTuple(hv_ErrorBasePoseInPixel.TupleGreater(hv_ErrorBasePoseInPixelTmp))) != 0)
      {
        hv_BaseInCamPose.Dispose();
        hv_BaseInCamPose = new HTuple(hv_BaseInCamPose0);
        hv_ErrorBasePoseInPixel.Dispose();
        hv_ErrorBasePoseInPixel = new HTuple(hv_ErrorBasePoseInPixelTmp);
        hv_CamParam.Dispose();
        hv_CamParam = new HTuple(hv_CamParam0);
      }
    }
    //Get the PlaneInCamPose.
    hv_TouchingPointPlaneInCamPose.Dispose();
    HOperatorSet.PoseCompose(hv_BaseInCamPose, hv_TouchingPointPlaneInBasePose, out hv_TouchingPointPlaneInCamPose);
    //
    //The z-axis of the plane should point away from the camera.
    hv_TouchingPointPlaneInCamPose0Rot.Dispose();
    hv_TouchingPointPlaneInCamPose0Rot = new HTuple(hv_TouchingPointPlaneInCamPose);
    if (hv_TouchingPointPlaneInCamPose0Rot == null)
      hv_TouchingPointPlaneInCamPose0Rot = new HTuple();
    hv_TouchingPointPlaneInCamPose0Rot[HTuple.TupleGenSequence(0,2,1)] = ((new HTuple(0)).TupleConcat(
        0)).TupleConcat(0);
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_TouchingPointPlaneInCamPose0Rot, out hv_HomMat3D);
    hv_Qx.Dispose();hv_Qy.Dispose();hv_CosAngleBetweenZAxis.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, 0, 0, 1, out hv_Qx, out hv_Qy, out hv_CosAngleBetweenZAxis);
    if ((int)(new HTuple(hv_CosAngleBetweenZAxis.TupleLess(0))) != 0)
    {
      hv_SwitchZDirection.Dispose();
      HOperatorSet.CreatePose(0, 0, 0, 180, 0, 0, "Rp+T", "gba", "point", out hv_SwitchZDirection);
      hv_TouchingPointPlaneInCamPose1.Dispose();
      HOperatorSet.PoseCompose(hv_TouchingPointPlaneInCamPose, hv_SwitchZDirection, 
          out hv_TouchingPointPlaneInCamPose1);
      hv_TouchingPointPlaneInCamPose.Dispose();
      hv_TouchingPointPlaneInCamPose = new HTuple(hv_TouchingPointPlaneInCamPose1);
      hv_CamInBasePose.Dispose();
      HOperatorSet.PoseInvert(hv_BaseInCamPose, out hv_CamInBasePose);
      hv_TouchingPointPlaneInBasePose.Dispose();
      HOperatorSet.PoseCompose(hv_CamInBasePose, hv_TouchingPointPlaneInCamPose, 
          out hv_TouchingPointPlaneInBasePose);
    }
    //
    //Get the difference of the points in the plane as seen by the camera
    //to the points in the plane as approached by the robot.
    hv_TouchingPointPlanePointsCamX.Dispose();hv_TouchingPointPlanePointsCamY.Dispose();
    HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_TouchingPointPlaneInCamPose, 
        hv_RowsTouchingPointInPlane, hv_ColumnsTouchingPointInPlane, "m", out hv_TouchingPointPlanePointsCamX, 
        out hv_TouchingPointPlanePointsCamY);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TouchingPointPlanePointsCamZ.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_TouchingPointPlanePointsCamY.TupleLength()
        ), 0.0, out hv_TouchingPointPlanePointsCamZ);
    }
    hv_BaseInTouchingPointPlanePose.Dispose();
    HOperatorSet.PoseInvert(hv_TouchingPointPlaneInBasePose, out hv_BaseInTouchingPointPlanePose);
    hv_HomMat3D1.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_BaseInTouchingPointPlanePose, out hv_HomMat3D1);
    hv_TouchingPointPlanePointsToolX.Dispose();hv_TouchingPointPlanePointsToolY.Dispose();hv_TouchingPointPlanePointsToolZ.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D1, hv_XBase, hv_YBase, hv_ZBase, out hv_TouchingPointPlanePointsToolX, 
        out hv_TouchingPointPlanePointsToolY, out hv_TouchingPointPlanePointsToolZ);
    hv_DiffX.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffX = hv_TouchingPointPlanePointsCamX-hv_TouchingPointPlanePointsToolX;
    }
    hv_DiffY.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffY = hv_TouchingPointPlanePointsCamY-hv_TouchingPointPlanePointsToolY;
    }
    hv_DiffZ.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffZ = hv_TouchingPointPlanePointsCamZ-hv_TouchingPointPlanePointsToolZ;
    }
    hv_SqrDiff.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SqrDiff = ((hv_DiffX*hv_DiffX)+(hv_DiffY*hv_DiffY))+(hv_DiffZ*hv_DiffZ);
    }
    hv_PlanePointsRMS.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PlanePointsRMS = (((hv_SqrDiff.TupleSum()
        )/(new HTuple(hv_DiffX.TupleLength())))).TupleSqrt();
    }
    hv_PlanePointsMaxDiff.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PlanePointsMaxDiff = ((hv_SqrDiff.TupleSqrt()
        )).TupleMax();
    }
    //
    hv_PlaneInBasePose.Dispose();
    HOperatorSet.SetOriginPose(hv_TouchingPointPlaneInBasePose, 0, 0, hv_DistanceObjectTouchingPointToPlane, 
        out hv_PlaneInBasePose);
    hv_PlaneInCamPose.Dispose();
    HOperatorSet.SetOriginPose(hv_TouchingPointPlaneInCamPose, 0, 0, hv_DistanceObjectTouchingPointToPlane, 
        out hv_PlaneInCamPose);
    //
    //Convert to output pose type.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_BaseInCamPose, hv_OrderOfTransform0, hv_OrderOfRotation0, 
        hv_ViewOfTransform0, out ExpTmpOutVar_0);
    hv_BaseInCamPose.Dispose();
    hv_BaseInCamPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInBasePose, hv_OrderOfTransform0, hv_OrderOfRotation0, 
        hv_ViewOfTransform0, out ExpTmpOutVar_0);
    hv_PlaneInBasePose.Dispose();
    hv_PlaneInBasePose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInCamPose, hv_OrderOfTransform0, hv_OrderOfRotation0, 
        hv_ViewOfTransform0, out ExpTmpOutVar_0);
    hv_PlaneInCamPose.Dispose();
    hv_PlaneInCamPose = ExpTmpOutVar_0;
    }
    //
    //Create output dict.
    hv_HandEyeCalibData.Dispose();
    HOperatorSet.CreateDict(out hv_HandEyeCalibData);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "CamParam", hv_CamParam);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "BaseInCamPose", hv_BaseInCamPose);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "PlaneInBasePose", hv_PlaneInBasePose);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "PlaneInCamPose0", hv_PlaneInCamPose);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "PlanePointsRMS", hv_PlanePointsRMS);
    HOperatorSet.SetDictTuple(hv_HandEyeCalibData, "PlanePointsMaxDiff", hv_PlanePointsMaxDiff);

    hv_OrderOfTransform0.Dispose();
    hv_OrderOfRotation0.Dispose();
    hv_ViewOfTransform0.Dispose();
    hv_Index.Dispose();
    hv_OrderOfTransform.Dispose();
    hv_OrderOfRotation.Dispose();
    hv_ViewOfTransform.Dispose();
    hv_RobotTouchingPointToToolXYZPose.Dispose();
    hv_XBase.Dispose();
    hv_YBase.Dispose();
    hv_ZBase.Dispose();
    hv_TouchingPointInBasePose.Dispose();
    hv_OM3DPlanePoints.Dispose();
    hv_OM3DPlane.Dispose();
    hv_TouchingPointPlaneInBasePose.Dispose();
    hv_FocusOrig.Dispose();
    hv_DiffRow.Dispose();
    hv_DiffCol.Dispose();
    hv_DistPixel.Dispose();
    hv_DiffX.Dispose();
    hv_DiffY.Dispose();
    hv_DiffZ.Dispose();
    hv_DistWorld.Dispose();
    hv_Quotient.Dispose();
    hv_SX.Dispose();
    hv_SY.Dispose();
    hv_FocusShift.Dispose();
    hv_BestIndex.Dispose();
    hv_ErrorBasePoseInPixel.Dispose();
    hv_NumFocus.Dispose();
    hv_Focus.Dispose();
    hv_CamParam0.Dispose();
    hv_BaseInCamPose0.Dispose();
    hv_ErrorBasePoseInPixelTmp.Dispose();
    hv_BaseInCamPose.Dispose();
    hv_CamParam.Dispose();
    hv_TouchingPointPlaneInCamPose.Dispose();
    hv_TouchingPointPlaneInCamPose0Rot.Dispose();
    hv_HomMat3D.Dispose();
    hv_Qx.Dispose();
    hv_Qy.Dispose();
    hv_CosAngleBetweenZAxis.Dispose();
    hv_SwitchZDirection.Dispose();
    hv_TouchingPointPlaneInCamPose1.Dispose();
    hv_CamInBasePose.Dispose();
    hv_TouchingPointPlanePointsCamX.Dispose();
    hv_TouchingPointPlanePointsCamY.Dispose();
    hv_TouchingPointPlanePointsCamZ.Dispose();
    hv_BaseInTouchingPointPlanePose.Dispose();
    hv_HomMat3D1.Dispose();
    hv_TouchingPointPlanePointsToolX.Dispose();
    hv_TouchingPointPlanePointsToolY.Dispose();
    hv_TouchingPointPlanePointsToolZ.Dispose();
    hv_SqrDiff.Dispose();
    hv_PlanePointsRMS.Dispose();
    hv_PlanePointsMaxDiff.Dispose();
    hv_PlaneInBasePose.Dispose();
    hv_PlaneInCamPose.Dispose();

    return;
  }

  // Chapter: Calibration / Hand-Eye
  // Short Description: Calibrate the X, Y, Z coordinates of a touching point of a robot. 
  public void calibrate_robot_touching_point (HTuple hv_DataDir, out HTuple hv_RobotTouchingPointInToolCoordinates)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WindowHandle = new HTuple(), hv_WindowHandleGraphics = new HTuple();
    HTuple hv_Index = new HTuple(), hv_ToolInBasePoseTouchingPoint = new HTuple();

    HTupleVector hvec_ToolInBasePosesTouchingPoint = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_RobotTouchingPointInToolCoordinates = new HTuple();
    //
    //Open a new window.
    hv_WindowHandle.Dispose();hv_WindowHandleGraphics.Dispose();
    open_new_window(out hv_WindowHandle, out hv_WindowHandleGraphics);
    //Display introduction.
    dev_disp_introduction(hv_WindowHandle, hv_WindowHandleGraphics);
    // stop(...); only in hdevelop
    //
    //Read three ToolInBasesPoses which are used
    //to calibrate the RobotTouchingPointInToolCoordinates.
    for (hv_Index=1; (int)hv_Index<=3; hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ToolInBasePoseTouchingPoint.Dispose();
      HOperatorSet.ReadPose(((hv_DataDir+"tool_in_base_pose_touching_point_0")+hv_Index)+".dat", 
          out hv_ToolInBasePoseTouchingPoint);
      }
      dev_disp_approach_pose_touching_point_instructions(hv_WindowHandle, hv_WindowHandleGraphics, 
          hv_Index);
      // stop(...); only in hdevelop
      //Collect poses in vector.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_ToolInBasePosesTouchingPoint[hv_Index-1] = dh.Add(new HTupleVector(hv_ToolInBasePoseTouchingPoint));
      }
    }
    HDevWindowStack.SetActive(hv_WindowHandleGraphics);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.CloseWindow(HDevWindowStack.Pop());
    }
    //
    //Calculate the coordinates of the touching point
    //of the robot with respect to the robot's tool.
    hv_RobotTouchingPointInToolCoordinates.Dispose();
    get_robot_touching_point_in_tool_coordinates(hvec_ToolInBasePosesTouchingPoint, 
        out hv_RobotTouchingPointInToolCoordinates);
    //
    //Visualize results.
    visualize_calibrated_touching_point(hv_RobotTouchingPointInToolCoordinates, hvec_ToolInBasePosesTouchingPoint, 
        hv_WindowHandle);

    hv_WindowHandle.Dispose();
    hv_WindowHandleGraphics.Dispose();
    hv_Index.Dispose();
    hv_ToolInBasePoseTouchingPoint.Dispose();
    hvec_ToolInBasePosesTouchingPoint.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Checks the contents of the parameter dictionary DLPreprocessParam. 
  public void check_dl_preprocess_param (HTuple hv_DLPreprocessParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DLModelType = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_ParamNamesGeneral = new HTuple(), hv_ParamNamesSegmentation = new HTuple();
    HTuple hv_ParamNamesAll = new HTuple(), hv_ParamNames = new HTuple();
    HTuple hv_KeysExists = new HTuple(), hv_I = new HTuple();
    HTuple hv_Exists = new HTuple(), hv_InputKeys = new HTuple();
    HTuple hv_Key = new HTuple(), hv_Value = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_ValidValues = new HTuple();
    HTuple hv_ValidTypes = new HTuple(), hv_V = new HTuple();
    HTuple hv_T = new HTuple(), hv_IsInt = new HTuple(), hv_ValidTypesListing = new HTuple();
    HTuple hv_Index = new HTuple(), hv_ValidValueListing = new HTuple();
    HTuple hv_SetBackgroundID = new HTuple(), hv_ClassIDsBackground = new HTuple();
    HTuple hv_Intersection = new HTuple(), hv_IgnoreClassIDs = new HTuple();
    HTuple hv_KnownClasses = new HTuple(), hv_IgnoreClassID = new HTuple();
    HTuple hv_IndexParam = new HTuple();
    // Initialize local and output iconic variables 
    //
    //This procedure checks a dictionary with parameters for DL preprocessing.
    //
    try
    {
      hv_DLModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_DLModelType);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      throw new HalconException(new HTuple(new HTuple("DLPreprocessParam needs the parameter: '")+"model_type")+"'");
    }
    //
    //Parameter names that are required.
    //General parameters.
    hv_ParamNamesGeneral.Dispose();
    hv_ParamNamesGeneral = new HTuple();
    hv_ParamNamesGeneral[0] = "model_type";
    hv_ParamNamesGeneral[1] = "image_width";
    hv_ParamNamesGeneral[2] = "image_height";
    hv_ParamNamesGeneral[3] = "image_num_channels";
    hv_ParamNamesGeneral[4] = "image_range_min";
    hv_ParamNamesGeneral[5] = "image_range_max";
    hv_ParamNamesGeneral[6] = "contrast_normalization";
    hv_ParamNamesGeneral[7] = "domain_handling";
    //Segmentation specific parameters.
    hv_ParamNamesSegmentation.Dispose();
    hv_ParamNamesSegmentation = new HTuple();
    hv_ParamNamesSegmentation[0] = "ignore_class_ids";
    hv_ParamNamesSegmentation[1] = "set_background_id";
    hv_ParamNamesSegmentation[2] = "class_ids_background";
    hv_ParamNamesAll.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ParamNamesAll = new HTuple();
    hv_ParamNamesAll = hv_ParamNamesAll.TupleConcat(hv_ParamNamesGeneral, hv_ParamNamesSegmentation);
    }
    if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
    {
      hv_ParamNames.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ParamNames = new HTuple();
      hv_ParamNames = hv_ParamNames.TupleConcat(hv_ParamNamesGeneral, hv_ParamNamesSegmentation);
      }
    }
    else
    {
      hv_ParamNames.Dispose();
      hv_ParamNames = new HTuple(hv_ParamNamesGeneral);
    }
    //
    //Check that all necessary parameters are included.
    hv_KeysExists.Dispose();
    HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNames, 
        out hv_KeysExists);
    if ((int)(new HTuple(((((hv_KeysExists.TupleEqualElem(0))).TupleSum())).TupleGreater(
        0))) != 0)
    {
      for (hv_I=0; (int)hv_I<=(int)(new HTuple(hv_KeysExists.TupleLength())); hv_I = (int)hv_I + 1)
      {
        hv_Exists.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Exists = hv_KeysExists.TupleSelect(
            hv_I);
        }
        if ((int)(hv_Exists.TupleNot()) != 0)
        {
          throw new HalconException(("DLPreprocessParam needs the parameter: '"+(hv_ParamNames.TupleSelect(
              hv_I)))+"'");
        }
      }
    }
    //
    //Check the keys provided.
    hv_InputKeys.Dispose();
    HOperatorSet.GetDictParam(hv_DLPreprocessParam, "keys", new HTuple(), out hv_InputKeys);
    for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_InputKeys.TupleLength()))-1); hv_I = (int)hv_I + 1)
    {
      hv_Key.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Key = hv_InputKeys.TupleSelect(
          hv_I);
      }
      hv_Value.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_Key, out hv_Value);
      //Check that the Key is known.
      hv_Indices.Dispose();
      HOperatorSet.TupleFind(hv_ParamNamesAll, hv_Key, out hv_Indices);
      if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
      {
        throw new HalconException(("The key '"+(hv_InputKeys.TupleSelect(
            hv_I)))+"' in DLPreprocessParam is unknown.");

        hv_DLModelType.Dispose();
        hv_Exception.Dispose();
        hv_ParamNamesGeneral.Dispose();
        hv_ParamNamesSegmentation.Dispose();
        hv_ParamNamesAll.Dispose();
        hv_ParamNames.Dispose();
        hv_KeysExists.Dispose();
        hv_I.Dispose();
        hv_Exists.Dispose();
        hv_InputKeys.Dispose();
        hv_Key.Dispose();
        hv_Value.Dispose();
        hv_Indices.Dispose();
        hv_ValidValues.Dispose();
        hv_ValidTypes.Dispose();
        hv_V.Dispose();
        hv_T.Dispose();
        hv_IsInt.Dispose();
        hv_ValidTypesListing.Dispose();
        hv_Index.Dispose();
        hv_ValidValueListing.Dispose();
        hv_SetBackgroundID.Dispose();
        hv_ClassIDsBackground.Dispose();
        hv_Intersection.Dispose();
        hv_IgnoreClassIDs.Dispose();
        hv_KnownClasses.Dispose();
        hv_IgnoreClassID.Dispose();
        hv_IndexParam.Dispose();

        return;
      }
      //Set expected values and types.
      hv_ValidValues.Dispose();
      hv_ValidValues = new HTuple();
      hv_ValidTypes.Dispose();
      hv_ValidTypes = new HTuple();
      if ((int)(new HTuple(hv_Key.TupleEqual("contrast_normalization"))) != 0)
      {
        hv_ValidValues.Dispose();
        hv_ValidValues = new HTuple();
        hv_ValidValues[0] = "true";
        hv_ValidValues[1] = "false";
      }
      else if ((int)(new HTuple(hv_Key.TupleEqual("domain_handling"))) != 0)
      {
        hv_ValidValues.Dispose();
        hv_ValidValues = new HTuple();
        hv_ValidValues[0] = "full_domain";
        hv_ValidValues[1] = "crop_domain";
      }
      else if ((int)(new HTuple(hv_Key.TupleEqual("model_type"))) != 0)
      {
        hv_ValidValues.Dispose();
        hv_ValidValues = new HTuple();
        hv_ValidValues[0] = "detection";
        hv_ValidValues[1] = "segmentation";
      }
      else if ((int)(new HTuple(hv_Key.TupleEqual("set_background_id"))) != 0)
      {
        hv_ValidTypes.Dispose();
        hv_ValidTypes = "int";
      }
      else if ((int)(new HTuple(hv_Key.TupleEqual("class_ids_background"))) != 0)
      {
        hv_ValidTypes.Dispose();
        hv_ValidTypes = "int";
      }
      //Check that type is valid.
      if ((int)(new HTuple((new HTuple(hv_ValidTypes.TupleLength())).TupleGreater(
          0))) != 0)
      {
        for (hv_V=0; (int)hv_V<=(int)((new HTuple(hv_ValidTypes.TupleLength()))-1); hv_V = (int)hv_V + 1)
        {
          hv_T.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_T = hv_ValidTypes.TupleSelect(
              hv_V);
          }
          if ((int)(new HTuple(hv_T.TupleEqual("int"))) != 0)
          {
            hv_IsInt.Dispose();
            HOperatorSet.TupleIsInt(hv_Value, out hv_IsInt);
            if ((int)(hv_IsInt.TupleNot()) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_ValidTypes = ("'"+hv_ValidTypes)+"'";
              hv_ValidTypes.Dispose();
              hv_ValidTypes = ExpTmpLocalVar_ValidTypes;
              }
              }
              if ((int)(new HTuple((new HTuple(hv_ValidTypes.TupleLength())).TupleLess(
                  2))) != 0)
              {
                hv_ValidTypesListing.Dispose();
                hv_ValidTypesListing = new HTuple(hv_ValidTypes);
              }
              else
              {
                hv_ValidTypesListing.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_ValidTypesListing = ((((hv_ValidTypes.TupleSelectRange(
                    0,(new HTuple(0)).TupleMax2((new HTuple(hv_ValidTypes.TupleLength()
                    ))-2)))+new HTuple(", "))+(hv_ValidTypes.TupleSelect((new HTuple(hv_ValidTypes.TupleLength()
                    ))-1)))).TupleSum();
                }
              }
              throw new HalconException(((((("The value given in the key '"+hv_Key)+"' of DLPreprocessParam is invalid. Valid types are: ")+hv_ValidTypesListing)+". The given value was '")+hv_Value)+"'.");

              hv_DLModelType.Dispose();
              hv_Exception.Dispose();
              hv_ParamNamesGeneral.Dispose();
              hv_ParamNamesSegmentation.Dispose();
              hv_ParamNamesAll.Dispose();
              hv_ParamNames.Dispose();
              hv_KeysExists.Dispose();
              hv_I.Dispose();
              hv_Exists.Dispose();
              hv_InputKeys.Dispose();
              hv_Key.Dispose();
              hv_Value.Dispose();
              hv_Indices.Dispose();
              hv_ValidValues.Dispose();
              hv_ValidTypes.Dispose();
              hv_V.Dispose();
              hv_T.Dispose();
              hv_IsInt.Dispose();
              hv_ValidTypesListing.Dispose();
              hv_Index.Dispose();
              hv_ValidValueListing.Dispose();
              hv_SetBackgroundID.Dispose();
              hv_ClassIDsBackground.Dispose();
              hv_Intersection.Dispose();
              hv_IgnoreClassIDs.Dispose();
              hv_KnownClasses.Dispose();
              hv_IgnoreClassID.Dispose();
              hv_IndexParam.Dispose();

              return;
            }
          }
          else
          {
            throw new HalconException("Internal error. Unknown valid type.");
          }
        }
      }
      //Check that value is valid.
      if ((int)(new HTuple((new HTuple(hv_ValidValues.TupleLength())).TupleGreater(
          0))) != 0)
      {
        hv_Index.Dispose();
        HOperatorSet.TupleFindFirst(hv_ValidValues, hv_Value, out hv_Index);
        if ((int)(new HTuple(hv_Index.TupleEqual(-1))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ValidValues = ("'"+hv_ValidValues)+"'";
          hv_ValidValues.Dispose();
          hv_ValidValues = ExpTmpLocalVar_ValidValues;
          }
          }
          if ((int)(new HTuple((new HTuple(hv_ValidValues.TupleLength())).TupleLess(
              2))) != 0)
          {
            hv_ValidValueListing.Dispose();
            hv_ValidValueListing = new HTuple(hv_ValidValues);
          }
          else
          {
            hv_ValidValueListing.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ValidValueListing = ((((hv_ValidValues.TupleSelectRange(
                0,(new HTuple(0)).TupleMax2((new HTuple(hv_ValidValues.TupleLength()
                ))-2)))+new HTuple(", "))+(hv_ValidValues.TupleSelect((new HTuple(hv_ValidValues.TupleLength()
                ))-1)))).TupleSum();
            }
          }
          throw new HalconException(((((("The value given in the key '"+hv_Key)+"' of DLPreprocessParam is invalid. Valid values are: ")+hv_ValidValueListing)+". The given value was '")+hv_Value)+"'.");
        }
      }
    }
    //
    //Check segmentation specific parameters.
    if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
    {
      //Check 'set_background_id'.
      hv_SetBackgroundID.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "set_background_id", out hv_SetBackgroundID);
      if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleGreater(
          1))) != 0)
      {
        throw new HalconException("Only one class_id as 'set_background_id' allowed.");
      }
      //Check 'class_ids_background'.
      hv_ClassIDsBackground.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_background", out hv_ClassIDsBackground);
      if ((int)((new HTuple((new HTuple((new HTuple(hv_SetBackgroundID.TupleLength()
          )).TupleGreater(0))).TupleAnd((new HTuple((new HTuple(hv_ClassIDsBackground.TupleLength()
          )).TupleGreater(0))).TupleNot()))).TupleOr((new HTuple((new HTuple(hv_ClassIDsBackground.TupleLength()
          )).TupleGreater(0))).TupleAnd((new HTuple((new HTuple(hv_SetBackgroundID.TupleLength()
          )).TupleGreater(0))).TupleNot()))) != 0)
      {
        throw new HalconException("Both keys 'set_background_id' and 'class_ids_background' are required.");
      }
      //Check that 'class_ids_background' and 'set_background_id' are disjoint.
      if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleGreater(
          0))) != 0)
      {
        hv_Intersection.Dispose();
        HOperatorSet.TupleIntersection(hv_SetBackgroundID, hv_ClassIDsBackground, 
            out hv_Intersection);
        if ((int)(new HTuple(hv_Intersection.TupleLength())) != 0)
        {
          throw new HalconException("Class IDs in 'set_background_id' and 'class_ids_background' need to be disjoint.");
        }
      }
      //Check 'ignore_class_ids'.
      hv_IgnoreClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
      hv_KnownClasses.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_KnownClasses = new HTuple();
      hv_KnownClasses = hv_KnownClasses.TupleConcat(hv_SetBackgroundID, hv_ClassIDsBackground);
      }
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_IgnoreClassIDs.TupleLength()))-1); hv_I = (int)hv_I + 1)
      {
        hv_IgnoreClassID.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_IgnoreClassID = hv_IgnoreClassIDs.TupleSelect(
            hv_I);
        }
        hv_Index.Dispose();
        HOperatorSet.TupleFindFirst(hv_KnownClasses, hv_IgnoreClassID, out hv_Index);
        if ((int)((new HTuple((new HTuple(hv_Index.TupleLength())).TupleGreater(0))).TupleAnd(
            new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
        {
          throw new HalconException("The given 'ignore_class_ids' must not be included in the 'class_ids_background' or 'set_background_id'.");
        }
      }
    }
    else if ((int)(new HTuple(hv_DLModelType.TupleEqual("detection"))) != 0)
    {
      //Check if segmentation specific parameters are set.
      hv_KeysExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesSegmentation, 
          out hv_KeysExists);
      //If they are present, check that they are [].
      for (hv_IndexParam=0; (int)hv_IndexParam<=(int)((new HTuple(hv_ParamNamesSegmentation.TupleLength()
          ))-1); hv_IndexParam = (int)hv_IndexParam + 1)
      {
        if ((int)(hv_KeysExists.TupleSelect(hv_IndexParam)) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Value.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesSegmentation.TupleSelect(
              hv_IndexParam), out hv_Value);
          }
          if ((int)(new HTuple(hv_Value.TupleNotEqual(new HTuple()))) != 0)
          {
            throw new HalconException(((("The preprocessing parameter '"+(hv_ParamNamesSegmentation.TupleSelect(
                hv_IndexParam)))+"' was set to ")+hv_Value)+new HTuple(" but for detection it should be set to [], as it is not used for this method."));
          }
        }
      }
    }


    hv_DLModelType.Dispose();
    hv_Exception.Dispose();
    hv_ParamNamesGeneral.Dispose();
    hv_ParamNamesSegmentation.Dispose();
    hv_ParamNamesAll.Dispose();
    hv_ParamNames.Dispose();
    hv_KeysExists.Dispose();
    hv_I.Dispose();
    hv_Exists.Dispose();
    hv_InputKeys.Dispose();
    hv_Key.Dispose();
    hv_Value.Dispose();
    hv_Indices.Dispose();
    hv_ValidValues.Dispose();
    hv_ValidTypes.Dispose();
    hv_V.Dispose();
    hv_T.Dispose();
    hv_IsInt.Dispose();
    hv_ValidTypesListing.Dispose();
    hv_Index.Dispose();
    hv_ValidValueListing.Dispose();
    hv_SetBackgroundID.Dispose();
    hv_ClassIDsBackground.Dispose();
    hv_Intersection.Dispose();
    hv_IgnoreClassIDs.Dispose();
    hv_KnownClasses.Dispose();
    hv_IgnoreClassID.Dispose();
    hv_IndexParam.Dispose();

    return;
  }

  public void check_find_surface_model_params (HTuple hv_WindowHandle, HTuple hv_SurfaceModel, 
      HTuple hv_ObjectModel3DScene, HTuple hv_GenParamNames, HTuple hv_GenParamValues)
  {



    // Local iconic variables 

    HObject ho_X=null, ho_Y=null, ho_Z=null;

    // Local control variables 

    HTuple hv_DiameterModel = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_NumScenePoints = new HTuple(), hv_HasTriangles = new HTuple();
    HTuple hv_HasPolygons = new HTuple(), hv_HasMapping = new HTuple();
    HTuple hv_HasPointNormals = new HTuple(), hv_NumPointsScene = new HTuple();
    HTuple hv_PX = new HTuple(), hv_PY = new HTuple(), hv_PZ = new HTuple();
    HTuple hv_BBox = new HTuple(), hv_DiameterScene = new HTuple();
    HTuple hv_CenterScene = new HTuple(), hv_EdgesTrained = new HTuple();
    HTuple hv_CenterModel = new HTuple(), hv_HasCamPar = new HTuple();
    HTuple hv_CamPar = new HTuple(), hv_SizesOK = new HTuple();
    HTuple hv_IsNaN = new HTuple(), hv_LargeNum = new HTuple();
    HTuple hv_Inf = new HTuple(), hv_IsInf = new HTuple();
    HTuple hv_DistThreshold = new HTuple(), hv_NumNeighbors = new HTuple();
    HTuple hv_MaxNumNeighbors = new HTuple(), hv_Pos = new HTuple();
    HTuple hv_MedianDensity = new HTuple(), hv_NormalsGood = new HTuple();
    HTuple hv_MLSNormals = new HTuple(), hv_NormalPos = new HTuple();
    HTuple hv_CheckNormals = new HTuple(), hv_NX = new HTuple();
    HTuple hv_NY = new HTuple(), hv_NZ = new HTuple(), hv_Length = new HTuple();
    HTuple hv_LengthOne = new HTuple(), hv_LengthNotOne = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Cols = new HTuple();
    HTuple hv_MappingAsString = new HTuple(), hv_CenterFromOrigin = new HTuple();
    HTuple hv_CenterToDiameter = new HTuple(), hv_NumSparsePoints = new HTuple();
    HTuple hv_MedianDirectionX = new HTuple(), hv_MedianDirectionXNorm = new HTuple();
    HTuple hv_MedianDirectionY = new HTuple(), hv_MedianDirectionYNorm = new HTuple();
    HTuple hv_ErrorX = new HTuple(), hv_ErrorY = new HTuple();
    HTuple hv_DistanceOriginRel = new HTuple(), hv_OM3D3DEdges = new HTuple();
    HTuple hv_ViewpointString = new HTuple(), hv_Viewpoint = new HTuple();
    HTuple hv_ViewpointToCenter = new HTuple(), hv_ZSigmaAbs = new HTuple();
    HTuple hv_ZSigmaRel = new HTuple(), hv_ZSigmaPct = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_X);
    HOperatorSet.GenEmptyObj(out ho_Y);
    HOperatorSet.GenEmptyObj(out ho_Z);
    write_note(hv_WindowHandle, "none", "Checking parameters for find_surface_model[_image]...");
    HOperatorSet.NewLine(hv_WindowHandle);

    //*****************************************************************
    //Basic Parameter Checks
    //*****************************************************************
    if ((int)((new HTuple((new HTuple(hv_SurfaceModel.TupleLength())).TupleNotEqual(
        1))).TupleOr(new HTuple((new HTuple(hv_ObjectModel3DScene.TupleLength())).TupleNotEqual(
        1)))) != 0)
    {
      write_note(hv_WindowHandle, "error", "Invalid number of surface model or scenes");
    }
    else
    {
      try
      {
        hv_DiameterModel.Dispose();
        HOperatorSet.GetSurfaceModelParam(hv_SurfaceModel, "diameter", out hv_DiameterModel);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        write_note(hv_WindowHandle, "error", "Invalid surface model (nor a valid surface model handle)");
      }
      try
      {
        hv_NumScenePoints.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "num_points", 
            out hv_NumScenePoints);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        write_note(hv_WindowHandle, "error", "Invalid scene (not a valid 3D object model handle)");
      }
      write_note(hv_WindowHandle, "ok", "Semantic types of parameters are OK");
    }

    if ((int)(new HTuple(hv_NumScenePoints.TupleLess(20))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      write_note(hv_WindowHandle, "warning", (("The scene contains only "+hv_NumScenePoints)+" point(s). ")+"Some tests might be disabled.");
      }
    }
    else
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      write_note(hv_WindowHandle, "ok", ("Number of scene points OK (Total number: "+hv_NumScenePoints)+")");
      }
    }


    hv_HasTriangles.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "has_triangles", out hv_HasTriangles);
    hv_HasPolygons.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "has_polygons", out hv_HasPolygons);
    hv_HasMapping.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "has_xyz_mapping", 
        out hv_HasMapping);
    hv_HasPointNormals.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "has_point_normals", 
        out hv_HasPointNormals);
    hv_NumPointsScene.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "num_points", out hv_NumPointsScene);
    try
    {
      hv_PX.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_x", 
          out hv_PX);
      hv_PY.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_y", 
          out hv_PY);
      hv_PZ.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_z", 
          out hv_PZ);
      hv_BBox.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "bounding_box1", 
          out hv_BBox);
      hv_DiameterScene.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "diameter", out hv_DiameterScene);
      hv_CenterScene.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "center", out hv_CenterScene);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      //No points
      hv_PX.Dispose();
      hv_PX = new HTuple();
      hv_PY.Dispose();
      hv_PY = new HTuple();
      hv_PZ.Dispose();
      hv_PZ = new HTuple();
      hv_BBox.Dispose();
      hv_BBox = new HTuple();
      hv_BBox[0] = 0;
      hv_BBox[1] = 0;
      hv_BBox[2] = 0;
      hv_BBox[3] = 0;
      hv_BBox[4] = 0;
      hv_BBox[5] = 0;
      hv_DiameterScene.Dispose();
      hv_DiameterScene = 0;
      hv_CenterScene.Dispose();
      hv_CenterScene = new HTuple();
      hv_CenterScene[0] = 0;
      hv_CenterScene[1] = 0;
      hv_CenterScene[2] = 0;
    }

    hv_EdgesTrained.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModel, "3d_edges_trained", out hv_EdgesTrained);
    hv_CenterModel.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModel, "center", out hv_CenterModel);

    hv_HasCamPar.Dispose();
    hv_HasCamPar = 0;
    try
    {
      hv_CamPar.Dispose();
      HOperatorSet.GetSurfaceModelParam(hv_SurfaceModel, "camera_parameter", out hv_CamPar);
      hv_HasCamPar.Dispose();
      hv_HasCamPar = 1;
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
    }

    if ((int)(hv_HasCamPar) != 0)
    {
      write_note(hv_WindowHandle, "warning", new HTuple("find_surface_model_images was used. Note that the parameters for image-based refinement (camera parameters, camera pose) are not checked by this version of the procedure."));
    }


    //*****************************************************************
    //Diameters
    //*****************************************************************
    hv_SizesOK.Dispose();
    hv_SizesOK = 1;
    hv_DiameterModel.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModel, "diameter", out hv_DiameterModel);

    if ((int)(new HTuple(hv_DiameterScene.TupleLess(0.3*hv_DiameterModel))) != 0)
    {
      write_note(hv_WindowHandle, "warning", "The diameter of the scene is very small (<30 % of model diameter)");
      hv_SizesOK.Dispose();
      hv_SizesOK = 0;
    }
    if ((int)(new HTuple(((hv_DiameterModel*30)).TupleLess(hv_DiameterScene))) != 0)
    {
      write_note(hv_WindowHandle, "warning", "The diameter of the scene is very large (more than 30 times the model diameter)");
      hv_SizesOK.Dispose();
      hv_SizesOK = 0;
    }
    if ((int)(hv_SizesOK) != 0)
    {
      write_note(hv_WindowHandle, "ok", "Scene and model diameters seem to match");
    }


    //*****************************************************************
    //Check for NaN, INF in the 3D data
    //*****************************************************************
    if ((int)(new HTuple(hv_NumScenePoints.TupleGreater(0))) != 0)
    {
      //NaNs are the only "numbers" that are not equal to themself
      hv_IsNaN.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IsNaN = (new HTuple(((hv_PX.TupleNotEqualElem(
          hv_PX))).TupleOr(hv_PY.TupleNotEqualElem(hv_PY)))).TupleOr(hv_PZ.TupleNotEqualElem(
          hv_PZ));
      }
      //Inf is created by multiplying a large number a few times.
      //We cannot directly create it (with, for example, 1e500), since that
      //does not work in all language exports.
      hv_LargeNum.Dispose();
      hv_LargeNum = 1e50;
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleMult(hv_LargeNum, hv_LargeNum, out ExpTmpOutVar_0);
      hv_LargeNum.Dispose();
      hv_LargeNum = ExpTmpOutVar_0;
      }
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleMult(hv_LargeNum, hv_LargeNum, out ExpTmpOutVar_0);
      hv_LargeNum.Dispose();
      hv_LargeNum = ExpTmpOutVar_0;
      }
      hv_Inf.Dispose();
      HOperatorSet.TupleMult(hv_LargeNum, hv_LargeNum, out hv_Inf);
      hv_IsInf.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IsInf = (new HTuple(((((hv_PX.TupleFabs()
          )).TupleGreaterEqualElem(hv_Inf))).TupleOr(((hv_PY.TupleFabs())).TupleGreaterEqualElem(
          hv_Inf)))).TupleOr(((hv_PZ.TupleFabs())).TupleGreaterEqualElem(hv_Inf));
      }
      if ((int)(new HTuple((new HTuple((new HTuple(hv_IsNaN.TupleOr(hv_IsInf))).TupleSum()
          )).TupleGreater(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "warning", new HTuple(new HTuple("The scene contains ")+((new HTuple(hv_IsNaN.TupleOr(
            hv_IsInf))).TupleSum()))+" point(s) with INF or NaN coordinates");
        }
      }
      else
      {
        write_note(hv_WindowHandle, "ok", "No INF or NaN in data");
      }
    }


    //*****************************************************************
    //Check for other multiple points in the data
    //*****************************************************************
    hv_DistThreshold.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DistThreshold = hv_DiameterModel*1e-7;
    }
    if ((int)(new HTuple(hv_NumScenePoints.TupleGreater(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumNeighbors.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "num_neighbors_fast "+hv_DistThreshold, 
          out hv_NumNeighbors);
      }
      hv_MaxNumNeighbors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxNumNeighbors = hv_NumNeighbors.TupleMax()
          ;
      }
      if ((int)(new HTuple(hv_MaxNumNeighbors.TupleGreater(30))) != 0)
      {
        hv_Pos.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Pos = (new HTuple(hv_NumNeighbors.TupleSortIndex()
            )).TupleSelect((new HTuple(hv_NumNeighbors.TupleLength()))-1);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "error", (((((((("The scene point with the following coordinates seems to be duplicated around "+hv_MaxNumNeighbors)+" times: ")+"(")+(hv_PX.TupleSelect(
            hv_Pos)))+new HTuple(","))+(hv_PY.TupleSelect(hv_Pos)))+new HTuple(","))+(hv_PZ.TupleSelect(
            hv_Pos)))+")");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "warning", new HTuple(new HTuple("Note that point duplication can generate several false positive ")+new HTuple("warnings and errors! It is recommended to first fix this problem, "))+"then to re-run this procedure");
        }
        write_note(hv_WindowHandle, "warning", new HTuple("To remove duplicate points, consider reducing the domain of the XYZ images or using select_points_object_model_3d with 'num_neighbors_fast'"));
        wait_continue_button(hv_WindowHandle);
        ho_X.Dispose();
        ho_Y.Dispose();
        ho_Z.Dispose();

        hv_DiameterModel.Dispose();
        hv_Exception.Dispose();
        hv_NumScenePoints.Dispose();
        hv_HasTriangles.Dispose();
        hv_HasPolygons.Dispose();
        hv_HasMapping.Dispose();
        hv_HasPointNormals.Dispose();
        hv_NumPointsScene.Dispose();
        hv_PX.Dispose();
        hv_PY.Dispose();
        hv_PZ.Dispose();
        hv_BBox.Dispose();
        hv_DiameterScene.Dispose();
        hv_CenterScene.Dispose();
        hv_EdgesTrained.Dispose();
        hv_CenterModel.Dispose();
        hv_HasCamPar.Dispose();
        hv_CamPar.Dispose();
        hv_SizesOK.Dispose();
        hv_IsNaN.Dispose();
        hv_LargeNum.Dispose();
        hv_Inf.Dispose();
        hv_IsInf.Dispose();
        hv_DistThreshold.Dispose();
        hv_NumNeighbors.Dispose();
        hv_MaxNumNeighbors.Dispose();
        hv_Pos.Dispose();
        hv_MedianDensity.Dispose();
        hv_NormalsGood.Dispose();
        hv_MLSNormals.Dispose();
        hv_NormalPos.Dispose();
        hv_CheckNormals.Dispose();
        hv_NX.Dispose();
        hv_NY.Dispose();
        hv_NZ.Dispose();
        hv_Length.Dispose();
        hv_LengthOne.Dispose();
        hv_LengthNotOne.Dispose();
        hv_Rows.Dispose();
        hv_Cols.Dispose();
        hv_MappingAsString.Dispose();
        hv_CenterFromOrigin.Dispose();
        hv_CenterToDiameter.Dispose();
        hv_NumSparsePoints.Dispose();
        hv_MedianDirectionX.Dispose();
        hv_MedianDirectionXNorm.Dispose();
        hv_MedianDirectionY.Dispose();
        hv_MedianDirectionYNorm.Dispose();
        hv_ErrorX.Dispose();
        hv_ErrorY.Dispose();
        hv_DistanceOriginRel.Dispose();
        hv_OM3D3DEdges.Dispose();
        hv_ViewpointString.Dispose();
        hv_Viewpoint.Dispose();
        hv_ViewpointToCenter.Dispose();
        hv_ZSigmaAbs.Dispose();
        hv_ZSigmaRel.Dispose();
        hv_ZSigmaPct.Dispose();

        return;
      }
      else
      {
        write_note(hv_WindowHandle, "ok", "No duplicate point(s) detected");
      }
    }



    //*****************************************************************
    //Density of scene points
    //*****************************************************************
    //Compute the approximate scene point density
    //ATTENTION: If a point is contained multiple times in the scene,
    //           the density can be reported to be very high
    if ((int)(new HTuple(hv_NumScenePoints.TupleGreater(0))) != 0)
    {
      hv_DistThreshold.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DistThreshold = hv_DiameterModel*0.05;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumNeighbors.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "num_neighbors_fast "+hv_DistThreshold, 
          out hv_NumNeighbors);
      }
      hv_MedianDensity.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MedianDensity = ((hv_NumNeighbors*1.0)).TupleMedian()
          ;
      }

      if ((int)(new HTuple(hv_MedianDensity.TupleLess(1))) != 0)
      {
        write_note(hv_WindowHandle, "warning", "The point density in the scene seems low");
      }
      else if ((int)(new HTuple(hv_MedianDensity.TupleGreater(350))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "warning", new HTuple(new HTuple("The point density in the scene seems very high. ")+"This is not necessarily a problem if the sensor has a ")+"very high resolution");
        }
      }
      else
      {
        write_note(hv_WindowHandle, "ok", "The point density in the scene looks good");
      }
    }

    //*****************************************************************
    //Check for Scene Normals
    //
    //Normals can come from:
    //- Precomputed normal vectors (for example with surface_normals_object_model_3d)
    //- A XYZ-Mapping, used to compute the normals
    //- Setting 'scene_normal_computation' to 'mls', which is identical to using
    //  surface_normals_object_model_3d, but faster
    //*****************************************************************
    hv_NormalsGood.Dispose();
    hv_NormalsGood = 0;
    hv_MLSNormals.Dispose();
    hv_MLSNormals = 0;
    hv_NormalPos.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NormalPos = hv_GenParamNames.TupleFind(
        "scene_normal_computation");
    }
    if ((int)((new HTuple(hv_NormalPos.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_NormalPos.TupleNotEqual(
        new HTuple())))) != 0)
    {
      hv_MLSNormals.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MLSNormals = new HTuple(((hv_GenParamValues.TupleSelect(
          hv_NormalPos))).TupleEqual("mls"));
      }
    }

    hv_CheckNormals.Dispose();
    hv_CheckNormals = 0;
    if ((int)(new HTuple(hv_MLSNormals.TupleEqual("true"))) != 0)
    {
      write_note(hv_WindowHandle, "ok", "Normals computed with MLS method");
    }
    else if ((int)(new HTuple(hv_HasPointNormals.TupleEqual("true"))) != 0)
    {
      write_note(hv_WindowHandle, "ok", "Scene contains normals vectors");
      hv_CheckNormals.Dispose();
      hv_CheckNormals = 1;
    }
    else if ((int)(new HTuple(hv_HasMapping.TupleEqual("true"))) != 0)
    {
      write_note(hv_WindowHandle, "ok", new HTuple("Scene contains XYZ-Mapping, used for normal computation"));
    }
    else
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      write_note(hv_WindowHandle, "error", new HTuple("No suitable way for computing the scene normals found (no XYZ mapping and no precomputed normals found). ")+"Please see the documentation of find_surface_model.");
      }
    }


    //*****************************************************************
    //Check Normal Correctness
    //*****************************************************************
    if ((int)(hv_CheckNormals) != 0)
    {
      hv_NX.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "point_normal_x", 
          out hv_NX);
      hv_NY.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "point_normal_y", 
          out hv_NY);
      hv_NZ.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "point_normal_z", 
          out hv_NZ);

      hv_Length.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Length = ((((hv_NX*hv_NX)+(hv_NY*hv_NY))+(hv_NZ*hv_NZ))).TupleSqrt()
          ;
      }
      hv_LengthOne.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LengthOne = ((((((hv_Length-1)).TupleFabs()
          )).TupleLessElem(0.05))).TupleSum();
      }
      hv_LengthNotOne.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LengthNotOne = (new HTuple(hv_Length.TupleLength()
          ))-hv_LengthOne;
      }
      if ((int)((new HTuple(hv_LengthNotOne.TupleGreater((new HTuple(hv_Length.TupleLength()
          ))*0.05))).TupleOr(new HTuple(hv_LengthNotOne.TupleGreater(10)))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "error", ((((new HTuple("Scene normals do not have length 1. ")+"(")+hv_LengthOne)+new HTuple(" have length ~ 1, "))+hv_LengthNotOne)+" have not.)");
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "ok", ((((new HTuple("Scene normals have length 1. ")+"(")+hv_LengthOne)+new HTuple(" have length ~ 1, "))+hv_LengthNotOne)+" have not.)");
        }
      }
    }


    //*****************************************************************
    //Check Mapping
    //
    //Avoid duplicates in the mapping, which can happen when merging
    //multiple scenes into one.
    //*****************************************************************
    if ((int)(new HTuple(hv_HasMapping.TupleEqual("true"))) != 0)
    {
      hv_Rows.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "mapping_row", out hv_Rows);
      hv_Cols.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "mapping_col", out hv_Cols);
      if ((int)((new HTuple((new HTuple((new HTuple(((((hv_Rows.TupleLessElem(0))).TupleSum()
          )).TupleGreater(0))).TupleOr(new HTuple(((((hv_Cols.TupleLessElem(0))).TupleSum()
          )).TupleGreater(0))))).TupleOr(new HTuple(((((hv_Rows.TupleGreaterElem(
          100000))).TupleSum())).TupleGreater(0))))).TupleOr(((hv_Cols.TupleGreaterElem(
          1000000))).TupleSum())) != 0)
      {
        write_note(hv_WindowHandle, "error", "Mapping contains invalid values (smaller zero or very large)");
      }
      else
      {
        //Search for duplicates
        hv_MappingAsString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MappingAsString = (hv_Rows+"#")+hv_Cols;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_MappingAsString = hv_MappingAsString.TupleUnion(
            new HTuple());
        hv_MappingAsString.Dispose();
        hv_MappingAsString = ExpTmpLocalVar_MappingAsString;
        }
        }
        if ((int)(new HTuple((new HTuple(hv_MappingAsString.TupleLength())).TupleNotEqual(
            new HTuple(hv_Rows.TupleLength())))) != 0)
        {
          write_note(hv_WindowHandle, "error", "Mapping contains duplicates. Maybe two scenes were merged into one?");
        }
      }
    }


    //*****************************************************************
    //Model Center
    //The model center should not be too far away from the origin.
    //Otherwise, numerical issues might worsen the result.
    //*****************************************************************
    hv_CenterFromOrigin.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CenterFromOrigin = ((((hv_CenterModel*hv_CenterModel)).TupleSum()
        )).TupleSqrt();
    }
    hv_CenterToDiameter.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CenterToDiameter = hv_CenterFromOrigin/hv_DiameterModel;
    }
    if ((int)(new HTuple(hv_CenterToDiameter.TupleGreater(10))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      write_note(hv_WindowHandle, "warning", ("The model center is far away from the origin (more than "+(hv_CenterToDiameter.TupleString(
          ".0")))+" times the diameter).");
      }
    }
    else
    {
      write_note(hv_WindowHandle, "ok", "Model center is close to origin");
    }


    //*****************************************************************
    //Scene contains a mesh?
    //*****************************************************************
    if ((int)((new HTuple(hv_HasTriangles.TupleEqual("true"))).TupleOr(new HTuple(hv_HasPolygons.TupleEqual(
        "true")))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      write_note(hv_WindowHandle, "warning", new HTuple("Scene contains a mesh (triangles or polygons). ")+new HTuple("Meshes are ignored, and only the 3D points are used during matching"));
      }
    }
    else
    {
      write_note(hv_WindowHandle, "ok", "Scene contains no mesh (triangles or polygons)");
    }


    //*****************************************************************
    //Scene contains sparse data / points?
    //A point is 'sparse' if it has very few neighbors
    //*****************************************************************
    if ((int)(new HTuple(hv_NumScenePoints.TupleGreater(0))) != 0)
    {
      hv_DistThreshold.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DistThreshold = hv_DiameterModel*0.05;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumNeighbors.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "num_neighbors_fast "+hv_DistThreshold, 
          out hv_NumNeighbors);
      }
      hv_NumSparsePoints.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumSparsePoints = ((hv_MaxNumNeighbors.TupleLessElem(
          3))).TupleSum();
      }
      if ((int)((new HTuple(hv_NumSparsePoints.TupleGreater(20))).TupleOr(new HTuple(hv_NumSparsePoints.TupleGreater(
          0.05*hv_NumScenePoints)))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "warning", (("Scene contains "+hv_NumSparsePoints)+" isolated point(s) that are far away from the other points. ")+"Consider removing them beforehand.");
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "ok", ("Scene contains "+hv_NumSparsePoints)+" isolated point(s).");
        }
      }
    }

    //*****************************************************************
    //For edge-based matching, does the scene contain a mapping?
    //*****************************************************************
    if ((int)(new HTuple(hv_EdgesTrained.TupleEqual("false"))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      write_note(hv_WindowHandle, "info", new HTuple("Surface model was not created for edge-supported matching, ")+"skipping corresponding checks.");
      }
    }
    else
    {
      write_note(hv_WindowHandle, "info", "Surface model was created for edge-supported matching");
    }

    if ((int)(new HTuple(hv_EdgesTrained.TupleEqual("true"))) != 0)
    {
      if ((int)(new HTuple(hv_HasMapping.TupleEqual("false"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "error", new HTuple("Scene does not contain XYZ-Mapping, which is required for ")+"edge-supported matching.  Create the scene with xyz_to_object_model_3d instead.");
        }
      }
      else
      {
        write_note(hv_WindowHandle, "ok", "Scene contains XYZ-Mapping");
      }
    }


    //*****************************************************************
    //For edge-based matching, is the mapping direction OK?
    //*****************************************************************
    if ((int)((new HTuple(hv_EdgesTrained.TupleEqual("true"))).TupleAnd(new HTuple(hv_HasMapping.TupleEqual(
        "true")))) != 0)
    {
      ho_X.Dispose();ho_Y.Dispose();ho_Z.Dispose();
      HOperatorSet.ObjectModel3dToXyz(out ho_X, out ho_Y, out ho_Z, hv_ObjectModel3DScene, 
          "from_xyz_map", new HTuple(), new HTuple());
      //Try to find the approximate direction in X
      hv_MedianDirectionX.Dispose();
      get_image_direction(ho_X, out hv_MedianDirectionX);
      if ((int)(new HTuple(((((((hv_MedianDirectionX*hv_MedianDirectionX)).TupleSum()
          )).TupleSqrt())).TupleGreater(1e-8))) != 0)
      {
        hv_MedianDirectionXNorm.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MedianDirectionXNorm = hv_MedianDirectionX/(((((hv_MedianDirectionX*hv_MedianDirectionX)).TupleSum()
            )).TupleSqrt());
        }
      }
      else
      {
        hv_MedianDirectionXNorm.Dispose();
        hv_MedianDirectionXNorm = new HTuple();
        hv_MedianDirectionXNorm[0] = 0;
        hv_MedianDirectionXNorm[1] = 0;
      }
      hv_MedianDirectionY.Dispose();
      get_image_direction(ho_Y, out hv_MedianDirectionY);
      if ((int)(new HTuple(((((((hv_MedianDirectionY*hv_MedianDirectionY)).TupleSum()
          )).TupleSqrt())).TupleGreater(1e-8))) != 0)
      {
        hv_MedianDirectionYNorm.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MedianDirectionYNorm = hv_MedianDirectionY/(((((hv_MedianDirectionY*hv_MedianDirectionY)).TupleSum()
            )).TupleSqrt());
        }
      }
      else
      {
        hv_MedianDirectionYNorm.Dispose();
        hv_MedianDirectionYNorm = new HTuple();
        hv_MedianDirectionYNorm[0] = 0;
        hv_MedianDirectionYNorm[1] = 0;
      }

      hv_ErrorX.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ErrorX = hv_MedianDirectionXNorm-
          (new HTuple(1)).TupleConcat(0);
      }
      hv_ErrorY.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ErrorY = hv_MedianDirectionYNorm-
          (new HTuple(0)).TupleConcat(1);
      }

      if ((int)((new HTuple(((((((hv_ErrorX*hv_ErrorX)).TupleSum())).TupleSqrt())).TupleGreater(
          0.2))).TupleOr(new HTuple(((((((hv_ErrorY*hv_ErrorY)).TupleSum())).TupleSqrt()
          )).TupleGreater(0.2)))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "error", new HTuple(new HTuple("X or Y image of scene is not aligned with coordinate axis. ")+"This leads to incorrect edge directions and must be corrected. ")+new HTuple("The X image should have increasing coordinates from left to right, the Y image from top to bottom."));
        }
      }
      else
      {
        write_note(hv_WindowHandle, "ok", "X- and Y-Directions of mapping seem good");
      }
    }




    //*****************************************************************
    //Check if the origin is inside the data AND we would compute
    //the normals from the mapping
    //*****************************************************************
    if ((int)((new HTuple(hv_HasPointNormals.TupleEqual("false"))).TupleAnd(new HTuple(hv_HasMapping.TupleEqual(
        "true")))) != 0)
    {
      hv_DistanceOriginRel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DistanceOriginRel = (((((hv_CenterScene*hv_CenterScene)).TupleSum()
          )).TupleSqrt())/hv_DiameterModel;
      }
      if ((int)((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(((hv_BBox.TupleSelect(
          0))).TupleLess(0))).TupleAnd(new HTuple(((hv_BBox.TupleSelect(1))).TupleLess(
          0))))).TupleAnd(new HTuple(((hv_BBox.TupleSelect(2))).TupleLess(0))))).TupleAnd(
          new HTuple(((hv_BBox.TupleSelect(3))).TupleGreater(0))))).TupleAnd(new HTuple(((hv_BBox.TupleSelect(
          4))).TupleGreater(0))))).TupleAnd(new HTuple(((hv_BBox.TupleSelect(5))).TupleGreater(
          0)))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "warning", (((new HTuple(new HTuple("The scene origin is inside the scene data. This is problematic, since normals ")+"are computed from the mapping and oriented towards the origin. ")+"The distance from scene center to origin is ~")+(hv_DistanceOriginRel.TupleString(
            ".1f")))+" times the model diameter. ")+"Consider moving the scene origin to the original viewpoint of the sensor.");
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "ok", ("Origin is not inside scene data. The distance from scene center to origin is ~"+(hv_DistanceOriginRel.TupleString(
            ".1f")))+" times the model diameter. ");
        }
      }
    }


    //*****************************************************************
    //Check if the viewpoint is inside the data AND we compute edges internally
    //*****************************************************************
    hv_OM3D3DEdges.Dispose();
    get_find_parameter(hv_GenParamNames, hv_GenParamValues, "3d_edges", new HTuple(), 
        out hv_OM3D3DEdges);
    if ((int)((new HTuple(hv_EdgesTrained.TupleEqual("true"))).TupleAnd(new HTuple(hv_OM3D3DEdges.TupleEqual(
        new HTuple())))) != 0)
    {
      //Obtain the viewpoint
      hv_ViewpointString.Dispose();
      get_find_parameter(hv_GenParamNames, hv_GenParamValues, "viewpoint", "0 0 0", 
          out hv_ViewpointString);
      hv_Viewpoint.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Viewpoint = ((hv_ViewpointString.TupleSplit(
          " "))).TupleNumber();
      }
      hv_ViewpointToCenter.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ViewpointToCenter = hv_Viewpoint-hv_CenterScene;
      }
      hv_DistanceOriginRel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DistanceOriginRel = (((((hv_ViewpointToCenter*hv_ViewpointToCenter)).TupleSum()
          )).TupleSqrt())/hv_DiameterModel;
      }
      if ((int)((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(((hv_BBox.TupleSelect(
          0))).TupleLess(0))).TupleAnd(new HTuple(((hv_BBox.TupleSelect(1))).TupleLess(
          0))))).TupleAnd(new HTuple(((hv_BBox.TupleSelect(2))).TupleLess(0))))).TupleAnd(
          new HTuple(((hv_BBox.TupleSelect(3))).TupleGreater(0))))).TupleAnd(new HTuple(((hv_BBox.TupleSelect(
          4))).TupleGreater(0))))).TupleAnd(new HTuple(((hv_BBox.TupleSelect(5))).TupleGreater(
          0)))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "warning", ((new HTuple("The viewpoint is inside the scene data. This is problematic, since the edge viewing directions will probably be incorrect. The distance from scene center to the viewpoint is ~")+(hv_DistanceOriginRel.TupleString(
            ".1f")))+" times the model diameter. ")+"Consider moving the viewpoint origin to the original viewpoint of the sensor.");
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "ok", ("Viewpoint is not inside scene data. The distance from scene center to origin is ~"+(hv_DistanceOriginRel.TupleString(
            ".1f")))+" times the model diameter. ");
        }
      }
    }


    //*****************************************************************
    //Check noise in Z-Direction
    //*****************************************************************
    if ((int)(new HTuple(hv_HasMapping.TupleEqual("true"))) != 0)
    {
      ho_X.Dispose();ho_Y.Dispose();ho_Z.Dispose();
      HOperatorSet.ObjectModel3dToXyz(out ho_X, out ho_Y, out ho_Z, hv_ObjectModel3DScene, 
          "from_xyz_map", new HTuple(), new HTuple());
      hv_ZSigmaAbs.Dispose();
      estimate_noise_real(ho_Z, 0.05, out hv_ZSigmaAbs);
      hv_ZSigmaRel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ZSigmaRel = hv_ZSigmaAbs/hv_DiameterModel;
      }
      hv_ZSigmaPct.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ZSigmaPct = (((hv_ZSigmaRel*100)).TupleString(
          ".1"))+"%";
      }
      if ((int)(new HTuple(hv_ZSigmaRel.TupleGreater(0.2))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "error", ((("The noise in the data is very high (relative value: "+hv_ZSigmaPct)+"). ")+"Consider smoothing the Z-image with a median filter and using ")+"the mls normal estimation method.");
        }
      }
      else if ((int)(new HTuple(hv_ZSigmaRel.TupleGreater(0.1))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "warning", ((("The noise in the data seems rather high (relative value: "+hv_ZSigmaPct)+"). ")+"Consider smoothing the Z-image with a median filter and using ")+"the mls normal estimation method.");
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandle, "ok", ("The noise in the data looks good (relative value: "+hv_ZSigmaPct)+")");
        }
      }
    }
    else
    {
      //No suitable way of checking the noise (yet)
      write_note(hv_WindowHandle, "info", "Noise was not checked (requires XYZ mapping)");
    }

    //*****************************************************************
    //DONE
    //Wait for user to click continue
    //*****************************************************************
    wait_continue_button(hv_WindowHandle);

    ho_X.Dispose();
    ho_Y.Dispose();
    ho_Z.Dispose();

    hv_DiameterModel.Dispose();
    hv_Exception.Dispose();
    hv_NumScenePoints.Dispose();
    hv_HasTriangles.Dispose();
    hv_HasPolygons.Dispose();
    hv_HasMapping.Dispose();
    hv_HasPointNormals.Dispose();
    hv_NumPointsScene.Dispose();
    hv_PX.Dispose();
    hv_PY.Dispose();
    hv_PZ.Dispose();
    hv_BBox.Dispose();
    hv_DiameterScene.Dispose();
    hv_CenterScene.Dispose();
    hv_EdgesTrained.Dispose();
    hv_CenterModel.Dispose();
    hv_HasCamPar.Dispose();
    hv_CamPar.Dispose();
    hv_SizesOK.Dispose();
    hv_IsNaN.Dispose();
    hv_LargeNum.Dispose();
    hv_Inf.Dispose();
    hv_IsInf.Dispose();
    hv_DistThreshold.Dispose();
    hv_NumNeighbors.Dispose();
    hv_MaxNumNeighbors.Dispose();
    hv_Pos.Dispose();
    hv_MedianDensity.Dispose();
    hv_NormalsGood.Dispose();
    hv_MLSNormals.Dispose();
    hv_NormalPos.Dispose();
    hv_CheckNormals.Dispose();
    hv_NX.Dispose();
    hv_NY.Dispose();
    hv_NZ.Dispose();
    hv_Length.Dispose();
    hv_LengthOne.Dispose();
    hv_LengthNotOne.Dispose();
    hv_Rows.Dispose();
    hv_Cols.Dispose();
    hv_MappingAsString.Dispose();
    hv_CenterFromOrigin.Dispose();
    hv_CenterToDiameter.Dispose();
    hv_NumSparsePoints.Dispose();
    hv_MedianDirectionX.Dispose();
    hv_MedianDirectionXNorm.Dispose();
    hv_MedianDirectionY.Dispose();
    hv_MedianDirectionYNorm.Dispose();
    hv_ErrorX.Dispose();
    hv_ErrorY.Dispose();
    hv_DistanceOriginRel.Dispose();
    hv_OM3D3DEdges.Dispose();
    hv_ViewpointString.Dispose();
    hv_Viewpoint.Dispose();
    hv_ViewpointToCenter.Dispose();
    hv_ZSigmaAbs.Dispose();
    hv_ZSigmaRel.Dispose();
    hv_ZSigmaPct.Dispose();

    return;

  }

  // Chapter: Calibration / Hand-Eye
  // Short Description: Check the input poses of the hand-eye calibration for consistency. 
  public void check_hand_eye_calibration_input_poses (HTuple hv_CalibDataID, HTuple hv_RotationTolerance, 
      HTuple hv_TranslationTolerance, out HTuple hv_Warnings)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinLargeRotationFraction = new HTuple();
    HTuple hv_MinLargeAnglesFraction = new HTuple(), hv_StdDevFactor = new HTuple();
    HTuple hv_Type = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_IsHandEyeScara = new HTuple(), hv_IsHandEyeArticulated = new HTuple();
    HTuple hv_NumCameras = new HTuple(), hv_NumCalibObjs = new HTuple();
    HTuple hv_I1 = new HTuple(), hv_PosesIdx = new HTuple();
    HTuple hv_RefCalibDataID = new HTuple(), hv_UseTemporaryCopy = new HTuple();
    HTuple hv_CamPoseCal = new HTuple(), hv_SerializedItemHandle = new HTuple();
    HTuple hv_TmpCalibDataID = new HTuple(), hv_Error = new HTuple();
    HTuple hv_Index = new HTuple(), hv_CamDualQuatCal = new HTuple();
    HTuple hv_BasePoseTool = new HTuple(), hv_BaseDualQuatTool = new HTuple();
    HTuple hv_NumCalibrationPoses = new HTuple(), hv_LX2s = new HTuple();
    HTuple hv_LY2s = new HTuple(), hv_LZ2s = new HTuple();
    HTuple hv_TranslationToleranceSquared = new HTuple(), hv_RotationToleranceSquared = new HTuple();
    HTuple hv_Index1 = new HTuple(), hv_CamDualQuatCal1 = new HTuple();
    HTuple hv_Cal1DualQuatCam = new HTuple(), hv_BaseDualQuatTool1 = new HTuple();
    HTuple hv_Tool1DualQuatBase = new HTuple(), hv_Index2 = new HTuple();
    HTuple hv_CamDualQuatCal2 = new HTuple(), hv_DualQuat1 = new HTuple();
    HTuple hv_BaseDualQuatTool2 = new HTuple(), hv_DualQuat2 = new HTuple();
    HTuple hv_LX1 = new HTuple(), hv_LY1 = new HTuple(), hv_LZ1 = new HTuple();
    HTuple hv_MX1 = new HTuple(), hv_MY1 = new HTuple(), hv_MZ1 = new HTuple();
    HTuple hv_Rot1 = new HTuple(), hv_Trans1 = new HTuple();
    HTuple hv_LX2 = new HTuple(), hv_LY2 = new HTuple(), hv_LZ2 = new HTuple();
    HTuple hv_MX2 = new HTuple(), hv_MY2 = new HTuple(), hv_MZ2 = new HTuple();
    HTuple hv_Rot2 = new HTuple(), hv_Trans2 = new HTuple();
    HTuple hv_MeanRot = new HTuple(), hv_MeanTrans = new HTuple();
    HTuple hv_SinTheta2 = new HTuple(), hv_CosTheta2 = new HTuple();
    HTuple hv_SinTheta2Squared = new HTuple(), hv_CosTheta2Squared = new HTuple();
    HTuple hv_ErrorRot = new HTuple(), hv_StdDevQ0 = new HTuple();
    HTuple hv_ToleranceDualQuat0 = new HTuple(), hv_ErrorDualQuat0 = new HTuple();
    HTuple hv_StdDevQ4 = new HTuple(), hv_ToleranceDualQuat4 = new HTuple();
    HTuple hv_ErrorDualQuat4 = new HTuple(), hv_Message = new HTuple();
    HTuple hv_NumPairs = new HTuple(), hv_NumPairsMax = new HTuple();
    HTuple hv_LargeRotationFraction = new HTuple(), hv_NumPairPairs = new HTuple();
    HTuple hv_NumPairPairsMax = new HTuple(), hv_Angles = new HTuple();
    HTuple hv_Idx = new HTuple(), hv_LXA = new HTuple(), hv_LYA = new HTuple();
    HTuple hv_LZA = new HTuple(), hv_LXB = new HTuple(), hv_LYB = new HTuple();
    HTuple hv_LZB = new HTuple(), hv_ScalarProduct = new HTuple();
    HTuple hv_LargeAngles = new HTuple(), hv_LargeAnglesFraction = new HTuple();

    HTupleVector hvec_CamDualQuatsCal = new HTupleVector(1);
    HTupleVector hvec_BaseDualQuatsTool = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_Warnings = new HTuple();
    //This procedure checks the hand-eye calibration input poses that are stored in
    //the calibration data model CalibDataID for consistency.
    //
    //For this check, it is necessary to know the accuracy of the input poses.
    //Therefore, the RotationTolerance and TranslationTolerance must be
    //specified that approximately describe the error in the rotation and in the
    //translation part of the input poses, respectively. The rotation tolerance must
    //be passed in RotationTolerance in radians. The translation tolerance must be
    //passed in TranslationTolerance in the same unit in which the input poses were
    //given, i.e., typically in meters. Therefore, the more accurate the
    //input poses are, the lower the values for RotationTolerance and
    //TranslationTolerance should be chosen. If the accuracy of the robot's tool
    //poses is different from the accuracy of the calibration object poses, the
    //tolerance values of the poses with the lower accuracy (i.e., the higher
    //tolerance values) should be passed.
    //
    //Typically, check_hand_eye_calibration_input_poses is called after all
    //calibration poses have been set in the calibration data model and before the
    //hand eye calibration is performed. The procedure checks all pairs of robot
    //tool poses and compares them to the corresponding pair of calibration object
    //poses. For each inconsistent pose pair, a string is returned in Warnings that
    //indicates the inconsistent pose pair. For larger values for RotationTolerance
    //or TranslationTolerance, i.e., for less accurate input poses, fewer warnings
    //will be generated because the check is more tolerant, and vice versa. The
    //procedure is also helpful if the errors that are returned by the hand-eye
    //calibration are larger than expected to identify potentially erroneous poses.
    //Note that it is not possible to check the consistency of a single pose but
    //only of pose pairs. Nevertheless, if a certain pose occurs multiple times in
    //different warning messages, it is likely that the pose is erroneous.
    //Erroneous poses that result in inconsistent pose pairs should removed
    //from the calibration data model by using remove_calib_data_observ and
    //remove_calib_data before performing the hand-eye calibration.
    //
    //check_hand_eye_calibration_input_poses also checks whether enough calibration
    //pose pairs are passed with a significant relative rotation angle, which
    //is necessary for a robust hand-eye calibration.
    //
    //check_hand_eye_calibration_input_poses also verifies that the correct
    //calibration model was chosen in create_calib_data. If a model of type
    //'hand_eye_stationary_cam' or 'hand_eye_moving_cam' was chosen, the calibration
    //of an articulated robot is assumed. For 'hand_eye_scara_stationary_cam' or
    //'hand_eye_scara_moving_cam', the calibration of a SCARA robot is assumed.
    //Therefore, if all input poses for an articulated robot are parallel or if some
    //robot poses for a SCARA robot are tilted, a corresponding message is returned
    //in Warnings. Furthermore, if the number of tilted input poses for articulated
    //robots is below a certain value, a corresponding message in Warnings indicates
    //that the accuracy of the result of the hand-eye calibration might be low.
    //
    //If no problems have been detected in the input poses, an empty tuple is
    //returned in Warnings.
    //
    //
    //Define the minimum fraction of pose pairs with a rotation angle exceeding
    //2*RotationTolerance.
    hv_MinLargeRotationFraction.Dispose();
    hv_MinLargeRotationFraction = 0.1;
    //Define the minimum fraction of screw axes pairs with an angle exceeding
    //2*RotationTolerance for articulated robots.
    hv_MinLargeAnglesFraction.Dispose();
    hv_MinLargeAnglesFraction = 0.1;
    //Factor that is used to multiply the standard deviations to obtain an error
    //threshold.
    hv_StdDevFactor.Dispose();
    hv_StdDevFactor = 3.0;
    //
    //Check input control parameters.
    if ((int)(new HTuple((new HTuple(hv_CalibDataID.TupleLength())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("Wrong number of values of control parameter: 1");
    }
    if ((int)(new HTuple((new HTuple(hv_RotationTolerance.TupleLength())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("Wrong number of values of control parameter: 2");
    }
    if ((int)(new HTuple((new HTuple(hv_TranslationTolerance.TupleLength())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("Wrong number of values of control parameter: 3");
    }
    try
    {
      hv_Type.Dispose();
      HOperatorSet.GetCalibData(hv_CalibDataID, "model", "general", "type", out hv_Type);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      throw new HalconException("Wrong value of control parameter: 1");
    }
    if ((int)(new HTuple(hv_RotationTolerance.TupleLess(0))) != 0)
    {
      throw new HalconException("Wrong value of control parameter: 2");
    }
    if ((int)(new HTuple(hv_TranslationTolerance.TupleLess(0))) != 0)
    {
      throw new HalconException("Wrong value of control parameter: 3");
    }
    //
    //Read out the calibration data model.
    hv_IsHandEyeScara.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IsHandEyeScara = (new HTuple(hv_Type.TupleEqual(
        "hand_eye_scara_stationary_cam"))).TupleOr(new HTuple(hv_Type.TupleEqual(
        "hand_eye_scara_moving_cam")));
    }
    hv_IsHandEyeArticulated.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IsHandEyeArticulated = (new HTuple(hv_Type.TupleEqual(
        "hand_eye_stationary_cam"))).TupleOr(new HTuple(hv_Type.TupleEqual("hand_eye_moving_cam")));
    }
    //This procedure only works for hand-eye calibration applications.
    if ((int)((new HTuple(hv_IsHandEyeScara.TupleNot())).TupleAnd(hv_IsHandEyeArticulated.TupleNot()
        )) != 0)
    {
      throw new HalconException("check_hand_eye_calibration_input_poses only works for hand-eye calibrations");
    }
    hv_NumCameras.Dispose();
    HOperatorSet.GetCalibData(hv_CalibDataID, "model", "general", "num_cameras", 
        out hv_NumCameras);
    hv_NumCalibObjs.Dispose();
    HOperatorSet.GetCalibData(hv_CalibDataID, "model", "general", "num_calib_objs", 
        out hv_NumCalibObjs);
    //
    //Get all valid calibration pose indices.
    hv_I1.Dispose();hv_PosesIdx.Dispose();
    HOperatorSet.QueryCalibDataObservIndices(hv_CalibDataID, "camera", 0, out hv_I1, 
        out hv_PosesIdx);
    hv_RefCalibDataID.Dispose();
    hv_RefCalibDataID = new HTuple(hv_CalibDataID);
    hv_UseTemporaryCopy.Dispose();
    hv_UseTemporaryCopy = 0;
    //If necessary, calibrate the interior camera parameters.
    if ((int)(hv_IsHandEyeArticulated) != 0)
    {
      //For articulated (non-SCARA) robots, we have to check whether the camera
      //is already calibrated. Otherwise, the queried poses might not be very
      //accurate.
      try
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamPoseCal.Dispose();
        HOperatorSet.GetCalibData(hv_CalibDataID, "calib_obj_pose", (new HTuple(0)).TupleConcat(
            hv_PosesIdx.TupleSelect(0)), "pose", out hv_CamPoseCal);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        if ((int)((new HTuple(hv_NumCameras.TupleNotEqual(0))).TupleAnd(new HTuple(hv_NumCalibObjs.TupleNotEqual(
            0)))) != 0)
        {
          //If the interior camera parameters are not calibrated yet, perform
          //the camera calibration by using a temporary copy of the calibration
          //data model.
          hv_SerializedItemHandle.Dispose();
          HOperatorSet.SerializeCalibData(hv_CalibDataID, out hv_SerializedItemHandle);
          hv_TmpCalibDataID.Dispose();
          HOperatorSet.DeserializeCalibData(hv_SerializedItemHandle, out hv_TmpCalibDataID);
          HOperatorSet.ClearSerializedItem(hv_SerializedItemHandle);
          hv_RefCalibDataID.Dispose();
          hv_RefCalibDataID = new HTuple(hv_TmpCalibDataID);
          hv_UseTemporaryCopy.Dispose();
          hv_UseTemporaryCopy = 1;
          hv_Error.Dispose();
          HOperatorSet.CalibrateCameras(hv_TmpCalibDataID, out hv_Error);
        }
      }
    }
    //Query all robot tool and calibration object poses.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_PosesIdx.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      try
      {
        //For an articulated robot with a camera and a calibration object,
        //a calibrated poses should always be available.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamPoseCal.Dispose();
        HOperatorSet.GetCalibData(hv_RefCalibDataID, "calib_obj_pose", (new HTuple(0)).TupleConcat(
            hv_PosesIdx.TupleSelect(hv_Index)), "pose", out hv_CamPoseCal);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //For a SCARA robot or for an articulated robots with a general
        //sensor and no calibration object, directly use the observed poses.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamPoseCal.Dispose();
        HOperatorSet.GetCalibDataObservPose(hv_RefCalibDataID, 0, 0, hv_PosesIdx.TupleSelect(
            hv_Index), out hv_CamPoseCal);
        }
      }
      //Transform the calibration object poses to dual quaternions.
      hv_CamDualQuatCal.Dispose();
      HOperatorSet.PoseToDualQuat(hv_CamPoseCal, out hv_CamDualQuatCal);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_CamDualQuatsCal[hv_Index] = dh.Add(new HTupleVector(hv_CamDualQuatCal));
      }
      //Transform the robot tool pose to dual quaternions.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BasePoseTool.Dispose();
      HOperatorSet.GetCalibData(hv_RefCalibDataID, "tool", hv_PosesIdx.TupleSelect(
          hv_Index), "tool_in_base_pose", out hv_BasePoseTool);
      }
      hv_BaseDualQuatTool.Dispose();
      HOperatorSet.PoseToDualQuat(hv_BasePoseTool, out hv_BaseDualQuatTool);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hvec_BaseDualQuatsTool[hv_Index] = dh.Add(new HTupleVector(hv_BaseDualQuatTool));
      }
    }
    hv_NumCalibrationPoses.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumCalibrationPoses = new HTuple(hv_PosesIdx.TupleLength()
        );
    }
    if ((int)(hv_UseTemporaryCopy) != 0)
    {
      HOperatorSet.ClearCalibData(hv_TmpCalibDataID);
    }
    //
    //In the first test, check the poses for consistency. The principle of
    //the hand-eye calibration is that the movement of the robot from time
    //i to time j is represented by the relative pose of the calibration
    //object from i to j in the camera coordinate system and also by the
    //relative pose of the robot tool from i to j in the robot base
    //coordinate system. Because both relative poses represent the same 3D
    //rigid transformation, but only seen from two different coordinate
    //systems, their screw axes differ but their screw angle and their
    //screw translation should be identical. This knowledge can be used to
    //check the consistency of the input poses. Furthermore, remember the
    //screw axes for all robot movements to later check whether the
    //correct calibration model (SCARA or articulated) was selected by the
    //user.
    hv_Warnings.Dispose();
    hv_Warnings = new HTuple();
    hv_LX2s.Dispose();
    hv_LX2s = new HTuple();
    hv_LY2s.Dispose();
    hv_LY2s = new HTuple();
    hv_LZ2s.Dispose();
    hv_LZ2s = new HTuple();
    hv_TranslationToleranceSquared.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TranslationToleranceSquared = hv_TranslationTolerance*hv_TranslationTolerance;
    }
    hv_RotationToleranceSquared.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RotationToleranceSquared = hv_RotationTolerance*hv_RotationTolerance;
    }
    HTuple end_val162 = hv_NumCalibrationPoses-2;
    HTuple step_val162 = 1;
    for (hv_Index1=0; hv_Index1.Continue(end_val162, step_val162); hv_Index1 = hv_Index1.TupleAdd(step_val162))
    {
      hv_CamDualQuatCal1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CamDualQuatCal1 = new HTuple(hvec_CamDualQuatsCal[hv_Index1].T);
      }
      hv_Cal1DualQuatCam.Dispose();
      HOperatorSet.DualQuatConjugate(hv_CamDualQuatCal1, out hv_Cal1DualQuatCam);
      hv_BaseDualQuatTool1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BaseDualQuatTool1 = new HTuple(hvec_BaseDualQuatsTool[hv_Index1].T);
      }
      hv_Tool1DualQuatBase.Dispose();
      HOperatorSet.DualQuatConjugate(hv_BaseDualQuatTool1, out hv_Tool1DualQuatBase);
      HTuple end_val167 = hv_NumCalibrationPoses-1;
      HTuple step_val167 = 1;
      for (hv_Index2=hv_Index1+1; hv_Index2.Continue(end_val167, step_val167); hv_Index2 = hv_Index2.TupleAdd(step_val167))
      {
        //For two robot poses, ...
        //... compute the movement of the calibration object in the
        //camera coordinate system.
        hv_CamDualQuatCal2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamDualQuatCal2 = new HTuple(hvec_CamDualQuatsCal[hv_Index2].T);
        }
        hv_DualQuat1.Dispose();
        HOperatorSet.DualQuatCompose(hv_Cal1DualQuatCam, hv_CamDualQuatCal2, out hv_DualQuat1);
        //
        //... compute the movement of the tool in the robot base
        //coordinate system.
        hv_BaseDualQuatTool2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BaseDualQuatTool2 = new HTuple(hvec_BaseDualQuatsTool[hv_Index2].T);
        }
        hv_DualQuat2.Dispose();
        HOperatorSet.DualQuatCompose(hv_Tool1DualQuatBase, hv_BaseDualQuatTool2, 
            out hv_DualQuat2);
        //
        //Check whether the two movements are consistent. If the two
        //movements are consistent, the scalar parts of the corresponding
        //dual quaternions should be equal. For the equality check, we
        //have to take the accuracy of the input poses into account, which
        //are given by RotationTolerance and TranslationTolerance.
        hv_LX1.Dispose();hv_LY1.Dispose();hv_LZ1.Dispose();hv_MX1.Dispose();hv_MY1.Dispose();hv_MZ1.Dispose();hv_Rot1.Dispose();hv_Trans1.Dispose();
        HOperatorSet.DualQuatToScrew(hv_DualQuat1, "moment", out hv_LX1, out hv_LY1, 
            out hv_LZ1, out hv_MX1, out hv_MY1, out hv_MZ1, out hv_Rot1, out hv_Trans1);
        hv_LX2.Dispose();hv_LY2.Dispose();hv_LZ2.Dispose();hv_MX2.Dispose();hv_MY2.Dispose();hv_MZ2.Dispose();hv_Rot2.Dispose();hv_Trans2.Dispose();
        HOperatorSet.DualQuatToScrew(hv_DualQuat2, "moment", out hv_LX2, out hv_LY2, 
            out hv_LZ2, out hv_MX2, out hv_MY2, out hv_MZ2, out hv_Rot2, out hv_Trans2);
        while ((int)(new HTuple(hv_Rot1.TupleGreater((new HTuple(180.0)).TupleRad()
            ))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Rot1 = hv_Rot1-((new HTuple(360.0)).TupleRad()
              );
          hv_Rot1.Dispose();
          hv_Rot1 = ExpTmpLocalVar_Rot1;
          }
          }
        }
        while ((int)(new HTuple(hv_Rot2.TupleGreater((new HTuple(180.0)).TupleRad()
            ))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Rot2 = hv_Rot2-((new HTuple(360.0)).TupleRad()
              );
          hv_Rot2.Dispose();
          hv_Rot2 = ExpTmpLocalVar_Rot2;
          }
          }
        }
        //
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Rot1 = hv_Rot1.TupleFabs()
            ;
        hv_Rot1.Dispose();
        hv_Rot1 = ExpTmpLocalVar_Rot1;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Trans1 = hv_Trans1.TupleFabs()
            ;
        hv_Trans1.Dispose();
        hv_Trans1 = ExpTmpLocalVar_Trans1;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Rot2 = hv_Rot2.TupleFabs()
            ;
        hv_Rot2.Dispose();
        hv_Rot2 = ExpTmpLocalVar_Rot2;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Trans2 = hv_Trans2.TupleFabs()
            ;
        hv_Trans2.Dispose();
        hv_Trans2 = ExpTmpLocalVar_Trans2;
        }
        }
        hv_MeanRot.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MeanRot = 0.5*(hv_Rot1+hv_Rot2);
        }
        hv_MeanTrans.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MeanTrans = 0.5*(hv_Trans1+hv_Trans2);
        }
        hv_SinTheta2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SinTheta2 = ((0.5*hv_MeanRot)).TupleSin()
            ;
        }
        hv_CosTheta2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CosTheta2 = ((0.5*hv_MeanRot)).TupleCos()
            ;
        }
        hv_SinTheta2Squared.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SinTheta2Squared = hv_SinTheta2*hv_SinTheta2;
        }
        hv_CosTheta2Squared.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CosTheta2Squared = hv_CosTheta2*hv_CosTheta2;
        }
        //
        //1. Check the scalar part of the real part of the dual quaternion,
        //which encodes the rotation component of the screw:
        //  q[0] = cos(theta/2)
        //Here, theta is the screw rotation angle.
        hv_ErrorRot.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ErrorRot = ((hv_Rot1-hv_Rot2)).TupleFabs()
            ;
        }
        while ((int)(new HTuple(hv_ErrorRot.TupleGreater((new HTuple(180.0)).TupleRad()
            ))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ErrorRot = hv_ErrorRot-((new HTuple(360.0)).TupleRad()
              );
          hv_ErrorRot.Dispose();
          hv_ErrorRot = ExpTmpLocalVar_ErrorRot;
          }
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ErrorRot = hv_ErrorRot.TupleFabs()
            ;
        hv_ErrorRot.Dispose();
        hv_ErrorRot = ExpTmpLocalVar_ErrorRot;
        }
        }
        //Compute the standard deviation of the scalar part of the real part
        //by applying the law of error propagation.
        hv_StdDevQ0.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_StdDevQ0 = (0.5*hv_SinTheta2)*hv_RotationTolerance;
        }
        //Multiply the standard deviation by a factor to increase the certainty.
        hv_ToleranceDualQuat0.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ToleranceDualQuat0 = hv_StdDevFactor*hv_StdDevQ0;
        }
        hv_ErrorDualQuat0.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ErrorDualQuat0 = (((((hv_DualQuat2.TupleSelect(
            0))).TupleFabs())-(((hv_DualQuat1.TupleSelect(0))).TupleFabs()))).TupleFabs()
            ;
        }
        //
        //2. Check the scalar part of the dual part of the dual quaternion,
        //which encodes translation and rotation components of the screw:
        //  q[4] = -d/2*sin(theta/2)
        //Here, d is the screw translation.
        //
        //Compute the standard deviation of the scalar part of the dual part
        //by applying the law of error propagation.
        hv_StdDevQ4.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_StdDevQ4 = ((((0.25*hv_SinTheta2Squared)*hv_TranslationToleranceSquared)+((((0.0625*hv_MeanTrans)*hv_MeanTrans)*hv_CosTheta2Squared)*hv_RotationToleranceSquared))).TupleSqrt()
            ;
        }
        //Multiply the standard deviation by a factor to increase the certainty.
        hv_ToleranceDualQuat4.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ToleranceDualQuat4 = hv_StdDevFactor*hv_StdDevQ4;
        }
        hv_ErrorDualQuat4.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ErrorDualQuat4 = (((((hv_DualQuat2.TupleSelect(
            4))).TupleFabs())-(((hv_DualQuat1.TupleSelect(4))).TupleFabs()))).TupleFabs()
            ;
        }
        //If one of the two errors exceeds the computed thresholds, return
        //a warning for the current pose pair.
        if ((int)((new HTuple(hv_ErrorDualQuat0.TupleGreater(hv_ToleranceDualQuat0))).TupleOr(
            new HTuple(hv_ErrorDualQuat4.TupleGreater(hv_ToleranceDualQuat4)))) != 0)
        {
          hv_Message.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Message = ((("Inconsistent pose pair ("+(((hv_PosesIdx.TupleSelect(
              hv_Index1))).TupleString("2d")))+new HTuple(","))+(((hv_PosesIdx.TupleSelect(
              hv_Index2))).TupleString("2d")))+")";
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Warnings = hv_Warnings.TupleConcat(
              hv_Message);
          hv_Warnings.Dispose();
          hv_Warnings = ExpTmpLocalVar_Warnings;
          }
          }
        }
        //
        //Remember the screw axes (of the robot tool movements) for screws
        //with a significant rotation part. For movements without rotation
        //the direction of the screw axis is determined by the translation
        //part only. Hence, the direction of the screw axis cannot be used
        //to decide whether an articulated or a SCARA robot is used.
        if ((int)(new HTuple(hv_Rot2.TupleGreater(hv_StdDevFactor*hv_RotationTolerance))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_LX2s = hv_LX2s.TupleConcat(
              hv_LX2);
          hv_LX2s.Dispose();
          hv_LX2s = ExpTmpLocalVar_LX2s;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_LY2s = hv_LY2s.TupleConcat(
              hv_LY2);
          hv_LY2s.Dispose();
          hv_LY2s = ExpTmpLocalVar_LY2s;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_LZ2s = hv_LZ2s.TupleConcat(
              hv_LZ2);
          hv_LZ2s.Dispose();
          hv_LZ2s = ExpTmpLocalVar_LZ2s;
          }
          }
        }
      }
    }
    //
    //In the second test, we check whether enough calibration poses with a
    //significant rotation part are available for calibration.
    hv_NumPairs.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumPairs = new HTuple(hv_LX2s.TupleLength()
        );
    }
    hv_NumPairsMax.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumPairsMax = (hv_NumCalibrationPoses*(hv_NumCalibrationPoses-1))/2;
    }
    if ((int)(new HTuple(hv_NumPairs.TupleLess(2))) != 0)
    {
      hv_Message.Dispose();
      hv_Message = "There are not enough rotated calibration poses available.";
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Warnings = hv_Warnings.TupleConcat(
          hv_Message);
      hv_Warnings.Dispose();
      hv_Warnings = ExpTmpLocalVar_Warnings;
      }
      }
      //In this case, we can skip further test.

      hv_MinLargeRotationFraction.Dispose();
      hv_MinLargeAnglesFraction.Dispose();
      hv_StdDevFactor.Dispose();
      hv_Type.Dispose();
      hv_Exception.Dispose();
      hv_IsHandEyeScara.Dispose();
      hv_IsHandEyeArticulated.Dispose();
      hv_NumCameras.Dispose();
      hv_NumCalibObjs.Dispose();
      hv_I1.Dispose();
      hv_PosesIdx.Dispose();
      hv_RefCalibDataID.Dispose();
      hv_UseTemporaryCopy.Dispose();
      hv_CamPoseCal.Dispose();
      hv_SerializedItemHandle.Dispose();
      hv_TmpCalibDataID.Dispose();
      hv_Error.Dispose();
      hv_Index.Dispose();
      hv_CamDualQuatCal.Dispose();
      hv_BasePoseTool.Dispose();
      hv_BaseDualQuatTool.Dispose();
      hv_NumCalibrationPoses.Dispose();
      hv_LX2s.Dispose();
      hv_LY2s.Dispose();
      hv_LZ2s.Dispose();
      hv_TranslationToleranceSquared.Dispose();
      hv_RotationToleranceSquared.Dispose();
      hv_Index1.Dispose();
      hv_CamDualQuatCal1.Dispose();
      hv_Cal1DualQuatCam.Dispose();
      hv_BaseDualQuatTool1.Dispose();
      hv_Tool1DualQuatBase.Dispose();
      hv_Index2.Dispose();
      hv_CamDualQuatCal2.Dispose();
      hv_DualQuat1.Dispose();
      hv_BaseDualQuatTool2.Dispose();
      hv_DualQuat2.Dispose();
      hv_LX1.Dispose();
      hv_LY1.Dispose();
      hv_LZ1.Dispose();
      hv_MX1.Dispose();
      hv_MY1.Dispose();
      hv_MZ1.Dispose();
      hv_Rot1.Dispose();
      hv_Trans1.Dispose();
      hv_LX2.Dispose();
      hv_LY2.Dispose();
      hv_LZ2.Dispose();
      hv_MX2.Dispose();
      hv_MY2.Dispose();
      hv_MZ2.Dispose();
      hv_Rot2.Dispose();
      hv_Trans2.Dispose();
      hv_MeanRot.Dispose();
      hv_MeanTrans.Dispose();
      hv_SinTheta2.Dispose();
      hv_CosTheta2.Dispose();
      hv_SinTheta2Squared.Dispose();
      hv_CosTheta2Squared.Dispose();
      hv_ErrorRot.Dispose();
      hv_StdDevQ0.Dispose();
      hv_ToleranceDualQuat0.Dispose();
      hv_ErrorDualQuat0.Dispose();
      hv_StdDevQ4.Dispose();
      hv_ToleranceDualQuat4.Dispose();
      hv_ErrorDualQuat4.Dispose();
      hv_Message.Dispose();
      hv_NumPairs.Dispose();
      hv_NumPairsMax.Dispose();
      hv_LargeRotationFraction.Dispose();
      hv_NumPairPairs.Dispose();
      hv_NumPairPairsMax.Dispose();
      hv_Angles.Dispose();
      hv_Idx.Dispose();
      hv_LXA.Dispose();
      hv_LYA.Dispose();
      hv_LZA.Dispose();
      hv_LXB.Dispose();
      hv_LYB.Dispose();
      hv_LZB.Dispose();
      hv_ScalarProduct.Dispose();
      hv_LargeAngles.Dispose();
      hv_LargeAnglesFraction.Dispose();
      hvec_CamDualQuatsCal.Dispose();
      hvec_BaseDualQuatsTool.Dispose();

      return;
    }
    hv_LargeRotationFraction.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_LargeRotationFraction = (hv_NumPairs.TupleReal()
        )/hv_NumPairsMax;
    }
    if ((int)((new HTuple(hv_NumPairs.TupleLess(4))).TupleOr(new HTuple(hv_LargeRotationFraction.TupleLess(
        hv_MinLargeRotationFraction)))) != 0)
    {
      hv_Message.Dispose();
      hv_Message = new HTuple("Only few rotated robot poses available, which might result in a reduced accuracy of the calibration results.");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Warnings = hv_Warnings.TupleConcat(
          hv_Message);
      hv_Warnings.Dispose();
      hv_Warnings = ExpTmpLocalVar_Warnings;
      }
      }
    }
    //
    //In the third test, we compute the angle between the screw axes with
    //a significant rotation part. For SCARA robots, this angle must be 0 in
    //all cases. For articulated robots, for a significant fraction of robot
    //poses, this angle should exceed a certain threshold. For this test, we
    //use the robot tool poses as they are assumed to be more accurate than the
    //calibration object poses.
    hv_NumPairPairs.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumPairPairs = (hv_NumPairs*(hv_NumPairs-1))/2;
    }
    hv_NumPairPairsMax.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumPairPairsMax = (hv_NumPairsMax*(hv_NumPairsMax-1))/2;
    }
    hv_Angles.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Angles = HTuple.TupleGenConst(
        hv_NumPairPairs,0);
    }
    hv_Idx.Dispose();
    hv_Idx = 0;
    HTuple end_val277 = hv_NumPairs-2;
    HTuple step_val277 = 1;
    for (hv_Index1=0; hv_Index1.Continue(end_val277, step_val277); hv_Index1 = hv_Index1.TupleAdd(step_val277))
    {
      hv_LXA.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LXA = hv_LX2s.TupleSelect(
          hv_Index1);
      }
      hv_LYA.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LYA = hv_LY2s.TupleSelect(
          hv_Index1);
      }
      hv_LZA.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LZA = hv_LZ2s.TupleSelect(
          hv_Index1);
      }
      HTuple end_val281 = hv_NumPairs-1;
      HTuple step_val281 = 1;
      for (hv_Index2=hv_Index1+1; hv_Index2.Continue(end_val281, step_val281); hv_Index2 = hv_Index2.TupleAdd(step_val281))
      {
        hv_LXB.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LXB = hv_LX2s.TupleSelect(
            hv_Index2);
        }
        hv_LYB.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LYB = hv_LY2s.TupleSelect(
            hv_Index2);
        }
        hv_LZB.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LZB = hv_LZ2s.TupleSelect(
            hv_Index2);
        }
        //Compute the scalar product, i.e. the cosine of the screw
        //axes. To obtain valid values, crop the cosine to the
        //interval [-1,1].
        hv_ScalarProduct.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ScalarProduct = ((((((((((hv_LXA*hv_LXB)+(hv_LYA*hv_LYB))+(hv_LZA*hv_LZB))).TupleConcat(
            1))).TupleMin())).TupleConcat(-1))).TupleMax();
        }
        //Compute the angle between the axes in the range [0,pi/2].
        if (hv_Angles == null)
          hv_Angles = new HTuple();
        hv_Angles[hv_Idx] = ((hv_ScalarProduct.TupleFabs())).TupleAcos();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Idx = hv_Idx+1;
        hv_Idx.Dispose();
        hv_Idx = ExpTmpLocalVar_Idx;
        }
        }
      }
    }
    //Large angles should significantly exceed the RotationTolerance.
    hv_LargeAngles.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_LargeAngles = ((hv_Angles.TupleGreaterElem(
        hv_StdDevFactor*hv_RotationTolerance))).TupleSum();
    }
    //Calculate the fraction of pairs of movements, i.e., pairs of pose
    //pairs, that have a large angle between their corresponding screw
    //axes.
    hv_LargeAnglesFraction.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_LargeAnglesFraction = (hv_LargeAngles.TupleReal()
        )/hv_NumPairPairsMax;
    }
    //For SCARA robots, all screw axes should be parallel, i.e., no
    //two screw axes should have a large angle.
    if ((int)(hv_IsHandEyeScara.TupleAnd(new HTuple(hv_LargeAngles.TupleGreater(0)))) != 0)
    {
      hv_Message.Dispose();
      hv_Message = new HTuple("The robot poses indicate that this might be an articulated robot, although a SCARA robot was selected in the calibration data model.");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Warnings = hv_Warnings.TupleConcat(
          hv_Message);
      hv_Warnings.Dispose();
      hv_Warnings = ExpTmpLocalVar_Warnings;
      }
      }
    }
    //For articulated robots, the screw axes should have a large
    //angles.
    if ((int)(hv_IsHandEyeArticulated) != 0)
    {
      if ((int)(new HTuple(hv_LargeAngles.TupleEqual(0))) != 0)
      {
        //If there is no pair of movements with a large angle between
        //their corresponding screw axes, this might be a SCARA robot.
        hv_Message.Dispose();
        hv_Message = new HTuple("The robot poses indicate that this might be a SCARA robot (no tilted robot poses available), although an articulated robot was selected in the calibration data model.");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Warnings = hv_Warnings.TupleConcat(
            hv_Message);
        hv_Warnings.Dispose();
        hv_Warnings = ExpTmpLocalVar_Warnings;
        }
        }
      }
      else if ((int)(new HTuple(hv_LargeAngles.TupleLess(3))) != 0)
      {
        //If there are at most 2 movements with a large angle between
        //their corresponding screw axes, the calibration might be
        //unstable.
        hv_Message.Dispose();
        hv_Message = "Not enough tilted robot poses available for an accurate calibration of an articulated robot.";
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Warnings = hv_Warnings.TupleConcat(
            hv_Message);
        hv_Warnings.Dispose();
        hv_Warnings = ExpTmpLocalVar_Warnings;
        }
        }
      }
      else if ((int)(new HTuple(hv_LargeAnglesFraction.TupleLess(hv_MinLargeAnglesFraction))) != 0)
      {
        //If there is only a low fraction of pairs of movements with
        //a large angle between their corresponding screw axes, the
        //accuracy of the calibration might be low.
        hv_Message.Dispose();
        hv_Message = new HTuple("Only few tilted robot poses available, which might result in a reduced accuracy of the calibration results.");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Warnings = hv_Warnings.TupleConcat(
            hv_Message);
        hv_Warnings.Dispose();
        hv_Warnings = ExpTmpLocalVar_Warnings;
        }
        }
      }
    }

    hv_MinLargeRotationFraction.Dispose();
    hv_MinLargeAnglesFraction.Dispose();
    hv_StdDevFactor.Dispose();
    hv_Type.Dispose();
    hv_Exception.Dispose();
    hv_IsHandEyeScara.Dispose();
    hv_IsHandEyeArticulated.Dispose();
    hv_NumCameras.Dispose();
    hv_NumCalibObjs.Dispose();
    hv_I1.Dispose();
    hv_PosesIdx.Dispose();
    hv_RefCalibDataID.Dispose();
    hv_UseTemporaryCopy.Dispose();
    hv_CamPoseCal.Dispose();
    hv_SerializedItemHandle.Dispose();
    hv_TmpCalibDataID.Dispose();
    hv_Error.Dispose();
    hv_Index.Dispose();
    hv_CamDualQuatCal.Dispose();
    hv_BasePoseTool.Dispose();
    hv_BaseDualQuatTool.Dispose();
    hv_NumCalibrationPoses.Dispose();
    hv_LX2s.Dispose();
    hv_LY2s.Dispose();
    hv_LZ2s.Dispose();
    hv_TranslationToleranceSquared.Dispose();
    hv_RotationToleranceSquared.Dispose();
    hv_Index1.Dispose();
    hv_CamDualQuatCal1.Dispose();
    hv_Cal1DualQuatCam.Dispose();
    hv_BaseDualQuatTool1.Dispose();
    hv_Tool1DualQuatBase.Dispose();
    hv_Index2.Dispose();
    hv_CamDualQuatCal2.Dispose();
    hv_DualQuat1.Dispose();
    hv_BaseDualQuatTool2.Dispose();
    hv_DualQuat2.Dispose();
    hv_LX1.Dispose();
    hv_LY1.Dispose();
    hv_LZ1.Dispose();
    hv_MX1.Dispose();
    hv_MY1.Dispose();
    hv_MZ1.Dispose();
    hv_Rot1.Dispose();
    hv_Trans1.Dispose();
    hv_LX2.Dispose();
    hv_LY2.Dispose();
    hv_LZ2.Dispose();
    hv_MX2.Dispose();
    hv_MY2.Dispose();
    hv_MZ2.Dispose();
    hv_Rot2.Dispose();
    hv_Trans2.Dispose();
    hv_MeanRot.Dispose();
    hv_MeanTrans.Dispose();
    hv_SinTheta2.Dispose();
    hv_CosTheta2.Dispose();
    hv_SinTheta2Squared.Dispose();
    hv_CosTheta2Squared.Dispose();
    hv_ErrorRot.Dispose();
    hv_StdDevQ0.Dispose();
    hv_ToleranceDualQuat0.Dispose();
    hv_ErrorDualQuat0.Dispose();
    hv_StdDevQ4.Dispose();
    hv_ToleranceDualQuat4.Dispose();
    hv_ErrorDualQuat4.Dispose();
    hv_Message.Dispose();
    hv_NumPairs.Dispose();
    hv_NumPairsMax.Dispose();
    hv_LargeRotationFraction.Dispose();
    hv_NumPairPairs.Dispose();
    hv_NumPairPairsMax.Dispose();
    hv_Angles.Dispose();
    hv_Idx.Dispose();
    hv_LXA.Dispose();
    hv_LYA.Dispose();
    hv_LZA.Dispose();
    hv_LXB.Dispose();
    hv_LYB.Dispose();
    hv_LZB.Dispose();
    hv_ScalarProduct.Dispose();
    hv_LargeAngles.Dispose();
    hv_LargeAnglesFraction.Dispose();
    hvec_CamDualQuatsCal.Dispose();
    hvec_BaseDualQuatsTool.Dispose();

    return;
  }

  public void check_model_edges (HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3D, 
      HTuple hv_WindowHandleViewpoint, HTuple hv_WindowHandleVisualization)
  {

    using (HDevThreadContext context = new HDevThreadContext())
    {
    // +++ Threading variables 
    HDevThread devThread;


    // Local iconic variables 

    // Local control variables 

    HTuple hv_GenParamValue = new HTuple(), hv_Instructions = new HTuple();
    HTuple hv_MessageQueues1 = new HTuple(), hv_Buttons = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_CameraParam = new HTuple(), hv_CurrentState1 = new HTuple();
    HTuple hv_DiameterModel = new HTuple(), hv_CenterModel = new HTuple();
    HTuple hv_Viewpoint = new HTuple(), hv_OM3DCamera = new HTuple();
    HTuple hv_OM3DLineSphereToModel = new HTuple(), hv_Center = new HTuple();
    HTuple hv_PoseInT = new HTuple(), hv_PoseInR = new HTuple();
    HTuple hv_PoseIn = new HTuple(), hv_CamParamVis = new HTuple();
    HTuple hv_PoseEstimated = new HTuple(), hv_MessageQueues2 = new HTuple();
    HTuple hv_DirectionsShown = new HTuple(), hv_CurrentState2 = new HTuple();
    HTuple hv_DidFinish1 = new HTuple(), hv_ButtonPressed = new HTuple();
    HTuple hv_Pose = new HTuple(), hv_PoseInvert = new HTuple();
    HTuple hv_Direction = new HTuple(), hv_Length = new HTuple();
    HTuple hv_OM3DSphere = new HTuple(), hv_OM3DModelEdges = new HTuple();
    HTuple hv_EdgeDirs = new HTuple(), hv_MessageHandle = new HTuple();
    HTuple hv_DidFinish2 = new HTuple(), hv_TIT = new HTuple();

    HTupleVector hvec_TI = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_GenParamValue.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModelID, "diameter", out hv_GenParamValue);
    //
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[0] = "Rotate: Left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[1] = "Zoom:   Shift + left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[2] = "Move:   Ctrl  + left button";
    //
    hv_MessageQueues1.Dispose();
    create_visualization_message_queues(out hv_MessageQueues1);
    hv_Buttons.Dispose();
    hv_Buttons = new HTuple();
    hv_Buttons[0] = "Continue";
    hv_Buttons[1] = "right";
    hv_Buttons[2] = "bottom";
    hv_Buttons[3] = -1;
    hv_Buttons[4] = -1;
    hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandleViewpoint, out hv_Row, out hv_Column, 
        out hv_Width, out hv_Height);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam.Dispose();
    gen_cam_par_area_scan_division(0.008, 0, 5.2e-006, 5.2e-006, (hv_Width*0.5)+0.5, 
        (hv_Height*0.5)+0.5, hv_Width, hv_Height, out hv_CameraParam);
    }
    devThread = new HDevThread(context,
      (HDevThread.ProcCallback) delegate(HDevThread devThreadCB)
    {
      try
      {
        // Input parameters
        HTuple        cbhv_WindowHandle = devThreadCB.GetInputCtrlParamTuple(0);
        HTuple        cbhv_ObjectModel3D = devThreadCB.GetInputCtrlParamTuple(1);
        HTuple        cbhv_CamParam = devThreadCB.GetInputCtrlParamTuple(2);
        HTuple        cbhv_PoseIn = devThreadCB.GetInputCtrlParamTuple(3);
        HTuple        cbhv_GenParamName = devThreadCB.GetInputCtrlParamTuple(4);
        HTuple        cbhv_GenParamValue = devThreadCB.GetInputCtrlParamTuple(5);
        HTuple        cbhv_Title = devThreadCB.GetInputCtrlParamTuple(6);
        HTuple        cbhv_Label = devThreadCB.GetInputCtrlParamTuple(7);
        HTuple        cbhv_Information = devThreadCB.GetInputCtrlParamTuple(8);
        HTuple        cbhv_MessageQueue = devThreadCB.GetInputCtrlParamTuple(9);
        HTuple        cbhv_Buttons = devThreadCB.GetInputCtrlParamTuple(10);
        HTuple        cbhv_Type = devThreadCB.GetInputCtrlParamTuple(11);
        HTuple        cbhv_Message = devThreadCB.GetInputCtrlParamTuple(12);
        HTuple        cbhv_DispViewPoint = devThreadCB.GetInputCtrlParamTuple(13);
        HTuple        cbhv_ViewPoint = devThreadCB.GetInputCtrlParamTuple(14);

        // Call visualize_object_model_3d_ext
        visualize_object_model_3d_ext(cbhv_WindowHandle, cbhv_ObjectModel3D, cbhv_CamParam, 
                cbhv_PoseIn, cbhv_GenParamName, cbhv_GenParamValue, cbhv_Title, cbhv_Label, 
                cbhv_Information, cbhv_MessageQueue, cbhv_Buttons, cbhv_Type, cbhv_Message, 
                cbhv_DispViewPoint, cbhv_ViewPoint);

        // Reduce reference counter of thread object
        devThreadCB.Exit();
        devThreadCB.Dispose();

      }
      catch (HalconException exc)
      {
        // No exceptions may be raised from stub in parallel case,
        // so we need to store this information prior to cleanup
        bool is_direct_call = devThreadCB.IsDirectCall();
        // Attempt to clean up in error case, too
        devThreadCB.Exit();
        devThreadCB.Dispose();
        // Propagate exception if called directly
        if (is_direct_call)
          throw exc;
      }
    },15,0);
    // Set thread procedure call arguments 
    devThread.SetInputCtrlParamTuple(0,hv_WindowHandleViewpoint);
    devThread.SetInputCtrlParamTuple(1,hv_ObjectModel3D);
    devThread.SetInputCtrlParamTuple(2,hv_CameraParam);
    devThread.SetInputCtrlParamTuple(3,new HTuple());
    devThread.SetInputCtrlParamTuple(4,(
        (new HTuple("disp_pose")).TupleConcat("color_0")).TupleConcat("alpha_0"));
    devThread.SetInputCtrlParamTuple(5,(
        (new HTuple("true")).TupleConcat("cyan")).TupleConcat(0.5));
    devThread.SetInputCtrlParamTuple(6,new HTuple());
    devThread.SetInputCtrlParamTuple(7,new HTuple());
    devThread.SetInputCtrlParamTuple(8,hv_Instructions);
    devThread.SetInputCtrlParamTuple(9,hv_MessageQueues1);
    devThread.SetInputCtrlParamTuple(10,hv_Buttons);
    devThread.SetInputCtrlParamTuple(11,new HTuple());
    devThread.SetInputCtrlParamTuple(12,new HTuple());
    devThread.SetInputCtrlParamTuple(13,"false");
    devThread.SetInputCtrlParamTuple(14,new HTuple());

    // Start proc line in thread
    {
    HTuple TmpThreadId;
    devThread.ParStart(out TmpThreadId);
    hvec_TI[0].T = TmpThreadId;
    }

    hv_CurrentState1.Dispose();
    hv_CurrentState1 = new HTuple();
    //
    hv_DiameterModel.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModelID, "diameter", out hv_DiameterModel);
    hv_CenterModel.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModelID, "center", out hv_CenterModel);
    hv_Viewpoint.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Viewpoint = hv_CenterModel-((
        (new HTuple(0)).TupleConcat(0)).TupleConcat(1)*hv_DiameterModel);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DCamera.Dispose();
    gen_camera_object_model_3d(hv_Viewpoint.TupleConcat((((new HTuple(0)).TupleConcat(
        0)).TupleConcat(0)).TupleConcat(0)), hv_DiameterModel*0.05, out hv_OM3DCamera);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DLineSphereToModel.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(((hv_Viewpoint.TupleSelect(0))).TupleConcat(
        hv_CenterModel.TupleSelect(0)), ((hv_Viewpoint.TupleSelect(1))).TupleConcat(
        hv_CenterModel.TupleSelect(1)), ((hv_Viewpoint.TupleSelect(2))).TupleConcat(
        hv_CenterModel.TupleSelect(2)), out hv_OM3DLineSphereToModel);
    }
    HOperatorSet.SetObjectModel3dAttribMod(hv_OM3DLineSphereToModel, "lines", new HTuple(), 
        ((new HTuple(2)).TupleConcat(0)).TupleConcat(1));
    //
    //Find a pose for the second window such that both the model and the camer are visible,
    //from the side.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Center.Dispose();
    get_object_models_center(((hv_ObjectModel3D.TupleConcat(hv_OM3DCamera))).TupleConcat(
        hv_OM3DLineSphereToModel), out hv_Center);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PoseInT.Dispose();
    HOperatorSet.CreatePose(-(hv_Center.TupleSelect(0)), -(hv_Center.TupleSelect(
        1)), -(hv_Center.TupleSelect(2)), 0, 0, 0, "Rp+T", "gba", "point", out hv_PoseInT);
    }
    hv_PoseInR.Dispose();
    HOperatorSet.CreatePose(0, 0, 0, -90, 0, 0, "Rp+T", "gba", "point", out hv_PoseInR);
    hv_PoseIn.Dispose();
    HOperatorSet.PoseCompose(hv_PoseInR, hv_PoseInT, out hv_PoseIn);
    hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandleVisualization, out hv_Row, out hv_Column, 
        out hv_Width, out hv_Height);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CamParamVis.Dispose();
    gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width/2, hv_Height/2, 
        hv_Width, hv_Height, out hv_CamParamVis);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PoseEstimated.Dispose();
    determine_optimum_pose_distance(((hv_ObjectModel3D.TupleConcat(hv_OM3DCamera))).TupleConcat(
        hv_OM3DLineSphereToModel), hv_CamParamVis, 0.5, hv_PoseIn, out hv_PoseEstimated);
    }
    //
    hv_MessageQueues2.Dispose();
    create_visualization_message_queues(out hv_MessageQueues2);
    hv_Buttons.Dispose();
    hv_Buttons = new HTuple();
    hv_Buttons[0] = "Hide Edge Directions";
    hv_Buttons[1] = "center";
    hv_Buttons[2] = "bottom";
    hv_Buttons[3] = -1;
    hv_Buttons[4] = -1;
    hv_DirectionsShown.Dispose();
    hv_DirectionsShown = 1;
    devThread = new HDevThread(context,
      (HDevThread.ProcCallback) delegate(HDevThread devThreadCB)
    {
      try
      {
        // Input parameters
        HTuple        cbhv_WindowHandle = devThreadCB.GetInputCtrlParamTuple(0);
        HTuple        cbhv_ObjectModel3D = devThreadCB.GetInputCtrlParamTuple(1);
        HTuple        cbhv_CamParam = devThreadCB.GetInputCtrlParamTuple(2);
        HTuple        cbhv_PoseIn = devThreadCB.GetInputCtrlParamTuple(3);
        HTuple        cbhv_GenParamName = devThreadCB.GetInputCtrlParamTuple(4);
        HTuple        cbhv_GenParamValue = devThreadCB.GetInputCtrlParamTuple(5);
        HTuple        cbhv_Title = devThreadCB.GetInputCtrlParamTuple(6);
        HTuple        cbhv_Label = devThreadCB.GetInputCtrlParamTuple(7);
        HTuple        cbhv_Information = devThreadCB.GetInputCtrlParamTuple(8);
        HTuple        cbhv_MessageQueue = devThreadCB.GetInputCtrlParamTuple(9);
        HTuple        cbhv_Buttons = devThreadCB.GetInputCtrlParamTuple(10);
        HTuple        cbhv_Type = devThreadCB.GetInputCtrlParamTuple(11);
        HTuple        cbhv_Message = devThreadCB.GetInputCtrlParamTuple(12);
        HTuple        cbhv_DispViewPoint = devThreadCB.GetInputCtrlParamTuple(13);
        HTuple        cbhv_ViewPoint = devThreadCB.GetInputCtrlParamTuple(14);

        // Call visualize_object_model_3d_ext
        visualize_object_model_3d_ext(cbhv_WindowHandle, cbhv_ObjectModel3D, cbhv_CamParam, 
                cbhv_PoseIn, cbhv_GenParamName, cbhv_GenParamValue, cbhv_Title, cbhv_Label, 
                cbhv_Information, cbhv_MessageQueue, cbhv_Buttons, cbhv_Type, cbhv_Message, 
                cbhv_DispViewPoint, cbhv_ViewPoint);

        // Reduce reference counter of thread object
        devThreadCB.Exit();
        devThreadCB.Dispose();

      }
      catch (HalconException exc)
      {
        // No exceptions may be raised from stub in parallel case,
        // so we need to store this information prior to cleanup
        bool is_direct_call = devThreadCB.IsDirectCall();
        // Attempt to clean up in error case, too
        devThreadCB.Exit();
        devThreadCB.Dispose();
        // Propagate exception if called directly
        if (is_direct_call)
          throw exc;
      }
    },15,0);
    // Set thread procedure call arguments 
    devThread.SetInputCtrlParamTuple(0,hv_WindowHandleVisualization);
    devThread.SetInputCtrlParamTuple(1,((((hv_ObjectModel3D.TupleConcat(
        hv_ObjectModel3D))).TupleConcat(hv_OM3DCamera))).TupleConcat(hv_OM3DLineSphereToModel));
    devThread.SetInputCtrlParamTuple(2,hv_CamParamVis);
    devThread.SetInputCtrlParamTuple(3,hv_PoseEstimated);
    devThread.SetInputCtrlParamTuple(4,((((
        (new HTuple("color_0")).TupleConcat("color_1")).TupleConcat("color_2")).TupleConcat(
        "color_3")).TupleConcat("alpha_0")).TupleConcat("disp_normals_1"));
    devThread.SetInputCtrlParamTuple(5,((((
        (new HTuple("cyan")).TupleConcat("red")).TupleConcat("gray")).TupleConcat(
        "white")).TupleConcat(0.5)).TupleConcat("true"));
    devThread.SetInputCtrlParamTuple(6,new HTuple());
    devThread.SetInputCtrlParamTuple(7,((
        (new HTuple("")).TupleConcat("")).TupleConcat("Viewpoint")).TupleConcat(""));
    devThread.SetInputCtrlParamTuple(8,new HTuple());
    devThread.SetInputCtrlParamTuple(9,hv_MessageQueues2);
    devThread.SetInputCtrlParamTuple(10,hv_Buttons);
    devThread.SetInputCtrlParamTuple(11,new HTuple());
    devThread.SetInputCtrlParamTuple(12,new HTuple());
    devThread.SetInputCtrlParamTuple(13,"false");
    devThread.SetInputCtrlParamTuple(14,new HTuple());

    // Start proc line in thread
    {
    HTuple TmpThreadId;
    devThread.ParStart(out TmpThreadId);
    hvec_TI[1].T = TmpThreadId;
    }

    hv_CurrentState2.Dispose();
    hv_CurrentState2 = new HTuple();
    //
    do
    {
      hv_DidFinish1.Dispose();
      {
      HTuple ExpTmpOutVar_0;hv_ButtonPressed.Dispose();hv_Pose.Dispose();
      process_visualize_events_generic(hv_WindowHandleViewpoint, hv_MessageQueues1, 
          hv_CurrentState1, out hv_DidFinish1, out ExpTmpOutVar_0, out hv_ButtonPressed, 
          out hv_Pose);
      hv_CurrentState1.Dispose();
      hv_CurrentState1 = ExpTmpOutVar_0;
      }
      if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(0))) != 0)
      {
        //Exit button
        break;
      }
      if ((int)(new HTuple(hv_Pose.TupleNotEqual(new HTuple()))) != 0)
      {
        //The pose of view 1 was updated
        //-> Update the viewpoint in view 2
        hv_PoseInvert.Dispose();
        HOperatorSet.PoseInvert(hv_Pose, out hv_PoseInvert);
        hv_Viewpoint.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Viewpoint = hv_PoseInvert.TupleSelectRange(
            0,2);
        }
        //Change the viewpoint such that its distance from the model is always about constant
        hv_Direction.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Direction = hv_Viewpoint-hv_CenterModel;
        }
        hv_Length.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Length = ((((hv_Direction*hv_Direction)).TupleSum()
            )).TupleSqrt();
        }
        hv_Viewpoint.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Viewpoint = hv_CenterModel+(hv_Direction*(hv_DiameterModel/hv_Length));
        }
        //
        if (hv_PoseInvert == null)
          hv_PoseInvert = new HTuple();
        hv_PoseInvert[HTuple.TupleGenSequence(0,2,1)] = hv_Viewpoint;
        //
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OM3DSphere.Dispose();
        gen_camera_object_model_3d(hv_PoseInvert, hv_DiameterModel*0.05, out hv_OM3DSphere);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OM3DLineSphereToModel.Dispose();
        HOperatorSet.GenObjectModel3dFromPoints(((hv_Viewpoint.TupleSelect(0))).TupleConcat(
            hv_CenterModel.TupleSelect(0)), ((hv_Viewpoint.TupleSelect(1))).TupleConcat(
            hv_CenterModel.TupleSelect(1)), ((hv_Viewpoint.TupleSelect(2))).TupleConcat(
            hv_CenterModel.TupleSelect(2)), out hv_OM3DLineSphereToModel);
        }
        HOperatorSet.SetObjectModel3dAttribMod(hv_OM3DLineSphereToModel, "lines", 
            new HTuple(), ((new HTuple(2)).TupleConcat(0)).TupleConcat(1));
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OM3DModelEdges.Dispose();
        HOperatorSet.GetSurfaceModelParam(hv_SurfaceModelID, "edges "+((((hv_Viewpoint-hv_CenterModel)+" ")).TupleSum()
            ), out hv_OM3DModelEdges);
        }
        //
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_EdgeDirs.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_OM3DModelEdges, new HTuple("edge_dir_")+(
            (new HTuple("x")).TupleConcat("y")).TupleConcat("z"), out hv_EdgeDirs);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetObjectModel3dAttribMod(hv_OM3DModelEdges, new HTuple("point_normal_")+(
            (new HTuple("x")).TupleConcat("y")).TupleConcat("z"), new HTuple(), hv_EdgeDirs);
        }
        //
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "replace_object_model");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "index", ((new HTuple(1)).TupleConcat(
            2)).TupleConcat(3));
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "model", ((hv_OM3DModelEdges.TupleConcat(
            hv_OM3DSphere))).TupleConcat(hv_OM3DLineSphereToModel));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
      }

      hv_DidFinish2.Dispose();
      {
      HTuple ExpTmpOutVar_0;hv_ButtonPressed.Dispose();hv_Pose.Dispose();
      process_visualize_events_generic(hv_WindowHandleVisualization, hv_MessageQueues2, 
          hv_CurrentState2, out hv_DidFinish2, out ExpTmpOutVar_0, out hv_ButtonPressed, 
          out hv_Pose);
      hv_CurrentState2.Dispose();
      hv_CurrentState2 = ExpTmpOutVar_0;
      }
      if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_DirectionsShown = hv_DirectionsShown.TupleNot()
            ;
        hv_DirectionsShown.Dispose();
        hv_DirectionsShown = ExpTmpLocalVar_DirectionsShown;
        }
        }
        //Toggle edge direction, using the normal vectors of the edge
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "toggle_param");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "param", "disp_normals_1");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "change_button_text");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "index", 0);
        if ((int)(hv_DirectionsShown) != 0)
        {
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "text", "Hide Edge Directions");
        }
        else
        {
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "text", "Show Edge Directions");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
      }
    }
    while ((int)(hv_DidFinish1.TupleOr(hv_DidFinish2)) == 0);

    //Send termination message to all subthreads
    hv_MessageHandle.Dispose();
    HOperatorSet.CreateMessage(out hv_MessageHandle);
    HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "exit");
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.EnqueueMessage(hv_MessageQueues1.TupleSelect(1), hv_MessageHandle, 
        new HTuple(), new HTuple());
    }
    hv_MessageHandle.Dispose();
    HOperatorSet.CreateMessage(out hv_MessageHandle);
    HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "exit");
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
        new HTuple(), new HTuple());
    }

    //Wait for all subthreads to finish
    hv_TIT = hvec_TI.ConvertVectorToTuple();
    HDevThread.ParJoin(hv_TIT);

    hv_GenParamValue.Dispose();
    hv_Instructions.Dispose();
    hv_MessageQueues1.Dispose();
    hv_Buttons.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_CameraParam.Dispose();
    hv_CurrentState1.Dispose();
    hv_DiameterModel.Dispose();
    hv_CenterModel.Dispose();
    hv_Viewpoint.Dispose();
    hv_OM3DCamera.Dispose();
    hv_OM3DLineSphereToModel.Dispose();
    hv_Center.Dispose();
    hv_PoseInT.Dispose();
    hv_PoseInR.Dispose();
    hv_PoseIn.Dispose();
    hv_CamParamVis.Dispose();
    hv_PoseEstimated.Dispose();
    hv_MessageQueues2.Dispose();
    hv_DirectionsShown.Dispose();
    hv_CurrentState2.Dispose();
    hv_DidFinish1.Dispose();
    hv_ButtonPressed.Dispose();
    hv_Pose.Dispose();
    hv_PoseInvert.Dispose();
    hv_Direction.Dispose();
    hv_Length.Dispose();
    hv_OM3DSphere.Dispose();
    hv_OM3DModelEdges.Dispose();
    hv_EdgeDirs.Dispose();
    hv_MessageHandle.Dispose();
    hv_DidFinish2.Dispose();
    hv_TIT.Dispose();
    hvec_TI.Dispose();

    return;
    }
  }

  public void check_mouse_over_button (HTuple hv_Parameters, HTuple hv_GraphButtonRow, 
      HTuple hv_GraphButtonColumn, out HTuple hv_FoundButton)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_gButtons = new HTuple(), hv_idx = new HTuple();
    // Initialize local and output iconic variables 
    hv_FoundButton = new HTuple();
    hv_gButtons.Dispose();
    HOperatorSet.GetMessageTuple(hv_Parameters, "gButtons", out hv_gButtons);
    hv_FoundButton.Dispose();
    hv_FoundButton = -1;
    for (hv_idx=0; (int)hv_idx<=(int)((new HTuple(hv_gButtons.TupleLength()))-1); hv_idx = (int)hv_idx + 5)
    {
      if ((int)((new HTuple((new HTuple((new HTuple(hv_GraphButtonRow.TupleGreaterEqual(
          (hv_gButtons.TupleSelect(hv_idx+2))-1))).TupleAnd(new HTuple(hv_GraphButtonRow.TupleLessEqual(
          (hv_gButtons.TupleSelect(hv_idx+4))+1))))).TupleAnd(new HTuple(hv_GraphButtonColumn.TupleGreaterEqual(
          (hv_gButtons.TupleSelect(hv_idx+1))-1))))).TupleAnd(new HTuple(hv_GraphButtonColumn.TupleLessEqual(
          (hv_gButtons.TupleSelect(hv_idx+3))+1)))) != 0)
      {
        hv_FoundButton.Dispose();
        hv_FoundButton = new HTuple(hv_idx);
      }
    }

    hv_gButtons.Dispose();
    hv_idx.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  public void check_train_dl_model_params (HTuple hv_DLDataset, HTuple hv_DLModelHandle, 
      HTuple hv_NumTrainSamples, HTuple hv_StartEpoch, HTuple hv_TrainParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_PreprocessedDataset = new HTuple();
    HTuple hv_PreprocessParam = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_NumEpochs = new HTuple(), hv_BatchSize = new HTuple();
    HTuple hv_ClassIDsModel = new HTuple(), hv_ClassIDsDataset = new HTuple();
    HTuple hv_Index = new HTuple(), hv_IndexFind = new HTuple();
    HTuple hv_ClassIDsModelStr = new HTuple(), hv_ClassIDsDatasetStr = new HTuple();
    HTuple hv_TrainParamCopy = new HTuple(), hv__ = new HTuple();
    // Initialize local and output iconic variables 
    //
    //This procedure checks the parameters used in the procedure train_dl_model for consistency.
    //
    //Check the NumEpochs parameter.
    if ((int)(new HTuple(hv_StartEpoch.TupleLess(0.0))) != 0)
    {
      throw new HalconException("Error: StartEpoch < 0 is not allowed.");
    }
    //
    //Check if the dataset is already preprocessed.
    hv_PreprocessedDataset.Dispose();
    hv_PreprocessedDataset = 0;
    try
    {
      hv_PreprocessParam.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "preprocess_param", out hv_PreprocessParam);
      hv_PreprocessedDataset.Dispose();
      hv_PreprocessedDataset = 1;
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
    }
    if ((int)(hv_PreprocessedDataset.TupleNot()) != 0)
    {
      throw new HalconException("Error: The supplied dataset needs to be preprocessed already. Use the standard procedure preprocess_dl_dataset.");
    }
    //
    //Check the NumEpochs parameter.
    hv_NumEpochs.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainParam, "num_epochs", out hv_NumEpochs);
    if ((int)(new HTuple(hv_StartEpoch.TupleGreater(hv_NumEpochs))) != 0)
    {
      throw new HalconException("Error: StartEpoch > NumEpochs is not allowed.");
    }
    //
    //Check that the number of training samples is at least as big as the batch size.
    hv_BatchSize.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
    if ((int)(new HTuple(hv_NumTrainSamples.TupleLess(hv_BatchSize))) != 0)
    {
      throw new HalconException("Error: Number of training samples is smaller than batch size.");
    }
    //
    //Check that all model class IDs are a part of the DLDataset class IDs.
    hv_ClassIDsModel.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDsModel);
    hv_ClassIDsDataset.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDsDataset);
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ClassIDsModel.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IndexFind.Dispose();
      HOperatorSet.TupleFindFirst(hv_ClassIDsDataset, hv_ClassIDsModel.TupleSelect(
          hv_Index), out hv_IndexFind);
      }
      if ((int)(new HTuple(hv_IndexFind.TupleLess(0))) != 0)
      {
        hv_ClassIDsModelStr.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassIDsModelStr = ((" "+hv_ClassIDsModel)).TupleSum()
            ;
        }
        hv_ClassIDsDatasetStr.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassIDsDatasetStr = ((" "+hv_ClassIDsDataset)).TupleSum()
            ;
        }
        throw new HalconException((((("Error: A model class ID is not part of the DLDataset class IDs. DLModelHandle class ID: "+hv_ClassIDsModelStr)+". ")+"DLDataset class IDs: ")+hv_ClassIDsDatasetStr)+".");
      }
    }
    //
    //Initialize change and serialization strategies in order to test for valid values.
    hv_TrainParamCopy.Dispose();
    HOperatorSet.CopyDict(hv_TrainParam, new HTuple(), new HTuple(), out hv_TrainParamCopy);
    hv__.Dispose();
    init_train_dl_model_change_strategies(hv_TrainParamCopy, out hv__);
    hv__.Dispose();
    init_train_dl_model_serialization_strategies(hv_TrainParamCopy, out hv__);
    //

    hv_PreprocessedDataset.Dispose();
    hv_PreprocessParam.Dispose();
    hv_Exception.Dispose();
    hv_NumEpochs.Dispose();
    hv_BatchSize.Dispose();
    hv_ClassIDsModel.Dispose();
    hv_ClassIDsDataset.Dispose();
    hv_Index.Dispose();
    hv_IndexFind.Dispose();
    hv_ClassIDsModelStr.Dispose();
    hv_ClassIDsDatasetStr.Dispose();
    hv_TrainParamCopy.Dispose();
    hv__.Dispose();

    return;
  }

  // Chapter: Calibration / Monocular
  // Short Description: Collect the data to calibrate a camera with a single image. 
  public void collect_single_image_calibration_data (HTuple hv_ImageCaltabFileName, 
      HTuple hv_CalPlateDescr, HTuple hv_CalPlateThickness, HTuple hv_StartCamParam, 
      out HTuple hv_CalibObjectData)
  {



    // Local iconic variables 

    HObject ho_ImageCaltab;

    // Local control variables 

    HTuple hv_FinderRow = new HTuple(), hv_FinderColumn = new HTuple();
    HTuple hv_MarksPerRow = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageCaltab);
    hv_CalibObjectData = new HTuple();
    //
    //Read an image of the calibration plate
    //that is placed in the measurement plane of the robot.
    ho_ImageCaltab.Dispose();
    HOperatorSet.ReadImage(out ho_ImageCaltab, hv_ImageCaltabFileName);
    dev_disp_calibration_data_instructions(ho_ImageCaltab);
    // stop(...); only in hdevelop
    //
    //Specify the finder pattern of the calibration plate you used.
    //The information can usually be found in the used description file.
    hv_FinderRow.Dispose();
    hv_FinderRow = new HTuple();
    hv_FinderRow[0] = 13;
    hv_FinderRow[1] = 6;
    hv_FinderRow[2] = 6;
    hv_FinderRow[3] = 20;
    hv_FinderRow[4] = 20;
    hv_FinderColumn.Dispose();
    hv_FinderColumn = new HTuple();
    hv_FinderColumn[0] = 15;
    hv_FinderColumn[1] = 6;
    hv_FinderColumn[2] = 24;
    hv_FinderColumn[3] = 6;
    hv_FinderColumn[4] = 24;
    //Specify the number of marks per row.
    hv_MarksPerRow.Dispose();
    hv_MarksPerRow = 31;
    //
    //Create output dict.
    hv_CalibObjectData.Dispose();
    HOperatorSet.CreateDict(out hv_CalibObjectData);
    HOperatorSet.SetDictObject(ho_ImageCaltab, hv_CalibObjectData, "ImageCaltab");
    HOperatorSet.SetDictTuple(hv_CalibObjectData, "CalPlateDescr", hv_CalPlateDescr);
    HOperatorSet.SetDictTuple(hv_CalibObjectData, "CalPlateThickness", hv_CalPlateThickness);
    HOperatorSet.SetDictTuple(hv_CalibObjectData, "StartCamParam", hv_StartCamParam);
    HOperatorSet.SetDictTuple(hv_CalibObjectData, "FinderRow", hv_FinderRow);
    HOperatorSet.SetDictTuple(hv_CalibObjectData, "FinderColumn", hv_FinderColumn);
    HOperatorSet.SetDictTuple(hv_CalibObjectData, "MarksPerRow", hv_MarksPerRow);
    ho_ImageCaltab.Dispose();

    hv_FinderRow.Dispose();
    hv_FinderColumn.Dispose();
    hv_MarksPerRow.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Collect the information required for displaying the training progress update. 
  public void collect_train_dl_model_info (HTuple hv_DLModelHandle, HTuple hv_TrainResults, 
      HTuple hv_EvaluationInfos, HTuple hv_EvaluationComparisonKeys, HTuple hv_Iteration, 
      HTuple hv_NumIterations, HTuple hv_NumIterationsPerEpoch, HTuple hv_NumSamplesMeanLoss, 
      out HTuple hv_TrainInfo)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_EpochReal = new HTuple(), hv_NumEpochs = new HTuple();
    HTuple hv_TrainResultsStored = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_PossibleParamNames = new HTuple(), hv_ModelParams = new HTuple();
    HTuple hv_ParamNamesGettable = new HTuple(), hv_Index = new HTuple();
    HTuple hv_ParamName = new HTuple(), hv_GenParamValue = new HTuple();
    HTuple hv_LossSamplesTrainResults = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_TrainResultsUsed = new HTuple(), hv_BatchSize = new HTuple();
    HTuple hv_NumIterationsMean = new HTuple(), hv_LossParam = new HTuple();
    HTuple hv_LossValues = new HTuple(), hv_TrainResult = new HTuple();
    HTuple hv_LossValue = new HTuple(), hv_LossMean = new HTuple();
    HTuple hv_BestEvaluationInfo = new HTuple(), hv_BestEvaluationValue = new HTuple();
    HTuple hv_BestEvaluationKeys = new HTuple(), hv_EvaluationInfo = new HTuple();
    HTuple hv_EvaluationResult = new HTuple(), hv_Value = new HTuple();
    HTuple hv_ValidEvaluationKeys = new HTuple(), hv_BestEvaluationData = new HTuple();
    // Initialize local and output iconic variables 
    hv_TrainInfo = new HTuple();
    //
    //This procedure computes training information for the given iteration.
    //
    hv_TrainInfo.Dispose();
    HOperatorSet.CreateDict(out hv_TrainInfo);
    //
    //General iteration and epoch status.
    hv_EpochReal.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EpochReal = (hv_Iteration+1)/(hv_NumIterationsPerEpoch.TupleReal()
        );
    }
    //Important note:
    //Inside of this procedure, we compute iterations like that:
    //*  IterationTmp := int(round(EpochReal * (NumIterationsPerEpoch))-1)
    //If a caller of this procedure supplies a value we should use:
    //*  IterationTmp := int(floor(EpochReal * NumIterationsPerEpoch))
    //
    hv_NumEpochs.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumEpochs = ((hv_NumIterations/(hv_NumIterationsPerEpoch.TupleReal()
        ))).TupleInt();
    }
    //
    //Note, iterations depend on a specific batch size,
    //hence only epochs are expressive.
    HOperatorSet.SetDictTuple(hv_TrainInfo, "epoch", hv_EpochReal);
    HOperatorSet.SetDictTuple(hv_TrainInfo, "num_epochs", hv_NumEpochs);
    //
    try
    {
      hv_TrainResultsStored.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrainResultsStored = hv_TrainResults.TupleSelect(
          ((hv_TrainResults.TupleNotEqualElem(-1))).TupleFind(1));
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_TrainResultsStored.Dispose();
      hv_TrainResultsStored = new HTuple();
    }
    //
    //Collect all model parameters.
    hv_PossibleParamNames.Dispose();
    HOperatorSet.GetParamInfo("get_dl_model_param", "GenParamName", "value_list", 
        out hv_PossibleParamNames);
    hv_ModelParams.Dispose();
    HOperatorSet.CreateDict(out hv_ModelParams);
    HOperatorSet.SetDictTuple(hv_TrainInfo, "model_params", hv_ModelParams);
    hv_ParamNamesGettable.Dispose();
    hv_ParamNamesGettable = new HTuple();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_PossibleParamNames.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_ParamName.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ParamName = hv_PossibleParamNames.TupleSelect(
          hv_Index);
      }
      //Do not collect summary as it cannot change during training and consumes much space.
      if ((int)(new HTuple(hv_ParamName.TupleEqual("summary"))) != 0)
      {
        continue;
      }
      try
      {
        hv_GenParamValue.Dispose();
        HOperatorSet.GetDlModelParam(hv_DLModelHandle, hv_ParamName, out hv_GenParamValue);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        continue;
      }
      hv_ParamNamesGettable.Dispose();
      hv_ParamNamesGettable = new HTuple(hv_ParamName);
      HOperatorSet.SetDictTuple(hv_ModelParams, hv_ParamName, hv_GenParamValue);
    }
    //
    //Calculate a mean loss value.
    HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss", new HTuple());
    HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss_samples", 0);
    //
    hv_LossSamplesTrainResults.Dispose();
    hv_LossSamplesTrainResults = new HTuple();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Indices.Dispose();
    HOperatorSet.TupleFind(hv_TrainResults.TupleNotEqualElem(-1), 1, out hv_Indices);
    }
    if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
    {
      hv_TrainResultsUsed.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrainResultsUsed = hv_TrainResults.TupleSelect(
          hv_Indices);
      }
    }
    else
    {
      hv_TrainResultsUsed.Dispose();
      hv_TrainResultsUsed = new HTuple();
    }
    if ((int)(new HTuple((new HTuple(hv_TrainResultsUsed.TupleLength())).TupleGreater(
        0))) != 0)
    {
      hv_BatchSize.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
      hv_NumIterationsMean.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumIterationsMean = ((((hv_NumSamplesMeanLoss/(hv_BatchSize.TupleReal()
          ))).TupleCeil())).TupleInt();
      }

      if ((int)(new HTuple(hv_NumIterationsMean.TupleEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TrainResultsUsed = hv_TrainResultsUsed.TupleSelect(
            (new HTuple(hv_TrainResultsUsed.TupleLength()))-1);
        hv_TrainResultsUsed.Dispose();
        hv_TrainResultsUsed = ExpTmpLocalVar_TrainResultsUsed;
        }
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TrainResultsUsed = hv_TrainResultsUsed.TupleSelectRange(
            (((new HTuple(hv_TrainResultsUsed.TupleLength()))-hv_NumIterationsMean)).TupleMax2(
            0),(new HTuple(hv_TrainResultsUsed.TupleLength()))-1);
        hv_TrainResultsUsed.Dispose();
        hv_TrainResultsUsed = ExpTmpLocalVar_TrainResultsUsed;
        }
        }
      }

      hv_LossParam.Dispose();
      hv_LossParam = "total_loss";
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LossValues.Dispose();
      HOperatorSet.TupleGenConst(new HTuple(hv_TrainResultsUsed.TupleLength()), -1, 
          out hv_LossValues);
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_TrainResultsUsed.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        hv_TrainResult.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TrainResult = hv_TrainResultsUsed.TupleSelect(
            hv_Index);
        }
        hv_LossValue.Dispose();
        HOperatorSet.GetDictTuple(hv_TrainResult, hv_LossParam, out hv_LossValue);
        if (hv_LossValues == null)
          hv_LossValues = new HTuple();
        hv_LossValues[hv_Index] = hv_LossValue;
      }
      hv_LossMean.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LossMean = hv_LossValues.TupleMean()
          ;
      }
      HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss", hv_LossMean);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss_samples", new HTuple(hv_LossValues.TupleLength()
          ));
      }
    }
    //
    //Collect the best evaluation infos.
    hv_BestEvaluationInfo.Dispose();
    hv_BestEvaluationInfo = new HTuple();
    hv_BestEvaluationValue.Dispose();
    hv_BestEvaluationValue = new HTuple();
    hv_BestEvaluationKeys.Dispose();
    hv_BestEvaluationKeys = new HTuple();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_EvaluationInfos.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_EvaluationInfo.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EvaluationInfo = hv_EvaluationInfos.TupleSelect(
          hv_Index);
      }
      //Ignore missing infos
      if ((int)(new HTuple(hv_EvaluationInfo.TupleEqual(-1))) != 0)
      {
        continue;
      }
      //
      hv_EvaluationResult.Dispose();
      HOperatorSet.GetDictTuple(hv_EvaluationInfo, "result", out hv_EvaluationResult);
      //
      //Reduce the result to a single (mean) value.
      hv_Value.Dispose();hv_ValidEvaluationKeys.Dispose();
      reduce_dl_evaluation_result(hv_EvaluationResult, hv_EvaluationComparisonKeys, 
          out hv_Value, out hv_ValidEvaluationKeys);
      //
      //Compare evaluation result verses the best.
      if ((int)((new HTuple((new HTuple(hv_BestEvaluationInfo.TupleLength())).TupleEqual(
          0))).TupleOr(new HTuple(hv_Value.TupleGreaterEqual(hv_BestEvaluationValue)))) != 0)
      {
        hv_BestEvaluationInfo.Dispose();
        hv_BestEvaluationInfo = new HTuple(hv_EvaluationInfo);
        hv_BestEvaluationValue.Dispose();
        hv_BestEvaluationValue = new HTuple(hv_Value);
        hv_BestEvaluationKeys.Dispose();
        hv_BestEvaluationKeys = new HTuple(hv_ValidEvaluationKeys);
      }
    }
    //
    //Store best evaluation information.
    if ((int)(new HTuple((new HTuple(hv_BestEvaluationInfo.TupleLength())).TupleGreater(
        0))) != 0)
    {
      hv_BestEvaluationData.Dispose();
      HOperatorSet.CreateDict(out hv_BestEvaluationData);
      HOperatorSet.SetDictTuple(hv_BestEvaluationData, "comparison_keys", hv_BestEvaluationKeys);
      HOperatorSet.SetDictTuple(hv_BestEvaluationData, "best_info", hv_BestEvaluationInfo);
      HOperatorSet.SetDictTuple(hv_BestEvaluationData, "best_value", hv_BestEvaluationValue);
      HOperatorSet.SetDictTuple(hv_TrainInfo, "best_evaluation", hv_BestEvaluationData);
    }
    else
    {
      HOperatorSet.SetDictTuple(hv_TrainInfo, "best_evaluation", new HTuple());
    }

    hv_EpochReal.Dispose();
    hv_NumEpochs.Dispose();
    hv_TrainResultsStored.Dispose();
    hv_Exception.Dispose();
    hv_PossibleParamNames.Dispose();
    hv_ModelParams.Dispose();
    hv_ParamNamesGettable.Dispose();
    hv_Index.Dispose();
    hv_ParamName.Dispose();
    hv_GenParamValue.Dispose();
    hv_LossSamplesTrainResults.Dispose();
    hv_Indices.Dispose();
    hv_TrainResultsUsed.Dispose();
    hv_BatchSize.Dispose();
    hv_NumIterationsMean.Dispose();
    hv_LossParam.Dispose();
    hv_LossValues.Dispose();
    hv_TrainResult.Dispose();
    hv_LossValue.Dispose();
    hv_LossMean.Dispose();
    hv_BestEvaluationInfo.Dispose();
    hv_BestEvaluationValue.Dispose();
    hv_BestEvaluationKeys.Dispose();
    hv_EvaluationInfo.Dispose();
    hv_EvaluationResult.Dispose();
    hv_Value.Dispose();
    hv_ValidEvaluationKeys.Dispose();
    hv_BestEvaluationData.Dispose();

    return;
  }

  // Chapter: Graphics / Parameters
  public void color_string_to_rgb (HTuple hv_Color, out HTuple hv_RGB)
  {



    // Local iconic variables 

    HObject ho_Rectangle, ho_Image;

    // Local control variables 

    HTuple hv_WindowHandleBuffer = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    HOperatorSet.GenEmptyObj(out ho_Image);
    hv_RGB = new HTuple();
    hv_WindowHandleBuffer.Dispose();
    HOperatorSet.OpenWindow(0, 0, 1, 1, 0, "buffer", "", out hv_WindowHandleBuffer);
    HOperatorSet.SetPart(hv_WindowHandleBuffer, 0, 0, -1, -1);
    ho_Rectangle.Dispose();
    HOperatorSet.GenRectangle1(out ho_Rectangle, 0, 0, 0, 0);
    try
    {
      HOperatorSet.SetColor(hv_WindowHandleBuffer, hv_Color);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_Exception.Dispose();
      hv_Exception = "Wrong value of control parameter Color (must be a valid color string)";
      throw new HalconException(hv_Exception);
    }
    HOperatorSet.DispObj(ho_Rectangle, hv_WindowHandleBuffer);
    ho_Image.Dispose();
    HOperatorSet.DumpWindowImage(out ho_Image, hv_WindowHandleBuffer);
    HOperatorSet.CloseWindow(hv_WindowHandleBuffer);
    hv_RGB.Dispose();
    HOperatorSet.GetGrayval(ho_Image, 0, 0, out hv_RGB);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_RGB = hv_RGB+(
        (new HTuple(0)).TupleConcat(0)).TupleConcat(0);
    hv_RGB.Dispose();
    hv_RGB = ExpTmpLocalVar_RGB;
    }
    }
    ho_Rectangle.Dispose();
    ho_Image.Dispose();

    hv_WindowHandleBuffer.Dispose();
    hv_Exception.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Compute the TopK error. 
  public void compute_top_k_error (HTuple hv_DLClassifierHandle, HTuple hv_DLClassifierResultID, 
      HTuple hv_GroundTruthLabels, HTuple hv_Indices, HTuple hv_K, out HTuple hv_TopKError)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumMatches = new HTuple(), hv_GroundTruthLabelsSelected = new HTuple();
    HTuple hv_BatchSize = new HTuple(), hv_IndexLabel = new HTuple();
    HTuple hv_CurrentLabel = new HTuple(), hv_ResultHandleIndex = new HTuple();
    HTuple hv_ResultIndex = new HTuple(), hv_PredictedClasses = new HTuple();
    // Initialize local and output iconic variables 
    hv_TopKError = new HTuple();
    //This procedure compares the GroundtruthLabels
    //with the K inferred classes of highest probability,
    //stored in DLClassifierResultID, and returns the TopKError.
    //Indices defines which images (and thus GroundTruthLabels
    //as well as inference results) are considered.
    hv_NumMatches.Dispose();
    hv_NumMatches = 0;
    //
    //Select the chosen GroundTruthLabels.
    hv_GroundTruthLabelsSelected.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_GroundTruthLabelsSelected = hv_GroundTruthLabels.TupleSelect(
        hv_Indices);
    }
    //
    //Get the batch size from the classifier handle.
    hv_BatchSize.Dispose();
    HOperatorSet.GetDlClassifierParam(hv_DLClassifierHandle, "batch_size", out hv_BatchSize);
    //
    //Loop through all selected ground truth labels.
    for (hv_IndexLabel=0; (int)hv_IndexLabel<=(int)((new HTuple(hv_GroundTruthLabelsSelected.TupleLength()
        ))-1); hv_IndexLabel = (int)hv_IndexLabel + 1)
    {
      //Get ground truth label.
      hv_CurrentLabel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentLabel = hv_GroundTruthLabelsSelected.TupleSelect(
          hv_IndexLabel);
      }
      hv_ResultHandleIndex.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ResultHandleIndex = (((((hv_Indices.TupleSelect(
          hv_IndexLabel))/hv_BatchSize)).TupleFloor())).TupleInt();
      }
      hv_ResultIndex.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ResultIndex = (hv_Indices.TupleSelect(
          hv_IndexLabel))%hv_BatchSize;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PredictedClasses.Dispose();
      HOperatorSet.GetDlClassifierResult(hv_DLClassifierResultID.TupleSelect(hv_ResultHandleIndex), 
          hv_ResultIndex, "predicted_classes", out hv_PredictedClasses);
      }
      //Get the K best results.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PredictedClasses = hv_PredictedClasses.TupleSelectRange(
          0,hv_K-1);
      hv_PredictedClasses.Dispose();
      hv_PredictedClasses = ExpTmpLocalVar_PredictedClasses;
      }
      }
      //Count how often the ground truth label
      //and K predicted classes match.
      if ((int)(new HTuple(((hv_PredictedClasses.TupleFind(hv_CurrentLabel))).TupleNotEqual(
          -1))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_NumMatches = hv_NumMatches+1;
        hv_NumMatches.Dispose();
        hv_NumMatches = ExpTmpLocalVar_NumMatches;
        }
        }
      }
    }
    hv_TopKError.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TopKError = 1.0-((hv_NumMatches.TupleReal()
        )/(new HTuple(hv_GroundTruthLabelsSelected.TupleLength())));
    }

    hv_NumMatches.Dispose();
    hv_GroundTruthLabelsSelected.Dispose();
    hv_BatchSize.Dispose();
    hv_IndexLabel.Dispose();
    hv_CurrentLabel.Dispose();
    hv_ResultHandleIndex.Dispose();
    hv_ResultIndex.Dispose();
    hv_PredictedClasses.Dispose();

    return;
  }

  // Chapter: Identification / Bar Code
  // Short Description: Convert a decoded string of a bar code of type 'Code 39' to the type 'Code 32'. 
  public void convert_decoded_string_code39_to_code32 (HTuple hv_DecodedDataStringCode39, 
      out HTuple hv_ConvertedDataStringCode32)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Symbols = new HTuple(), hv_Digit = new HTuple();
    HTuple hv_CheckDigit = new HTuple(), hv_CheckSum = new HTuple();
    HTuple hv_Value = new HTuple();
    // Initialize local and output iconic variables 
    hv_ConvertedDataStringCode32 = new HTuple();
    //This procedure converts a decoded string of a 'Code 32'
    //barcode that was read with the bar code reader for 'Code 39'
    //to the 'Code 32' decoding.
    //
    //Basically a 'Code 32' bar code corresponds to a 'Code 39' with
    //8 digits and a checksum digit % 10 whereas even positions are
    //weighted twice.
    //The 9-digit number is represented to the base 32 and written
    //with chars (via the symbol table) analogous to a hexadecimal number.
    //
    //Initialize symbol table
    hv_Symbols.Dispose();
    hv_Symbols = new HTuple();
    hv_Symbols[0] = "0";
    hv_Symbols[1] = "1";
    hv_Symbols[2] = "2";
    hv_Symbols[3] = "3";
    hv_Symbols[4] = "4";
    hv_Symbols[5] = "5";
    hv_Symbols[6] = "6";
    hv_Symbols[7] = "7";
    hv_Symbols[8] = "8";
    hv_Symbols[9] = "9";
    hv_Symbols[10] = "B";
    hv_Symbols[11] = "C";
    hv_Symbols[12] = "D";
    hv_Symbols[13] = "F";
    hv_Symbols[14] = "G";
    hv_Symbols[15] = "H";
    hv_Symbols[16] = "J";
    hv_Symbols[17] = "K";
    hv_Symbols[18] = "L";
    hv_Symbols[19] = "M";
    hv_Symbols[20] = "N";
    hv_Symbols[21] = "P";
    hv_Symbols[22] = "Q";
    hv_Symbols[23] = "R";
    hv_Symbols[24] = "S";
    hv_Symbols[25] = "T";
    hv_Symbols[26] = "U";
    hv_Symbols[27] = "V";
    hv_Symbols[28] = "W";
    hv_Symbols[29] = "X";
    hv_Symbols[30] = "Y";
    hv_Symbols[31] = "Z";
    //Check the chars in the decoded 'Code 39' string.
    //It must consist of exactly 6 chars and must not
    //contain any invalid chars. If these conditions are
    //fulfilled, convert the string to 'Code 32', else
    //return an empty string.
    if ((int)(hv_DecodedDataStringCode39.TupleRegexpTest(("^["+(hv_Symbols.TupleSum()
        ))+"]{6}$")) != 0)
    {
      //
      //Convert the value of each digit in the decoded 'Code 39' string
      hv_ConvertedDataStringCode32.Dispose();
      hv_ConvertedDataStringCode32 = 0;
      for (hv_Digit=0; (int)hv_Digit<=5; hv_Digit = (int)hv_Digit + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ConvertedDataStringCode32 = hv_ConvertedDataStringCode32+(hv_Symbols.TupleFind(
            hv_DecodedDataStringCode39.TupleStrBitSelect(hv_Digit)));
        hv_ConvertedDataStringCode32.Dispose();
        hv_ConvertedDataStringCode32 = ExpTmpLocalVar_ConvertedDataStringCode32;
        }
        }
        if ((int)(new HTuple(hv_Digit.TupleLess(5))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ConvertedDataStringCode32 = hv_ConvertedDataStringCode32*32;
          hv_ConvertedDataStringCode32.Dispose();
          hv_ConvertedDataStringCode32 = ExpTmpLocalVar_ConvertedDataStringCode32;
          }
          }
        }
      }
      //Write the converted string as 9 digit string with leading zeros
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ConvertedDataStringCode32 = hv_ConvertedDataStringCode32.TupleString(
          "9.9d");
      hv_ConvertedDataStringCode32.Dispose();
      hv_ConvertedDataStringCode32 = ExpTmpLocalVar_ConvertedDataStringCode32;
      }
      }
      //
      //Verify the checksum (last digit)
      hv_CheckDigit.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CheckDigit = ((hv_ConvertedDataStringCode32.TupleStrBitSelect(
          8))).TupleNumber();
      }
      hv_CheckSum.Dispose();
      hv_CheckSum = 0;
      for (hv_Digit=0; (int)hv_Digit<=7; hv_Digit = (int)hv_Digit + 1)
      {
        //Sum first 8 digits, but even digits have weight 2
        hv_Value.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value = (1+(hv_Digit%2))*(((hv_ConvertedDataStringCode32.TupleStrBitSelect(
            hv_Digit))).TupleNumber());
        }
        //But actually we only want the cross digit sum,
        //This 'formula' works for 0-19
        if ((int)(new HTuple(hv_Value.TupleGreaterEqual(10))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Value = hv_Value-9;
          hv_Value.Dispose();
          hv_Value = ExpTmpLocalVar_Value;
          }
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_CheckSum = hv_CheckSum+hv_Value;
        hv_CheckSum.Dispose();
        hv_CheckSum = ExpTmpLocalVar_CheckSum;
        }
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_CheckSum = hv_CheckSum%10;
      hv_CheckSum.Dispose();
      hv_CheckSum = ExpTmpLocalVar_CheckSum;
      }
      }
      //
      //If the checksum fits, return the converted 'Code 32' string,
      //else return an empty string
      if ((int)(new HTuple(hv_CheckDigit.TupleNotEqual(hv_CheckSum))) != 0)
      {
        //Bad checksum
        hv_ConvertedDataStringCode32.Dispose();
        hv_ConvertedDataStringCode32 = "";
      }
      else
      {
        //Always printed with leading A
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ConvertedDataStringCode32 = "A"+hv_ConvertedDataStringCode32;
        hv_ConvertedDataStringCode32.Dispose();
        hv_ConvertedDataStringCode32 = ExpTmpLocalVar_ConvertedDataStringCode32;
        }
        }
      }
    }
    else
    {
      //Wrong number of chars or invalid chars
      hv_ConvertedDataStringCode32.Dispose();
      hv_ConvertedDataStringCode32 = "";
    }

    hv_Symbols.Dispose();
    hv_Digit.Dispose();
    hv_CheckDigit.Dispose();
    hv_CheckSum.Dispose();
    hv_Value.Dispose();

    return;
    //
  }

  // Chapter: Deep Learning / Model
  // Short Description: Creates a dictionary with preprocessing parameters. 
  public void create_dl_preprocess_param (HTuple hv_DLModelType, HTuple hv_ImageWidth, 
      HTuple hv_ImageHeight, HTuple hv_ImageNumChannels, HTuple hv_ImageRangeMin, 
      HTuple hv_ImageRangeMax, HTuple hv_ContrastNormalization, HTuple hv_DomainHandling, 
      HTuple hv_IgnoreClassIDs, HTuple hv_SetBackgroundID, HTuple hv_ClassIDsBackground, 
      HTuple hv_GenParam, out HTuple hv_DLPreprocessParam)
  {



    // Local control variables 

    HTuple hv_GenParamNames = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_GenParamValue = new HTuple();
    // Initialize local and output iconic variables 
    hv_DLPreprocessParam = new HTuple();
    //
    //This procedure creates a dictionary with all parameters needed for preprocessing.
    //
    //Additional parameters can be specified via the dictionary GenParam.
    //Note, that no generic parameters are supported yet.
    //The following check is provided for future implementations of parameters.
    //Check generic parameters.
    if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_GenParamNames.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
      for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamNames.TupleLength()
          ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
      {
        throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamNames.TupleSelect(
            hv_GenParamIndex)))+"'");
      }
    }
    //
    hv_DLPreprocessParam.Dispose();
    HOperatorSet.CreateDict(out hv_DLPreprocessParam);
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "model_type", hv_DLModelType);
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_width", hv_ImageWidth);
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_height", hv_ImageHeight);
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_num_channels", hv_ImageNumChannels);
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_min", hv_ImageRangeMin);
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_max", hv_ImageRangeMax);
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "contrast_normalization", hv_ContrastNormalization);
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "domain_handling", hv_DomainHandling);
    //
    //Set segmentation specific parameters.
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", hv_IgnoreClassIDs);
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "set_background_id", hv_SetBackgroundID);
    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "class_ids_background", hv_ClassIDsBackground);
    //
    //Set generic parameters.
    if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_GenParamNames.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
      for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamNames.TupleLength()
          ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GenParamValue.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamNames.TupleSelect(hv_GenParamIndex), 
            out hv_GenParamValue);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, hv_GenParamNames.TupleSelect(
            hv_GenParamIndex), hv_GenParamValue);
        }
      }
    }
    //
    //Check the validity of the preprocessing parameters.
    check_dl_preprocess_param(hv_DLPreprocessParam);

    hv_GenParamNames.Dispose();
    hv_GenParamIndex.Dispose();
    hv_GenParamValue.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Creates a dictionary with the preprocessing parameters based on a given DL model. 
  public void create_dl_preprocess_param_from_model (HTuple hv_DLModelHandle, HTuple hv_ContrastNormalization, 
      HTuple hv_DomainHandling, HTuple hv_SetBackgroundID, HTuple hv_ClassIDsBackground, 
      HTuple hv_GenParam, out HTuple hv_DLPreprocessParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ModelType = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_ImageNumChannels = new HTuple();
    HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
    HTuple hv_IgnoreClassIDs = new HTuple();
    // Initialize local and output iconic variables 
    hv_DLPreprocessParam = new HTuple();
    //
    //This procedure creates a dictionary with all parameters needed for preprocessing
    //according to a model provided through DLModelHandle.
    //
    //Get the relevant model parameters.
    hv_ModelType.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
    hv_ImageWidth.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_width", out hv_ImageWidth);
    hv_ImageHeight.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_height", out hv_ImageHeight);
    hv_ImageNumChannels.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_num_channels", out hv_ImageNumChannels);
    hv_ImageRangeMin.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_range_min", out hv_ImageRangeMin);
    hv_ImageRangeMax.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_range_max", out hv_ImageRangeMax);
    //Get segmentation specific parameters.
    if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
    {
      hv_IgnoreClassIDs.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_class_ids", out hv_IgnoreClassIDs);
    }
    else
    {
      hv_IgnoreClassIDs.Dispose();
      hv_IgnoreClassIDs = new HTuple();
    }
    //Create the dictionary with the preprocessing parameters returned by this procedure.
    hv_DLPreprocessParam.Dispose();
    create_dl_preprocess_param(hv_ModelType, hv_ImageWidth, hv_ImageHeight, hv_ImageNumChannels, 
        hv_ImageRangeMin, hv_ImageRangeMax, hv_ContrastNormalization, hv_DomainHandling, 
        hv_IgnoreClassIDs, hv_SetBackgroundID, hv_ClassIDsBackground, hv_GenParam, 
        out hv_DLPreprocessParam);

    hv_ModelType.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_ImageNumChannels.Dispose();
    hv_ImageRangeMin.Dispose();
    hv_ImageRangeMax.Dispose();
    hv_IgnoreClassIDs.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Create a training parameter dictionary which is used in train_dl_model. 
  public void create_dl_train_param (HTuple hv_DLModelHandle, HTuple hv_NumEpochs, 
      HTuple hv_EvaluationIntervalEpochs, HTuple hv_EnableDisplay, HTuple hv_SeedRand, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, out HTuple hv_TrainParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_AvailableGenParam = new HTuple();
    HTuple hv_IndexGenParam = new HTuple(), hv_IndexFind = new HTuple();
    HTuple hv_ModelType = new HTuple(), hv_EvaluationParam = new HTuple();
    HTuple hv_AugmentationParam = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_ChangeStrategies = new HTuple(), hv_SerializationStrategy = new HTuple();
    HTuple hv_SerializationStrategies = new HTuple(), hv_Seconds = new HTuple();
    HTuple hv_IsString = new HTuple(), hv_DisplayParam = new HTuple();
    HTuple hv_NumImagesPreview = new HTuple(), hv_StatusModelParamNames = new HTuple();
    HTuple hv_TiledParamDict = new HTuple(), hv_EvaluationComparisonKeys = new HTuple();
    HTuple   hv_EnableDisplay_COPY_INP_TMP = new HTuple(hv_EnableDisplay);
    HTuple   hv_SeedRand_COPY_INP_TMP = new HTuple(hv_SeedRand);

    // Initialize local and output iconic variables 
    hv_TrainParam = new HTuple();
    //
    //This procedure creates a dictionary with all needed training parameters,
    //as required by train_dl_model as input.
    //
    //Check length of input GenParam tuple.
    if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleNotEqual(
        new HTuple(hv_GenParamValue.TupleLength())))) != 0)
    {
      throw new HalconException("GenParamName and GenParamValue have to have the same length.");
    }
    //Check if the given GenParamName strings are available.
    hv_AvailableGenParam.Dispose();
    hv_AvailableGenParam = new HTuple();
    hv_AvailableGenParam[0] = "evaluate";
    hv_AvailableGenParam[1] = "augment";
    hv_AvailableGenParam[2] = "change";
    hv_AvailableGenParam[3] = "serialize";
    for (hv_IndexGenParam=0; (int)hv_IndexGenParam<=(int)((new HTuple(hv_GenParamName.TupleLength()
        ))-1); hv_IndexGenParam = (int)hv_IndexGenParam + 1)
    {
      hv_IndexFind.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IndexFind = hv_AvailableGenParam.TupleFind(
          hv_GenParamName.TupleSelect(hv_IndexGenParam));
      }
      if ((int)(new HTuple(hv_IndexFind.TupleEqual(-1))) != 0)
      {
        throw new HalconException(("The provided GenParamName "+(hv_GenParamName.TupleSelect(
            hv_IndexGenParam)))+" is invalid.");
      }
    }
    //
    //Initialize the dictionary that holds all train parameters.
    hv_TrainParam.Dispose();
    HOperatorSet.CreateDict(out hv_TrainParam);
    //
    //Some default parameters depend on model type.
    hv_ModelType.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
    //
    //** User supplied parameters: ***
    //
    //Number of epochs to train the model on the train split of the dataset.
    HOperatorSet.SetDictTuple(hv_TrainParam, "num_epochs", hv_NumEpochs);
    //
    //Interval (in epochs) to evaluate the model on the validation split of the dataset.
    HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_interval_epochs", hv_EvaluationIntervalEpochs);
    //
    //Evaluation parameter passed to evaluate_dl_model during evaluation.
    hv_EvaluationParam.Dispose();
    get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "evaluate", out hv_EvaluationParam);
    HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_param", hv_EvaluationParam);
    //
    //Augmentation parameter passed to augment_dl_samples during training.
    hv_AugmentationParam.Dispose();
    get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "augment", out hv_AugmentationParam);
    HOperatorSet.SetDictTuple(hv_TrainParam, "augmentation_param", hv_AugmentationParam);
    //
    //Change strategies for any parameters that need to be changed during training.
    hv_Indices.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Indices = hv_GenParamName.TupleFind(
        "change");
    }
    if ((int)((new HTuple((new HTuple(hv_Indices.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_Indices.TupleEqual(-1)))) != 0)
    {
      //Set a default in case no value is provided.
      hv_ChangeStrategies.Dispose();
      hv_ChangeStrategies = new HTuple();
    }
    else
    {
      //Set user provided values.
      hv_ChangeStrategies.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ChangeStrategies = hv_GenParamValue.TupleSelect(
          hv_Indices);
      }
    }
    HOperatorSet.SetDictTuple(hv_TrainParam, "change_strategies", hv_ChangeStrategies);
    //
    //Serialization strategies used during training.
    hv_Indices.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Indices = hv_GenParamName.TupleFind(
        "serialize");
    }
    if ((int)((new HTuple((new HTuple(hv_Indices.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_Indices.TupleEqual(-1)))) != 0)
    {
      //Set a default in case no value is provided.
      hv_SerializationStrategy.Dispose();
      HOperatorSet.CreateDict(out hv_SerializationStrategy);
      HOperatorSet.SetDictTuple(hv_SerializationStrategy, "type", "best");
      HOperatorSet.SetDictTuple(hv_SerializationStrategy, "basename", "model_best");
      hv_SerializationStrategies.Dispose();
      hv_SerializationStrategies = new HTuple(hv_SerializationStrategy);
    }
    else
    {
      //Set user provided values.
      hv_SerializationStrategies.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SerializationStrategies = hv_GenParamValue.TupleSelect(
          hv_Indices);
      }
    }
    HOperatorSet.SetDictTuple(hv_TrainParam, "serialization_strategies", hv_SerializationStrategies);
    //
    //Get random seed or set a useful default value.
    if ((int)(new HTuple((new HTuple(hv_SeedRand_COPY_INP_TMP.TupleLength())).TupleGreater(
        0))) != 0)
    {
      HOperatorSet.SetDictTuple(hv_TrainParam, "seed_rand", hv_SeedRand_COPY_INP_TMP);
    }
    else
    {
      //If no random seed is given we will use system time as a default.
      hv_Seconds.Dispose();
      HOperatorSet.CountSeconds(out hv_Seconds);
      hv_SeedRand_COPY_INP_TMP.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SeedRand_COPY_INP_TMP = hv_Seconds.TupleInt()
          ;
      }
      HOperatorSet.SetDictTuple(hv_TrainParam, "seed_rand", hv_SeedRand_COPY_INP_TMP);
    }
    //
    //** Display parameters: ***
    //
    //Check the enable display parameter.
    hv_IsString.Dispose();
    HOperatorSet.TupleIsString(hv_EnableDisplay_COPY_INP_TMP, out hv_IsString);
    if ((int)(hv_IsString) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_EnableDisplay = new HTuple(hv_EnableDisplay_COPY_INP_TMP.TupleEqual(
          "true"));
      hv_EnableDisplay_COPY_INP_TMP.Dispose();
      hv_EnableDisplay_COPY_INP_TMP = ExpTmpLocalVar_EnableDisplay;
      }
      }
    }
    else
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_EnableDisplay = new HTuple(hv_EnableDisplay_COPY_INP_TMP.TupleEqual(
          1));
      hv_EnableDisplay_COPY_INP_TMP.Dispose();
      hv_EnableDisplay_COPY_INP_TMP = ExpTmpLocalVar_EnableDisplay;
      }
      }
    }
    //Create the parameter dict.
    hv_DisplayParam.Dispose();
    HOperatorSet.CreateDict(out hv_DisplayParam);
    HOperatorSet.SetDictTuple(hv_DisplayParam, "enabled", hv_EnableDisplay_COPY_INP_TMP);
    if ((int)(hv_EnableDisplay_COPY_INP_TMP) != 0)
    {
      //Set default values. You might want to change them after this procedure call.
      if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
      {
        hv_NumImagesPreview.Dispose();
        hv_NumImagesPreview = 4;
      }
      else
      {
        hv_NumImagesPreview.Dispose();
        hv_NumImagesPreview = 2;
      }
      //
      //Number of images to display in the images preview.
      HOperatorSet.SetDictTuple(hv_DisplayParam, "num_images", hv_NumImagesPreview);
      //
      //If true, at each update new random images from validation set are chosen.
      HOperatorSet.SetDictTuple(hv_DisplayParam, "randomize_images", 1);
      //
      //Interval (in epochs) to update the images preview.
      HOperatorSet.SetDictTuple(hv_DisplayParam, "update_images_interval_epochs", 
          0.5);
      //
      //Interval (in seconds) to switch between plots.
      HOperatorSet.SetDictTuple(hv_DisplayParam, "change_plot_interval_seconds", 
          10);
      //
      //These model parameters are displayed in the text window if available.
      hv_StatusModelParamNames.Dispose();
      hv_StatusModelParamNames = new HTuple();
      hv_StatusModelParamNames[0] = "learning_rate";
      hv_StatusModelParamNames[1] = "batch_size";
      hv_StatusModelParamNames[2] = "momentum";
      hv_StatusModelParamNames[3] = "weight_prior";
      hv_StatusModelParamNames[4] = "image_dimensions";
      HOperatorSet.SetDictTuple(hv_DisplayParam, "status_model_params", hv_StatusModelParamNames);
      //
      //Tiled images parameter dict. Note, this is passed to a standard procedure
      //dev_display_dl_data_tiled and any valid entries are passed.
      //Otherwise, defaults are set within the train_dl_model procedure.
      hv_TiledParamDict.Dispose();
      HOperatorSet.CreateDict(out hv_TiledParamDict);
      HOperatorSet.SetDictTuple(hv_DisplayParam, "tiled_param", hv_TiledParamDict);
    }
    HOperatorSet.SetDictTuple(hv_TrainParam, "display_param", hv_DisplayParam);
    //
    //** Generic internal defaults: ***
    //
    //Default update interval (in seconds) of TrainInfo calculation and text/plot updates
    //in case display is enabled.
    HOperatorSet.SetDictTuple(hv_TrainParam, "update_interval_seconds", 2);
    //
    //Evaluation comparison keys. Note, that internally only those keys apply which
    //are really available. No error is thrown as long as a valid key is given.
    //Hence, we use the major defaults here for detection ('mean_ap') and segmentation ('mean_io').
    hv_EvaluationComparisonKeys.Dispose();
    hv_EvaluationComparisonKeys = new HTuple();
    if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
    {
      hv_EvaluationComparisonKeys.Dispose();
      hv_EvaluationComparisonKeys = "mean_iou";
    }
    else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
    {
      hv_EvaluationComparisonKeys.Dispose();
      hv_EvaluationComparisonKeys = "mean_ap";
    }
    HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_comparison_keys", hv_EvaluationComparisonKeys);
    //
    //Number of samples used to average the loss during training. Note, this is used for display
    //and information calculation only and does not have an effect on training the model.
    HOperatorSet.SetDictTuple(hv_TrainParam, "num_samples_mean_loss", 1000);
    //

    hv_EnableDisplay_COPY_INP_TMP.Dispose();
    hv_SeedRand_COPY_INP_TMP.Dispose();
    hv_AvailableGenParam.Dispose();
    hv_IndexGenParam.Dispose();
    hv_IndexFind.Dispose();
    hv_ModelType.Dispose();
    hv_EvaluationParam.Dispose();
    hv_AugmentationParam.Dispose();
    hv_Indices.Dispose();
    hv_ChangeStrategies.Dispose();
    hv_SerializationStrategy.Dispose();
    hv_SerializationStrategies.Dispose();
    hv_Seconds.Dispose();
    hv_IsString.Dispose();
    hv_DisplayParam.Dispose();
    hv_NumImagesPreview.Dispose();
    hv_StatusModelParamNames.Dispose();
    hv_TiledParamDict.Dispose();
    hv_EvaluationComparisonKeys.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Generate a dictionary EvalParams, which contains default values for evaluation parameters. 
  public void create_evaluation_default_param (HTuple hv_EvaluationType, HTuple hv_ClassIDsModel, 
      out HTuple hv_EvalParams)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_EvaluateInstances = new HTuple();
    HTuple hv_AvailableEvaluationTypes = new HTuple(), hv_EvaluationTypesStr = new HTuple();
    HTuple hv_AreaRanges = new HTuple(), hv_AllocationBlockLength = new HTuple();
    HTuple hv_Measures = new HTuple();
    // Initialize local and output iconic variables 
    hv_EvalParams = new HTuple();
    //
    //This procedure generates a dictionary EvalParams,
    //which contains default values for evaluation parameters.
    //Depending on the evaluation type, the corresponding default parameters and values are set.
    //The class IDs that the model can predict must be given via ClassIDsModel.
    //
    //Check inputs.
    hv_EvaluateInstances.Dispose();
    hv_EvaluateInstances = 0;
    hv_AvailableEvaluationTypes.Dispose();
    hv_AvailableEvaluationTypes = new HTuple();
    hv_AvailableEvaluationTypes[0] = "segmentation";
    hv_AvailableEvaluationTypes[1] = "detection";
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EvaluationTypesStr.Dispose();
    HOperatorSet.TupleGenConst((2*(new HTuple(hv_AvailableEvaluationTypes.TupleLength()
        )))-1, new HTuple("','"), out hv_EvaluationTypesStr);
    }
    if (hv_EvaluationTypesStr == null)
      hv_EvaluationTypesStr = new HTuple();
    hv_EvaluationTypesStr[HTuple.TupleGenSequence(0,new HTuple(hv_EvaluationTypesStr.TupleLength()
        ),2)] = hv_AvailableEvaluationTypes;
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_EvaluationTypesStr = hv_EvaluationTypesStr.TupleSum()
        ;
    hv_EvaluationTypesStr.Dispose();
    hv_EvaluationTypesStr = ExpTmpLocalVar_EvaluationTypesStr;
    }
    }
    if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
    {
      hv_EvaluateInstances.Dispose();
      hv_EvaluateInstances = 0;
    }
    else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
    {
      hv_EvaluateInstances.Dispose();
      hv_EvaluateInstances = 1;
    }
    else
    {
      throw new HalconException(((("Unknown evaluation_type: "+hv_EvaluationType)+". Choose one of ['")+hv_EvaluationTypesStr)+"']");
    }
    if ((int)(new HTuple((new HTuple(hv_ClassIDsModel.TupleLength())).TupleLess(1))) != 0)
    {
      throw new HalconException("ClassIDsModel should have at least one entry");
    }
    //
    //Initialize EvalParams.
    hv_EvalParams.Dispose();
    HOperatorSet.CreateDict(out hv_EvalParams);
    HOperatorSet.SetDictTuple(hv_EvalParams, "evaluation_type", hv_EvaluationType);
    HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_instances", hv_EvaluateInstances);
    //
    //Set the class IDs.
    HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_ClassIDsModel);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_ClassIDsModel.TupleLength()
        ));
    }
    //
    if ((int)(hv_EvaluateInstances) != 0)
    {
      //Set instance-specific default values.
      //
      //Generate ten IoU-thresholds from 0.5 to 0.95 in steps of 0.05.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", HTuple.TupleGenSequence(
          0.5,0.96,0.05));
      }
      //Set maximal number of detections to -1, i.e. all results per image will be evaluated.
      HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", -1);
      //Set default area range named 'all', thus areas from 0 to a value larger than all likely occurring values.
      hv_AreaRanges.Dispose();
      HOperatorSet.CreateDict(out hv_AreaRanges);
      HOperatorSet.SetDictTuple(hv_AreaRanges, "name", "all");
      HOperatorSet.SetDictTuple(hv_AreaRanges, "min", 0);
      HOperatorSet.SetDictTuple(hv_AreaRanges, "max", 2e8);
      HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
      //Some tuples are changing their length during the evaluation. As this slows down the
      //evaluation process they are allocated in blocks of AllocationBlockLength.
      hv_AllocationBlockLength.Dispose();
      hv_AllocationBlockLength = 200;
      HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
      //Detailed evaluation is not switched on per default, as it slows down the evaluation-process.
      HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", 0);
    }
    else
    {
      //
      //Per default there are no ignored classes.
      HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", new HTuple());
      //
    }
    //
    //Measures to be evaluated.
    if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
    {
      //Set default instance measures.
      hv_Measures.Dispose();
      hv_Measures = "mean_ap";
      //Set the instance type to rectangle1.
      HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", "rectangle1");
    }
    else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
    {
      //Set default pixel measures.
      hv_Measures.Dispose();
      hv_Measures = new HTuple();
      hv_Measures[0] = "pixel_accuracy";
      hv_Measures[1] = "mean_accuracy";
      hv_Measures[2] = "mean_iou";
    }
    //
    HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures);
    //

    hv_EvaluateInstances.Dispose();
    hv_AvailableEvaluationTypes.Dispose();
    hv_EvaluationTypesStr.Dispose();
    hv_AreaRanges.Dispose();
    hv_AllocationBlockLength.Dispose();
    hv_Measures.Dispose();

    return;
  }

  public void create_visualization_message_queues (out HTuple hv_MessageQueues)
  {


    // Local iconic variables 

    // Local control variables 

    HTuple hv_QueueHandleInMouse = new HTuple();
    HTuple hv_QueueHandleInEvents = new HTuple(), hv_QueueHandleOut = new HTuple();
    // Initialize local and output iconic variables 
    hv_MessageQueues = new HTuple();
    hv_QueueHandleInMouse.Dispose();
    HOperatorSet.CreateMessageQueue(out hv_QueueHandleInMouse);
    hv_QueueHandleInEvents.Dispose();
    HOperatorSet.CreateMessageQueue(out hv_QueueHandleInEvents);
    hv_QueueHandleOut.Dispose();
    HOperatorSet.CreateMessageQueue(out hv_QueueHandleOut);
    HOperatorSet.SetMessageQueueParam(hv_QueueHandleInMouse, "max_message_num", 1);
    hv_MessageQueues.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MessageQueues = new HTuple();
    hv_MessageQueues = hv_MessageQueues.TupleConcat(hv_QueueHandleInMouse, hv_QueueHandleInEvents, hv_QueueHandleOut);
    }

    hv_QueueHandleInMouse.Dispose();
    hv_QueueHandleInEvents.Dispose();
    hv_QueueHandleOut.Dispose();

    return;

  }

  // Chapter: 3D Matching / Surface-Based
  // Short Description: Inspect the parameters for surface-based matching. 
  public void debug_find_surface_model (HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3DModel, 
      HTuple hv_ObjectModel3DScene, HTuple hv_SurfaceMatchingResultID, out HTuple hv_CreateSurfaceModelParamName, 
      out HTuple hv_CreateSurfaceModelParamValue, out HTuple hv_FindSurfaceModelParamName, 
      out HTuple hv_FindSurfaceModelParamValue)
  {



    // Local iconic variables 

    HObject ho_MenuRegions;

    // Local control variables 

    HTuple hv_WindowScaling = new HTuple(), hv_WindowSize = new HTuple();
    HTuple hv_FontSize = new HTuple(), hv_WidthMenu = new HTuple();
    HTuple hv_HeightMenu = new HTuple(), hv_WindowHandleMenu = new HTuple();
    HTuple hv_WindowHandle1 = new HTuple(), hv_WindowHandle2 = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_HasEdges = new HTuple(), hv_MenuText = new HTuple();
    HTuple hv_MenuCode = new HTuple(), hv_TopBottom = new HTuple();
    HTuple hv_NumCols = new HTuple(), hv_NumRows = new HTuple();
    HTuple hv_PercentageHeight = new HTuple(), hv_CheckedCase = new HTuple();
    HTuple hv_Case = new HTuple(), hv_RowButtons0 = new HTuple();
    HTuple hv_ColumnButtons0 = new HTuple(), hv_RowButtons1 = new HTuple();
    HTuple hv_ColumnButtons1 = new HTuple(), hv_MenuBottom = new HTuple();
    HTuple hv_RelSamplingDistance = new HTuple(), hv_KeyPointFraction = new HTuple();
    HTuple hv_MinScore = new HTuple(), hv_GenParamNames = new HTuple();
    HTuple hv_GenParamValues = new HTuple(), hv_NumPoses = new HTuple();
    HTuple hv_Pose = new HTuple(), hv_Score = new HTuple();
    HTuple hv_Index = new HTuple(), hv_CurrPose = new HTuple();
    HTuple hv_CurrScore = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_CasesDone = new HTuple(), hv_CurrentCase = new HTuple();
    HTuple hv_MaxGap = new HTuple(), hv_MinAmplitudeAbs = new HTuple();
    HTuple hv_Viewpoint = new HTuple(), hv_LastException = new HTuple();
    HTuple hv_UserProvidedEdges = new HTuple(), hv_ModelDiameter = new HTuple();
    HTuple hv_ViewpointStr = new HTuple(), hv_MinAmplitudeRel = new HTuple();
    HTuple hv_OM3DProvidedEdges = new HTuple(), hv_NormalParamsSet = new HTuple();
    HTuple hv_ErrorMessage = new HTuple(), hv_Message = new HTuple();
    HTuple hv_CreateName = new HTuple(), hv_CreateValue = new HTuple();
    HTuple hv_FindNames = new HTuple(), hv_FindValues = new HTuple();
    HTuple hv_EdgeParamsSet = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_MenuRegions);
    hv_CreateSurfaceModelParamName = new HTuple();
    hv_CreateSurfaceModelParamValue = new HTuple();
    hv_FindSurfaceModelParamName = new HTuple();
    hv_FindSurfaceModelParamValue = new HTuple();
    //Please adjust the WindowScaling parameter in order to zoom the window size as desired
    hv_WindowScaling.Dispose();
    hv_WindowScaling = 1.2;
    //
    hv_WindowSize.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowSize = ((512*hv_WindowScaling)).TupleInt()
        ;
    }
    hv_FontSize.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_FontSize = 13.5*hv_WindowScaling;
    }
    //
    hv_WidthMenu.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WidthMenu = hv_WindowSize*2;
    }
    hv_HeightMenu.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HeightMenu = hv_WindowSize/3;
    }
    //
    HOperatorSet.SetWindowAttr("background_color","black");
    HOperatorSet.OpenWindow(0,0,hv_WidthMenu,hv_HeightMenu,0,"visible","",out hv_WindowHandleMenu);
    HDevWindowStack.Push(hv_WindowHandleMenu);
    hv_WindowHandle1.Dispose();
    hv_WindowHandle1 = new HTuple();
    hv_WindowHandle2.Dispose();
    hv_WindowHandle2 = new HTuple();
    //
    hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandleMenu, out hv_Row, out hv_Column, 
        out hv_Width, out hv_Height);
    set_display_font(hv_WindowHandleMenu, hv_FontSize, "mono", "true", "false");
    //
    //Define the entries in the menu
    hv_HasEdges.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModelID, "3d_edges_trained", out hv_HasEdges);
    if ((int)(new HTuple((new HTuple(hv_SurfaceMatchingResultID.TupleLength())).TupleEqual(
        0))) != 0)
    {
      if ((int)(new HTuple(hv_HasEdges.TupleEqual("true"))) != 0)
      {
        hv_MenuText.Dispose();
        hv_MenuText = new HTuple();
        hv_MenuText[0] = "Automatic Value Check";
        hv_MenuText[1] = "Inspect Model Edges";
        hv_MenuText[2] = "Exit";
        hv_MenuCode.Dispose();
        hv_MenuCode = new HTuple();
        hv_MenuCode[0] = "check";
        hv_MenuCode[1] = "model_edges";
        hv_MenuCode[2] = "exit";
      }
      else
      {
        hv_MenuText.Dispose();
        hv_MenuText = new HTuple();
        hv_MenuText[0] = "Automatic Value Check";
        hv_MenuText[1] = "Normal Directions";
        hv_MenuText[2] = "Exit";
        hv_MenuCode.Dispose();
        hv_MenuCode = new HTuple();
        hv_MenuCode[0] = "check";
        hv_MenuCode[1] = "normals";
        hv_MenuCode[2] = "exit";
      }
    }
    else
    {
      if ((int)(new HTuple(hv_HasEdges.TupleEqual("true"))) != 0)
      {
        hv_MenuText.Dispose();
        hv_MenuText = new HTuple();
        hv_MenuText[0] = "Automatic Value Check";
        hv_MenuText[1] = "Inspect Model Edges";
        hv_MenuText[2] = "Normal Directions";
        hv_MenuText[3] = "3D Edge Extraction";
        hv_MenuText[4] = "3D Edge Directions";
        hv_MenuText[5] = "Matching Results";
        hv_MenuText[6] = "Exit";
        hv_MenuCode.Dispose();
        hv_MenuCode = new HTuple();
        hv_MenuCode[0] = "check";
        hv_MenuCode[1] = "model_edges";
        hv_MenuCode[2] = "normals";
        hv_MenuCode[3] = "scene_edge_params";
        hv_MenuCode[4] = "scene_edge_dirs";
        hv_MenuCode[5] = "results";
        hv_MenuCode[6] = "exit";
      }
      else
      {
        hv_MenuText.Dispose();
        hv_MenuText = new HTuple();
        hv_MenuText[0] = "Automatic Value Check";
        hv_MenuText[1] = "Normal Directions";
        hv_MenuText[2] = "Matching Results";
        hv_MenuText[3] = "Exit";
        hv_MenuCode.Dispose();
        hv_MenuCode = new HTuple();
        hv_MenuCode[0] = "check";
        hv_MenuCode[1] = "normals";
        hv_MenuCode[2] = "results";
        hv_MenuCode[3] = "exit";
      }
    }
    //Generate the menu buttons
    hv_TopBottom.Dispose();
    hv_TopBottom = "top";
    hv_NumCols.Dispose();
    hv_NumCols = 4;
    hv_NumRows.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumRows = 1+(((new HTuple(hv_MenuText.TupleLength()
        ))-1)/hv_NumCols);
    }
    hv_PercentageHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PercentageHeight = 20*hv_NumRows;
    }
    hv_CheckedCase.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CheckedCase = hv_NumCols+1;
    }
    hv_Case.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Case = hv_NumCols+1;
    }
    ho_MenuRegions.Dispose();
    gen_menu_regions_ext(out ho_MenuRegions, hv_TopBottom, hv_WindowHandleMenu, hv_PercentageHeight, 
        hv_NumRows, hv_NumCols);
    //
    hv_RowButtons0.Dispose();hv_ColumnButtons0.Dispose();hv_RowButtons1.Dispose();hv_ColumnButtons1.Dispose();
    HOperatorSet.SmallestRectangle1(ho_MenuRegions, out hv_RowButtons0, out hv_ColumnButtons0, 
        out hv_RowButtons1, out hv_ColumnButtons1);
    hv_MenuBottom.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MenuBottom = hv_RowButtons1.TupleMax()
        ;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetTposition(hv_WindowHandleMenu, hv_MenuBottom+6, 1);
    }
    write_note(hv_WindowHandleMenu, "instruction", "Handlungsanweisung");
    //
    if ((int)(new HTuple((new HTuple(hv_SurfaceMatchingResultID.TupleLength())).TupleGreater(
        0))) != 0)
    {
      try
      {
        hv_RelSamplingDistance.Dispose();
        HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampling_rate", 
            0, out hv_RelSamplingDistance);
        hv_KeyPointFraction.Dispose();
        HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "refpt_rate", 
            0, out hv_KeyPointFraction);
        hv_MinScore.Dispose();
        HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "min_score", 
            0, out hv_MinScore);
        hv_GenParamNames.Dispose();
        HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "param_names", 
            0, out hv_GenParamNames);
        hv_GenParamValues.Dispose();
        HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "param_values", 
            0, out hv_GenParamValues);
        hv_NumPoses.Dispose();
        HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "num_poses", 
            0, out hv_NumPoses);
        hv_Pose.Dispose();
        hv_Pose = new HTuple();
        hv_Score.Dispose();
        hv_Score = new HTuple();
        HTuple end_val59 = hv_NumPoses-1;
        HTuple step_val59 = 1;
        for (hv_Index=0; hv_Index.Continue(end_val59, step_val59); hv_Index = hv_Index.TupleAdd(step_val59))
        {
          hv_CurrPose.Dispose();
          HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "pose", 
              hv_Index, out hv_CurrPose);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Pose = hv_Pose.TupleConcat(
              hv_CurrPose);
          hv_Pose.Dispose();
          hv_Pose = ExpTmpLocalVar_Pose;
          }
          }
          hv_CurrScore.Dispose();
          HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "score", 
              hv_Index, out hv_CurrScore);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Score = hv_Score.TupleConcat(
              hv_CurrScore);
          hv_Score.Dispose();
          hv_Score = ExpTmpLocalVar_Score;
          }
          }
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //Result handle is invalid, or we are in an unsupported HALCON version
        HDevWindowStack.SetActive(hv_WindowHandleMenu);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        disp_message(hv_WindowHandleMenu, new HTuple("Error: This version of HALCON is not supported by this procedure, or the given result handle\n was not created with find_surface_model"), 
            "window", 12, 12, "red", "false");
        wait_continue_button(hv_WindowHandleMenu);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
        ho_MenuRegions.Dispose();

        hv_WindowScaling.Dispose();
        hv_WindowSize.Dispose();
        hv_FontSize.Dispose();
        hv_WidthMenu.Dispose();
        hv_HeightMenu.Dispose();
        hv_WindowHandleMenu.Dispose();
        hv_WindowHandle1.Dispose();
        hv_WindowHandle2.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_HasEdges.Dispose();
        hv_MenuText.Dispose();
        hv_MenuCode.Dispose();
        hv_TopBottom.Dispose();
        hv_NumCols.Dispose();
        hv_NumRows.Dispose();
        hv_PercentageHeight.Dispose();
        hv_CheckedCase.Dispose();
        hv_Case.Dispose();
        hv_RowButtons0.Dispose();
        hv_ColumnButtons0.Dispose();
        hv_RowButtons1.Dispose();
        hv_ColumnButtons1.Dispose();
        hv_MenuBottom.Dispose();
        hv_RelSamplingDistance.Dispose();
        hv_KeyPointFraction.Dispose();
        hv_MinScore.Dispose();
        hv_GenParamNames.Dispose();
        hv_GenParamValues.Dispose();
        hv_NumPoses.Dispose();
        hv_Pose.Dispose();
        hv_Score.Dispose();
        hv_Index.Dispose();
        hv_CurrPose.Dispose();
        hv_CurrScore.Dispose();
        hv_Exception.Dispose();
        hv_CasesDone.Dispose();
        hv_CurrentCase.Dispose();
        hv_MaxGap.Dispose();
        hv_MinAmplitudeAbs.Dispose();
        hv_Viewpoint.Dispose();
        hv_LastException.Dispose();
        hv_UserProvidedEdges.Dispose();
        hv_ModelDiameter.Dispose();
        hv_ViewpointStr.Dispose();
        hv_MinAmplitudeRel.Dispose();
        hv_OM3DProvidedEdges.Dispose();
        hv_NormalParamsSet.Dispose();
        hv_ErrorMessage.Dispose();
        hv_Message.Dispose();
        hv_CreateName.Dispose();
        hv_CreateValue.Dispose();
        hv_FindNames.Dispose();
        hv_FindValues.Dispose();
        hv_EdgeParamsSet.Dispose();

        return;
      }
      if ((int)(new HTuple(hv_RelSamplingDistance.TupleEqual(0))) != 0)
      {
        HDevWindowStack.SetActive(hv_WindowHandleMenu);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        disp_message(hv_WindowHandleMenu, "Error: The given result handle was not created with find_surface_model. Please pass a result handle\n created by find_surface_model.", 
            "window", 12, 12, "red", "false");
        wait_continue_button(hv_WindowHandleMenu);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
        ho_MenuRegions.Dispose();

        hv_WindowScaling.Dispose();
        hv_WindowSize.Dispose();
        hv_FontSize.Dispose();
        hv_WidthMenu.Dispose();
        hv_HeightMenu.Dispose();
        hv_WindowHandleMenu.Dispose();
        hv_WindowHandle1.Dispose();
        hv_WindowHandle2.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_HasEdges.Dispose();
        hv_MenuText.Dispose();
        hv_MenuCode.Dispose();
        hv_TopBottom.Dispose();
        hv_NumCols.Dispose();
        hv_NumRows.Dispose();
        hv_PercentageHeight.Dispose();
        hv_CheckedCase.Dispose();
        hv_Case.Dispose();
        hv_RowButtons0.Dispose();
        hv_ColumnButtons0.Dispose();
        hv_RowButtons1.Dispose();
        hv_ColumnButtons1.Dispose();
        hv_MenuBottom.Dispose();
        hv_RelSamplingDistance.Dispose();
        hv_KeyPointFraction.Dispose();
        hv_MinScore.Dispose();
        hv_GenParamNames.Dispose();
        hv_GenParamValues.Dispose();
        hv_NumPoses.Dispose();
        hv_Pose.Dispose();
        hv_Score.Dispose();
        hv_Index.Dispose();
        hv_CurrPose.Dispose();
        hv_CurrScore.Dispose();
        hv_Exception.Dispose();
        hv_CasesDone.Dispose();
        hv_CurrentCase.Dispose();
        hv_MaxGap.Dispose();
        hv_MinAmplitudeAbs.Dispose();
        hv_Viewpoint.Dispose();
        hv_LastException.Dispose();
        hv_UserProvidedEdges.Dispose();
        hv_ModelDiameter.Dispose();
        hv_ViewpointStr.Dispose();
        hv_MinAmplitudeRel.Dispose();
        hv_OM3DProvidedEdges.Dispose();
        hv_NormalParamsSet.Dispose();
        hv_ErrorMessage.Dispose();
        hv_Message.Dispose();
        hv_CreateName.Dispose();
        hv_CreateValue.Dispose();
        hv_FindNames.Dispose();
        hv_FindValues.Dispose();
        hv_EdgeParamsSet.Dispose();

        return;
      }
    }
    else
    {
      hv_GenParamNames.Dispose();
      hv_GenParamNames = new HTuple();
      hv_GenParamValues.Dispose();
      hv_GenParamValues = new HTuple();
    }
    //
    hv_CasesDone.Dispose();
    hv_CasesDone = new HTuple();
    hv_CurrentCase.Dispose();
    hv_CurrentCase = new HTuple();
    //
    //Find the parameters used for the edge extraction
    hv_MaxGap.Dispose();
    hv_MaxGap = new HTuple();
    hv_MinAmplitudeAbs.Dispose();
    hv_MinAmplitudeAbs = new HTuple();
    hv_Viewpoint.Dispose();
    hv_Viewpoint = new HTuple();
    hv_LastException.Dispose();
    hv_LastException = new HTuple();
    hv_UserProvidedEdges.Dispose();
    hv_UserProvidedEdges = 0;
    if ((int)((new HTuple(hv_HasEdges.TupleEqual("true"))).TupleAnd(new HTuple((new HTuple(hv_SurfaceMatchingResultID.TupleLength()
        )).TupleGreater(0)))) != 0)
    {
      hv_ModelDiameter.Dispose();
      HOperatorSet.GetSurfaceModelParam(hv_SurfaceModelID, "diameter", out hv_ModelDiameter);
      hv_ViewpointStr.Dispose();
      get_find_parameter(hv_GenParamNames, hv_GenParamValues, "viewpoint", "0 0 0", 
          out hv_ViewpointStr);
      hv_Viewpoint.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Viewpoint = ((hv_ViewpointStr.TupleSplit(
          " "))).TupleNumber();
      }
      hv_MaxGap.Dispose();
      get_find_parameter(hv_GenParamNames, hv_GenParamValues, "max_gap", 30, out hv_MaxGap);
      hv_MinAmplitudeRel.Dispose();
      get_find_parameter(hv_GenParamNames, hv_GenParamValues, "3d_edge_min_amplitude_rel", 
          new HTuple(), out hv_MinAmplitudeRel);
      if ((int)(new HTuple(hv_MinAmplitudeRel.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_MinAmplitudeAbs.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MinAmplitudeAbs = hv_MinAmplitudeRel*hv_ModelDiameter;
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MinAmplitudeAbs.Dispose();
        get_find_parameter(hv_GenParamNames, hv_GenParamValues, "3d_edge_min_amplitude_abs", 
            0.05*hv_ModelDiameter, out hv_MinAmplitudeAbs);
        }
      }
      //
      hv_OM3DProvidedEdges.Dispose();
      get_find_parameter(hv_GenParamNames, hv_GenParamValues, "3d_edges", new HTuple(), 
          out hv_OM3DProvidedEdges);
      hv_UserProvidedEdges.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_UserProvidedEdges = new HTuple((new HTuple(hv_OM3DProvidedEdges.TupleLength()
          )).TupleGreater(0));
      }
    }
    hv_NormalParamsSet.Dispose();
    hv_NormalParamsSet = 0;
    //
    while ((int)(1) != 0)
    {
      HOperatorSet.ClearWindow(hv_WindowHandleMenu);
      disp_menu_ext(ho_MenuRegions, hv_WindowHandleMenu, hv_MenuText, hv_CasesDone, 
          new HTuple());
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetTposition(hv_WindowHandleMenu, hv_MenuBottom+6, 1);
      }
      write_note(hv_WindowHandleMenu, "info", "Please consider the limitations of this procedure as described in its documentation.");
      write_note(hv_WindowHandleMenu, "instruction", "Select a test from above. It is recommended to start with the Automatic Value Check.");
      if ((int)(new HTuple((new HTuple(hv_SurfaceMatchingResultID.TupleLength())).TupleEqual(
          0))) != 0)
      {
        write_note(hv_WindowHandleMenu, "warning", new HTuple("No result handle was provided. To enable more tests, run find_surface_model() with 'ReturnResultHandle' set to 'true' beforehand and pass the result handle to this procedure."));
      }
      if ((int)(hv_UserProvidedEdges) != 0)
      {
        write_note(hv_WindowHandleMenu, "warning", new HTuple("Edges were passed to find_surface_model manually with the '3d_edges' parameter. Some checks of scene edges might be incorrect, since they assume that edges are extracted by find_surface_model."));
      }
      if ((int)(new HTuple(hv_LastException.TupleNotEqual(new HTuple()))) != 0)
      {
        HalconException.GetExceptionData(hv_LastException,"error_message",out hv_ErrorMessage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandleMenu, "warning", (("Exception while running tool: "+hv_ErrorMessage)).TupleConcat(
            new HTuple("The scene, model or edges might be empty. Try the Automatic Value Check first.")));
        }
        hv_LastException.Dispose();
        hv_LastException = new HTuple();
      }
      hv_CurrentCase.Dispose();
      select_case(ho_MenuRegions, hv_WindowHandleMenu, hv_MenuText, out hv_CurrentCase);
      if ((int)(new HTuple(hv_CurrentCase.TupleEqual(-1))) != 0)
      {
        //Window was closed -> abort
        break;
      }
      if ((int)(new HTuple(((hv_MenuCode.TupleSelect(hv_CurrentCase))).TupleEqual(
          "exit"))) != 0)
      {
        break;
      }
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleUnion(hv_CasesDone, hv_CurrentCase, out ExpTmpOutVar_0);
      hv_CasesDone.Dispose();
      hv_CasesDone = ExpTmpOutVar_0;
      }
      disp_menu_ext(ho_MenuRegions, hv_WindowHandleMenu, hv_MenuText, hv_CasesDone, 
          hv_CurrentCase);
      //
      try
      {
        //****************************
        //Inspect Normal Directions *
        //****************************
        if ((int)(new HTuple(((hv_MenuCode.TupleSelect(hv_CurrentCase))).TupleEqual(
            "normals"))) != 0)
        {
          HDevWindowStack.SetActive(hv_WindowHandleMenu);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetTposition(hv_WindowHandleMenu, hv_MenuBottom+6, 1);
          }
          hv_Message.Dispose();
          hv_Message = new HTuple("Check visually, if the normals of the model point approximately in the same direction as the normals of the scene by moving the model and the scene accordingly");
          write_note(hv_WindowHandleMenu, "instruction", hv_Message);
          //
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_HeightMenu+50,0,hv_WindowSize,hv_WindowSize,0,"visible","",out hv_WindowHandle1);
          HDevWindowStack.Push(hv_WindowHandle1);
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_HeightMenu+50,hv_WindowSize,hv_WindowSize,hv_WindowSize,0,"visible","",out hv_WindowHandle2);
          HDevWindowStack.Push(hv_WindowHandle2);
          set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
          set_display_font(hv_WindowHandle2, hv_FontSize, "mono", "true", "false");
          //
          hv_CreateName.Dispose();hv_CreateValue.Dispose();hv_FindNames.Dispose();hv_FindValues.Dispose();
          inspect_normal_direction(ho_MenuRegions, hv_WindowHandle1, hv_WindowHandle2, 
              hv_WindowHandleMenu, hv_SurfaceModelID, hv_ObjectModel3DScene, hv_RelSamplingDistance, 
              hv_KeyPointFraction, hv_MinScore, hv_GenParamNames, hv_GenParamValues, 
              hv_SurfaceMatchingResultID, hv_MenuText, hv_CurrentCase, hv_CasesDone, 
              hv_FontSize, out hv_CreateName, out hv_CreateValue, out hv_FindNames, 
              out hv_FindValues);
          hv_NormalParamsSet.Dispose();
          hv_NormalParamsSet = 1;
          //
          dev_close_window_if_open(hv_WindowHandle1);
          dev_close_window_if_open(hv_WindowHandle2);
        }
        //
        //***************************
        //Check the data structure *
        //***************************
        //
        if ((int)(new HTuple(((hv_MenuCode.TupleSelect(hv_CurrentCase))).TupleEqual(
            "check"))) != 0)
        {
          //Update the visualization of the menue
          HDevWindowStack.SetActive(hv_WindowHandleMenu);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetTposition(hv_WindowHandleMenu, hv_MenuBottom+6, 1);
          }
          write_note(hv_WindowHandleMenu, "instruction", "Please wait while an automatic check of parameters and values is performed");
          //
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_HeightMenu+50,0,hv_WindowSize*2,hv_WindowSize,0,"visible","",out hv_WindowHandle1);
          HDevWindowStack.Push(hv_WindowHandle1);
          set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
          //
          check_find_surface_model_params(hv_WindowHandle1, hv_SurfaceModelID, hv_ObjectModel3DScene, 
              hv_GenParamNames, hv_GenParamValues);
          //
          dev_close_window_if_open(hv_WindowHandle1);
        }
        //
        //****************
        //Prepare edges *
        //****************
        //
        if ((int)(new HTuple(((hv_MenuCode.TupleSelect(hv_CurrentCase))).TupleEqual(
            "scene_edge_params"))) != 0)
        {
          HDevWindowStack.SetActive(hv_WindowHandleMenu);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetTposition(hv_WindowHandleMenu, hv_MenuBottom+6, 1);
          }
          hv_Message.Dispose();
          hv_Message = "Find the 3D edges by adjusting the MinAmplitude and the MaxGap accordingly";
          write_note(hv_WindowHandleMenu, "instruction", hv_Message);
          //
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_HeightMenu+50,0,hv_WindowSize,hv_WindowSize,0,"visible","",out hv_WindowHandle1);
          HDevWindowStack.Push(hv_WindowHandle1);
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_HeightMenu+50,hv_WindowSize,hv_WindowSize,hv_WindowSize,0,"visible","",out hv_WindowHandle2);
          HDevWindowStack.Push(hv_WindowHandle2);
          set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
          set_display_font(hv_WindowHandle2, hv_FontSize, "mono", "true", "false");
          //
          {
          HTuple ExpTmpOutVar_0;HTuple ExpTmpOutVar_1;
          inspect_scene_edge_parameters(hv_WindowHandle1, hv_WindowHandle2, hv_SurfaceModelID, 
              hv_ObjectModel3DScene, hv_SurfaceMatchingResultID, hv_MaxGap, hv_MinAmplitudeAbs, 
              hv_Viewpoint, out ExpTmpOutVar_0, out ExpTmpOutVar_1);
          hv_MaxGap.Dispose();
          hv_MaxGap = ExpTmpOutVar_0;
          hv_MinAmplitudeAbs.Dispose();
          hv_MinAmplitudeAbs = ExpTmpOutVar_1;
          }
          hv_EdgeParamsSet.Dispose();
          hv_EdgeParamsSet = 1;
          //
          dev_close_window_if_open(hv_WindowHandle1);
          dev_close_window_if_open(hv_WindowHandle2);
        }
        //
        //******************
        //Edge Directions *
        //******************
        //
        if ((int)(new HTuple(((hv_MenuCode.TupleSelect(hv_CurrentCase))).TupleEqual(
            "scene_edge_dirs"))) != 0)
        {
          HDevWindowStack.SetActive(hv_WindowHandleMenu);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetTposition(hv_WindowHandleMenu, hv_MenuBottom+6, 1);
          }
          hv_Message.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Message = new HTuple(new HTuple("Move the left view such that you see the scene from the direction of the sensor (viewpoint, default is [0,0,0]). ")+new HTuple("The right view shows the extracted edges, viewing directions (green) and edge directions (red). The viewing directions show away from the viewpoint. "))+"The edge directions should be perpendicular to the edges and point outward.";
          }
          write_note(hv_WindowHandleMenu, "instruction", hv_Message);
          //
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_HeightMenu+50,0,hv_WindowSize,hv_WindowSize,0,"visible","",out hv_WindowHandle1);
          HDevWindowStack.Push(hv_WindowHandle1);
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_HeightMenu+50,hv_WindowSize,hv_WindowSize,hv_WindowSize,0,"visible","",out hv_WindowHandle2);
          HDevWindowStack.Push(hv_WindowHandle2);
          set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
          set_display_font(hv_WindowHandle2, hv_FontSize, "mono", "true", "false");
          //
          {
          HTuple ExpTmpOutVar_0;
          inspect_scene_edge_directions(hv_WindowHandle1, hv_WindowHandle2, hv_SurfaceModelID, 
              hv_ObjectModel3DScene, hv_SurfaceMatchingResultID, hv_MaxGap, hv_MinAmplitudeAbs, 
              hv_Viewpoint, out ExpTmpOutVar_0);
          hv_Viewpoint.Dispose();
          hv_Viewpoint = ExpTmpOutVar_0;
          }
          //
          dev_close_window_if_open(hv_WindowHandle1);
          dev_close_window_if_open(hv_WindowHandle2);
        }
        //
        //***************************
        //Inspect Model Edges      *
        //***************************
        //
        if ((int)(new HTuple(((hv_MenuCode.TupleSelect(hv_CurrentCase))).TupleEqual(
            "model_edges"))) != 0)
        {
          //Update the visualization of the menue
          HDevWindowStack.SetActive(hv_WindowHandleMenu);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetTposition(hv_WindowHandleMenu, hv_MenuBottom+6, 1);
          }
          write_note(hv_WindowHandleMenu, "info", "This tool allows to inspect the edges that create_surface_model found in the object.");
          write_note(hv_WindowHandleMenu, "instruction", "Use the left window to move the viewpoint and the right window to inspect the edges.");
          write_note(hv_WindowHandleMenu, "info", "The visualized \"edge directions\" should be perpendicular to the direction of the model edges and point outward.");
          //
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_HeightMenu+50,0,hv_WindowSize,hv_WindowSize,0,"visible","",out hv_WindowHandle1);
          HDevWindowStack.Push(hv_WindowHandle1);
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_HeightMenu+50,hv_WindowSize,hv_WindowSize,hv_WindowSize,0,"visible","",out hv_WindowHandle2);
          HDevWindowStack.Push(hv_WindowHandle2);
          set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
          set_display_font(hv_WindowHandle2, hv_FontSize, "mono", "true", "false");
          //
          check_model_edges(hv_SurfaceModelID, hv_ObjectModel3DModel, hv_WindowHandle1, 
              hv_WindowHandle2);
          //
          dev_close_window_if_open(hv_WindowHandle1);
          dev_close_window_if_open(hv_WindowHandle2);
        }
        //
        //***************************
        //Inspect Matching Results *
        //***************************
        //
        if ((int)(new HTuple(((hv_MenuCode.TupleSelect(hv_CurrentCase))).TupleEqual(
            "results"))) != 0)
        {
          //Update the visualization of the menue
          HDevWindowStack.SetActive(hv_WindowHandleMenu);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetTposition(hv_WindowHandleMenu, hv_MenuBottom+6, 1);
          }
          write_note(hv_WindowHandleMenu, "instruction", "Inspect the matching results below.");
          //
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_HeightMenu+50,0,hv_WindowSize,hv_WindowSize,0,"visible","",out hv_WindowHandle1);
          HDevWindowStack.Push(hv_WindowHandle1);
          set_display_font(hv_WindowHandle1, hv_FontSize, "mono", "true", "false");
          //
          dev_display_surface_matching_results(hv_WindowHandle1, hv_SurfaceMatchingResultID, 
              hv_ObjectModel3DModel, hv_ObjectModel3DScene, hv_Score, hv_Pose, hv_HasEdges);
          //
          dev_close_window_if_open(hv_WindowHandle1);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_LastException.Dispose();
        hv_LastException = new HTuple(hv_Exception);
        dev_close_window_if_open(hv_WindowHandle1);
        dev_close_window_if_open(hv_WindowHandle2);
      }
    }
    //
    dev_close_window_if_open(hv_WindowHandleMenu);
    //
    //Construct the parameters
    hv_CreateSurfaceModelParamName.Dispose();
    hv_CreateSurfaceModelParamName = new HTuple();
    hv_CreateSurfaceModelParamValue.Dispose();
    hv_CreateSurfaceModelParamValue = new HTuple();
    hv_FindSurfaceModelParamName.Dispose();
    hv_FindSurfaceModelParamName = new HTuple();
    hv_FindSurfaceModelParamValue.Dispose();
    hv_FindSurfaceModelParamValue = new HTuple();

    if ((int)(hv_NormalParamsSet) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_CreateSurfaceModelParamName = hv_CreateSurfaceModelParamName.TupleConcat(
          hv_CreateName);
      hv_CreateSurfaceModelParamName.Dispose();
      hv_CreateSurfaceModelParamName = ExpTmpLocalVar_CreateSurfaceModelParamName;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_CreateSurfaceModelParamValue = hv_CreateSurfaceModelParamValue.TupleConcat(
          hv_CreateValue);
      hv_CreateSurfaceModelParamValue.Dispose();
      hv_CreateSurfaceModelParamValue = ExpTmpLocalVar_CreateSurfaceModelParamValue;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_FindSurfaceModelParamName = hv_FindSurfaceModelParamName.TupleConcat(
          hv_FindNames);
      hv_FindSurfaceModelParamName.Dispose();
      hv_FindSurfaceModelParamName = ExpTmpLocalVar_FindSurfaceModelParamName;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_FindSurfaceModelParamValue = hv_FindSurfaceModelParamValue.TupleConcat(
          hv_FindValues);
      hv_FindSurfaceModelParamValue.Dispose();
      hv_FindSurfaceModelParamValue = ExpTmpLocalVar_FindSurfaceModelParamValue;
      }
      }
    }

    if ((int)(new HTuple(hv_MaxGap.TupleNotEqual(new HTuple()))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_FindSurfaceModelParamName = hv_FindSurfaceModelParamName.TupleConcat(
          (new HTuple("3d_edge_min_amplitude_abs")).TupleConcat("max_gap"));
      hv_FindSurfaceModelParamName.Dispose();
      hv_FindSurfaceModelParamName = ExpTmpLocalVar_FindSurfaceModelParamName;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_FindSurfaceModelParamValue = ((hv_FindSurfaceModelParamValue.TupleConcat(
          hv_MinAmplitudeAbs))).TupleConcat(hv_MaxGap);
      hv_FindSurfaceModelParamValue.Dispose();
      hv_FindSurfaceModelParamValue = ExpTmpLocalVar_FindSurfaceModelParamValue;
      }
      }
    }

    if ((int)(new HTuple(hv_Viewpoint.TupleNotEqual(new HTuple()))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_FindSurfaceModelParamName = hv_FindSurfaceModelParamName.TupleConcat(
          "viewpoint");
      hv_FindSurfaceModelParamName.Dispose();
      hv_FindSurfaceModelParamName = ExpTmpLocalVar_FindSurfaceModelParamName;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_FindSurfaceModelParamValue = hv_FindSurfaceModelParamValue.TupleConcat(
          ((((hv_Viewpoint.TupleSelect(0))+" ")+(hv_Viewpoint.TupleSelect(1)))+" ")+(hv_Viewpoint.TupleSelect(
          2)));
      hv_FindSurfaceModelParamValue.Dispose();
      hv_FindSurfaceModelParamValue = ExpTmpLocalVar_FindSurfaceModelParamValue;
      }
      }
    }

  }

  // Chapter: Graphics / Output
  // Short Description: Determine the optimum distance of the object to obtain a reasonable visualization 
  public void determine_optimum_pose_distance (HTuple hv_ObjectModel3DID, HTuple hv_CamParam, 
      HTuple hv_ImageCoverage, HTuple hv_PoseIn, out HTuple hv_PoseOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Rows = new HTuple(), hv_Cols = new HTuple();
    HTuple hv_MinMinZ = new HTuple(), hv_BB = new HTuple();
    HTuple hv_Index = new HTuple(), hv_CurrBB = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_Seq = new HTuple();
    HTuple hv_DXMax = new HTuple(), hv_DYMax = new HTuple();
    HTuple hv_DZMax = new HTuple(), hv_Diameter = new HTuple();
    HTuple hv_ZAdd = new HTuple(), hv_BBX0 = new HTuple();
    HTuple hv_BBX1 = new HTuple(), hv_BBY0 = new HTuple();
    HTuple hv_BBY1 = new HTuple(), hv_BBZ0 = new HTuple();
    HTuple hv_BBZ1 = new HTuple(), hv_X = new HTuple(), hv_Y = new HTuple();
    HTuple hv_Z = new HTuple(), hv_HomMat3DIn = new HTuple();
    HTuple hv_QX_In = new HTuple(), hv_QY_In = new HTuple();
    HTuple hv_QZ_In = new HTuple(), hv_PoseInter = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_QX = new HTuple();
    HTuple hv_QY = new HTuple(), hv_QZ = new HTuple(), hv_Cx = new HTuple();
    HTuple hv_Cy = new HTuple(), hv_DR = new HTuple(), hv_DC = new HTuple();
    HTuple hv_MaxDist = new HTuple(), hv_HomMat3DRotate = new HTuple();
    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_MinImageSize = new HTuple(), hv_Zs = new HTuple();
    HTuple hv_ZDiff = new HTuple(), hv_ScaleZ = new HTuple();
    HTuple hv_ZNew = new HTuple();
    // Initialize local and output iconic variables 
    hv_PoseOut = new HTuple();
    //Determine the optimum distance of the object to obtain
    //a reasonable visualization
    //
    hv_Rows.Dispose();
    hv_Rows = new HTuple();
    hv_Cols.Dispose();
    hv_Cols = new HTuple();
    hv_MinMinZ.Dispose();
    hv_MinMinZ = 1e30;
    hv_BB.Dispose();
    hv_BB = new HTuple();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ObjectModel3DID.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      try
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrBB.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID.TupleSelect(hv_Index), 
            "bounding_box1", out hv_CurrBB);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BB = hv_BB.TupleConcat(
            hv_CurrBB);
        hv_BB.Dispose();
        hv_BB = ExpTmpLocalVar_BB;
        }
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //3D object model is empty / has no bounding box -> ignore it
      }
    }
    if ((int)(new HTuple(((((((hv_BB.TupleAbs())).TupleConcat(0))).TupleSum())).TupleEqual(
        0.0))) != 0)
    {
      hv_BB.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BB = new HTuple();
      hv_BB = hv_BB.TupleConcat(-((new HTuple(HTuple.TupleRand(
          3)*1e-20)).TupleAbs()));
      hv_BB = hv_BB.TupleConcat((new HTuple(HTuple.TupleRand(
          3)*1e-20)).TupleAbs());
      }
    }
    //Calculate diameter over all objects to be visualized
    hv_Seq.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Seq = HTuple.TupleGenSequence(
        0,(new HTuple(hv_BB.TupleLength()))-1,6);
    }
    hv_DXMax.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DXMax = (((hv_BB.TupleSelect(
        hv_Seq+3))).TupleMax())-(((hv_BB.TupleSelect(hv_Seq))).TupleMin());
    }
    hv_DYMax.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DYMax = (((hv_BB.TupleSelect(
        hv_Seq+4))).TupleMax())-(((hv_BB.TupleSelect(hv_Seq+1))).TupleMin());
    }
    hv_DZMax.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DZMax = (((hv_BB.TupleSelect(
        hv_Seq+5))).TupleMax())-(((hv_BB.TupleSelect(hv_Seq+2))).TupleMin());
    }
    hv_Diameter.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Diameter = ((((hv_DXMax*hv_DXMax)+(hv_DYMax*hv_DYMax))+(hv_DZMax*hv_DZMax))).TupleSqrt()
        ;
    }
    //Allow the visualization of single points or extremely small objects
    hv_ZAdd.Dispose();
    hv_ZAdd = 0.0;
    if ((int)(new HTuple(((hv_Diameter.TupleMax())).TupleLess(1e-10))) != 0)
    {
      hv_ZAdd.Dispose();
      hv_ZAdd = 0.01;
    }
    //Set extremely small diameters to 1e-10 to avoid CZ == 0.0, which would lead
    //to projection errors
    if ((int)(new HTuple(((hv_Diameter.TupleMin())).TupleLess(1e-10))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Diameter = hv_Diameter-(((((((hv_Diameter-1e-10)).TupleSgn()
          )-1)).TupleSgn())*1e-10);
      hv_Diameter.Dispose();
      hv_Diameter = ExpTmpLocalVar_Diameter;
      }
      }
    }
    //Move all points infront of the camera
    hv_BBX0.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_BBX0 = hv_BB.TupleSelect(
        hv_Seq+0);
    }
    hv_BBX1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_BBX1 = hv_BB.TupleSelect(
        hv_Seq+3);
    }
    hv_BBY0.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_BBY0 = hv_BB.TupleSelect(
        hv_Seq+1);
    }
    hv_BBY1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_BBY1 = hv_BB.TupleSelect(
        hv_Seq+4);
    }
    hv_BBZ0.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_BBZ0 = hv_BB.TupleSelect(
        hv_Seq+2);
    }
    hv_BBZ1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_BBZ1 = hv_BB.TupleSelect(
        hv_Seq+5);
    }
    hv_X.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_X = new HTuple();
    hv_X = hv_X.TupleConcat(hv_BBX0, hv_BBX0, hv_BBX0, hv_BBX0, hv_BBX1, hv_BBX1, hv_BBX1, hv_BBX1);
    }
    hv_Y.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Y = new HTuple();
    hv_Y = hv_Y.TupleConcat(hv_BBY0, hv_BBY0, hv_BBY1, hv_BBY1, hv_BBY0, hv_BBY0, hv_BBY1, hv_BBY1);
    }
    hv_Z.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Z = new HTuple();
    hv_Z = hv_Z.TupleConcat(hv_BBZ0, hv_BBZ1, hv_BBZ0, hv_BBZ1, hv_BBZ0, hv_BBZ1, hv_BBZ0, hv_BBZ1);
    }
    hv_HomMat3DIn.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_PoseIn, out hv_HomMat3DIn);
    hv_QX_In.Dispose();hv_QY_In.Dispose();hv_QZ_In.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3DIn, hv_X, hv_Y, hv_Z, out hv_QX_In, 
        out hv_QY_In, out hv_QZ_In);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PoseInter.Dispose();
    HOperatorSet.PoseCompose(((((new HTuple(0)).TupleConcat(0)).TupleConcat((-(hv_QZ_In.TupleMin()
        ))+(2*(hv_Diameter.TupleMax()))))).TupleConcat((((new HTuple(0)).TupleConcat(
        0)).TupleConcat(0)).TupleConcat(0)), hv_PoseIn, out hv_PoseInter);
    }
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_PoseInter, out hv_HomMat3D);
    //Determine the maximum extension of the projection
    hv_QX.Dispose();hv_QY.Dispose();hv_QZ.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_X, hv_Y, hv_Z, out hv_QX, out hv_QY, 
        out hv_QZ);
    hv_Rows.Dispose();hv_Cols.Dispose();
    HOperatorSet.Project3dPoint(hv_QX, hv_QY, hv_QZ, hv_CamParam, out hv_Rows, out hv_Cols);
    hv_MinMinZ.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MinMinZ = hv_QZ.TupleMin()
        ;
    }
    hv_Cx.Dispose();
    get_cam_par_data(hv_CamParam, "cx", out hv_Cx);
    hv_Cy.Dispose();
    get_cam_par_data(hv_CamParam, "cy", out hv_Cy);
    hv_DR.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DR = hv_Rows-hv_Cy;
    }
    hv_DC.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DC = hv_Cols-hv_Cx;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_DR = (hv_DR.TupleMax()
        )-(hv_DR.TupleMin());
    hv_DR.Dispose();
    hv_DR = ExpTmpLocalVar_DR;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_DC = (hv_DC.TupleMax()
        )-(hv_DC.TupleMin());
    hv_DC.Dispose();
    hv_DC = ExpTmpLocalVar_DC;
    }
    }
    hv_MaxDist.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxDist = (((hv_DR*hv_DR)+(hv_DC*hv_DC))).TupleSqrt()
        ;
    }
    //
    if ((int)(new HTuple(hv_MaxDist.TupleLess(1e-10))) != 0)
    {
      //If the object has no extension in the above projection (looking along
      //a line), we determine the extension of the object in a rotated view
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HomMat3DRotate.Dispose();
      HOperatorSet.HomMat3dRotateLocal(hv_HomMat3D, (new HTuple(90)).TupleRad(), 
          "x", out hv_HomMat3DRotate);
      }
      hv_QX.Dispose();hv_QY.Dispose();hv_QZ.Dispose();
      HOperatorSet.AffineTransPoint3d(hv_HomMat3DRotate, hv_X, hv_Y, hv_Z, out hv_QX, 
          out hv_QY, out hv_QZ);
      hv_Rows.Dispose();hv_Cols.Dispose();
      HOperatorSet.Project3dPoint(hv_QX, hv_QY, hv_QZ, hv_CamParam, out hv_Rows, 
          out hv_Cols);
      hv_DR.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DR = hv_Rows-hv_Cy;
      }
      hv_DC.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DC = hv_Cols-hv_Cx;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DR = (hv_DR.TupleMax()
          )-(hv_DR.TupleMin());
      hv_DR.Dispose();
      hv_DR = ExpTmpLocalVar_DR;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DC = (hv_DC.TupleMax()
          )-(hv_DC.TupleMin());
      hv_DC.Dispose();
      hv_DC = ExpTmpLocalVar_DC;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_MaxDist = ((hv_MaxDist.TupleConcat(
          (((hv_DR*hv_DR)+(hv_DC*hv_DC))).TupleSqrt()))).TupleMax();
      hv_MaxDist.Dispose();
      hv_MaxDist = ExpTmpLocalVar_MaxDist;
      }
      }
    }
    //
    hv_ImageWidth.Dispose();
    get_cam_par_data(hv_CamParam, "image_width", out hv_ImageWidth);
    hv_ImageHeight.Dispose();
    get_cam_par_data(hv_CamParam, "image_height", out hv_ImageHeight);
    hv_MinImageSize.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MinImageSize = ((hv_ImageWidth.TupleConcat(
        hv_ImageHeight))).TupleMin();
    }
    //
    hv_Z.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Z = hv_PoseInter.TupleSelect(
        2);
    }
    hv_Zs.Dispose();
    hv_Zs = new HTuple(hv_MinMinZ);
    hv_ZDiff.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ZDiff = hv_Z-hv_Zs;
    }
    hv_ScaleZ.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ScaleZ = hv_MaxDist/(((0.5*hv_MinImageSize)*hv_ImageCoverage)*2.0);
    }
    hv_ZNew.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ZNew = ((hv_ScaleZ*hv_Zs)+hv_ZDiff)+hv_ZAdd;
    }
    hv_PoseOut.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PoseOut = hv_PoseInter.TupleReplace(
        2,hv_ZNew);
    }
    //

    hv_Rows.Dispose();
    hv_Cols.Dispose();
    hv_MinMinZ.Dispose();
    hv_BB.Dispose();
    hv_Index.Dispose();
    hv_CurrBB.Dispose();
    hv_Exception.Dispose();
    hv_Seq.Dispose();
    hv_DXMax.Dispose();
    hv_DYMax.Dispose();
    hv_DZMax.Dispose();
    hv_Diameter.Dispose();
    hv_ZAdd.Dispose();
    hv_BBX0.Dispose();
    hv_BBX1.Dispose();
    hv_BBY0.Dispose();
    hv_BBY1.Dispose();
    hv_BBZ0.Dispose();
    hv_BBZ1.Dispose();
    hv_X.Dispose();
    hv_Y.Dispose();
    hv_Z.Dispose();
    hv_HomMat3DIn.Dispose();
    hv_QX_In.Dispose();
    hv_QY_In.Dispose();
    hv_QZ_In.Dispose();
    hv_PoseInter.Dispose();
    hv_HomMat3D.Dispose();
    hv_QX.Dispose();
    hv_QY.Dispose();
    hv_QZ.Dispose();
    hv_Cx.Dispose();
    hv_Cy.Dispose();
    hv_DR.Dispose();
    hv_DC.Dispose();
    hv_MaxDist.Dispose();
    hv_HomMat3DRotate.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_MinImageSize.Dispose();
    hv_Zs.Dispose();
    hv_ZDiff.Dispose();
    hv_ScaleZ.Dispose();
    hv_ZNew.Dispose();

    return;
  }

  public void determine_visualization_pose_distance_aligned_with_y_axis (HTuple hv_ObjectModel3DRigidTrans5Tmp, 
      HTuple hv_WindowHandle1, out HTuple hv_PoseEstimatedDistance, out HTuple hv_Center)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_PoseCenterScene = new HTuple(), hv_ObjectModel3DRigidTrans4 = new HTuple();
    HTuple hv_PoseRot = new HTuple(), hv_ObjectModel3DRigidTrans5 = new HTuple();
    HTuple hv_PoseTrans = new HTuple(), hv_ObjectModel3DRigidTrans6 = new HTuple();
    HTuple hv_ObjectModel3D0 = new HTuple(), hv_UnionObjectModel3D1 = new HTuple();
    HTuple hv_RowNotUsed = new HTuple(), hv_ColumnNotUsed = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_CamParam = new HTuple();
    // Initialize local and output iconic variables 
    hv_PoseEstimatedDistance = new HTuple();
    hv_Center = new HTuple();
    hv_Center.Dispose();
    get_object_models_center(hv_ObjectModel3DRigidTrans5Tmp, out hv_Center);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PoseCenterScene.Dispose();
    HOperatorSet.CreatePose(-(hv_Center.TupleSelect(0)), -(hv_Center.TupleSelect(
        1)), -(hv_Center.TupleSelect(2)), 0, 0, 0, "Rp+T", "gba", "point", out hv_PoseCenterScene);
    }
    hv_ObjectModel3DRigidTrans4.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_ObjectModel3DRigidTrans5Tmp, hv_PoseCenterScene, 
        out hv_ObjectModel3DRigidTrans4);
    hv_PoseRot.Dispose();
    hv_PoseRot = new HTuple();
    hv_PoseRot[0] = 0;
    hv_PoseRot[1] = 0;
    hv_PoseRot[2] = 0;
    hv_PoseRot[3] = 90;
    hv_PoseRot[4] = 0;
    hv_PoseRot[5] = 0;
    hv_PoseRot[6] = 0;
    hv_ObjectModel3DRigidTrans5.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_ObjectModel3DRigidTrans4, hv_PoseRot, 
        out hv_ObjectModel3DRigidTrans5);
    hv_PoseTrans.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PoseTrans = new HTuple();
    hv_PoseTrans = hv_PoseTrans.TupleConcat(hv_Center.TupleSelect(
        0));
    hv_PoseTrans = hv_PoseTrans.TupleConcat(hv_Center.TupleSelect(2));
    hv_PoseTrans = hv_PoseTrans.TupleConcat(hv_Center.TupleSelect(
        1));
    hv_PoseTrans = hv_PoseTrans.TupleConcat(new HTuple(0, 0, 0, 0));
    }
    hv_ObjectModel3DRigidTrans6.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_ObjectModel3DRigidTrans5, hv_PoseTrans, 
        out hv_ObjectModel3DRigidTrans6);
    hv_ObjectModel3D0.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(0, 0, 0, out hv_ObjectModel3D0);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_UnionObjectModel3D1.Dispose();
    HOperatorSet.UnionObjectModel3d(hv_ObjectModel3D0.TupleConcat(hv_ObjectModel3DRigidTrans6), 
        "points_surface", out hv_UnionObjectModel3D1);
    }
    //
    hv_RowNotUsed.Dispose();hv_ColumnNotUsed.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle1, out hv_RowNotUsed, out hv_ColumnNotUsed, 
        out hv_Width, out hv_Height);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CamParam.Dispose();
    gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width/2, hv_Height/2, 
        hv_Width, hv_Height, out hv_CamParam);
    }
    hv_PoseEstimatedDistance.Dispose();
    determine_optimum_pose_distance(hv_UnionObjectModel3D1, hv_CamParam, 0.9, hv_PoseCenterScene, 
        out hv_PoseEstimatedDistance);

    hv_PoseCenterScene.Dispose();
    hv_ObjectModel3DRigidTrans4.Dispose();
    hv_PoseRot.Dispose();
    hv_ObjectModel3DRigidTrans5.Dispose();
    hv_PoseTrans.Dispose();
    hv_ObjectModel3DRigidTrans6.Dispose();
    hv_ObjectModel3D0.Dispose();
    hv_UnionObjectModel3D1.Dispose();
    hv_RowNotUsed.Dispose();
    hv_ColumnNotUsed.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_CamParam.Dispose();

    return;
  }

  // Short Description: Closes the window if it is still open. 
  public void dev_close_window_if_open (HTuple hv_WindowHandle)
  {



    // Local control variables 

    HTuple hv_CurrWindowHandle = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      HDevWindowStack.SetActive(hv_WindowHandle);
      if (HDevWindowStack.IsOpen())
      {
        hv_CurrWindowHandle = HDevWindowStack.GetActive();
      }
      if ((int)(new HTuple(hv_CurrWindowHandle.TupleEqual(hv_WindowHandle))) != 0)
      {
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      //Window might already be closed -> ignore errors
    }

    hv_CurrWindowHandle.Dispose();
    hv_Exception.Dispose();

    return;
  }

  // Chapter: Graphics / Text
  public void dev_disp_approach_pose_touching_point_instructions (HTuple hv_WindowHandle, 
      HTuple hv_WindowHandleGraphics, HTuple hv_Index)
  {



    // Local iconic variables 

    HObject ho_Image, ho_Rectangle;

    // Local control variables 

    HTuple hv_Text = new HTuple(), hv_Color = new HTuple();
    HTuple hv_HighlighColumn = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    //
    HDevWindowStack.SetActive(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
    }
    hv_Text.Dispose();
    hv_Text = "Calibrate touching point";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[1] = "";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[2] = "General workflow";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[3] = "----------------";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[4] = new HTuple("Approach a fixed point in the plane with your gripper, and read the");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[5] = "pose as ToolInBasePoseTouchingPoint.";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[6] = new HTuple("Then, approach the same point at least twice again, rotating the tool");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[7] = "around at least two axis and reading the corresponding ";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[8] = "ToolInBasePoseTouchingPoint.";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[9] = "";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[10] = ("Read ToolInBasePoseTouchingPoint "+hv_Index)+new HTuple("/3, then press F5.");
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
          "left", "white", "box", "false");
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
          "window", "bottom", "right", "black", new HTuple(), new HTuple());
    }
    hv_Color.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Color = HTuple.TupleGenConst(
        3,"gray");
    }
    if (hv_Color == null)
      hv_Color = new HTuple();
    hv_Color[hv_Index-1] = "#fbba00";
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), "   1   ", "window", 255, 
          12, "black", (new HTuple("box_color")).TupleConcat("shadow"), ((hv_Color.TupleSelect(
          0))).TupleConcat("false"));
      }
    }
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), "   2   ", "window", 255, 
          112, "black", (new HTuple("box_color")).TupleConcat("shadow"), ((hv_Color.TupleSelect(
          1))).TupleConcat("false"));
      }
    }
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), "   3   ", "window", 255, 
          212, "black", (new HTuple("box_color")).TupleConcat("shadow"), ((hv_Color.TupleSelect(
          2))).TupleConcat("false"));
      }
    }
    //
    HDevWindowStack.SetActive(hv_WindowHandleGraphics);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
    }
    ho_Image.Dispose();
    HOperatorSet.ReadImage(out ho_Image, "3d_machine_vision/hand_eye/instruction_images/tool_in_base_pose_touching_point");
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
    }
    hv_HighlighColumn.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HighlighColumn = 255+(hv_Index*200);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_Rectangle.Dispose();
    HOperatorSet.GenRectangle1(out ho_Rectangle, 320, hv_HighlighColumn-100, 630, 
        hv_HighlighColumn+100);
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 4);
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetColor(HDevWindowStack.GetActive(), "#fbba00");
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_Rectangle, HDevWindowStack.GetActive());
    }
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), "Read this pose", "image", 
          6350, hv_HighlighColumn-105, "black", "box_color", "#fbba00");
      }
    }
    ho_Image.Dispose();
    ho_Rectangle.Dispose();

    hv_Text.Dispose();
    hv_Color.Dispose();
    hv_HighlighColumn.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Display an interactive button. 
  public void dev_disp_button (HTuple hv_String, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_Width, HTuple hv_Height, HTuple hv_ColorString, HTuple hv_ColorBackground, 
      HTuple hv_ColorBackgroundActive, HTuple hv_WindowHandle, out HTuple hv_SelectedButton)
  {



    // Local iconic variables 

    HObject ho_ButtonRect, ho_ObjectSelected=null;

    // Local control variables 

    HTuple hv_ClipRegion = new HTuple(), hv_Flush = new HTuple();
    HTuple hv__ = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple(), hv_PartHeight = new HTuple();
    HTuple hv_PartWidth = new HTuple(), hv_WindowImageWidthRatio = new HTuple();
    HTuple hv_WindowImageHeightRatio = new HTuple(), hv_ButtonRowScaled = new HTuple();
    HTuple hv_ButtonColumnScaled = new HTuple(), hv_ButtonHeightScaled = new HTuple();
    HTuple hv_ButtonWidthScaled = new HTuple(), hv_HighlightColors = new HTuple();
    HTuple hv_Ascents = new HTuple(), hv_Descents = new HTuple();
    HTuple hv_TextWidths = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv_TextWidth = new HTuple(), hv_TextHeight = new HTuple();
    HTuple hv_TextRow = new HTuple(), hv_TextColumn = new HTuple();
    HTuple hv_Button = new HTuple(), hv_ButtonIndex = new HTuple();
    HTuple hv_IsInside = new HTuple(), hv_Exception = new HTuple();
    HTuple   hv_ColorBackground_COPY_INP_TMP = new HTuple(hv_ColorBackground);
    HTuple   hv_Column_COPY_INP_TMP = new HTuple(hv_Column);
    HTuple   hv_Row_COPY_INP_TMP = new HTuple(hv_Row);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ButtonRect);
    HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
    hv_SelectedButton = new HTuple();
    //
    hv_ClipRegion.Dispose();
    HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
    HOperatorSet.SetSystem("clip_region", "false");
    // dev_get_preferences(...); only in hdevelop
    // dev_set_preferences(...); only in hdevelop
    hv_Flush.Dispose();
    HOperatorSet.GetWindowParam(hv_WindowHandle, "flush", out hv_Flush);
    HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", "false");
    //
    //Get the scaling factor for window/image coordinate conversion.
    hv__.Dispose();hv__.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_WindowWidth, 
        out hv_WindowHeight);
    hv__.Dispose();hv__.Dispose();hv_PartHeight.Dispose();hv_PartWidth.Dispose();
    HOperatorSet.GetPart(hv_WindowHandle, out hv__, out hv__, out hv_PartHeight, 
        out hv_PartWidth);
    hv_WindowImageWidthRatio.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowImageWidthRatio = hv_WindowWidth/(1.0*hv_PartWidth);
    }
    hv_WindowImageHeightRatio.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowImageHeightRatio = hv_WindowHeight/(1.0*hv_PartHeight);
    }
    //
    //Scale the button coordinates.
    hv_ButtonRowScaled.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonRowScaled = hv_Row_COPY_INP_TMP/hv_WindowImageHeightRatio;
    }
    hv_ButtonColumnScaled.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonColumnScaled = hv_Column_COPY_INP_TMP/hv_WindowImageWidthRatio;
    }
    hv_ButtonHeightScaled.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonHeightScaled = hv_Height/hv_WindowImageHeightRatio;
    }
    hv_ButtonWidthScaled.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonWidthScaled = hv_Width/hv_WindowImageWidthRatio;
    }
    //
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_ButtonRect.Dispose();
    HOperatorSet.GenRectangle1(out ho_ButtonRect, hv_ButtonRowScaled, hv_ButtonColumnScaled, 
        hv_ButtonRowScaled+hv_ButtonHeightScaled, hv_ButtonColumnScaled+hv_ButtonWidthScaled);
    }
    if ((int)(new HTuple((new HTuple(hv_ColorBackground_COPY_INP_TMP.TupleLength()
        )).TupleEqual(1))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ColorBackground = HTuple.TupleGenConst(
          new HTuple(hv_String.TupleLength()),hv_ColorBackground_COPY_INP_TMP);
      hv_ColorBackground_COPY_INP_TMP.Dispose();
      hv_ColorBackground_COPY_INP_TMP = ExpTmpLocalVar_ColorBackground;
      }
      }
    }
    hv_HighlightColors.Dispose();
    hv_HighlightColors = new HTuple(hv_ColorBackground_COPY_INP_TMP);
    //
    //We want to place the text centered in the button.
    hv_Ascents.Dispose();
    hv_Ascents = new HTuple();
    hv_Descents.Dispose();
    hv_Descents = new HTuple();
    hv_TextWidths.Dispose();
    hv_TextWidths = new HTuple();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String.TupleSelect(hv_Index), 
          out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Ascents = hv_Ascents.TupleConcat(
          hv_Ascent);
      hv_Ascents.Dispose();
      hv_Ascents = ExpTmpLocalVar_Ascents;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Descents = hv_Descents.TupleConcat(
          hv_Descent);
      hv_Descents.Dispose();
      hv_Descents = ExpTmpLocalVar_Descents;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TextWidths = hv_TextWidths.TupleConcat(
          hv_TextWidth);
      hv_TextWidths.Dispose();
      hv_TextWidths = ExpTmpLocalVar_TextWidths;
      }
      }
    }
    //
    hv_TextRow.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TextRow = (hv_Row_COPY_INP_TMP+((hv_Height-hv_TextHeight)/2))-hv_Descent;
    }
    hv_TextColumn.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TextColumn = hv_Column_COPY_INP_TMP+((hv_Width-hv_TextWidths)/2);
    }
    hv_SelectedButton.Dispose();
    hv_SelectedButton = 0;
    hv_Button.Dispose();
    hv_Button = 0;
    //
    while ((int)((new HTuple(hv_SelectedButton.TupleEqual(0))).TupleOr(new HTuple(hv_Button.TupleNotEqual(
        1)))) != 0)
    {
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_HighlightColors);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_ButtonRect, HDevWindowStack.GetActive());
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_String, "window", hv_TextRow, 
            hv_TextColumn, hv_ColorString, "box", "false");
      }
      //Actual display.
      HOperatorSet.FlushBuffer(hv_WindowHandle);
      try
      {
        hv_Row_COPY_INP_TMP.Dispose();hv_Column_COPY_INP_TMP.Dispose();hv_Button.Dispose();
        HOperatorSet.GetMposition(hv_WindowHandle, out hv_Row_COPY_INP_TMP, out hv_Column_COPY_INP_TMP, 
            out hv_Button);
        hv_SelectedButton.Dispose();
        hv_SelectedButton = 0;
        for (hv_ButtonIndex=1; (int)hv_ButtonIndex<=(int)(new HTuple(hv_ButtonRowScaled.TupleLength()
            )); hv_ButtonIndex = (int)hv_ButtonIndex + 1)
        {
          ho_ObjectSelected.Dispose();
          HOperatorSet.SelectObj(ho_ButtonRect, out ho_ObjectSelected, hv_ButtonIndex);
          hv_IsInside.Dispose();
          HOperatorSet.TestRegionPoint(ho_ObjectSelected, hv_Row_COPY_INP_TMP, hv_Column_COPY_INP_TMP, 
              out hv_IsInside);
          if ((int)(hv_IsInside) != 0)
          {
            hv_SelectedButton.Dispose();
            hv_SelectedButton = new HTuple(hv_ButtonIndex);
            break;
          }
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }
      if ((int)(new HTuple(hv_SelectedButton.TupleGreater(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HighlightColors.Dispose();
        HOperatorSet.TupleReplace(hv_ColorBackground_COPY_INP_TMP, hv_SelectedButton-1, 
            hv_ColorBackgroundActive, out hv_HighlightColors);
        }
      }
      else
      {
        hv_HighlightColors.Dispose();
        hv_HighlightColors = new HTuple(hv_ColorBackground_COPY_INP_TMP);
      }
    }
    //Return index.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_SelectedButton = hv_SelectedButton-1;
    hv_SelectedButton.Dispose();
    hv_SelectedButton = ExpTmpLocalVar_SelectedButton;
    }
    }
    //
    HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
    // dev_set_preferences(...); only in hdevelop
    HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", hv_Flush);
    ho_ButtonRect.Dispose();
    ho_ObjectSelected.Dispose();

    hv_ColorBackground_COPY_INP_TMP.Dispose();
    hv_Column_COPY_INP_TMP.Dispose();
    hv_Row_COPY_INP_TMP.Dispose();
    hv_ClipRegion.Dispose();
    hv_Flush.Dispose();
    hv__.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();
    hv_PartHeight.Dispose();
    hv_PartWidth.Dispose();
    hv_WindowImageWidthRatio.Dispose();
    hv_WindowImageHeightRatio.Dispose();
    hv_ButtonRowScaled.Dispose();
    hv_ButtonColumnScaled.Dispose();
    hv_ButtonHeightScaled.Dispose();
    hv_ButtonWidthScaled.Dispose();
    hv_HighlightColors.Dispose();
    hv_Ascents.Dispose();
    hv_Descents.Dispose();
    hv_TextWidths.Dispose();
    hv_Index.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_TextWidth.Dispose();
    hv_TextHeight.Dispose();
    hv_TextRow.Dispose();
    hv_TextColumn.Dispose();
    hv_Button.Dispose();
    hv_ButtonIndex.Dispose();
    hv_IsInside.Dispose();
    hv_Exception.Dispose();

    return;
  }

  // Chapter: Graphics / Text
  public void dev_disp_calibration_data_instructions (HObject ho_Image)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
    }
    hv_Text.Dispose();
    hv_Text = new HTuple("In the code, please");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[1] = new HTuple("- read an image of a calibration plate in the measurement plane,");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[2] = new HTuple("- specify the location of the calibration plate description file,");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[3] = "- specify the thickness of the calibration plate (in meters) and";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[4] = "- specify initial camera parameters.";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[5] = "";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[6] = new HTuple(" (If you did NOT use a standard HALCON calibration plate, ");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[7] = new HTuple("  but used create_caltab to create your own calibration plate,");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[8] = new HTuple("  you also need to adapt the parameters FinderRow, FinderColumn,");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[9] = "  and MarksPerRow accordingly.)";
    //
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
          "left", "black", new HTuple(), new HTuple());
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
          "window", "bottom", "right", "black", new HTuple(), new HTuple());
    }

    hv_Text.Dispose();

    return;
  }

  // Chapter: Graphics / Text
  public void dev_disp_calibration_data_instructions2 (HObject ho_Image)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
    }
    hv_Text.Dispose();
    hv_Text = new HTuple("If you did NOT use a standard HALCON calibration plate, ");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[1] = new HTuple("but used create_caltab to create your own calibration plate,");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[2] = new HTuple("please adapt the parameters FinderRow, FinderColumn, and MarksPerRow");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[3] = "in the code.";
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
          "left", "black", new HTuple(), new HTuple());
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
          "window", "bottom", "right", "black", new HTuple(), new HTuple());
    }

    hv_Text.Dispose();

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: Display the introduction for the procedure calibrate_robot_touching_point. 
  public void dev_disp_introduction (HTuple hv_WindowHandle, HTuple hv_WindowHandleGraphics)
  {



    // Local iconic variables 

    HObject ho_InstructionImage;

    // Local control variables 

    HTuple hv_Text = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_InstructionImage);
    //
    HDevWindowStack.SetActive(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
    }
    hv_Text.Dispose();
    hv_Text = new HTuple("With this procedure, we calibrate the coordinates of the touching point");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[1] = "of a robot with respect to the robot's tool.";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[2] = "";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[3] = "The touching point is a point that has to be fixed with respect to";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[4] = new HTuple("the tool coordinate system, but does not have to be located on the");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[5] = new HTuple("surface of the gripper. It can, for example, lie halfway between");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[6] = "two fingers of a gripper.";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[7] = "";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[8] = "The touching point should be chosen such that it can approach ";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[9] = "a point in the plane easily and accurately.";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[10] = "";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[11] = "The coordinates of this point (RobotTouchingPointInToolCoordinates)";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[12] = new HTuple("are necessary, for example, to perform a hand-eye calibration of a robot");
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[13] = "with a stationary camera.";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[14] = "";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[15] = "This procedure is used in the example";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[16] = "calibrate_hand_eye_stationary_cam_approx.hdev.";
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
          "left", "white", "box", "false");
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
          "window", "bottom", "right", "black", new HTuple(), new HTuple());
    }
    //
    HDevWindowStack.SetActive(hv_WindowHandleGraphics);
    ho_InstructionImage.Dispose();
    HOperatorSet.ReadImage(out ho_InstructionImage, "3d_machine_vision/hand_eye/instruction_images/robot_touching_point_in_tool_coordinates");
    hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width, 
        out hv_Height);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    dev_resize_window_fit_image(ho_InstructionImage, 0, hv_Width+10, 600, -1);
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_InstructionImage, HDevWindowStack.GetActive());
    }
    ho_InstructionImage.Dispose();

    hv_Text.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();

    return;

  }

  // Chapter: Graphics / Output
  // Short Description: Display a map of the confidences. 
  public void dev_display_confidence_regions (HObject ho_ImageConfidence, HTuple hv_DrawTransparency, 
      out HTuple hv_Colors)
  {




    // Local iconic variables 

    HObject ho_Region=null;

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
    HTuple hv_ColorIndex = new HTuple(), hv_Threshold = new HTuple();
    HTuple hv_MinGray = new HTuple(), hv_MaxGray = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Region);
    hv_Colors = new HTuple();
    //
    //This procedure displays a map of the confidences
    //given in ImageConfidence as regions.
    //DrawTransparency determines the alpha value of the colors.
    //The used colors are returned.
    //
    //Define colors.
    hv_NumColors.Dispose();
    hv_NumColors = 20;
    hv_Colors.Dispose();
    get_distinct_colors(hv_NumColors, 0, 0, 100, out hv_Colors);
    hv_WeightsColorsAlpha.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WeightsColorsAlpha = hv_Colors+hv_DrawTransparency;
    }
    hv_ColorIndex.Dispose();
    hv_ColorIndex = 0;
    //
    //Threshold the image according to
    //the number of colors and
    //display resulting regions.
    HTuple end_val15 = hv_NumColors-1;
    HTuple step_val15 = 1;
    for (hv_ColorIndex=0; hv_ColorIndex.Continue(end_val15, step_val15); hv_ColorIndex = hv_ColorIndex.TupleAdd(step_val15))
    {
      hv_Threshold.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Threshold = hv_ColorIndex*(1.0/hv_NumColors);
      }
      hv_MinGray.Dispose();
      hv_MinGray = new HTuple(hv_Threshold);
      hv_MaxGray.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxGray = hv_Threshold+(1/hv_NumColors);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_Region.Dispose();
      HOperatorSet.Threshold(ho_ImageConfidence, out ho_Region, hv_Threshold, hv_Threshold+(1.0/hv_NumColors));
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_WeightsColorsAlpha.TupleSelect(
            hv_ColorIndex));
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Region, HDevWindowStack.GetActive());
      }
    }
    ho_Region.Dispose();

    hv_NumColors.Dispose();
    hv_WeightsColorsAlpha.Dispose();
    hv_ColorIndex.Dispose();
    hv_Threshold.Dispose();
    hv_MinGray.Dispose();
    hv_MaxGray.Dispose();

    return;
  }

  // Chapter: Identification / Data Code
  // Short Description: Display print quality information for individual data code modules. 
  public void dev_display_data_code_2d_print_quality_results (HTuple hv_DataCodeHandle, 
      HTuple hv_ResultHandle, HTuple hv_Mode, HTuple hv_QualityStandard, HTuple hv_Color, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue)
  {



    // Local iconic variables 

    HObject ho_Circle=null, ho_Cross=null;

    // Local control variables 

    HTuple hv_MODE_RMMG = new HTuple(), hv_MODE_GRID = new HTuple();
    HTuple hv_MODE_BAD = new HTuple(), hv_SupportedModes = new HTuple();
    HTuple hv_SupportedQualityStandards = new HTuple(), hv_GEN_CENTER = new HTuple();
    HTuple hv_GEN_CIRCLE = new HTuple(), hv_GEN_LEGEND = new HTuple();
    HTuple hv_GEN_MAX_GRADE = new HTuple(), hv_DisplayCenter = new HTuple();
    HTuple hv_DisplayCircle = new HTuple(), hv_DisplayLegend = new HTuple();
    HTuple hv_MaxGrade = new HTuple(), hv_I = new HTuple();
    HTuple hv_QualityParameter = new HTuple(), hv_QualityRows = new HTuple();
    HTuple hv_QualityCols = new HTuple(), hv_ModuleGrades = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Cols = new HTuple();
    HTuple hv_QualityLabels = new HTuple(), hv_Grades = new HTuple();
    HTuple hv_Labels = new HTuple(), hv_ModuleHeight = new HTuple();
    HTuple hv_ModuleWidth = new HTuple(), hv_Aperture = new HTuple();
    HTuple hv_Radius = new HTuple(), hv_Grade = new HTuple();
    HTuple hv_GradeIdx = new HTuple(), hv_GradeRows = new HTuple();
    HTuple hv_GradeCols = new HTuple(), hv_GradeRadius = new HTuple();
    HTuple   hv_Color_COPY_INP_TMP = new HTuple(hv_Color);
    HTuple   hv_QualityStandard_COPY_INP_TMP = new HTuple(hv_QualityStandard);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Circle);
    HOperatorSet.GenEmptyObj(out ho_Cross);
    //This procedure displays the print quality results for data matrix ECC 200 codes.
    //
    //
    //Available modes
    hv_MODE_RMMG.Dispose();
    hv_MODE_RMMG = "reflectance_margin_module_grades";
    hv_MODE_GRID.Dispose();
    hv_MODE_GRID = "grid";
    hv_MODE_BAD.Dispose();
    hv_MODE_BAD = "bad_modules";
    hv_SupportedModes.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SupportedModes = new HTuple();
    hv_SupportedModes = hv_SupportedModes.TupleConcat(hv_MODE_RMMG, hv_MODE_GRID, hv_MODE_BAD);
    }
    //Available standards
    hv_SupportedQualityStandards.Dispose();
    hv_SupportedQualityStandards = new HTuple();
    hv_SupportedQualityStandards[0] = "isoiec15415";
    hv_SupportedQualityStandards[1] = "isoiec_tr_29158";
    hv_SupportedQualityStandards[2] = "aimdpm_1_2006";
    //Available generic parameters
    hv_GEN_CENTER.Dispose();
    hv_GEN_CENTER = "center";
    hv_GEN_CIRCLE.Dispose();
    hv_GEN_CIRCLE = "circle";
    hv_GEN_LEGEND.Dispose();
    hv_GEN_LEGEND = "legend";
    hv_GEN_MAX_GRADE.Dispose();
    hv_GEN_MAX_GRADE = "max_grade";
    //Defaults
    hv_DisplayCenter.Dispose();
    hv_DisplayCenter = 0;
    hv_DisplayCircle.Dispose();
    hv_DisplayCircle = 1;
    hv_DisplayLegend.Dispose();
    hv_DisplayLegend = 1;
    hv_MaxGrade.Dispose();
    hv_MaxGrade = 3;
    //
    //Check modes
    if ((int)(new HTuple((new HTuple(hv_Mode.TupleLength())).TupleNotEqual(1))) != 0)
    {
      throw new HalconException("Please specify exactly one of following modes:"+(((" "+hv_SupportedModes)).TupleSum()
          ));
    }
    if ((int)(new HTuple(((hv_SupportedModes.TupleFind(hv_Mode))).TupleEqual(-1))) != 0)
    {
      throw new HalconException("Unknown Mode: "+hv_Mode);
    }
    //
    //Check QualityStandard
    if ((int)(new HTuple(((hv_SupportedQualityStandards.TupleFind(hv_QualityStandard_COPY_INP_TMP))).TupleEqual(
        -1))) != 0)
    {
      throw new HalconException("Unknown QualityStandard: "+hv_QualityStandard_COPY_INP_TMP);
    }
    else
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_QualityStandard = "quality_"+hv_QualityStandard_COPY_INP_TMP;
      hv_QualityStandard_COPY_INP_TMP.Dispose();
      hv_QualityStandard_COPY_INP_TMP = ExpTmpLocalVar_QualityStandard;
      }
      }
    }
    //
    //Check generic parameters
    //
    //Override defaults in special modes
    if ((int)(new HTuple(hv_Mode.TupleEqual(hv_MODE_GRID))) != 0)
    {
      hv_DisplayCenter.Dispose();
      hv_DisplayCenter = 1;
      hv_DisplayCircle.Dispose();
      hv_DisplayCircle = 0;
      hv_DisplayLegend.Dispose();
      hv_DisplayLegend = 0;
      hv_MaxGrade.Dispose();
      hv_MaxGrade = 4;
      if ((int)(new HTuple((new HTuple(hv_Color_COPY_INP_TMP.TupleLength())).TupleEqual(
          0))) != 0)
      {
        hv_Color_COPY_INP_TMP.Dispose();
        hv_Color_COPY_INP_TMP = "gray";
      }
    }
    else if ((int)(new HTuple(hv_Mode.TupleEqual(hv_MODE_BAD))) != 0)
    {
      hv_DisplayCenter.Dispose();
      hv_DisplayCenter = 0;
      hv_DisplayCircle.Dispose();
      hv_DisplayCircle = 1;
      hv_DisplayLegend.Dispose();
      hv_DisplayLegend = 0;
      hv_MaxGrade.Dispose();
      hv_MaxGrade = 0;
    }
    //
    if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleNotEqual(
        new HTuple(hv_GenParamValue.TupleLength())))) != 0)
    {
      //Check if number of values matches number of parameters
      throw new HalconException("GenParamName and GenParamValue do not match.");
    }
    else
    {
      //Set generic parameters
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_GenParamName.TupleLength()))-1); hv_I = (int)hv_I + 1)
      {
        //'center'
        if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_I))).TupleEqual(hv_GEN_CENTER))) != 0)
        {
          //Check if values are valid
          if ((int)((new HTuple(((hv_GenParamValue.TupleSelect(hv_I))).TupleNotEqual(
              "true"))).TupleAnd(new HTuple(((hv_GenParamValue.TupleSelect(hv_I))).TupleNotEqual(
              "false")))) != 0)
          {
            throw new HalconException(("Wrong parameter value for generic parameter 'center': "+(hv_GenParamValue.TupleSelect(
                hv_I)))+" Please use 'true' or 'false'.");
          }
          //Set new value
          hv_DisplayCenter.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DisplayCenter = new HTuple(((hv_GenParamValue.TupleSelect(
              hv_I))).TupleEqual("true"));
          }
          //'circle'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_I))).TupleEqual(
            hv_GEN_CIRCLE))) != 0)
        {
          //Check if values are valid
          if ((int)((new HTuple(((hv_GenParamValue.TupleSelect(hv_I))).TupleNotEqual(
              "true"))).TupleAnd(new HTuple(((hv_GenParamValue.TupleSelect(hv_I))).TupleNotEqual(
              "false")))) != 0)
          {
            throw new HalconException(("Wrong parameter value for generic parameter 'circle': "+(hv_GenParamValue.TupleSelect(
                hv_I)))+" Please use 'true' or 'false'.");
          }
          //Set new value
          hv_DisplayCircle.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DisplayCircle = new HTuple(((hv_GenParamValue.TupleSelect(
              hv_I))).TupleEqual("true"));
          }
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_I))).TupleEqual(
            hv_GEN_LEGEND))) != 0)
        {
          //Check if values are valid
          if ((int)((new HTuple(((hv_GenParamValue.TupleSelect(hv_I))).TupleNotEqual(
              "true"))).TupleAnd(new HTuple(((hv_GenParamValue.TupleSelect(hv_I))).TupleNotEqual(
              "false")))) != 0)
          {
            throw new HalconException(("Wrong parameter value for generic parameter 'legend': "+(hv_GenParamValue.TupleSelect(
                hv_I)))+" Please use 'true' or 'false'.");
          }
          //Set new value
          hv_DisplayLegend.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DisplayLegend = new HTuple(((hv_GenParamValue.TupleSelect(
              hv_I))).TupleEqual("true"));
          }
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_I))).TupleEqual(
            hv_GEN_MAX_GRADE))) != 0)
        {
          //Check if values are valid
          if ((int)((new HTuple(((hv_GenParamValue.TupleSelect(hv_I))).TupleLess(
              0))).TupleOr(new HTuple(((hv_GenParamValue.TupleSelect(hv_I))).TupleGreater(
              4)))) != 0)
          {
            throw new HalconException(("Wrong parameter value for generic parameter 'max_grade': "+(hv_GenParamValue.TupleSelect(
                hv_I)))+" Please use a value between 0 and 4.");
          }
          //Set new value
          hv_MaxGrade.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MaxGrade = ((hv_GenParamValue.TupleSelect(
              hv_I))).TupleInt();
          }
        }
        else
        {
          //Unknown parameter
          throw new HalconException("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
              hv_I)));
        }
      }
    }
    //
    //Check Color
    if ((int)(new HTuple((new HTuple(hv_Color_COPY_INP_TMP.TupleLength())).TupleEqual(
        0))) != 0)
    {
      hv_Color_COPY_INP_TMP.Dispose();
      hv_Color_COPY_INP_TMP = new HTuple();
      hv_Color_COPY_INP_TMP[0] = "red";
      hv_Color_COPY_INP_TMP[1] = "orange";
      hv_Color_COPY_INP_TMP[2] = "yellow";
      hv_Color_COPY_INP_TMP[3] = "cyan";
      hv_Color_COPY_INP_TMP[4] = "green";
    }
    //Build color tuple with rotating colors if too few colors are specified
    while ((int)(new HTuple((new HTuple(hv_Color_COPY_INP_TMP.TupleLength())).TupleLess(
        hv_MaxGrade+1))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Color = hv_Color_COPY_INP_TMP.TupleConcat(
          hv_Color_COPY_INP_TMP);
      hv_Color_COPY_INP_TMP.Dispose();
      hv_Color_COPY_INP_TMP = ExpTmpLocalVar_Color;
      }
      }
    }
    //
    //Visualization
    //
    //Get modulation grades, rows and cols for all symbol modules incl.
    //the 4 quiet zones adjacent to the symbol and the finder patterns.
    hv_QualityParameter.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QualityParameter = hv_QualityStandard_COPY_INP_TMP+"_reflectance_margin_module_grades";
    }
    hv_QualityRows.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QualityRows = hv_QualityStandard_COPY_INP_TMP+"_rows";
    }
    hv_QualityCols.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QualityCols = hv_QualityStandard_COPY_INP_TMP+"_cols";
    }
    hv_ModuleGrades.Dispose();
    HOperatorSet.GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityParameter, 
        out hv_ModuleGrades);
    hv_Rows.Dispose();
    HOperatorSet.GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityRows, 
        out hv_Rows);
    hv_Cols.Dispose();
    HOperatorSet.GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityCols, 
        out hv_Cols);
    hv_QualityLabels.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QualityLabels = hv_QualityStandard_COPY_INP_TMP+"_labels";
    }
    hv_Grades.Dispose();
    HOperatorSet.GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityStandard_COPY_INP_TMP, 
        out hv_Grades);
    hv_Labels.Dispose();
    HOperatorSet.GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityLabels, 
        out hv_Labels);
    hv_ModuleHeight.Dispose();
    HOperatorSet.GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, "module_height", 
        out hv_ModuleHeight);
    hv_ModuleWidth.Dispose();
    HOperatorSet.GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, "module_width", 
        out hv_ModuleWidth);
    hv_Aperture.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Aperture = hv_Grades.TupleSelect(
        hv_Labels.TupleFind("Aperture"));
    }
    hv_Radius.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Radius = (0.5*hv_Aperture)*(hv_ModuleHeight.TupleMin2(
        hv_ModuleWidth));
    }
    //
    //Iterate over all possible modulation grades to visualize
    HTuple end_val125 = hv_MaxGrade;
    HTuple step_val125 = 1;
    for (hv_Grade=0; hv_Grade.Continue(end_val125, step_val125); hv_Grade = hv_Grade.TupleAdd(step_val125))
    {
      hv_GradeIdx.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_GradeIdx = hv_ModuleGrades.TupleFind(
          hv_Grade);
      }
      if ((int)(new HTuple(hv_GradeIdx.TupleLess(0))) != 0)
      {
        continue;
      }
      hv_GradeRows.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_GradeRows = hv_Rows.TupleSelect(
          hv_GradeIdx);
      }
      hv_GradeCols.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_GradeCols = hv_Cols.TupleSelect(
          hv_GradeIdx);
      }
      hv_GradeRadius.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_GradeRadius = HTuple.TupleGenConst(
          new HTuple(hv_GradeRows.TupleLength()),hv_Radius);
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color_COPY_INP_TMP.TupleSelect(
            hv_Grade));
        }
      }
      if ((int)(hv_DisplayCircle) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Circle.Dispose();
        HOperatorSet.GenCircleContourXld(out ho_Circle, hv_GradeRows, hv_GradeCols, 
            hv_GradeRadius, (new HTuple(0)).TupleRad(), (new HTuple(360)).TupleRad()
            , "positive", 1);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Circle, HDevWindowStack.GetActive());
        }
      }
      if ((int)(hv_DisplayCenter) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Cross.Dispose();
        HOperatorSet.GenCrossContourXld(out ho_Cross, hv_GradeRows, hv_GradeCols, 
            2*hv_Radius, (new HTuple(0)).TupleRad());
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
        }
      }
    }
    if ((int)(hv_DisplayLegend) != 0)
    {
      //Display legend with modulation grades
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), (new HTuple("Reflectance Margin")).TupleConcat(
            "Module Grade "+HTuple.TupleGenSequence(0,hv_MaxGrade,1)), "window", 
            "bottom", "left", (new HTuple("white")).TupleConcat(hv_Color_COPY_INP_TMP), 
            "box_color", "#00000080");
        }
      }
    }
    ho_Circle.Dispose();
    ho_Cross.Dispose();

    hv_Color_COPY_INP_TMP.Dispose();
    hv_QualityStandard_COPY_INP_TMP.Dispose();
    hv_MODE_RMMG.Dispose();
    hv_MODE_GRID.Dispose();
    hv_MODE_BAD.Dispose();
    hv_SupportedModes.Dispose();
    hv_SupportedQualityStandards.Dispose();
    hv_GEN_CENTER.Dispose();
    hv_GEN_CIRCLE.Dispose();
    hv_GEN_LEGEND.Dispose();
    hv_GEN_MAX_GRADE.Dispose();
    hv_DisplayCenter.Dispose();
    hv_DisplayCircle.Dispose();
    hv_DisplayLegend.Dispose();
    hv_MaxGrade.Dispose();
    hv_I.Dispose();
    hv_QualityParameter.Dispose();
    hv_QualityRows.Dispose();
    hv_QualityCols.Dispose();
    hv_ModuleGrades.Dispose();
    hv_Rows.Dispose();
    hv_Cols.Dispose();
    hv_QualityLabels.Dispose();
    hv_Grades.Dispose();
    hv_Labels.Dispose();
    hv_ModuleHeight.Dispose();
    hv_ModuleWidth.Dispose();
    hv_Aperture.Dispose();
    hv_Radius.Dispose();
    hv_Grade.Dispose();
    hv_GradeIdx.Dispose();
    hv_GradeRows.Dispose();
    hv_GradeCols.Dispose();
    hv_GradeRadius.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Display the confusion matrix for the evaluation results of a model with type detection. 
  public void dev_display_detection_confusion_matrix (HTuple hv_WindowHandles, HTuple hv_IoUEvaluationResult, 
      HTuple hv_ClassIDs, HTuple hv_GenParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DisplayAbsoluteMatrix = new HTuple();
    HTuple hv_DisplayRelativeMatrix = new HTuple(), hv_DisplayColor = new HTuple();
    HTuple hv_DisplayColumnWidth = new HTuple(), hv_GenParamKeys = new HTuple();
    HTuple hv_KeyExists = new HTuple(), hv_ValueTmp = new HTuple();
    HTuple hv_DisplayColumnWidthTmp = new HTuple(), hv_CalculateRelativeMatrix = new HTuple();
    HTuple hv_ConfusionMatrix = new HTuple(), hv_NumRows = new HTuple();
    HTuple hv_NumColumns = new HTuple(), hv_Values = new HTuple();
    HTuple hv_ConfusionMatrixRelative = new HTuple(), hv_C = new HTuple();
    HTuple hv_RowValues = new HTuple(), hv_NumTPAndFN = new HTuple();
    HTuple hv_ValueColors = new HTuple(), hv_DiagonalColor = new HTuple();
    HTuple hv_Seq = new HTuple(), hv_DiagonalIndices = new HTuple();
    HTuple hv_ClassStrings = new HTuple(), hv_FPStrings = new HTuple();
    HTuple hv_ColumnNames = new HTuple(), hv_RowNames = new HTuple();
    HTuple hv_MatrixMaxID = new HTuple(), hv_MaxValue = new HTuple();
    HTuple hv_NumberFormat = new HTuple(), hv_ValuesRelative = new HTuple();
    HTuple   hv_GenParam_COPY_INP_TMP = new HTuple(hv_GenParam);

    // Initialize local and output iconic variables 
    //
    //This procedure displays the detection confusion matrix
    //given in IoUEvaluationResult.
    //Thereby, the matrix can be displayed with absolute or
    //relative values.
    //
    //Set generic parameter default values.
    hv_DisplayAbsoluteMatrix.Dispose();
    hv_DisplayAbsoluteMatrix = 1;
    hv_DisplayRelativeMatrix.Dispose();
    hv_DisplayRelativeMatrix = 0;
    hv_DisplayColor.Dispose();
    hv_DisplayColor = 1;
    hv_DisplayColumnWidth.Dispose();
    hv_DisplayColumnWidth = "equal";
    //
    //Parse generic parameters.
    if ((int)(new HTuple((new HTuple(hv_GenParam_COPY_INP_TMP.TupleLength())).TupleGreater(
        0))) != 0)
    {
      hv_GenParamKeys.Dispose();
      hv_GenParamKeys = new HTuple();
      hv_GenParamKeys[0] = "display_color";
      hv_GenParamKeys[1] = "display_relative_matrix";
      hv_GenParamKeys[2] = "display_absolute_matrix";
      hv_GenParamKeys[3] = "display_column_width";
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "key_exists", hv_GenParamKeys, 
          out hv_KeyExists);
      //DisplayColor
      if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_color", out hv_ValueTmp);
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
            hv_ValueTmp))).TupleEqual(-1)))) != 0)
        {
          throw new HalconException("Invalid value for 'display_color'");
        }
        else
        {
          hv_DisplayColor.Dispose();
          hv_DisplayColor = new HTuple(hv_ValueTmp);
        }
      }
      //DisplayRelativeMatrix
      if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_relative_matrix", 
            out hv_ValueTmp);
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
            hv_ValueTmp))).TupleEqual(-1)))) != 0)
        {
          throw new HalconException("Invalid value for 'display_relative_matrix'");
        }
        else
        {
          hv_DisplayRelativeMatrix.Dispose();
          hv_DisplayRelativeMatrix = new HTuple(hv_ValueTmp);
        }
      }
      //DisplayAbsoluteMatrix
      if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_absolute_matrix", 
            out hv_ValueTmp);
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
            hv_ValueTmp))).TupleEqual(-1)))) != 0)
        {
          throw new HalconException("Invalid value for 'display_absolute_matrix'");
        }
        else
        {
          hv_DisplayAbsoluteMatrix.Dispose();
          hv_DisplayAbsoluteMatrix = new HTuple(hv_ValueTmp);
        }
      }
      if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
      {
        hv_DisplayColumnWidthTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_column_width", 
            out hv_DisplayColumnWidthTmp);
        if ((int)((new HTuple((new HTuple(hv_DisplayColumnWidthTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple((new HTuple(((new HTuple("equal")).TupleConcat(
            "minimal")).TupleFind(hv_DisplayColumnWidthTmp))).TupleEqual(-1)))) != 0)
        {
          throw new HalconException("Invalid value for 'display_column_width'");
        }
        else
        {
          hv_DisplayColumnWidth.Dispose();
          hv_DisplayColumnWidth = new HTuple(hv_DisplayColumnWidthTmp);
        }
      }
    }
    //
    if ((int)((new HTuple(hv_DisplayRelativeMatrix.TupleOr(hv_DisplayAbsoluteMatrix))).TupleNot()
        ) != 0)
    {
      throw new HalconException("At least one of 'display_absolute_matrix' and 'display_relative_matrix' should be true");
    }
    if ((int)(new HTuple(((hv_DisplayRelativeMatrix+hv_DisplayAbsoluteMatrix)).TupleNotEqual(
        new HTuple(hv_WindowHandles.TupleLength())))) != 0)
    {
      throw new HalconException("Wrong number of WindowHandles");
    }
    if ((int)(hv_DisplayRelativeMatrix.TupleOr(hv_DisplayColor)) != 0)
    {
      hv_CalculateRelativeMatrix.Dispose();
      hv_CalculateRelativeMatrix = 1;
    }
    else
    {
      hv_CalculateRelativeMatrix.Dispose();
      hv_CalculateRelativeMatrix = 0;
    }
    //
    //Calculate the confusion matrix with absolute values
    //and the confusion matrix with relative errors.
    //We start with an empty matrix
    //and add the number of matching labels.
    hv_ConfusionMatrix.Dispose();
    HOperatorSet.GetDictTuple(hv_IoUEvaluationResult, "detection_confusion_matrix", 
        out hv_ConfusionMatrix);
    hv_NumRows.Dispose();hv_NumColumns.Dispose();
    HOperatorSet.GetSizeMatrix(hv_ConfusionMatrix, out hv_NumRows, out hv_NumColumns);
    hv_Values.Dispose();
    HOperatorSet.GetFullMatrix(hv_ConfusionMatrix, out hv_Values);
    //
    if ((int)(hv_CalculateRelativeMatrix) != 0)
    {
      //Calculate the relative matrix.
      hv_ConfusionMatrixRelative.Dispose();
      HOperatorSet.CopyMatrix(hv_ConfusionMatrix, out hv_ConfusionMatrixRelative);
      //For each class:
      for (hv_C=0; (int)hv_C<=(int)((new HTuple(hv_ClassIDs.TupleLength()))-1); hv_C = (int)hv_C + 1)
      {
        //Get the total number of predictions and calculate the relative values.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RowValues.Dispose();
        HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, HTuple.TupleGenConst(hv_NumColumns,
            hv_C), HTuple.TupleGenSequence(0,hv_NumColumns-1,1), out hv_RowValues);
        }
        if ((int)(new HTuple(((hv_RowValues.TupleSum())).TupleGreater(0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ConfusionMatrixRelative, HTuple.TupleGenConst(
              hv_NumColumns,hv_C), HTuple.TupleGenSequence(0,hv_NumColumns-1,1), 
              (hv_RowValues.TupleReal())/(hv_RowValues.TupleSum()));
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ConfusionMatrixRelative, HTuple.TupleGenConst(
              hv_NumColumns,hv_C), HTuple.TupleGenSequence(0,hv_NumColumns-1,1), 
              hv_RowValues.TupleReal());
          }
        }
        //Get the total number of ground truth and calculate relative false negatives.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumTPAndFN.Dispose();
        HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_C.TupleConcat(new HTuple(hv_ClassIDs.TupleLength()
            )), hv_C.TupleConcat(hv_C), out hv_NumTPAndFN);
        }
        if ((int)(new HTuple(((hv_NumTPAndFN.TupleSum())).TupleGreater(0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ConfusionMatrixRelative, new HTuple(hv_ClassIDs.TupleLength()
              ), hv_C, (((hv_NumTPAndFN.TupleSelect(1))).TupleReal())/(hv_NumTPAndFN.TupleSum()
              ));
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ConfusionMatrixRelative, new HTuple(hv_ClassIDs.TupleLength()
              ), hv_C, ((hv_NumTPAndFN.TupleSelect(1))).TupleReal());
          }
        }
      }
    }
    //
    //Set color for displayed confusion matrix.
    hv_ValueColors.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ValueColors = HTuple.TupleGenConst(
        new HTuple(hv_Values.TupleLength()),"#666666");
    }
    if ((int)(hv_DisplayColor) != 0)
    {
      //Display off-diagonal values in red.
      hv_ValueColors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ValueColors = HTuple.TupleGenConst(
          new HTuple(hv_Values.TupleLength()),"#ff4500");
      }
      //Display diagonal values in green.
      hv_DiagonalColor.Dispose();
      hv_DiagonalColor = "#00ff00";
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Seq.Dispose();
      HOperatorSet.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength()))-1, 
          1, out hv_Seq);
      }
      hv_DiagonalIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DiagonalIndices = (hv_NumColumns*hv_Seq)+hv_Seq;
      }
      if (hv_ValueColors == null)
        hv_ValueColors = new HTuple();
      hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
    }
    //
    //Display the matrix.
    //
    //Collect column and row names.
    hv_ClassStrings.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ClassStrings = "class_"+hv_ClassIDs;
    }
    hv_FPStrings.Dispose();
    hv_FPStrings = new HTuple();
    hv_FPStrings[0] = "FP bg";
    hv_FPStrings[1] = "FP loc";
    hv_FPStrings[2] = "FP dup";
    hv_FPStrings[3] = "FP mult";
    hv_ColumnNames.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColumnNames = new HTuple();
    hv_ColumnNames = hv_ColumnNames.TupleConcat(hv_ClassStrings, hv_FPStrings);
    }
    hv_RowNames.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RowNames = new HTuple();
    hv_RowNames = hv_RowNames.TupleConcat(hv_ClassStrings);
    hv_RowNames = hv_RowNames.TupleConcat("FN");
    }
    //
    //Create GenParam for matrix display.
    hv_GenParam_COPY_INP_TMP.Dispose();
    HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_column_width", hv_DisplayColumnWidth);
    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_color", hv_DisplayColor);
    //The last 4 values are meaningless and therefore not displayed.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "idxs_no_display", HTuple.TupleGenSequence(
        (new HTuple(hv_Values.TupleLength()))-4,(new HTuple(hv_Values.TupleLength()
        ))-1,1));
    }
    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "axis_titles", (new HTuple("Ground truth")).TupleConcat(
        "Predicted"));
    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "value_colors", hv_ValueColors);
    if ((int)(hv_DisplayAbsoluteMatrix) != 0)
    {
      //Display absolute matrix.
      //Calculate proper number format.
      hv_MatrixMaxID.Dispose();
      HOperatorSet.MaxMatrix(hv_ConfusionMatrix, "full", out hv_MatrixMaxID);
      hv_MaxValue.Dispose();
      HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
      if ((int)(new HTuple(hv_MaxValue.TupleGreater(0))) != 0)
      {
        hv_NumberFormat.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumberFormat = (((((hv_MaxValue.TupleLog10()
            )).TupleCeil())).TupleInt())+".0f";
        }
      }
      else
      {
        hv_NumberFormat.Dispose();
        hv_NumberFormat = "1.0f";
      }
      HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "number_format", hv_NumberFormat);
      //Set title.
      HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "title", new HTuple("Detection confusion matrix, absolute"));
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      dev_display_matrix(hv_ConfusionMatrix, hv_ColumnNames, hv_RowNames, hv_WindowHandles.TupleSelect(
          0), hv_GenParam_COPY_INP_TMP);
      }
    }
    if ((int)(hv_DisplayRelativeMatrix) != 0)
    {
      //Display relative matrix.
      //Convert relative matrix values to percent.
      hv_ValuesRelative.Dispose();
      HOperatorSet.GetFullMatrix(hv_ConfusionMatrixRelative, out hv_ValuesRelative);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetFullMatrix(hv_ConfusionMatrixRelative, 100*hv_ValuesRelative);
      }
      //Set number format.
      hv_NumberFormat.Dispose();
      hv_NumberFormat = "2.1f";
      HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "number_format", hv_NumberFormat);
      //Set title.
      HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "title", new HTuple("Detection confusion matrix, relative [%]"));
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      dev_display_matrix(hv_ConfusionMatrixRelative, hv_ColumnNames, hv_RowNames, 
          hv_WindowHandles.TupleSelect(hv_DisplayAbsoluteMatrix), hv_GenParam_COPY_INP_TMP);
      }
    }


    hv_GenParam_COPY_INP_TMP.Dispose();
    hv_DisplayAbsoluteMatrix.Dispose();
    hv_DisplayRelativeMatrix.Dispose();
    hv_DisplayColor.Dispose();
    hv_DisplayColumnWidth.Dispose();
    hv_GenParamKeys.Dispose();
    hv_KeyExists.Dispose();
    hv_ValueTmp.Dispose();
    hv_DisplayColumnWidthTmp.Dispose();
    hv_CalculateRelativeMatrix.Dispose();
    hv_ConfusionMatrix.Dispose();
    hv_NumRows.Dispose();
    hv_NumColumns.Dispose();
    hv_Values.Dispose();
    hv_ConfusionMatrixRelative.Dispose();
    hv_C.Dispose();
    hv_RowValues.Dispose();
    hv_NumTPAndFN.Dispose();
    hv_ValueColors.Dispose();
    hv_DiagonalColor.Dispose();
    hv_Seq.Dispose();
    hv_DiagonalIndices.Dispose();
    hv_ClassStrings.Dispose();
    hv_FPStrings.Dispose();
    hv_ColumnNames.Dispose();
    hv_RowNames.Dispose();
    hv_MatrixMaxID.Dispose();
    hv_MaxValue.Dispose();
    hv_NumberFormat.Dispose();
    hv_ValuesRelative.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Visualize the results of a detailed evaluation for a model of type detection. 
  public void dev_display_detection_detailed_evaluation (HTuple hv_EvaluationResult, 
      HTuple hv_EvalParam, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
  {



      // Local iconic variables 

      // Local control variables 

      HTuple hv_DisplayPieChartsPrecision = new HTuple();
      HTuple hv_DisplayPieChartsRecall = new HTuple(), hv_DisplayConfusionAbsolute = new HTuple();
      HTuple hv_DisplayConfusionRelative = new HTuple(), hv_BaseWindowRow = new HTuple();
      HTuple hv_BaseWindowColumn = new HTuple(), hv_DetailedEvaluation = new HTuple();
      HTuple hv_AvailableIoUThresholds = new HTuple(), hv_MaxNumDetections = new HTuple();
      HTuple hv_AreaRanges = new HTuple(), hv_ClassIDs = new HTuple();
      HTuple hv_IoUThreshold = new HTuple(), hv_AreaRangeName = new HTuple();
      HTuple hv_MaxNumDetStr = new HTuple(), hv_MaxNumEvaluationResult = new HTuple();
      HTuple hv_AreaEvaluationResult = new HTuple(), hv_IoUEvaluationResult = new HTuple();
      HTuple hv_GenParamKeys = new HTuple(), hv_Keys = new HTuple();
      HTuple hv_IndexKeys = new HTuple(), hv_KeyExists = new HTuple();
      HTuple hv_Value = new HTuple(), hv_Exception = new HTuple();
      HTuple hv_WindowExists = new HTuple(), hv_WindowHandlePieChartsPrecision = new HTuple();
      HTuple hv_WindowHandlePieChartsRecall = new HTuple(), hv_WindowHandlesConfusion = new HTuple();
      HTuple hv_WindowHandleConfusionAbsolute = new HTuple();
      HTuple hv_WindowHandleConfusionRelative = new HTuple();
      HTuple hv_ColConfusion = new HTuple(), hv_RowConfusion = new HTuple();
      HTuple hv_WidthConf = new HTuple(), hv_HeightConf = new HTuple();
      HTuple hv__ = new HTuple(), hv_Width = new HTuple(), hv_Height = new HTuple();
      HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
      HTuple   hv_GenParam_COPY_INP_TMP = new HTuple(hv_GenParam);
      HTuple   hv_WindowHandleDict_COPY_INP_TMP = new HTuple(hv_WindowHandleDict);

      // Initialize local and output iconic variables 
    //
    //This procedure visualizes the detailed evaluation results for a model of type detection.
    //
    //Set the default values.
    hv_DisplayPieChartsPrecision.Dispose();
    hv_DisplayPieChartsPrecision = 1;
    hv_DisplayPieChartsRecall.Dispose();
    hv_DisplayPieChartsRecall = 0;
    hv_DisplayConfusionAbsolute.Dispose();
    hv_DisplayConfusionAbsolute = 0;
    hv_DisplayConfusionRelative.Dispose();
    hv_DisplayConfusionRelative = 0;
    //
    //Default settings for window placement.
    hv_BaseWindowRow.Dispose();
    hv_BaseWindowRow = 0;
    hv_BaseWindowColumn.Dispose();
    hv_BaseWindowColumn = 0;
    //
    //Get some evaluation parameters.
    hv_DetailedEvaluation.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParam, "detailed_evaluation", out hv_DetailedEvaluation);
    if ((int)(hv_DetailedEvaluation.TupleNot()) != 0)
    {
      throw new HalconException("detailed_evaluation has to be set to true for this visualization");
    }
    hv_AvailableIoUThresholds.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParam, "iou_threshold", out hv_AvailableIoUThresholds);
    hv_MaxNumDetections.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParam, "max_num_detections", out hv_MaxNumDetections);
    hv_AreaRanges.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParam, "area_ranges", out hv_AreaRanges);
    hv_ClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParam, "class_ids", out hv_ClassIDs);
    //
    //Use the first value under IoU threshold, MaxNumDetections and area-range.
    hv_IoUThreshold.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IoUThreshold = hv_AvailableIoUThresholds.TupleSelect(
        0);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_MaxNumDetections = hv_MaxNumDetections.TupleSelect(
        0);
    hv_MaxNumDetections.Dispose();
    hv_MaxNumDetections = ExpTmpLocalVar_MaxNumDetections;
    }
    }
    hv_AreaRangeName.Dispose();
    HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaRangeName);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_AreaRangeName = hv_AreaRangeName.TupleSelect(
        0);
    hv_AreaRangeName.Dispose();
    hv_AreaRangeName = ExpTmpLocalVar_AreaRangeName;
    }
    }
    //Get detailed evaluation results.
    hv_MaxNumDetStr.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxNumDetStr = ""+hv_MaxNumDetections;
    }
    if ((int)(new HTuple(hv_MaxNumDetections.TupleEqual(-1))) != 0)
    {
      hv_MaxNumDetStr.Dispose();
      hv_MaxNumDetStr = "all";
    }
    //
    //Get the detailed evaluation results for the first IoU-threshold, although it might be changed below depending on generic parameters.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxNumEvaluationResult.Dispose();
    HOperatorSet.GetDictTuple(hv_EvaluationResult, "max_num_detections_"+hv_MaxNumDetStr, 
        out hv_MaxNumEvaluationResult);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_AreaEvaluationResult.Dispose();
    HOperatorSet.GetDictTuple(hv_MaxNumEvaluationResult, "area_"+hv_AreaRangeName, 
        out hv_AreaEvaluationResult);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IoUEvaluationResult.Dispose();
    HOperatorSet.GetDictTuple(hv_AreaEvaluationResult, "detailed_evaluation_iou_"+(((""+hv_IoUThreshold)).TupleRegexpReplace(
        "\\.","")), out hv_IoUEvaluationResult);
    }
    //
    //Handle the generic parameters.
    if ((int)(new HTuple((new HTuple(hv_GenParam_COPY_INP_TMP.TupleLength())).TupleGreater(
        0))) != 0)
    {
      hv_GenParamKeys.Dispose();
      hv_GenParamKeys = new HTuple();
      hv_GenParamKeys[0] = "display_mode";
      hv_GenParamKeys[1] = "window_row";
      hv_GenParamKeys[2] = "window_column";
      hv_GenParamKeys[3] = "max_num_detections";
      hv_GenParamKeys[4] = "area_range_name";
      hv_GenParamKeys[5] = "iou_threshold";
      hv_Keys.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "keys", new HTuple(), out hv_Keys);
      for (hv_IndexKeys=0; (int)hv_IndexKeys<=(int)((new HTuple(hv_Keys.TupleLength()
          ))-1); hv_IndexKeys = (int)hv_IndexKeys + 1)
      {
        if ((int)(new HTuple(((hv_GenParamKeys.TupleFind(hv_Keys.TupleSelect(hv_IndexKeys)))).TupleEqual(
            -1))) != 0)
        {
          throw new HalconException(("Invalid GenParam key '"+(hv_Keys.TupleSelect(
              hv_IndexKeys)))+"'");
        }
      }
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "key_exists", hv_GenParamKeys, 
          out hv_KeyExists);
      //Display mode.
      if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
            0), out hv_Value);
        }
        if ((int)(new HTuple((new HTuple(hv_Value.TupleLength())).TupleGreater(0))) != 0)
        {
          //Pie chart precision.
          hv_DisplayPieChartsPrecision.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DisplayPieChartsPrecision = hv_Value.TupleFind(
              "pie_charts_precision");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_DisplayPieChartsPrecision = (new HTuple((new HTuple(hv_DisplayPieChartsPrecision.TupleLength()
              )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayPieChartsPrecision.TupleNotEqual(
              -1)));
          hv_DisplayPieChartsPrecision.Dispose();
          hv_DisplayPieChartsPrecision = ExpTmpLocalVar_DisplayPieChartsPrecision;
          }
          }
          //Pie chart recall.
          hv_DisplayPieChartsRecall.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DisplayPieChartsRecall = hv_Value.TupleFind(
              "pie_charts_recall");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_DisplayPieChartsRecall = (new HTuple((new HTuple(hv_DisplayPieChartsRecall.TupleLength()
              )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayPieChartsRecall.TupleNotEqual(
              -1)));
          hv_DisplayPieChartsRecall.Dispose();
          hv_DisplayPieChartsRecall = ExpTmpLocalVar_DisplayPieChartsRecall;
          }
          }
          //Absolute confusion matrix.
          hv_DisplayConfusionAbsolute.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DisplayConfusionAbsolute = hv_Value.TupleFind(
              "absolute_confusion_matrix");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_DisplayConfusionAbsolute = (new HTuple((new HTuple(hv_DisplayConfusionAbsolute.TupleLength()
              )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayConfusionAbsolute.TupleNotEqual(
              -1)));
          hv_DisplayConfusionAbsolute.Dispose();
          hv_DisplayConfusionAbsolute = ExpTmpLocalVar_DisplayConfusionAbsolute;
          }
          }
          //Relative confusion matrix.
          hv_DisplayConfusionRelative.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DisplayConfusionRelative = hv_Value.TupleFind(
              "relative_confusion_matrix");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_DisplayConfusionRelative = (new HTuple((new HTuple(hv_DisplayConfusionRelative.TupleLength()
              )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayConfusionRelative.TupleNotEqual(
              -1)));
          hv_DisplayConfusionRelative.Dispose();
          hv_DisplayConfusionRelative = ExpTmpLocalVar_DisplayConfusionRelative;
          }
          }
          if ((int)((new HTuple((new HTuple((new HTuple(hv_DisplayPieChartsPrecision.TupleOr(
              hv_DisplayPieChartsRecall))).TupleOr(hv_DisplayConfusionAbsolute))).TupleOr(
              hv_DisplayConfusionRelative))).TupleNot()) != 0)
          {
            throw new HalconException("'display_mode' not supported.");
          }
        }
      }
      //BaseWindowRow.
      if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
            1), out hv_Value);
        }
        if ((int)((new HTuple((new HTuple(hv_Value.TupleLength())).TupleEqual(1))).TupleAnd(
            new HTuple(hv_Value.TupleGreaterEqual(0)))) != 0)
        {
          hv_BaseWindowRow.Dispose();
          hv_BaseWindowRow = new HTuple(hv_Value);
        }
        else
        {
          throw new HalconException("Invalid GenParam 'window_row'.");
        }
      }
      //BaseWindowColumn.
      if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
            2), out hv_Value);
        }
        if ((int)((new HTuple((new HTuple(hv_Value.TupleLength())).TupleEqual(1))).TupleAnd(
            new HTuple(hv_Value.TupleGreaterEqual(0)))) != 0)
        {
          hv_BaseWindowColumn.Dispose();
          hv_BaseWindowColumn = new HTuple(hv_Value);
        }
        else
        {
          throw new HalconException("Invalid GenParam 'window_column'.");
        }
      }
      //MaxNumDetections.
      if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
            3), out hv_Value);
        }
        hv_MaxNumDetStr.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxNumDetStr = ""+hv_Value;
        }
        if ((int)(new HTuple(hv_Value.TupleEqual(-1))) != 0)
        {
          hv_MaxNumDetStr.Dispose();
          hv_MaxNumDetStr = "all";
        }
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MaxNumEvaluationResult.Dispose();
          HOperatorSet.GetDictTuple(hv_EvaluationResult, "max_num_detections_"+hv_MaxNumDetStr, 
              out hv_MaxNumEvaluationResult);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          throw new HalconException("Invalid GenParam 'max_num_detections'");
        }
        hv_MaxNumDetections.Dispose();
        hv_MaxNumDetections = new HTuple(hv_Value);
      }
      //AreaRange.
      if ((int)(hv_KeyExists.TupleSelect(4)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
            4), out hv_Value);
        }
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AreaEvaluationResult.Dispose();
          HOperatorSet.GetDictTuple(hv_MaxNumEvaluationResult, "area_"+hv_Value, 
              out hv_AreaEvaluationResult);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          throw new HalconException("Invalid GenParam 'area_range_name'");
        }
        hv_AreaRangeName.Dispose();
        hv_AreaRangeName = new HTuple(hv_Value);
      }
      //IoUThreshold.
      if ((int)(hv_KeyExists.TupleSelect(5)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
            5), out hv_Value);
        }
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IoUEvaluationResult.Dispose();
          HOperatorSet.GetDictTuple(hv_AreaEvaluationResult, "detailed_evaluation_iou_"+(((""+hv_Value)).TupleRegexpReplace(
              "\\.","")), out hv_IoUEvaluationResult);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          throw new HalconException("Invalid GenParam 'iou_threshold'");
        }
        hv_IoUThreshold.Dispose();
        hv_IoUThreshold = new HTuple(hv_Value);
      }
    }
    //
    //Check that the WindowHandleDict is of type dictionary.
    try
    {
      hv_Keys.Dispose();
      HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "keys", new HTuple(), 
          out hv_Keys);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1401))) != 0)
      {
        throw new HalconException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
      }
      else
      {
        throw new HalconException(hv_Exception);
      }
    }
    //
    //Update the IoUEvaluationResult in case MaxNumDetections, AreaRange or IoUThreshold have changed.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxNumEvaluationResult.Dispose();
    HOperatorSet.GetDictTuple(hv_EvaluationResult, "max_num_detections_"+hv_MaxNumDetStr, 
        out hv_MaxNumEvaluationResult);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_AreaEvaluationResult.Dispose();
    HOperatorSet.GetDictTuple(hv_MaxNumEvaluationResult, "area_"+hv_AreaRangeName, 
        out hv_AreaEvaluationResult);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IoUEvaluationResult.Dispose();
    HOperatorSet.GetDictTuple(hv_AreaEvaluationResult, "detailed_evaluation_iou_"+(((""+hv_IoUThreshold)).TupleRegexpReplace(
        "\\.","")), out hv_IoUEvaluationResult);
    }
    HOperatorSet.SetDictTuple(hv_IoUEvaluationResult, "iou_threshold", hv_IoUThreshold);
    //
    //Generate pie-charts with false positives information.
    if ((int)(hv_DisplayPieChartsPrecision) != 0)
    {
      hv_WindowExists.Dispose();
      HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "key_exists", "window_pie_chart_precision", 
          out hv_WindowExists);
      if ((int)(hv_WindowExists.TupleNot()) != 0)
      {
        HOperatorSet.SetWindowAttr("background_color","black");
        HOperatorSet.OpenWindow(hv_BaseWindowRow,hv_BaseWindowColumn,512,512,0,"visible","",out hv_WindowHandlePieChartsPrecision);
        HDevWindowStack.Push(hv_WindowHandlePieChartsPrecision);
        HOperatorSet.SetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_pie_chart_precision", 
            hv_WindowHandlePieChartsPrecision);
      }
      else
      {
        hv_WindowHandlePieChartsPrecision.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_pie_chart_precision", 
            out hv_WindowHandlePieChartsPrecision);
      }
      dev_display_detection_evaluation_pie_charts(hv_WindowHandlePieChartsPrecision, 
          hv_IoUEvaluationResult, hv_ClassIDs, "precision", hv_BaseWindowRow, hv_BaseWindowColumn);
    }
    //
    //Generate pie-charts with false negatives information.
    if ((int)(hv_DisplayPieChartsRecall) != 0)
    {
      hv_WindowExists.Dispose();
      HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "key_exists", "window_pie_chart_recall", 
          out hv_WindowExists);
      if ((int)(hv_WindowExists.TupleNot()) != 0)
      {
        HOperatorSet.SetWindowAttr("background_color","black");
        HOperatorSet.OpenWindow(hv_BaseWindowRow,hv_BaseWindowColumn,512,512,0,"visible","",out hv_WindowHandlePieChartsRecall);
        HDevWindowStack.Push(hv_WindowHandlePieChartsRecall);
        HOperatorSet.SetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_pie_chart_recall", 
            hv_WindowHandlePieChartsRecall);
      }
      else
      {
        hv_WindowHandlePieChartsRecall.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_pie_chart_recall", 
            out hv_WindowHandlePieChartsRecall);
      }
      dev_display_detection_evaluation_pie_charts(hv_WindowHandlePieChartsRecall, 
          hv_IoUEvaluationResult, hv_ClassIDs, "recall", hv_BaseWindowRow, hv_BaseWindowColumn);
    }
    //
    //Visualize detection confusion matrix.
    if ((int)(hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)) != 0)
    {
      hv_WindowHandlesConfusion.Dispose();
      hv_WindowHandlesConfusion = new HTuple();
      hv_GenParam_COPY_INP_TMP.Dispose();
      HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
      HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_relative_matrix", 
          hv_DisplayConfusionRelative);
      HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_absolute_matrix", 
          hv_DisplayConfusionAbsolute);
      HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_color", 1);
      if ((int)(hv_DisplayConfusionAbsolute) != 0)
      {
        hv_WindowExists.Dispose();
        HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "key_exists", 
            "window_absolute_confusion_matrix", out hv_WindowExists);
        if ((int)(hv_WindowExists.TupleNot()) != 0)
        {
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_BaseWindowRow,hv_BaseWindowColumn,512,512,0,"visible","",out hv_WindowHandleConfusionAbsolute);
          HDevWindowStack.Push(hv_WindowHandleConfusionAbsolute);
          HOperatorSet.SetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_absolute_confusion_matrix", 
              hv_WindowHandleConfusionAbsolute);
        }
        else
        {
          hv_WindowHandleConfusionAbsolute.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_absolute_confusion_matrix", 
              out hv_WindowHandleConfusionAbsolute);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_WindowHandlesConfusion = hv_WindowHandlesConfusion.TupleConcat(
            hv_WindowHandleConfusionAbsolute);
        hv_WindowHandlesConfusion.Dispose();
        hv_WindowHandlesConfusion = ExpTmpLocalVar_WindowHandlesConfusion;
        }
        }
      }
      if ((int)(hv_DisplayConfusionRelative) != 0)
      {
        hv_WindowExists.Dispose();
        HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "key_exists", 
            "window_relative_confusion_matrix", out hv_WindowExists);
        if ((int)(hv_WindowExists.TupleNot()) != 0)
        {
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(hv_BaseWindowRow,hv_BaseWindowColumn,512,512,0,"visible","",out hv_WindowHandleConfusionRelative);
          HDevWindowStack.Push(hv_WindowHandleConfusionRelative);
          HOperatorSet.SetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_relative_confusion_matrix", 
              hv_WindowHandleConfusionRelative);
        }
        else
        {
          hv_WindowHandleConfusionRelative.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_relative_confusion_matrix", 
              out hv_WindowHandleConfusionRelative);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_WindowHandlesConfusion = hv_WindowHandlesConfusion.TupleConcat(
            hv_WindowHandleConfusionRelative);
        hv_WindowHandlesConfusion.Dispose();
        hv_WindowHandlesConfusion = ExpTmpLocalVar_WindowHandlesConfusion;
        }
        }
      }
      dev_display_detection_confusion_matrix(hv_WindowHandlesConfusion, hv_IoUEvaluationResult, 
          hv_ClassIDs, hv_GenParam_COPY_INP_TMP);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_WindowHandleDict = hv_WindowHandleDict_COPY_INP_TMP.TupleConcat(
          hv_WindowHandlesConfusion);
      hv_WindowHandleDict_COPY_INP_TMP.Dispose();
      hv_WindowHandleDict_COPY_INP_TMP = ExpTmpLocalVar_WindowHandleDict;
      }
      }
    }
    //
    //Rearrange windows.
    //If all four windows are used we display the pie-charts to the left,
    //while to the right the confusion matrices are shown below each other.
    //Else, if the pie-charts are not displayed, we display the confusion matrices next to each other.
    if ((int)(new HTuple((new HTuple(hv_WindowHandleDict_COPY_INP_TMP.TupleLength()
        )).TupleGreaterEqual(1))) != 0)
    {
      hv_ColConfusion.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColConfusion = new HTuple();
      hv_ColConfusion = hv_ColConfusion.TupleConcat(hv_BaseWindowColumn, hv_BaseWindowColumn);
      }
      hv_RowConfusion.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RowConfusion = new HTuple();
      hv_RowConfusion = hv_RowConfusion.TupleConcat(hv_BaseWindowRow, hv_BaseWindowRow);
      }
      hv_WidthConf.Dispose();
      hv_WidthConf = -1;
      hv_HeightConf.Dispose();
      hv_HeightConf = -1;
      if ((int)(hv_DisplayPieChartsPrecision.TupleOr(hv_DisplayPieChartsRecall)) != 0)
      {
        if ((int)(hv_DisplayPieChartsPrecision) != 0)
        {
          hv__.Dispose();hv__.Dispose();hv_Width.Dispose();hv_Height.Dispose();
          HOperatorSet.GetWindowExtents(hv_WindowHandlePieChartsPrecision, out hv__, 
              out hv__, out hv_Width, out hv_Height);
          HDevWindowStack.SetActive(hv_WindowHandlePieChartsPrecision);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_BaseWindowRow, 
                hv_BaseWindowColumn, hv_Width, hv_Height);
          }
        }
        else
        {
          hv__.Dispose();hv__.Dispose();hv_Width.Dispose();hv_Height.Dispose();
          HOperatorSet.GetWindowExtents(hv_WindowHandlePieChartsRecall, out hv__, 
              out hv__, out hv_Width, out hv_Height);
          if ((int)(hv_DisplayPieChartsPrecision.TupleNot()) != 0)
          {
            HDevWindowStack.SetActive(hv_WindowHandlePieChartsRecall);
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_BaseWindowRow, 
                  hv_BaseWindowColumn, hv_Width, hv_Height);
            }
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ColConfusion = (hv_ColConfusion+hv_Width)+8;
        hv_ColConfusion.Dispose();
        hv_ColConfusion = ExpTmpLocalVar_ColConfusion;
        }
        }
        if ((int)(hv_DisplayPieChartsPrecision.TupleAnd(hv_DisplayPieChartsRecall)) != 0)
        {
          HDevWindowStack.SetActive(hv_WindowHandlePieChartsRecall);
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), (hv_BaseWindowRow+hv_Height)+55, 
                hv_BaseWindowColumn, hv_Width, hv_Height);
            }
          }
        }
      }
      if ((int)(hv_DisplayConfusionAbsolute) != 0)
      {
        hv_Row.Dispose();hv_Column.Dispose();hv_WidthConf.Dispose();hv_HeightConf.Dispose();
        HOperatorSet.GetWindowExtents(hv_WindowHandleConfusionAbsolute, out hv_Row, 
            out hv_Column, out hv_WidthConf, out hv_HeightConf);
        HDevWindowStack.SetActive(hv_WindowHandleConfusionAbsolute);
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_RowConfusion.TupleSelect(
              0), hv_ColConfusion.TupleSelect(0), hv_WidthConf, hv_HeightConf);
          }
        }
        if ((int)(hv_DisplayPieChartsPrecision.TupleOr(hv_DisplayPieChartsRecall)) != 0)
        {
          if (hv_RowConfusion == null)
            hv_RowConfusion = new HTuple();
          hv_RowConfusion[1] = ((hv_RowConfusion.TupleSelect(1))+hv_HeightConf)+55;
        }
        else
        {
          if (hv_ColConfusion == null)
            hv_ColConfusion = new HTuple();
          hv_ColConfusion[1] = ((hv_ColConfusion.TupleSelect(1))+hv_WidthConf)+8;
        }
      }
      if ((int)(hv_DisplayConfusionRelative) != 0)
      {
        HDevWindowStack.SetActive(hv_WindowHandleConfusionRelative);
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_RowConfusion.TupleSelect(
              1), hv_ColConfusion.TupleSelect(1), hv_WidthConf, hv_HeightConf);
          }
        }
      }
    }
    //

    hv_GenParam_COPY_INP_TMP.Dispose();
    hv_WindowHandleDict_COPY_INP_TMP.Dispose();
    hv_DisplayPieChartsPrecision.Dispose();
    hv_DisplayPieChartsRecall.Dispose();
    hv_DisplayConfusionAbsolute.Dispose();
    hv_DisplayConfusionRelative.Dispose();
    hv_BaseWindowRow.Dispose();
    hv_BaseWindowColumn.Dispose();
    hv_DetailedEvaluation.Dispose();
    hv_AvailableIoUThresholds.Dispose();
    hv_MaxNumDetections.Dispose();
    hv_AreaRanges.Dispose();
    hv_ClassIDs.Dispose();
    hv_IoUThreshold.Dispose();
    hv_AreaRangeName.Dispose();
    hv_MaxNumDetStr.Dispose();
    hv_MaxNumEvaluationResult.Dispose();
    hv_AreaEvaluationResult.Dispose();
    hv_IoUEvaluationResult.Dispose();
    hv_GenParamKeys.Dispose();
    hv_Keys.Dispose();
    hv_IndexKeys.Dispose();
    hv_KeyExists.Dispose();
    hv_Value.Dispose();
    hv_Exception.Dispose();
    hv_WindowExists.Dispose();
    hv_WindowHandlePieChartsPrecision.Dispose();
    hv_WindowHandlePieChartsRecall.Dispose();
    hv_WindowHandlesConfusion.Dispose();
    hv_WindowHandleConfusionAbsolute.Dispose();
    hv_WindowHandleConfusionRelative.Dispose();
    hv_ColConfusion.Dispose();
    hv_RowConfusion.Dispose();
    hv_WidthConf.Dispose();
    hv_HeightConf.Dispose();
    hv__.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Display a pie-chart for the evaluation results of one class or all classes together. 
  public void dev_display_detection_eval_class_pie_chart (HTuple hv_WindowHandle, 
      HTuple hv_ClassEvaluationResult, HTuple hv_CenterRow, HTuple hv_Mode, HTuple hv_CenterColumn, 
      HTuple hv_Radius, HTuple hv_Colors, HTuple hv_Title, out HTuple hv_Ratios)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_SectorFP;

    // Local control variables 

    HTuple hv_Keys = new HTuple(), hv_Numbers = new HTuple();
    HTuple hv_K = new HTuple(), hv_Num = new HTuple(), hv_NumTotal = new HTuple();
    HTuple hv_ColorsPieChart = new HTuple(), hv_GenParamPieChart = new HTuple();
    HTuple hv_NumFP = new HTuple(), hv_FullCircleAngle = new HTuple();
    HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DRotate = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SectorFP);
    hv_Ratios = new HTuple();
    //This procedure displays the evaluation results
    //in the dictionary ClassEvaluationResult as a pie-chart.
    //Thereby, the procedure plots one pie-chart
    //for a specific class or all classes together.
    //
    //num_fp has to be handled separately.
    if ((int)(new HTuple(hv_Mode.TupleEqual("precision"))) != 0)
    {
      hv_Keys.Dispose();
      hv_Keys = new HTuple();
      hv_Keys[0] = "num_tp";
      hv_Keys[1] = "num_fp_class";
      hv_Keys[2] = "num_fp_background";
      hv_Keys[3] = "num_fp_localization";
      hv_Keys[4] = "num_fp_duplicate";
      hv_Keys[5] = "num_fp_multiple";
    }
    else
    {
      hv_Keys.Dispose();
      hv_Keys = new HTuple();
      hv_Keys[0] = "num_tp";
      hv_Keys[1] = "num_fn";
    }
    hv_Numbers.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Numbers = HTuple.TupleGenConst(
        new HTuple(hv_Keys.TupleLength()),0);
    }
    for (hv_K=0; (int)hv_K<=(int)((new HTuple(hv_Keys.TupleLength()))-1); hv_K = (int)hv_K + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Num.Dispose();
      HOperatorSet.GetDictTuple(hv_ClassEvaluationResult, hv_Keys.TupleSelect(hv_K), 
          out hv_Num);
      }
      if (hv_Numbers == null)
        hv_Numbers = new HTuple();
      hv_Numbers[hv_K] = hv_Num;
    }
    hv_NumTotal.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumTotal = hv_Numbers.TupleSum()
        ;
    }
    hv_ColorsPieChart.Dispose();
    hv_ColorsPieChart = new HTuple(hv_Colors);
    if ((int)(new HTuple(hv_NumTotal.TupleEqual(0))) != 0)
    {
      //No predictions available, we print a full gray circle.
      hv_Ratios.Dispose();
      hv_Ratios = 1.0;
      hv_ColorsPieChart.Dispose();
      hv_ColorsPieChart = "gray";
    }
    else
    {
      hv_Ratios.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ratios = (hv_Numbers.TupleReal()
          )/hv_NumTotal;
      }
    }
    //
    //Draw the pie-chart.
    hv_GenParamPieChart.Dispose();
    HOperatorSet.CreateDict(out hv_GenParamPieChart);
    if ((int)(new HTuple(hv_Title.TupleNotEqual(""))) != 0)
    {
      HOperatorSet.SetDictTuple(hv_GenParamPieChart, "title", hv_Title);
    }
    dev_display_pie_chart(hv_WindowHandle, hv_Ratios, hv_CenterRow, hv_CenterColumn, 
        hv_Radius, hv_ColorsPieChart, hv_GenParamPieChart);
    //
    //Highlight total number of false positives.
    if ((int)(new HTuple(hv_NumTotal.TupleGreater(0))) != 0)
    {
      //Add ratio of all false positives to output if there are any detections.
      hv_NumFP.Dispose();
      HOperatorSet.GetDictTuple(hv_ClassEvaluationResult, "num_fp", out hv_NumFP);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Ratios = hv_Ratios.TupleConcat(
          (hv_NumFP.TupleReal())/hv_NumTotal);
      hv_Ratios.Dispose();
      hv_Ratios = ExpTmpLocalVar_Ratios;
      }
      }
    }
    hv_FullCircleAngle.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_FullCircleAngle = 2*3.14159;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_SectorFP.Dispose();
    HOperatorSet.GenCircleSector(out ho_SectorFP, hv_CenterRow, hv_CenterColumn, 
        hv_Radius+2, (hv_Ratios.TupleSelect(0))*hv_FullCircleAngle, hv_FullCircleAngle);
    }
    //Rotate.
    hv_HomMat2DIdentity.Dispose();
    HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HomMat2DRotate.Dispose();
    HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, 0.25*hv_FullCircleAngle, hv_CenterRow, 
        hv_CenterColumn, out hv_HomMat2DRotate);
    }
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.AffineTransRegion(ho_SectorFP, out ExpTmpOutVar_0, hv_HomMat2DRotate, 
        "nearest_neighbor");
    ho_SectorFP.Dispose();
    ho_SectorFP = ExpTmpOutVar_0;
    }
    HDevWindowStack.SetActive(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorsPieChart.TupleSelect(
          (new HTuple(hv_ColorsPieChart.TupleLength()))-1));
      }
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 4);
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_SectorFP, HDevWindowStack.GetActive());
    }
    ho_SectorFP.Dispose();

    hv_Keys.Dispose();
    hv_Numbers.Dispose();
    hv_K.Dispose();
    hv_Num.Dispose();
    hv_NumTotal.Dispose();
    hv_ColorsPieChart.Dispose();
    hv_GenParamPieChart.Dispose();
    hv_NumFP.Dispose();
    hv_FullCircleAngle.Dispose();
    hv_HomMat2DIdentity.Dispose();
    hv_HomMat2DRotate.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Display the evaluation results as pie-charts. 
  public void dev_display_detection_evaluation_pie_charts (HTuple hv_WindowHandle, 
      HTuple hv_IoUEvaluationResult, HTuple hv_ClassIDs, HTuple hv_Mode, HTuple hv_BaseWindowRow, 
      HTuple hv_BaseWindowColumn)
  {



    // Local iconic variables 

    HObject ho_Image;

    // Local control variables 

    HTuple hv_CenterRowOverall = new HTuple();
    HTuple hv_CenterColOverall = new HTuple(), hv_RadiusOverall = new HTuple();
    HTuple hv_ClassChartsPerRow = new HTuple(), hv_RadiusClass = new HTuple();
    HTuple hv_ChartRowDistance = new HTuple(), hv_ChartColDistance = new HTuple();
    HTuple hv_StartRow = new HTuple(), hv_StartCol = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    HTuple hv_Font = new HTuple(), hv_NumColors = new HTuple();
    HTuple hv_Colors = new HTuple(), hv_ColorsFP = new HTuple();
    HTuple hv_Ratios = new HTuple(), hv_Descriptions = new HTuple();
    HTuple hv_IoUThreshold = new HTuple(), hv_PercentStr = new HTuple();
    HTuple hv_IndexDescription = new HTuple(), hv_C = new HTuple();
    HTuple hv_CenterRow = new HTuple(), hv_CenterCol = new HTuple();
    HTuple hv_ClassEvaluationResult = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    //Display the detailed evaluation results for TP and FP as pie-charts.
    //
    //Drawing parameters.
    //Overall pie-chart.
    hv_CenterRowOverall.Dispose();
    hv_CenterRowOverall = 150;
    hv_CenterColOverall.Dispose();
    hv_CenterColOverall = 150;
    hv_RadiusOverall.Dispose();
    hv_RadiusOverall = 100;
    //Per-class pie-chart.
    hv_ClassChartsPerRow.Dispose();
    hv_ClassChartsPerRow = 10;
    hv_RadiusClass.Dispose();
    hv_RadiusClass = 40;
    hv_ChartRowDistance.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ChartRowDistance = 3*hv_RadiusClass;
    }
    hv_ChartColDistance.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ChartColDistance = 2.5*hv_RadiusClass;
    }
    hv_StartRow.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_StartRow = (hv_CenterRowOverall+(1.5*hv_RadiusOverall))+(1.5*hv_RadiusClass);
    }
    hv_StartCol.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_StartCol = 1.5*hv_RadiusClass;
    }
    //
    //Open Window and set font.
    hv_WindowWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowWidth = (new HTuple(600)).TupleMax2(
        ((((new HTuple(hv_ClassIDs.TupleLength())).TupleMin2(hv_ClassChartsPerRow))-1)*hv_ChartColDistance)+(2*hv_StartCol));
    }
    hv_WindowHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowHeight = (3*hv_RadiusOverall)+(((((((new HTuple(hv_ClassIDs.TupleLength()
        )).TupleReal())/hv_ClassChartsPerRow)).TupleCeil())*3)*hv_RadiusClass);
    }
    HDevWindowStack.SetActive(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_BaseWindowRow, 
          hv_BaseWindowColumn, hv_WindowWidth, hv_WindowHeight);
    }
    ho_Image.Dispose();
    HOperatorSet.GenImageConst(out ho_Image, "byte", hv_WindowWidth, hv_WindowHeight);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
    }
    hv_Font.Dispose();
    HOperatorSet.QueryFont(hv_WindowHandle, out hv_Font);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Font = (hv_Font.TupleSelect(
        0))+"-Bold-15";
    hv_Font.Dispose();
    hv_Font = ExpTmpLocalVar_Font;
    }
    }
    HOperatorSet.SetFont(hv_WindowHandle, hv_Font);
    //
    //Generate different red colors for false positive categories.
    if ((int)(new HTuple(hv_Mode.TupleEqual("precision"))) != 0)
    {
      hv_NumColors.Dispose();
      hv_NumColors = 7;
    }
    else
    {
      hv_NumColors.Dispose();
      hv_NumColors = 2;
    }
    hv_Colors.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Colors = HTuple.TupleGenConst(
        hv_NumColors,"");
    }
    if (hv_Colors == null)
      hv_Colors = new HTuple();
    hv_Colors[0] = "green";
    if (hv_Colors == null)
      hv_Colors = new HTuple();
    hv_Colors[hv_NumColors-1] = "red";
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColorsFP.Dispose();
    get_distinct_colors(hv_NumColors-1, 0, 10, 45, out hv_ColorsFP);
    }
    if (hv_Colors == null)
      hv_Colors = new HTuple();
    hv_Colors[HTuple.TupleGenSequence(1,hv_NumColors-2,1)] = hv_ColorsFP.TupleSelectRange(
        1,(new HTuple(hv_ColorsFP.TupleLength()))-1);
    //
    hv_Ratios.Dispose();
    dev_display_detection_eval_class_pie_chart(hv_WindowHandle, hv_IoUEvaluationResult, 
        hv_CenterRowOverall, hv_Mode, hv_CenterColOverall, hv_RadiusOverall, hv_Colors, 
        "All classes", out hv_Ratios);
    //
    //Write descriptions for overall pie-chart.
    if ((int)(new HTuple((new HTuple(hv_Ratios.TupleLength())).TupleGreater(1))) != 0)
    {
      if ((int)(new HTuple(hv_Mode.TupleEqual("precision"))) != 0)
      {
        hv_Descriptions.Dispose();
        hv_Descriptions = new HTuple();
        hv_Descriptions[0] = "true positives";
        hv_Descriptions[1] = "false positives: wrong class";
        hv_Descriptions[2] = "false positives: background";
        hv_Descriptions[3] = "false positives: bad localization";
        hv_Descriptions[4] = "false positives: duplicate";
        hv_Descriptions[5] = "false positives: multiple reasons";
        hv_Descriptions[6] = "false positives: total";
      }
      else
      {
        hv_Descriptions.Dispose();
        hv_Descriptions = new HTuple();
        hv_Descriptions[0] = "recall (TP / TP + FN)";
        hv_Descriptions[1] = "false negatives";
      }
      hv_IoUThreshold.Dispose();
      HOperatorSet.GetDictTuple(hv_IoUEvaluationResult, "iou_threshold", out hv_IoUThreshold);
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Results @ IoU: "+hv_IoUThreshold, 
            "image", 20, (hv_CenterColOverall+hv_RadiusOverall)+20, "white", "box", 
            "false");
        }
      }
      hv_PercentStr.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PercentStr = (((hv_Ratios*100)).TupleString(
          ".1f"))+"";
      }
      for (hv_IndexDescription=0; (int)hv_IndexDescription<=(int)((new HTuple(hv_Descriptions.TupleLength()
          ))-2); hv_IndexDescription = (int)hv_IndexDescription + 1)
      {
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), ((hv_PercentStr.TupleSelect(
              hv_IndexDescription))+"%: ")+(hv_Descriptions.TupleSelect(hv_IndexDescription)), 
              "image", 30+((hv_IndexDescription+1)*20), (hv_CenterColOverall+hv_RadiusOverall)+20, 
              hv_Colors.TupleSelect(hv_IndexDescription), "box", "false");
          }
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), ((hv_PercentStr.TupleSelect(
            hv_IndexDescription))+"%: ")+(hv_Descriptions.TupleSelect(hv_IndexDescription)), 
            "image", 30+((hv_IndexDescription+1)*20), (hv_CenterColOverall+hv_RadiusOverall)+20, 
            hv_Colors.TupleSelect(hv_IndexDescription), "box", "false");
        }
      }
    }
    else
    {
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "There are no predictions", 
            "image", 30, (hv_CenterColOverall+hv_RadiusOverall)+20, "white", "box", 
            "false");
        }
      }
    }
    //
    //
    //Per-class pie-charts.
    //
    for (hv_C=0; (int)hv_C<=(int)((new HTuple(hv_ClassIDs.TupleLength()))-1); hv_C = (int)hv_C + 1)
    {
      //Get the position of the class-pie-chart.
      hv_CenterRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CenterRow = hv_StartRow+(((((hv_C.TupleReal()
          )/hv_ClassChartsPerRow)).TupleFloor())*hv_ChartRowDistance);
      }
      hv_CenterCol.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CenterCol = hv_StartCol+((hv_C%hv_ClassChartsPerRow)*hv_ChartColDistance);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassEvaluationResult.Dispose();
      HOperatorSet.GetDictTuple(hv_IoUEvaluationResult, "class_"+(hv_ClassIDs.TupleSelect(
          hv_C)), out hv_ClassEvaluationResult);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ratios.Dispose();
      dev_display_detection_eval_class_pie_chart(hv_WindowHandle, hv_ClassEvaluationResult, 
          hv_CenterRow, hv_Mode, hv_CenterCol, hv_RadiusClass, hv_Colors, "Class "+(hv_ClassIDs.TupleSelect(
          hv_C)), out hv_Ratios);
      }
    }
    ho_Image.Dispose();

    hv_CenterRowOverall.Dispose();
    hv_CenterColOverall.Dispose();
    hv_RadiusOverall.Dispose();
    hv_ClassChartsPerRow.Dispose();
    hv_RadiusClass.Dispose();
    hv_ChartRowDistance.Dispose();
    hv_ChartColDistance.Dispose();
    hv_StartRow.Dispose();
    hv_StartCol.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();
    hv_Font.Dispose();
    hv_NumColors.Dispose();
    hv_Colors.Dispose();
    hv_ColorsFP.Dispose();
    hv_Ratios.Dispose();
    hv_Descriptions.Dispose();
    hv_IoUThreshold.Dispose();
    hv_PercentStr.Dispose();
    hv_IndexDescription.Dispose();
    hv_C.Dispose();
    hv_CenterRow.Dispose();
    hv_CenterCol.Dispose();
    hv_ClassEvaluationResult.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Visualize and return the heatmap of a deep learning classification. 
  public void dev_display_dl_classifier_heatmap (HObject ho_Image, HTuple hv_DLClassifierHandle, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Partition, ho_RegionGrid, ho_OccludedRegions;
    HObject ho_ImageR=null, ho_ImageG=null, ho_ImageB=null;
    HObject ho_ImagesOccluded=null, ho_OccludedRegion=null;
    HObject ho_ImageOccluded=null, ho_HeatmapRegions, ho_PartsSelected=null;
    HObject ho_HeatmapRegion=null, ho_HeatmapRegionsNegative;
    HObject ho_HeatmapRegionNegative=null, ho_BinRegion=null;

    // Local control variables 

    HTuple hv_FeatureSize = new HTuple(), hv_SamplingSize = new HTuple();
    HTuple hv_DisplayConfidence = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_Number = new HTuple(), hv_NumInputChannels = new HTuple();
    HTuple hv_NumImageChannels = new HTuple(), hv_DLClassifierResultHandle = new HTuple();
    HTuple hv_OriginalConfidence = new HTuple(), hv_OriginalPredictedClass = new HTuple();
    HTuple hv_ClipRegionSettingBefore = new HTuple(), hv_HeightRegion = new HTuple();
    HTuple hv_WidthRegion = new HTuple(), hv_RatioRegion = new HTuple();
    HTuple hv_SamplingSizeUsed = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_CenterRows = new HTuple();
    HTuple hv_CenterColumns = new HTuple(), hv_NumRegions = new HTuple();
    HTuple hv_Confidences = new HTuple(), hv_MeanGray = new HTuple();
    HTuple hv_DeviationGray = new HTuple(), hv_MeanRed = new HTuple();
    HTuple hv_DeviationRed = new HTuple(), hv_MeanGreen = new HTuple();
    HTuple hv_DeviationGreen = new HTuple(), hv_MeanBlue = new HTuple();
    HTuple hv_DeviationBlue = new HTuple(), hv_BatchSize = new HTuple();
    HTuple hv_BatchIndex = new HTuple(), hv_BatchIndices = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Mean = new HTuple();
    HTuple hv_NumImagesOccluded = new HTuple(), hv_IndexOccluded = new HTuple();
    HTuple hv_PredictedClass = new HTuple(), hv_Confidence = new HTuple();
    HTuple hv_Area = new HTuple(), hv_AveragingCenterRows = new HTuple();
    HTuple hv_AveragingCenterColumns = new HTuple(), hv_PartitionConfidences = new HTuple();
    HTuple hv_PartIndex = new HTuple(), hv_ConfidenceIndices = new HTuple();
    HTuple hv_ConfidenceDeviations = new HTuple(), hv_MaxDeviation = new HTuple();
    HTuple hv_NumBins = new HTuple(), hv_Step = new HTuple();
    HTuple hv_End = new HTuple(), hv_Factor = new HTuple();
    HTuple hv_Lesser = new HTuple(), hv_Greater = new HTuple();
    HTuple hv_IndicesInBin = new HTuple(), hv_WidthImage = new HTuple();
    HTuple hv_HeightImage = new HTuple(), hv_Colors = new HTuple();
    HTuple hv_BinIndex = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Partition);
    HOperatorSet.GenEmptyObj(out ho_RegionGrid);
    HOperatorSet.GenEmptyObj(out ho_OccludedRegions);
    HOperatorSet.GenEmptyObj(out ho_ImageR);
    HOperatorSet.GenEmptyObj(out ho_ImageG);
    HOperatorSet.GenEmptyObj(out ho_ImageB);
    HOperatorSet.GenEmptyObj(out ho_ImagesOccluded);
    HOperatorSet.GenEmptyObj(out ho_OccludedRegion);
    HOperatorSet.GenEmptyObj(out ho_ImageOccluded);
    HOperatorSet.GenEmptyObj(out ho_HeatmapRegions);
    HOperatorSet.GenEmptyObj(out ho_PartsSelected);
    HOperatorSet.GenEmptyObj(out ho_HeatmapRegion);
    HOperatorSet.GenEmptyObj(out ho_HeatmapRegionsNegative);
    HOperatorSet.GenEmptyObj(out ho_HeatmapRegionNegative);
    HOperatorSet.GenEmptyObj(out ho_BinRegion);
    //This procedure generates a heatmap for an Image which is classified
    //with the deep learning classifier DLClassifierHandle and displays
    //it in the WindowHandle. The procedure can be adjusted with generic
    //parameters using GenParamName and GenParamValue.
    //
    //Please note that the heatmap is intended for visual inspection.
    //Therefore, the resulting regions and confidence values are not
    //returned. If you require the heatmap regions or confidence values,
    //e.g. for your own visualization, these are the parameters to return:
    //- HeatmapRegions (Regions in which confidence is decreased when occluded)
    //- HeatmapRegionsNegative (Regions in which confidence is increased
    //  when occluded)
    //- OriginalConfidence (Confidence of original class assignment)
    //- MaxDeviation (Maximum absolute deviation from OriginalConfidence in heatmap)
    //
    //Set default parameters.
    hv_FeatureSize.Dispose();
    hv_FeatureSize = 30;
    hv_SamplingSize.Dispose();
    hv_SamplingSize = 7;
    hv_DisplayConfidence.Dispose();
    hv_DisplayConfidence = 1;
    //
    //Parse the input parameters.
    for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
        ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
    {
      if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "feature_size"))) != 0)
      {
        //Set 'feature_size'.
        hv_FeatureSize.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FeatureSize = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "sampling_size"))) != 0)
      {
        //Set 'sampling_size'.
        hv_SamplingSize.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SamplingSize = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "display_confidence"))) != 0)
      {
        //Set 'display_confidence'.
        hv_DisplayConfidence.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DisplayConfidence = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else
      {
        throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
            hv_GenParamIndex)))+"'");
      }
    }
    //
    //Check the input parameters.
    hv_Number.Dispose();
    HOperatorSet.CountObj(ho_Image, out hv_Number);
    if ((int)(new HTuple(hv_Number.TupleGreater(1))) != 0)
    {
      throw new HalconException("Please use only a single image as input.");
    }
    if ((int)(new HTuple(hv_SamplingSize.TupleLess(0))) != 0)
    {
      throw new HalconException(("The \"sampling_size\" ("+hv_SamplingSize)+") must be greater than zero.");
    }
    if ((int)(new HTuple(hv_FeatureSize.TupleLess(0))) != 0)
    {
      throw new HalconException(("The \"feature_size\" ("+hv_FeatureSize)+") must be greater than zero.");
    }
    if ((int)(new HTuple(hv_SamplingSize.TupleGreaterEqual(hv_FeatureSize))) != 0)
    {
      throw new HalconException(((("The \"sampling_size\" ("+hv_SamplingSize)+") must be smaller than the \"feature_size\" (")+hv_FeatureSize)+")");
    }
    hv_NumInputChannels.Dispose();
    HOperatorSet.GetDlClassifierParam(hv_DLClassifierHandle, "image_num_channels", 
        out hv_NumInputChannels);
    hv_NumImageChannels.Dispose();
    HOperatorSet.CountChannels(ho_Image, out hv_NumImageChannels);
    if ((int)(new HTuple(hv_NumImageChannels.TupleNotEqual(hv_NumInputChannels))) != 0)
    {
      throw new HalconException((((("The number of image channels ("+hv_NumImageChannels)+") does not match ")+"the number of input channels expected by the classifier (")+hv_NumInputChannels)+")");
    }
    //
    //Get the predicted class and its confidence
    //when classifying the original (unoccluded) image.
    hv_DLClassifierResultHandle.Dispose();
    HOperatorSet.ApplyDlClassifier(ho_Image, hv_DLClassifierHandle, out hv_DLClassifierResultHandle);
    hv_OriginalConfidence.Dispose();
    HOperatorSet.GetDlClassifierResult(hv_DLClassifierResultHandle, "all", "confidences", 
        out hv_OriginalConfidence);
    hv_OriginalPredictedClass.Dispose();
    HOperatorSet.GetDlClassifierResult(hv_DLClassifierResultHandle, "all", "predicted_classes", 
        out hv_OriginalPredictedClass);
    HOperatorSet.ClearDlClassifierResult(hv_DLClassifierResultHandle);
    //
    hv_ClipRegionSettingBefore.Dispose();
    HOperatorSet.GetSystem("clip_region", out hv_ClipRegionSettingBefore);
    HOperatorSet.SetSystem("clip_region", "false");
    //
    //Partition the image into rectangular regions. The height and width of the
    //rectangles are approximately equal to sampling_size.
    ho_Partition.Dispose();
    HOperatorSet.PartitionRectangle(ho_Image, out ho_Partition, hv_SamplingSize, 
        hv_SamplingSize);
    hv_HeightRegion.Dispose();hv_WidthRegion.Dispose();hv_RatioRegion.Dispose();
    HOperatorSet.HeightWidthRatio(ho_Partition, out hv_HeightRegion, out hv_WidthRegion, 
        out hv_RatioRegion);
    //
    //Generate a set of regions to be occluded based on the center coordinates
    //and the dimensions of these rectangles. Depending on the values of
    //feature_size and sampling_size, these regions may overlap.
    hv_SamplingSizeUsed.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SamplingSizeUsed = ((hv_HeightRegion.TupleConcat(
        hv_WidthRegion))).TupleMedian();
    }
    hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_RegionGrid.Dispose();
    HOperatorSet.GenGridRegion(out ho_RegionGrid, hv_SamplingSizeUsed, hv_SamplingSizeUsed, 
        "points", hv_Width+1, hv_Height+1);
    }
    hv_CenterRows.Dispose();hv_CenterColumns.Dispose();
    HOperatorSet.GetRegionPoints(ho_RegionGrid, out hv_CenterRows, out hv_CenterColumns);
    hv_NumRegions.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumRegions = new HTuple(hv_CenterRows.TupleLength()
        );
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_OccludedRegions.Dispose();
    HOperatorSet.GenCircle(out ho_OccludedRegions, hv_CenterRows, hv_CenterColumns, 
        HTuple.TupleGenConst(hv_NumRegions,hv_FeatureSize/2));
    }
    //
    //Generate and classify the occluded images.
    hv_Confidences.Dispose();
    hv_Confidences = new HTuple();
    if ((int)(new HTuple(hv_NumInputChannels.TupleEqual(1))) != 0)
    {
      hv_MeanGray.Dispose();hv_DeviationGray.Dispose();
      HOperatorSet.Intensity(ho_OccludedRegions, ho_Image, out hv_MeanGray, out hv_DeviationGray);
    }
    else
    {
      ho_ImageR.Dispose();ho_ImageG.Dispose();ho_ImageB.Dispose();
      HOperatorSet.Decompose3(ho_Image, out ho_ImageR, out ho_ImageG, out ho_ImageB
          );
      hv_MeanRed.Dispose();hv_DeviationRed.Dispose();
      HOperatorSet.Intensity(ho_OccludedRegions, ho_ImageR, out hv_MeanRed, out hv_DeviationRed);
      hv_MeanGreen.Dispose();hv_DeviationGreen.Dispose();
      HOperatorSet.Intensity(ho_OccludedRegions, ho_ImageG, out hv_MeanGreen, out hv_DeviationGreen);
      hv_MeanBlue.Dispose();hv_DeviationBlue.Dispose();
      HOperatorSet.Intensity(ho_OccludedRegions, ho_ImageB, out hv_MeanBlue, out hv_DeviationBlue);
    }
    hv_BatchSize.Dispose();
    HOperatorSet.GetDlClassifierParam(hv_DLClassifierHandle, "batch_size", out hv_BatchSize);
    HTuple end_val92 = ((hv_NumRegions/hv_BatchSize)).TupleInt()
        ;
    HTuple step_val92 = 1;
    for (hv_BatchIndex=0; hv_BatchIndex.Continue(end_val92, step_val92); hv_BatchIndex = hv_BatchIndex.TupleAdd(step_val92))
    {
      ho_ImagesOccluded.Dispose();
      HOperatorSet.GenEmptyObj(out ho_ImagesOccluded);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BatchIndices.Dispose();
      HOperatorSet.TupleGenSequence((hv_BatchIndex*hv_BatchSize)+1, (((((hv_BatchIndex+1)*hv_BatchSize)).TupleConcat(
          hv_NumRegions))).TupleMin(), 1, out hv_BatchIndices);
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_BatchIndices.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_OccludedRegion.Dispose();
        HOperatorSet.SelectObj(ho_OccludedRegions, out ho_OccludedRegion, hv_BatchIndices.TupleSelect(
            hv_Index));
        }
        if ((int)(new HTuple(hv_NumInputChannels.TupleEqual(1))) != 0)
        {
          hv_Mean.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Mean = hv_MeanGray.TupleSelect(
              (hv_BatchIndices.TupleSelect(hv_Index))-1);
          }
        }
        else
        {
          hv_Mean.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Mean = new HTuple();
          hv_Mean = hv_Mean.TupleConcat(hv_MeanRed.TupleSelect(
              (hv_BatchIndices.TupleSelect(hv_Index))-1));
          hv_Mean = hv_Mean.TupleConcat(hv_MeanGreen.TupleSelect(
              (hv_BatchIndices.TupleSelect(hv_Index))-1));
          hv_Mean = hv_Mean.TupleConcat(hv_MeanBlue.TupleSelect(
              (hv_BatchIndices.TupleSelect(hv_Index))-1));
          }
        }
        ho_ImageOccluded.Dispose();
        HOperatorSet.PaintRegion(ho_OccludedRegion, ho_Image, out ho_ImageOccluded, 
            hv_Mean, "fill");
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ImagesOccluded, ho_ImageOccluded, out ExpTmpOutVar_0
            );
        ho_ImagesOccluded.Dispose();
        ho_ImagesOccluded = ExpTmpOutVar_0;
        }
      }
      //
      //For each occluded image, get the confidence
      //for the predicted class of the original image.
      hv_NumImagesOccluded.Dispose();
      HOperatorSet.CountObj(ho_ImagesOccluded, out hv_NumImagesOccluded);
      if ((int)(new HTuple(hv_NumImagesOccluded.TupleGreater(0))) != 0)
      {
        hv_DLClassifierResultHandle.Dispose();
        HOperatorSet.ApplyDlClassifier(ho_ImagesOccluded, hv_DLClassifierHandle, 
            out hv_DLClassifierResultHandle);
        HTuple end_val111 = hv_NumImagesOccluded-1;
        HTuple step_val111 = 1;
        for (hv_IndexOccluded=0; hv_IndexOccluded.Continue(end_val111, step_val111); hv_IndexOccluded = hv_IndexOccluded.TupleAdd(step_val111))
        {
          hv_PredictedClass.Dispose();
          HOperatorSet.GetDlClassifierResult(hv_DLClassifierResultHandle, hv_IndexOccluded, 
              "predicted_classes", out hv_PredictedClass);
          hv_Confidence.Dispose();
          HOperatorSet.GetDlClassifierResult(hv_DLClassifierResultHandle, hv_IndexOccluded, 
              "confidences", out hv_Confidence);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Confidences = hv_Confidences.TupleConcat(
              hv_Confidence.TupleSelect(hv_PredictedClass.TupleFind(hv_OriginalPredictedClass)));
          hv_Confidences.Dispose();
          hv_Confidences = ExpTmpLocalVar_Confidences;
          }
          }
        }
        HOperatorSet.ClearDlClassifierResult(hv_DLClassifierResultHandle);
      }
    }
    //
    //Since it is too expensive to compute the confidence value
    //for each individual pixel, we work with a subsampling of the image.
    //The distance between two sampling points is controlled
    //by the parameter 'sampling_size'. For each sampling point,
    //we average over the confidence values of all images
    //which were occluded with a regions to which this point belongs.
    hv_Area.Dispose();hv_AveragingCenterRows.Dispose();hv_AveragingCenterColumns.Dispose();
    HOperatorSet.AreaCenter(ho_Partition, out hv_Area, out hv_AveragingCenterRows, 
        out hv_AveragingCenterColumns);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PartitionConfidences.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_AveragingCenterRows.TupleLength()), 
        0, out hv_PartitionConfidences);
    }
    for (hv_PartIndex=0; (int)hv_PartIndex<=(int)((new HTuple(hv_AveragingCenterRows.TupleLength()
        ))-1); hv_PartIndex = (int)hv_PartIndex + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ConfidenceIndices.Dispose();
      HOperatorSet.GetRegionIndex(ho_OccludedRegions, ((hv_AveragingCenterRows.TupleSelect(
          hv_PartIndex))).TupleInt(), ((hv_AveragingCenterColumns.TupleSelect(hv_PartIndex))).TupleInt()
          , out hv_ConfidenceIndices);
      }
      if (hv_PartitionConfidences == null)
        hv_PartitionConfidences = new HTuple();
      hv_PartitionConfidences[hv_PartIndex] = ((hv_Confidences.TupleSelect(hv_ConfidenceIndices-1))).TupleMean()
          ;
    }
    //
    //Compute the deviation from the original confidence value and its maximum absolute value.
    hv_ConfidenceDeviations.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ConfidenceDeviations = hv_OriginalConfidence-hv_PartitionConfidences;
    }
    hv_MaxDeviation.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxDeviation = ((hv_ConfidenceDeviations.TupleAbs()
        )).TupleMax();
    }
    //
    //The heatmap is categorized into 'bins'. The regions where the deviation
    //is highest are in the first bin, the regions where the deviation
    //is lowest are in the last bin. This is done separately for deviations with
    //positive and negative sign.
    hv_NumBins.Dispose();
    hv_NumBins = 10;
    hv_Step.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Step = 1/(hv_NumBins.TupleReal()
        );
    }
    hv_End.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_End = 1-((hv_NumBins-1)*hv_Step);
    }
    ho_HeatmapRegions.Dispose();
    HOperatorSet.GenEmptyObj(out ho_HeatmapRegions);
    HTuple end_val145 = hv_End;
    HTuple step_val145 = -hv_Step;
    for (hv_Factor=1; hv_Factor.Continue(end_val145, step_val145); hv_Factor = hv_Factor.TupleAdd(step_val145))
    {
      hv_Lesser.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Lesser = hv_ConfidenceDeviations.TupleLessEqualElem(
          hv_MaxDeviation*hv_Factor);
      }
      hv_Greater.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Greater = hv_ConfidenceDeviations.TupleGreaterElem(
          hv_MaxDeviation*(hv_Factor-hv_Step));
      }
      hv_IndicesInBin.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IndicesInBin = ((hv_Lesser+hv_Greater)).TupleFind(
          2);
      }
      if ((int)(new HTuple(hv_IndicesInBin.TupleNotEqual(-1))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_PartsSelected.Dispose();
        HOperatorSet.SelectObj(ho_Partition, out ho_PartsSelected, hv_IndicesInBin+1);
        }
        ho_HeatmapRegion.Dispose();
        HOperatorSet.Union1(ho_PartsSelected, out ho_HeatmapRegion);
      }
      else
      {
        ho_HeatmapRegion.Dispose();
        HOperatorSet.GenEmptyRegion(out ho_HeatmapRegion);
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_HeatmapRegions, ho_HeatmapRegion, out ExpTmpOutVar_0
          );
      ho_HeatmapRegions.Dispose();
      ho_HeatmapRegions = ExpTmpOutVar_0;
      }
    }
    ho_HeatmapRegionsNegative.Dispose();
    HOperatorSet.GenEmptyObj(out ho_HeatmapRegionsNegative);
    HTuple end_val158 = hv_End;
    HTuple step_val158 = -hv_Step;
    for (hv_Factor=1; hv_Factor.Continue(end_val158, step_val158); hv_Factor = hv_Factor.TupleAdd(step_val158))
    {
      hv_Lesser.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Lesser = hv_ConfidenceDeviations.TupleLessElem(
          (-hv_MaxDeviation)*(hv_Factor-hv_Step));
      }
      hv_Greater.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Greater = hv_ConfidenceDeviations.TupleGreaterEqualElem(
          (-hv_MaxDeviation)*hv_Factor);
      }
      hv_IndicesInBin.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IndicesInBin = ((hv_Lesser+hv_Greater)).TupleFind(
          2);
      }
      if ((int)(new HTuple(hv_IndicesInBin.TupleNotEqual(-1))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_PartsSelected.Dispose();
        HOperatorSet.SelectObj(ho_Partition, out ho_PartsSelected, hv_IndicesInBin+1);
        }
        ho_HeatmapRegionNegative.Dispose();
        HOperatorSet.Union1(ho_PartsSelected, out ho_HeatmapRegionNegative);
      }
      else
      {
        ho_HeatmapRegionNegative.Dispose();
        HOperatorSet.GenEmptyRegion(out ho_HeatmapRegionNegative);
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_HeatmapRegionsNegative, ho_HeatmapRegionNegative, 
          out ExpTmpOutVar_0);
      ho_HeatmapRegionsNegative.Dispose();
      ho_HeatmapRegionsNegative = ExpTmpOutVar_0;
      }
    }
    //
    //Visualize the heatmap.
    HDevWindowStack.SetActive(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
    }
    hv_WidthImage.Dispose();hv_HeightImage.Dispose();
    HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_HeightImage-1, hv_WidthImage-1);
      }
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
    }
    //For regions for which the confidence decreased, generate a color palette
    //from red to yellow with 66% transparency
    hv_Colors.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Colors = (((
        (new HTuple("#ff3300")).TupleConcat("#ff6600")).TupleConcat("#ff9900")).TupleConcat(
        "#ffcc00")).TupleConcat("#ffff00")+"66";
    }
    for (hv_BinIndex=1; (int)hv_BinIndex<=5; hv_BinIndex = (int)hv_BinIndex + 1)
    {
      ho_BinRegion.Dispose();
      HOperatorSet.SelectObj(ho_HeatmapRegions, out ho_BinRegion, hv_BinIndex);
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
            hv_BinIndex-1));
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_BinRegion, HDevWindowStack.GetActive());
      }
    }
    //For regions for which the confidence increased, generate a color palette
    //from blue to cyan with 66% transparency
    hv_Colors.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Colors = (((
        (new HTuple("#0033ff")).TupleConcat("#0066ff")).TupleConcat("#0099ff")).TupleConcat(
        "#00ccff")).TupleConcat("#00ffff")+"66";
    }
    for (hv_BinIndex=1; (int)hv_BinIndex<=5; hv_BinIndex = (int)hv_BinIndex + 1)
    {
      ho_BinRegion.Dispose();
      HOperatorSet.SelectObj(ho_HeatmapRegionsNegative, out ho_BinRegion, hv_BinIndex);
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
            hv_BinIndex-1));
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_BinRegion, HDevWindowStack.GetActive());
      }
    }
    //
    if ((int)(hv_DisplayConfidence) != 0)
    {
      hv_Text.Dispose();
      hv_Text = new HTuple();
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Predicted Class: "+hv_OriginalPredictedClass;
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Original Confidence: "+(hv_OriginalConfidence.TupleString(
          ".3f"));
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Maximum Deviation:   "+(hv_MaxDeviation.TupleString(
          ".3f"));
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "right", (new HTuple("black")).TupleConcat("black"), new HTuple(), new HTuple());
      }
    }
    //
    HOperatorSet.SetSystem("clip_region", hv_ClipRegionSettingBefore);
    ho_Partition.Dispose();
    ho_RegionGrid.Dispose();
    ho_OccludedRegions.Dispose();
    ho_ImageR.Dispose();
    ho_ImageG.Dispose();
    ho_ImageB.Dispose();
    ho_ImagesOccluded.Dispose();
    ho_OccludedRegion.Dispose();
    ho_ImageOccluded.Dispose();
    ho_HeatmapRegions.Dispose();
    ho_PartsSelected.Dispose();
    ho_HeatmapRegion.Dispose();
    ho_HeatmapRegionsNegative.Dispose();
    ho_HeatmapRegionNegative.Dispose();
    ho_BinRegion.Dispose();

    hv_FeatureSize.Dispose();
    hv_SamplingSize.Dispose();
    hv_DisplayConfidence.Dispose();
    hv_GenParamIndex.Dispose();
    hv_Number.Dispose();
    hv_NumInputChannels.Dispose();
    hv_NumImageChannels.Dispose();
    hv_DLClassifierResultHandle.Dispose();
    hv_OriginalConfidence.Dispose();
    hv_OriginalPredictedClass.Dispose();
    hv_ClipRegionSettingBefore.Dispose();
    hv_HeightRegion.Dispose();
    hv_WidthRegion.Dispose();
    hv_RatioRegion.Dispose();
    hv_SamplingSizeUsed.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_CenterRows.Dispose();
    hv_CenterColumns.Dispose();
    hv_NumRegions.Dispose();
    hv_Confidences.Dispose();
    hv_MeanGray.Dispose();
    hv_DeviationGray.Dispose();
    hv_MeanRed.Dispose();
    hv_DeviationRed.Dispose();
    hv_MeanGreen.Dispose();
    hv_DeviationGreen.Dispose();
    hv_MeanBlue.Dispose();
    hv_DeviationBlue.Dispose();
    hv_BatchSize.Dispose();
    hv_BatchIndex.Dispose();
    hv_BatchIndices.Dispose();
    hv_Index.Dispose();
    hv_Mean.Dispose();
    hv_NumImagesOccluded.Dispose();
    hv_IndexOccluded.Dispose();
    hv_PredictedClass.Dispose();
    hv_Confidence.Dispose();
    hv_Area.Dispose();
    hv_AveragingCenterRows.Dispose();
    hv_AveragingCenterColumns.Dispose();
    hv_PartitionConfidences.Dispose();
    hv_PartIndex.Dispose();
    hv_ConfidenceIndices.Dispose();
    hv_ConfidenceDeviations.Dispose();
    hv_MaxDeviation.Dispose();
    hv_NumBins.Dispose();
    hv_Step.Dispose();
    hv_End.Dispose();
    hv_Factor.Dispose();
    hv_Lesser.Dispose();
    hv_Greater.Dispose();
    hv_IndicesInBin.Dispose();
    hv_WidthImage.Dispose();
    hv_HeightImage.Dispose();
    hv_Colors.Dispose();
    hv_BinIndex.Dispose();
    hv_Text.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Visualize different images, annotations and inference results for a sample. 
  public void dev_display_dl_data (HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo, 
      HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
  {



    // Local iconic variables 

    HObject ho_Image=null, ho_ImageWeight=null;
    HObject ho_ImageConfidence=null, ho_SegmentationImagGroundTruth=null;
    HObject ho_SegmentationImageResult=null, ho_ImageAbsDiff=null;
    HObject ho_DiffRegion=null;

    // Local control variables 

    HTuple hv_ThresholdWidth = new HTuple(), hv_ScaleWindows = new HTuple();
    HTuple hv_Font = new HTuple(), hv_FontSize = new HTuple();
    HTuple hv_LineWidth = new HTuple(), hv_MapTransparency = new HTuple();
    HTuple hv_MapColorBarWidth = new HTuple(), hv_SegMaxWeight = new HTuple();
    HTuple hv_SegDraw = new HTuple(), hv_SegTransparency = new HTuple();
    HTuple hv_SegExcludeClassIDs = new HTuple(), hv_BboxLabelColor = new HTuple();
    HTuple hv_BboxDisplayConfidence = new HTuple(), hv_BboxTextColor = new HTuple();
    HTuple hv_ShowBottomDesc = new HTuple(), hv_ShowLegend = new HTuple();
    HTuple hv_ShowLabels = new HTuple(), hv_GenParamNames = new HTuple();
    HTuple hv_ParamIndex = new HTuple(), hv_GenParamName = new HTuple();
    HTuple hv_GenParamValue = new HTuple(), hv_SampleKeys = new HTuple();
    HTuple hv_ResultKeys = new HTuple(), hv_ImageIDExists = new HTuple();
    HTuple hv_ImageID = new HTuple(), hv_ImageIDString = new HTuple();
    HTuple hv_NeededKeys = new HTuple(), hv_Index = new HTuple();
    HTuple hv_DLDatasetInfoKeys = new HTuple(), hv_ClassNames = new HTuple();
    HTuple hv_ClassIDs = new HTuple(), hv_Colors = new HTuple();
    HTuple hv_ClassesLegend = new HTuple(), hv_PrevWindowCoordinates = new HTuple();
    HTuple hv_Keys = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_MetaInfoIndex = new HTuple(), hv_MetaInfo = new HTuple();
    HTuple hv_FlushValues = new HTuple(), hv_WindowHandleKeys = new HTuple();
    HTuple hv_KeyIndex = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_WindowIndex = new HTuple(), hv_FlushValue = new HTuple();
    HTuple hv_WidthImage = new HTuple(), hv_HeightImage = new HTuple();
    HTuple hv_CurrentWindowHandle = new HTuple(), hv_WindowImageRatio = new HTuple();
    HTuple hv_BboxIDs = new HTuple(), hv_Text = new HTuple();
    HTuple hv_BboxColors = new HTuple(), hv_BboxIDsUniq = new HTuple();
    HTuple hv_BboxConfidences = new HTuple(), hv_TextConf = new HTuple();
    HTuple hv_BboxClassIndex = new HTuple(), hv_BboxColorsResults = new HTuple();
    HTuple hv_BboxClassIndexUniq = new HTuple(), hv_BboxLabelIndex = new HTuple();
    HTuple hv_BboxColorsBoth = new HTuple(), hv_BboxClassLabelIndexUniq = new HTuple();
    HTuple hv_ColorsSegmentation = new HTuple(), hv_DrawMode = new HTuple();
    HTuple hv_Width = new HTuple(), hv_ImageClassIDs = new HTuple();
    HTuple hv_ImageClassIDsUniq = new HTuple(), hv_ColorsResults = new HTuple();
    HTuple hv_GroundTruthIDs = new HTuple(), hv_ResultIDs = new HTuple();
    HTuple hv_StringSegExcludeClassIDs = new HTuple(), hv_StringIndex = new HTuple();
    HTuple hv_Min = new HTuple(), hv_Max = new HTuple(), hv_Range = new HTuple();
    HTuple hv_MinWeight = new HTuple(), hv_WeightsColors = new HTuple();
    HTuple hv_ConfidenceColors = new HTuple(), hv_WindowHandleKeysNew = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ImageWeight);
    HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
    HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
    HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
    HOperatorSet.GenEmptyObj(out ho_ImageAbsDiff);
    HOperatorSet.GenEmptyObj(out ho_DiffRegion);
    //
    //This procedure displays the content of the provided DLSample and/or DLResult
    //depending on the input string KeysForDisplay.
    //DLDatasetInfo is a dictionary containing the information about the dataset.
    //The visualization can be adapted with GenParam.
    //
    //** Set the default values: ***
    //
    //Define the screen width when a new window row is started.
    hv_ThresholdWidth.Dispose();
    hv_ThresholdWidth = 1024;
    //Since potentially a lot of windows are opened,
    //scale the windows consistently.
    hv_ScaleWindows.Dispose();
    hv_ScaleWindows = 0.8;
    //Set a font and a font size.
    hv_Font.Dispose();
    hv_Font = "mono";
    hv_FontSize.Dispose();
    hv_FontSize = 14;
    //
    hv_LineWidth.Dispose();
    hv_LineWidth = 2;
    hv_MapTransparency.Dispose();
    hv_MapTransparency = "cc";
    hv_MapColorBarWidth.Dispose();
    hv_MapColorBarWidth = 140;
    //
    //Define segmentation-specific parameter values.
    hv_SegMaxWeight.Dispose();
    hv_SegMaxWeight = 0;
    hv_SegDraw.Dispose();
    hv_SegDraw = "fill";
    hv_SegTransparency.Dispose();
    hv_SegTransparency = "aa";
    hv_SegExcludeClassIDs.Dispose();
    hv_SegExcludeClassIDs = new HTuple();
    //
    //Define bbox-specific parameter values.
    hv_BboxLabelColor.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_BboxLabelColor = new HTuple("#000000")+"99";
    }
    hv_BboxDisplayConfidence.Dispose();
    hv_BboxDisplayConfidence = 1;
    hv_BboxTextColor.Dispose();
    hv_BboxTextColor = "#eeeeee";
    //
    //By default, display a description on the bottom.
    hv_ShowBottomDesc.Dispose();
    hv_ShowBottomDesc = 1;
    //
    //By default, show a legend with class IDs.
    hv_ShowLegend.Dispose();
    hv_ShowLegend = 1;
    //
    //By default, show class labels for detection ground truth/results.
    hv_ShowLabels.Dispose();
    hv_ShowLabels = 1;
    //
    //** Set user defined values: ***
    //
    //Overwrite default values by given generic parameters.
    if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_GenParamNames.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
      for (hv_ParamIndex=0; (int)hv_ParamIndex<=(int)((new HTuple(hv_GenParamNames.TupleLength()
          ))-1); hv_ParamIndex = (int)hv_ParamIndex + 1)
      {
        hv_GenParamName.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GenParamName = hv_GenParamNames.TupleSelect(
            hv_ParamIndex);
        }
        hv_GenParamValue.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamName, out hv_GenParamValue);
        if ((int)(new HTuple(hv_GenParamName.TupleEqual("threshold_width"))) != 0)
        {
          hv_ThresholdWidth.Dispose();
          hv_ThresholdWidth = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("scale_windows"))) != 0)
        {
          hv_ScaleWindows.Dispose();
          hv_ScaleWindows = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("font"))) != 0)
        {
          hv_Font.Dispose();
          hv_Font = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("font_size"))) != 0)
        {
          hv_FontSize.Dispose();
          hv_FontSize = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("line_width"))) != 0)
        {
          hv_LineWidth.Dispose();
          hv_LineWidth = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("map_transparency"))) != 0)
        {
          hv_MapTransparency.Dispose();
          hv_MapTransparency = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("map_color_bar_width"))) != 0)
        {
          hv_MapColorBarWidth.Dispose();
          hv_MapColorBarWidth = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_max_weight"))) != 0)
        {
          hv_SegMaxWeight.Dispose();
          hv_SegMaxWeight = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_draw"))) != 0)
        {
          hv_SegDraw.Dispose();
          hv_SegDraw = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_transparency"))) != 0)
        {
          hv_SegTransparency.Dispose();
          hv_SegTransparency = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_exclude_class_ids"))) != 0)
        {
          hv_SegExcludeClassIDs.Dispose();
          hv_SegExcludeClassIDs = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_label_color"))) != 0)
        {
          hv_BboxLabelColor.Dispose();
          hv_BboxLabelColor = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_display_confidence"))) != 0)
        {
          hv_BboxDisplayConfidence.Dispose();
          hv_BboxDisplayConfidence = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_text_color"))) != 0)
        {
          hv_BboxTextColor.Dispose();
          hv_BboxTextColor = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_bottom_desc"))) != 0)
        {
          hv_ShowBottomDesc.Dispose();
          hv_ShowBottomDesc = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_legend"))) != 0)
        {
          hv_ShowLegend.Dispose();
          hv_ShowLegend = new HTuple(hv_GenParamValue);
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_labels"))) != 0)
        {
          hv_ShowLabels.Dispose();
          hv_ShowLabels = new HTuple(hv_GenParamValue);
        }
        else
        {
          throw new HalconException(("Unknown generic parameter: "+hv_GenParamName)+".");
        }
      }
    }
    //
    //Get the dictionary keys.
    hv_SampleKeys.Dispose();
    HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_SampleKeys);
    if ((int)(new HTuple(hv_DLResult.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_ResultKeys.Dispose();
      HOperatorSet.GetDictParam(hv_DLResult, "keys", new HTuple(), out hv_ResultKeys);
    }
    //
    //Get image ID if it is available.
    hv_ImageIDExists.Dispose();
    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_id", out hv_ImageIDExists);
    if ((int)(hv_ImageIDExists) != 0)
    {
      hv_ImageID.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageID);
      hv_ImageIDString.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageIDString = (" ("+hv_ImageID)+")";
      }
    }
    else
    {
      hv_ImageIDString.Dispose();
      hv_ImageIDString = "";
    }
    //
    //Check if DLDatasetInfo is valid.
    if ((int)(new HTuple(hv_DLDatasetInfo.TupleEqual(new HTuple()))) != 0)
    {
      //If DLDatasetInfo is empty, 'image' is the only key allowed in KeysForDisplay.
      if ((int)((new HTuple((new HTuple(hv_KeysForDisplay.TupleLength())).TupleNotEqual(
          1))).TupleOr(new HTuple(((hv_KeysForDisplay.TupleSelect(0))).TupleNotEqual(
          "image")))) != 0)
      {
        throw new HalconException("DLDatasetInfo is needed for requested keys in KeysForDisplay.");
      }
    }
    else
    {
      //Check if DLDatasetInfo contains necessary keys.
      hv_NeededKeys.Dispose();
      hv_NeededKeys = new HTuple();
      hv_NeededKeys[0] = "class_names";
      hv_NeededKeys[1] = "class_ids";
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_NeededKeys.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        hv_DLDatasetInfoKeys.Dispose();
        HOperatorSet.GetDictParam(hv_DLDatasetInfo, "keys", new HTuple(), out hv_DLDatasetInfoKeys);
        if ((int)(new HTuple(((hv_DLDatasetInfoKeys.TupleFindFirst(hv_NeededKeys.TupleSelect(
            hv_Index)))).TupleEqual(-1))) != 0)
        {
          throw new HalconException(("Key "+(hv_NeededKeys.TupleSelect(
              hv_Index)))+" is missing in DLDatasetInfo.");
        }
      }
    }
    //
    //Get the general dataset information, if available.
    if ((int)(new HTuple(hv_DLDatasetInfo.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_ClassNames.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassNames);
      hv_ClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_ids", out hv_ClassIDs);
      //
      //Define distinct colors for the classes.
      hv_Colors.Dispose();
      get_dl_class_colors(hv_ClassNames, out hv_Colors);
      //
      hv_ClassesLegend.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassesLegend = (hv_ClassIDs+" : ")+hv_ClassNames;
      }
    }
    //
    //** Set window parameters: ***
    //
    //Set previous window coordinates.
    hv_PrevWindowCoordinates.Dispose();
    hv_PrevWindowCoordinates = new HTuple();
    hv_PrevWindowCoordinates[0] = 0;
    hv_PrevWindowCoordinates[1] = 0;
    hv_PrevWindowCoordinates[2] = 0;
    hv_PrevWindowCoordinates[3] = 0;
    hv_PrevWindowCoordinates[4] = 1;
    //
    //
    //Check that the WindowHandleDict is of type dictionary.
    try
    {
      hv_Keys.Dispose();
      HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_Keys);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1401))) != 0)
      {
        throw new HalconException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
      }
      else
      {
        throw new HalconException(hv_Exception);
      }
    }
    //For better usage, add meta information about the window handles in WindowHandleDict.
    hv_MetaInfoIndex.Dispose();
    HOperatorSet.TupleFind(hv_Keys, "meta_information", out hv_MetaInfoIndex);
    if ((int)((new HTuple(hv_MetaInfoIndex.TupleEqual(-1))).TupleOr(new HTuple(hv_MetaInfoIndex.TupleEqual(
        new HTuple())))) != 0)
    {
      hv_MetaInfo.Dispose();
      HOperatorSet.CreateDict(out hv_MetaInfo);
      HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
    }
    //
    //For each window, set 'flush' to 'false' to avoid flickering.
    hv_FlushValues.Dispose();
    hv_FlushValues = new HTuple();
    hv_WindowHandleKeys.Dispose();
    HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeys.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      //Only consider the WindowHandleKeys that are needed for the current visualization.
      hv_KeyIndex.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_KeyIndex = hv_KeysForDisplay.TupleFind(
          hv_WindowHandleKeys.TupleSelect(hv_Index));
      }
      if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
          new HTuple())))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowHandles.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
            hv_Index), out hv_WindowHandles);
        }
        for (hv_WindowIndex=0; (int)hv_WindowIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
            ))-1); hv_WindowIndex = (int)hv_WindowIndex + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_FlushValue.Dispose();
          HOperatorSet.GetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
              "flush", out hv_FlushValue);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_FlushValues = hv_FlushValues.TupleConcat(
              hv_FlushValue);
          hv_FlushValues.Dispose();
          hv_FlushValues = ExpTmpLocalVar_FlushValues;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
              "flush", "false");
          }
        }
      }
    }
    //
    //** Display the data: ***
    //
    //Display data dictionaries.
    for (hv_KeyIndex=0; (int)hv_KeyIndex<=(int)((new HTuple(hv_KeysForDisplay.TupleLength()
        ))-1); hv_KeyIndex = (int)hv_KeyIndex + 1)
    {
      if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "image"))) != 0)
      {
        //
        //Image.
        ho_Image.Dispose();
        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, hv_WindowHandleDict, 
            hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Image"+hv_ImageIDString, 
                "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "segmentation_weight"))) != 0)
      {
        //
        //Weight image.
        ho_ImageWeight.Dispose();
        get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_ImageWeight, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, hv_WindowHandleDict, 
            hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_ImageWeight, HDevWindowStack.GetActive());
        }
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight image"+hv_ImageIDString, 
                "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "segmentation_confidence"))) != 0)
      {
        //
        //Segmentation confidences.
        ho_ImageConfidence.Dispose();
        get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_ImageConfidence, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, hv_WindowHandleDict, 
            hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_ImageConfidence, HDevWindowStack.GetActive());
        }
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence image"+hv_ImageIDString, 
                "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "bbox_ground_truth"))) != 0)
      {
        //
        //Sample bounding boxes on image.
        ho_Image.Dispose();
        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, hv_WindowHandleDict, 
            hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        //Visualization.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        //
        hv_BboxIDs.Dispose();
        dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_LineWidth, 
            hv_ClassIDs, hv_Colors, hv_BboxLabelColor, hv_BboxTextColor, hv_ShowLabels, 
            hv_CurrentWindowHandle, out hv_BboxIDs);
        hv_Text.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Text = "Ground truth bounding boxes"+hv_ImageIDString;
        }
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "bottom", "left", "white", "box", "false");
          }
        }
        //
        //Display the legend.
        if ((int)(hv_ShowLegend) != 0)
        {
          hv_BboxColors.Dispose();
          hv_BboxColors = "white";
          if ((int)(new HTuple(hv_BboxIDs.TupleLength())) != 0)
          {
            hv_BboxIDsUniq.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BboxIDsUniq = ((hv_BboxIDs.TupleSort()
                )).TupleUniq();
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_BboxIDsUniq));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_BboxColors = hv_BboxColors.TupleConcat(
                hv_Colors.TupleSelect(hv_BboxIDsUniq));
            hv_BboxColors.Dispose();
            hv_BboxColors = ExpTmpLocalVar_BboxColors;
            }
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                "No ground truth bounding boxes present.");
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
          }
          //
          //Get or open next child window.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_WindowImageRatio, 
              out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "top", "left", hv_BboxColors, "box", "false");
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "bbox_result"))) != 0)
      {
        //
        //Result bounding boxes on image.
        ho_Image.Dispose();
        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, hv_WindowHandleDict, 
            hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        //Visualization.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        //
        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
            -1))) != 0)
        {
          hv_BboxConfidences.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult, "bbox_confidence", out hv_BboxConfidences);
        }
        else
        {
          throw new HalconException("Result bounding box data could not be found in DLResult.");
        }
        if ((int)(hv_BboxDisplayConfidence) != 0)
        {
          hv_TextConf.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextConf = (" ("+(hv_BboxConfidences.TupleString(
              ".2f")))+")";
          }
        }
        else
        {
          hv_TextConf.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextConf = HTuple.TupleGenConst(
              new HTuple(hv_BboxConfidences.TupleLength()),"");
          }
        }
        hv_BboxClassIndex.Dispose();
        dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_LineWidth, hv_ClassIDs, 
            hv_TextConf, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio, "top", 
            hv_BboxTextColor, hv_ShowLabels, hv_CurrentWindowHandle, out hv_BboxClassIndex);
        hv_Text.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Text = "Result bounding boxes"+hv_ImageIDString;
        }
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "bottom", "left", "white", "box", "false");
          }
        }
        //
        //Display the legend.
        if ((int)(hv_ShowLegend) != 0)
        {
          hv_BboxColorsResults.Dispose();
          hv_BboxColorsResults = "white";
          if ((int)(new HTuple((new HTuple(hv_BboxClassIndex.TupleLength())).TupleGreater(
              0))) != 0)
          {
            hv_BboxClassIndexUniq.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BboxClassIndexUniq = ((hv_BboxClassIndex.TupleSort()
                )).TupleUniq();
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_BboxClassIndexUniq));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_BboxColorsResults = hv_BboxColorsResults.TupleConcat(
                hv_Colors.TupleSelect(hv_BboxClassIndexUniq));
            hv_BboxColorsResults.Dispose();
            hv_BboxColorsResults = ExpTmpLocalVar_BboxColorsResults;
            }
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                "No result bounding boxes present.");
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
          }
          //
          //Get or open next child window.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_WindowImageRatio, 
              out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "top", "left", hv_BboxColorsResults, "box", "false");
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "bbox_both"))) != 0)
      {
        //
        //Ground truth and result bounding boxes on image.
        ho_Image.Dispose();
        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, hv_WindowHandleDict, 
            hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        //
        //Visualization.
        hv_BboxLabelIndex.Dispose();
        dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_LineWidth, 
            hv_ClassIDs, hv_Colors, hv_BboxLabelColor, hv_BboxTextColor, hv_ShowLabels, 
            hv_CurrentWindowHandle, out hv_BboxLabelIndex);
        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
            -1))) != 0)
        {
          hv_BboxConfidences.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult, "bbox_confidence", out hv_BboxConfidences);
        }
        else
        {
          throw new HalconException("Result bounding box data could not be found in DLResult.");
        }
        if ((int)(hv_BboxDisplayConfidence) != 0)
        {
          hv_TextConf.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextConf = (" ("+(hv_BboxConfidences.TupleString(
              ".2f")))+")";
          }
        }
        else
        {
          hv_TextConf.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextConf = HTuple.TupleGenConst(
              new HTuple(hv_BboxConfidences.TupleLength()),"");
          }
        }
        hv_BboxClassIndex.Dispose();
        dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_LineWidth, hv_ClassIDs, 
            hv_TextConf, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio, "bottom", 
            hv_BboxTextColor, hv_ShowLabels, hv_CurrentWindowHandle, out hv_BboxClassIndex);
        hv_Text.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Text = "Ground truth and result bounding boxes"+hv_ImageIDString;
        }
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "bottom", "left", "white", "box", "false");
          }
        }
        hv_Text.Dispose();
        hv_Text = "Ground truth and";
        if (hv_Text == null)
          hv_Text = new HTuple();
        hv_Text[new HTuple(hv_Text.TupleLength())] = "result bounding boxes"+hv_ImageIDString;
        //
        //Display the legend.
        if ((int)(hv_ShowLegend) != 0)
        {
          hv_BboxColorsBoth.Dispose();
          hv_BboxColorsBoth = new HTuple();
          hv_BboxColorsBoth[0] = "white";
          hv_BboxColorsBoth[1] = "white";
          if ((int)(new HTuple((new HTuple((new HTuple(hv_BboxClassIndex.TupleLength()
              ))+(new HTuple(hv_BboxLabelIndex.TupleLength())))).TupleGreater(0))) != 0)
          {
            hv_BboxClassLabelIndexUniq.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BboxClassLabelIndexUniq = ((((hv_BboxClassIndex.TupleConcat(
                hv_BboxLabelIndex))).TupleSort())).TupleUniq();
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_BboxClassLabelIndexUniq));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_BboxColorsBoth = hv_BboxColorsBoth.TupleConcat(
                hv_Colors.TupleSelect(hv_BboxClassLabelIndexUniq));
            hv_BboxColorsBoth.Dispose();
            hv_BboxColorsBoth = ExpTmpLocalVar_BboxColorsBoth;
            }
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                "No ground truth nor result bounding boxes present.");
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
          }
          //
          //Get or open next child window.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_WindowImageRatio, 
              out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "top", "left", hv_BboxColorsBoth, "box", "false");
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "segmentation_image_ground_truth"))) != 0)
      {
        //
        //Ground truth segmentation image.
        ho_Image.Dispose();
        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
        ho_SegmentationImagGroundTruth.Dispose();
        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth, hv_SampleKeys, 
            hv_DLSample);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, hv_WindowHandleDict, 
            hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        //Visualization.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        //
        //Display segmentation regions.
        hv_ColorsSegmentation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ColorsSegmentation = hv_Colors+hv_SegTransparency;
        }
        hv_DrawMode.Dispose();
        HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_SegDraw);
        }
        hv_Width.Dispose();
        HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
        }
        hv_ImageClassIDs.Dispose();
        dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs, 
            hv_ColorsSegmentation, hv_SegExcludeClassIDs, out hv_ImageClassIDs);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
              );
          }
        }
        hv_Text.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Text = "Ground truth segmentation"+hv_ImageIDString;
        }
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "bottom", "left", "white", "box", "false");
          }
        }
        //
        //Display the legend.
        if ((int)(hv_ShowLegend) != 0)
        {
          hv_ImageClassIDsUniq.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
              )).TupleUniq();
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Text = hv_Text.TupleConcat(
              hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
          hv_Text.Dispose();
          hv_Text = ExpTmpLocalVar_Text;
          }
          }
          //
          //Get or open next child window
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_WindowImageRatio, 
              out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                hv_ImageClassIDsUniq)), "box", "false");
            }
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "segmentation_image_result"))) != 0)
      {
        //
        //Result segmentation on image.
        ho_Image.Dispose();
        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
        ho_SegmentationImageResult.Dispose();
        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys, 
            hv_DLResult);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, hv_WindowHandleDict, 
            hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        //Visualization.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        //
        //Display result segmentation regions.
        hv_ColorsResults.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ColorsResults = hv_Colors+hv_SegTransparency;
        }
        hv_DrawMode.Dispose();
        HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_SegDraw);
        }
        hv_Width.Dispose();
        HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
        }
        hv_ImageClassIDs.Dispose();
        dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs, 
            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_ImageClassIDs);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
              );
          }
        }
        hv_Text.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Text = "Result segmentation"+hv_ImageIDString;
        }
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "bottom", "left", "white", "box", "false");
          }
        }
        //
        //Display the legend.
        if ((int)(hv_ShowLegend) != 0)
        {
          hv_ImageClassIDsUniq.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
              )).TupleUniq();
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Text = hv_Text.TupleConcat(
              hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
          hv_Text.Dispose();
          hv_Text = ExpTmpLocalVar_Text;
          }
          }
          //
          //Get or open next child window.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_WindowImageRatio, 
              out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                hv_ImageClassIDsUniq)), "box", "false");
            }
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "segmentation_image_both"))) != 0)
      {
        //
        //Ground truth and result segmentation on image.
        ho_Image.Dispose();
        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
        ho_SegmentationImagGroundTruth.Dispose();
        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth, hv_SampleKeys, 
            hv_DLSample);
        ho_SegmentationImageResult.Dispose();
        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys, 
            hv_DLResult);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, hv_WindowHandleDict, 
            hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        //Visualization.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        //
        //Display regions.
        hv_ColorsResults.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ColorsResults = hv_Colors+hv_SegTransparency;
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 2);
        }
        hv_GroundTruthIDs.Dispose();
        dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs, 
            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_GroundTruthIDs);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 6);
        }
        hv_ResultIDs.Dispose();
        dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs, 
            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_ResultIDs);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
        }
        hv_Text.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Text = "Ground truth and result segmentation"+hv_ImageIDString;
        }
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "bottom", "left", "white", "box", "false");
          }
        }
        //
        //Display the legend.
        if ((int)(hv_ShowLegend) != 0)
        {
          hv_ImageClassIDsUniq.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImageClassIDsUniq = ((((hv_GroundTruthIDs.TupleConcat(
              hv_ResultIDs))).TupleSort())).TupleUniq();
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Text = hv_Text.TupleConcat(
              hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
          hv_Text.Dispose();
          hv_Text = ExpTmpLocalVar_Text;
          }
          }
          if (hv_Text == null)
            hv_Text = new HTuple();
          hv_Text[(new HTuple(hv_Text.TupleLength()))+1] = new HTuple("- thicker line: result, thinner lines: ground truth");
          if (hv_Text == null)
            hv_Text = new HTuple();
          hv_Text[new HTuple(hv_Text.TupleLength())] = "  (you may have to zoom in for a more detailed view)";
          hv_StringSegExcludeClassIDs.Dispose();
          hv_StringSegExcludeClassIDs = "";
          for (hv_StringIndex=0; (int)hv_StringIndex<=(int)((new HTuple(hv_SegExcludeClassIDs.TupleLength()
              ))-1); hv_StringIndex = (int)hv_StringIndex + 1)
          {
            if ((int)(new HTuple(hv_StringIndex.TupleEqual((new HTuple(hv_SegExcludeClassIDs.TupleLength()
                ))-1))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_StringSegExcludeClassIDs = hv_StringSegExcludeClassIDs+(hv_SegExcludeClassIDs.TupleSelect(
                  hv_StringIndex));
              hv_StringSegExcludeClassIDs.Dispose();
              hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
              }
              }
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_StringSegExcludeClassIDs = (hv_StringSegExcludeClassIDs+(hv_SegExcludeClassIDs.TupleSelect(
                  hv_StringIndex)))+new HTuple(", ");
              hv_StringSegExcludeClassIDs.Dispose();
              hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
              }
              }
            }
          }
          if ((int)(new HTuple(hv_SegExcludeClassIDs.TupleNotEqual(new HTuple()))) != 0)
          {
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = ("- (excluded classID(s) "+hv_StringSegExcludeClassIDs)+" from visualization)";
          }
          //
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_WindowImageRatio, 
              out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "top", "left", (((new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                hv_ImageClassIDsUniq)))).TupleConcat(((new HTuple("white")).TupleConcat(
                "white")).TupleConcat("white")), "box", "false");
            }
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "segmentation_image_diff"))) != 0)
      {
        //
        //Difference of ground truth and result segmentation on image.
        ho_Image.Dispose();
        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
        ho_SegmentationImagGroundTruth.Dispose();
        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth, hv_SampleKeys, 
            hv_DLSample);
        ho_SegmentationImageResult.Dispose();
        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys, 
            hv_DLResult);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, hv_WindowHandleDict, 
            hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        //Visualization.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        ho_ImageAbsDiff.Dispose();
        HOperatorSet.AbsDiffImage(ho_SegmentationImagGroundTruth, ho_SegmentationImageResult, 
            out ho_ImageAbsDiff, 1);
        hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
        HOperatorSet.MinMaxGray(ho_SegmentationImageResult, ho_ImageAbsDiff, 0, out hv_Min, 
            out hv_Max, out hv_Range);
        if ((int)(new HTuple(hv_Min.TupleNotEqual(hv_Max))) != 0)
        {
          ho_DiffRegion.Dispose();
          HOperatorSet.Threshold(ho_ImageAbsDiff, out ho_DiffRegion, 0.00001, hv_Max);
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), "#ff0000"+hv_SegTransparency);
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_DiffRegion, HDevWindowStack.GetActive());
          }
        }
        else
        {
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "No difference found.", 
                "window", "top", "left", "black", new HTuple(), new HTuple());
          }
        }
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Difference of ground truth and result segmentation"+hv_ImageIDString;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                "bottom", "left", "white", "box", "false");
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "segmentation_weight_map"))) != 0)
      {
        //
        //Weight map on image.
        ho_Image.Dispose();
        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
        ho_ImageWeight.Dispose();
        get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
        //
        if ((int)(new HTuple(hv_SegMaxWeight.TupleEqual(0))) != 0)
        {
          //Calculate SegMaxWeight if not given in GenParam.
          hv_MinWeight.Dispose();hv_SegMaxWeight.Dispose();hv_Range.Dispose();
          HOperatorSet.MinMaxGray(ho_ImageWeight, ho_ImageWeight, 0, out hv_MinWeight, 
              out hv_SegMaxWeight, out hv_Range);
        }
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
            hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        //Visualization.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        hv_WeightsColors.Dispose();
        dev_display_weight_regions(ho_ImageWeight, hv_MapTransparency, hv_SegMaxWeight, 
            out hv_WeightsColors);
        dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_MapColorBarWidth, 
            hv_WeightsColors, hv_SegMaxWeight, hv_WindowImageRatio, hv_CurrentWindowHandle);
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight map"+hv_ImageIDString, 
                "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
      }
      else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
          "segmentation_confidence_map"))) != 0)
      {
        //
        //Segmentation confidence map on image.
        ho_Image.Dispose();
        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
        ho_ImageConfidence.Dispose();
        get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
        //
        //Get or open next window.
        hv_WidthImage.Dispose();hv_HeightImage.Dispose();
        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
        get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
            hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
            hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
            out hv_WindowImageRatio, out ExpTmpOutVar_0);
        hv_PrevWindowCoordinates.Dispose();
        hv_PrevWindowCoordinates = ExpTmpOutVar_0;
        }
        //
        //Visualization.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        hv_ConfidenceColors.Dispose();
        dev_display_confidence_regions(ho_ImageConfidence, hv_MapTransparency, out hv_ConfidenceColors);
        dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_MapColorBarWidth, 
            hv_ConfidenceColors, 1.0, hv_WindowImageRatio, hv_CurrentWindowHandle);
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence map"+hv_ImageIDString, 
                "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
      }
      else
      {
        //Reset flush buffer of existing windows before throwing an exception.
        hv_WindowHandleKeys.Dispose();
        HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeys.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          //Only consider the WindowHandleKeys that are needed for the current visualization.
          hv_KeyIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_KeyIndex = hv_KeysForDisplay.TupleFind(
              hv_WindowHandleKeys.TupleSelect(hv_Index));
          }
          if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
              new HTuple())))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowHandles.Dispose();
            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                hv_Index), out hv_WindowHandles);
            }
            for (hv_WindowIndex=0; (int)hv_WindowIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
                ))-1); hv_WindowIndex = (int)hv_WindowIndex + 1)
            {
              //Reset values of windows that have been changed temporarily.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                  "flush", hv_FlushValues.TupleSelect(hv_Index));
              }
            }
          }
        }
        throw new HalconException("Key for display unknown: "+(hv_KeysForDisplay.TupleSelect(
            hv_KeyIndex)));
      }
    }
    //
    //Display results.
    hv_WindowHandleKeysNew.Dispose();
    HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeysNew);
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeysNew.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      //Only consider the WindowHandleKeys that are needed for the current visualization.
      hv_KeyIndex.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_KeyIndex = hv_KeysForDisplay.TupleFind(
          hv_WindowHandleKeysNew.TupleSelect(hv_Index));
      }
      if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
          new HTuple())))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowHandles.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeysNew.TupleSelect(
            hv_Index), out hv_WindowHandles);
        }
        for (hv_WindowIndex=0; (int)hv_WindowIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
            ))-1); hv_WindowIndex = (int)hv_WindowIndex + 1)
        {
          //Display content of window handle.
          if ((int)(new HTuple((new HTuple(hv_WindowHandleKeys.TupleLength())).TupleEqual(
              new HTuple(hv_WindowHandleKeysNew.TupleLength())))) != 0)
          {
            //Reset values of windows that have been changed temporarily.
            if ((int)(new HTuple(((hv_FlushValues.TupleSelect(hv_Index))).TupleEqual(
                "true"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
              }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                "flush", hv_FlushValues.TupleSelect(hv_Index));
            }
          }
          else
          {
            //Per default, 'flush' of new windows should be set to 'true'.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                "flush", "true");
            }
          }
        }
      }
    }
    ho_Image.Dispose();
    ho_ImageWeight.Dispose();
    ho_ImageConfidence.Dispose();
    ho_SegmentationImagGroundTruth.Dispose();
    ho_SegmentationImageResult.Dispose();
    ho_ImageAbsDiff.Dispose();
    ho_DiffRegion.Dispose();

    hv_ThresholdWidth.Dispose();
    hv_ScaleWindows.Dispose();
    hv_Font.Dispose();
    hv_FontSize.Dispose();
    hv_LineWidth.Dispose();
    hv_MapTransparency.Dispose();
    hv_MapColorBarWidth.Dispose();
    hv_SegMaxWeight.Dispose();
    hv_SegDraw.Dispose();
    hv_SegTransparency.Dispose();
    hv_SegExcludeClassIDs.Dispose();
    hv_BboxLabelColor.Dispose();
    hv_BboxDisplayConfidence.Dispose();
    hv_BboxTextColor.Dispose();
    hv_ShowBottomDesc.Dispose();
    hv_ShowLegend.Dispose();
    hv_ShowLabels.Dispose();
    hv_GenParamNames.Dispose();
    hv_ParamIndex.Dispose();
    hv_GenParamName.Dispose();
    hv_GenParamValue.Dispose();
    hv_SampleKeys.Dispose();
    hv_ResultKeys.Dispose();
    hv_ImageIDExists.Dispose();
    hv_ImageID.Dispose();
    hv_ImageIDString.Dispose();
    hv_NeededKeys.Dispose();
    hv_Index.Dispose();
    hv_DLDatasetInfoKeys.Dispose();
    hv_ClassNames.Dispose();
    hv_ClassIDs.Dispose();
    hv_Colors.Dispose();
    hv_ClassesLegend.Dispose();
    hv_PrevWindowCoordinates.Dispose();
    hv_Keys.Dispose();
    hv_Exception.Dispose();
    hv_MetaInfoIndex.Dispose();
    hv_MetaInfo.Dispose();
    hv_FlushValues.Dispose();
    hv_WindowHandleKeys.Dispose();
    hv_KeyIndex.Dispose();
    hv_WindowHandles.Dispose();
    hv_WindowIndex.Dispose();
    hv_FlushValue.Dispose();
    hv_WidthImage.Dispose();
    hv_HeightImage.Dispose();
    hv_CurrentWindowHandle.Dispose();
    hv_WindowImageRatio.Dispose();
    hv_BboxIDs.Dispose();
    hv_Text.Dispose();
    hv_BboxColors.Dispose();
    hv_BboxIDsUniq.Dispose();
    hv_BboxConfidences.Dispose();
    hv_TextConf.Dispose();
    hv_BboxClassIndex.Dispose();
    hv_BboxColorsResults.Dispose();
    hv_BboxClassIndexUniq.Dispose();
    hv_BboxLabelIndex.Dispose();
    hv_BboxColorsBoth.Dispose();
    hv_BboxClassLabelIndexUniq.Dispose();
    hv_ColorsSegmentation.Dispose();
    hv_DrawMode.Dispose();
    hv_Width.Dispose();
    hv_ImageClassIDs.Dispose();
    hv_ImageClassIDsUniq.Dispose();
    hv_ColorsResults.Dispose();
    hv_GroundTruthIDs.Dispose();
    hv_ResultIDs.Dispose();
    hv_StringSegExcludeClassIDs.Dispose();
    hv_StringIndex.Dispose();
    hv_Min.Dispose();
    hv_Max.Dispose();
    hv_Range.Dispose();
    hv_MinWeight.Dispose();
    hv_WeightsColors.Dispose();
    hv_ConfidenceColors.Dispose();
    hv_WindowHandleKeysNew.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Close all windows whose handle is contained in the dictionary WindowHandleDict. 
  public void dev_display_dl_data_close_windows (HTuple hv_WindowHandleDict)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WindowHandleKeys = new HTuple();
    HTuple hv_Index = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_WindowIndex = new HTuple(), hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    //
    //This procedure closes all window handles
    //that are contained in the dictionary WindowHandleDict.
    //
    hv_WindowHandleKeys.Dispose();
    HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_WindowHandleKeys = hv_WindowHandleKeys.TupleRemove(
        hv_WindowHandleKeys.TupleFind("meta_information"));
    hv_WindowHandleKeys.Dispose();
    hv_WindowHandleKeys = ExpTmpLocalVar_WindowHandleKeys;
    }
    }
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeys.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowHandles.Dispose();
      HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
          hv_Index), out hv_WindowHandles);
      }
      for (hv_WindowIndex=0; (int)hv_WindowIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
          ))-1); hv_WindowIndex = (int)hv_WindowIndex + 1)
      {
        //Since there are not only window handles saved in the dictionary, use try-catch.
        try
        {
          HDevWindowStack.SetActive(hv_WindowHandles.TupleSelect(
              hv_WindowIndex));
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.CloseWindow(HDevWindowStack.Pop());
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
          hv_Index));
      }
    }
    //

    hv_WindowHandleKeys.Dispose();
    hv_Index.Dispose();
    hv_WindowHandles.Dispose();
    hv_WindowIndex.Dispose();
    hv_Exception.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Visualize for a given number of samples the raw image, ground truth annotation, and inferred results. 
  public void dev_display_dl_data_tiled (HTuple hv_DLDataset, HTuple hv_DLModelHandle, 
      HTuple hv_NumSamples, HTuple hv_Split, HTuple hv_GenParam, HTuple hv_WindowHandle, 
      out HTuple hv_WindowHandleOut)
  {



      // Stack for temporary objects 
      HObject[] OTemp = new HObject[20];

      // Local iconic variables 

      HObject ho_FinalRows, ho_SampleImages, ho_SampleImage=null;
      HObject ho_FirstChannel=null, ho_ImageScaled=null, ho_ImageConverted=null;
      HObject ho_TiledImageRow, ho_TiledImage, ho_Domain, ho_RegionComplement;
      HObject ho_Image=null, ho_ImageCleared=null, ho_TiledResult=null;

      // Local control variables 

      HTuple hv_BackGroundColor = new HTuple();
      HTuple hv_SpacingRow = new HTuple(), hv_SpacingCol = new HTuple();
      HTuple hv_WindowRow = new HTuple(), hv_WindowCol = new HTuple();
      HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
      HTuple hv_IncludeImage = new HTuple(), hv_IncludeGroundTruth = new HTuple();
      HTuple hv_IncludeResults = new HTuple(), hv_Keys = new HTuple();
      HTuple hv_Index = new HTuple(), hv_Key = new HTuple();
      HTuple hv_Value = new HTuple(), hv_ModelType = new HTuple();
      HTuple hv_Samples = new HTuple(), hv_KeysExist = new HTuple();
      HTuple hv_DLSamples = new HTuple(), hv_SampleIndices = new HTuple();
      HTuple hv_BatchSize = new HTuple(), hv_FillUp = new HTuple();
      HTuple hv_DLResult = new HTuple(), hv_Batch = new HTuple();
      HTuple hv_DLResultBatch = new HTuple(), hv_ClassIDs = new HTuple();
      HTuple hv_BackGroundClass = new HTuple(), hv_RGB = new HTuple();
      HTuple hv_Channels = new HTuple(), hv_Width = new HTuple();
      HTuple hv_Height = new HTuple(), hv_Crop = new HTuple();
      HTuple hv_OffsetRow = new HTuple(), hv_TiledWidth = new HTuple();
      HTuple hv_TiledHeight = new HTuple(), hv_TopOffset = new HTuple();
      HTuple hv_GTLabel = new HTuple(), hv_GTCol1 = new HTuple();
      HTuple hv_GTRow1 = new HTuple(), hv_GTCol2 = new HTuple();
      HTuple hv_GTRow2 = new HTuple(), hv_LeftOffset = new HTuple();
      HTuple hv_LabelId = new HTuple(), hv_Col1 = new HTuple();
      HTuple hv_Row1 = new HTuple(), hv_Col2 = new HTuple();
      HTuple hv_Row2 = new HTuple(), hv_ResClass = new HTuple();
      HTuple hv_ResConfidence = new HTuple(), hv_ResCol1 = new HTuple();
      HTuple hv_ResRow1 = new HTuple(), hv_ResCol2 = new HTuple();
      HTuple hv_ResRow2 = new HTuple(), hv_ClassId = new HTuple();
      HTuple hv_Confidence = new HTuple(), hv_TiledDLSample = new HTuple();
      HTuple hv_TiledDLResult = new HTuple(), hv_WindowHandleDict = new HTuple();
      HTuple hv_Flush = new HTuple(), hv_KeyForDisplay = new HTuple();
      HTuple   hv_GenParam_COPY_INP_TMP = new HTuple(hv_GenParam);
      HTuple   hv_WindowHandle_COPY_INP_TMP = new HTuple(hv_WindowHandle);

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_FinalRows);
      HOperatorSet.GenEmptyObj(out ho_SampleImages);
      HOperatorSet.GenEmptyObj(out ho_SampleImage);
      HOperatorSet.GenEmptyObj(out ho_FirstChannel);
      HOperatorSet.GenEmptyObj(out ho_ImageScaled);
      HOperatorSet.GenEmptyObj(out ho_ImageConverted);
      HOperatorSet.GenEmptyObj(out ho_TiledImageRow);
      HOperatorSet.GenEmptyObj(out ho_TiledImage);
      HOperatorSet.GenEmptyObj(out ho_Domain);
      HOperatorSet.GenEmptyObj(out ho_RegionComplement);
      HOperatorSet.GenEmptyObj(out ho_Image);
      HOperatorSet.GenEmptyObj(out ho_ImageCleared);
      HOperatorSet.GenEmptyObj(out ho_TiledResult);
      hv_WindowHandleOut = new HTuple();
    //
    //This procedure visualizes samples, their ground truth annotations, and,
    //if not deactivated, the results obtained by applying the model given by DLModelHandle.
    //
    //** Set the default values for all the generic parameters: ***
    //
    hv_BackGroundColor.Dispose();
    hv_BackGroundColor = "#ffffff";
    hv_SpacingRow.Dispose();
    hv_SpacingRow = 0;
    hv_SpacingCol.Dispose();
    hv_SpacingCol = 0;
    hv_WindowRow.Dispose();
    hv_WindowRow = 0;
    hv_WindowCol.Dispose();
    hv_WindowCol = 0;
    hv_WindowWidth.Dispose();
    hv_WindowWidth = 640;
    hv_WindowHeight.Dispose();
    hv_WindowHeight = 480;
    //Show a row with the plain images.
    hv_IncludeImage.Dispose();
    hv_IncludeImage = 1;
    //Show a row with the images and their ground truth annotations.
    hv_IncludeGroundTruth.Dispose();
    hv_IncludeGroundTruth = 1;
    //Show a row with image and their inference results.
    hv_IncludeResults.Dispose();
    hv_IncludeResults = 1;
    //
    if ((int)(new HTuple((new HTuple(hv_GenParam_COPY_INP_TMP.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_Keys.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "keys", new HTuple(), out hv_Keys);
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Keys.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        hv_Key.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Key = hv_Keys.TupleSelect(
            hv_Index);
        }
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_Key, out hv_Value);
        if ((int)(new HTuple(hv_Key.TupleEqual("background_color"))) != 0)
        {
          hv_BackGroundColor.Dispose();
          hv_BackGroundColor = new HTuple(hv_Value);
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("spacing_row"))) != 0)
        {
          hv_SpacingRow.Dispose();
          hv_SpacingRow = new HTuple(hv_Value);
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("spacing_col"))) != 0)
        {
          hv_SpacingCol.Dispose();
          hv_SpacingCol = new HTuple(hv_Value);
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("window_width"))) != 0)
        {
          hv_WindowWidth.Dispose();
          hv_WindowWidth = new HTuple(hv_Value);
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("window_height"))) != 0)
        {
          hv_WindowHeight.Dispose();
          hv_WindowHeight = new HTuple(hv_Value);
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("window_row"))) != 0)
        {
          hv_WindowRow.Dispose();
          hv_WindowRow = new HTuple(hv_Value);
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("window_col"))) != 0)
        {
          hv_WindowCol.Dispose();
          hv_WindowCol = new HTuple(hv_Value);
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("display_input"))) != 0)
        {
          hv_IncludeImage.Dispose();
          hv_IncludeImage = new HTuple(hv_Value);
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("display_ground_truth"))) != 0)
        {
          hv_IncludeGroundTruth.Dispose();
          hv_IncludeGroundTruth = new HTuple(hv_Value);
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("display_result"))) != 0)
        {
          hv_IncludeResults.Dispose();
          hv_IncludeResults = new HTuple(hv_Value);
        }
        else
        {
          throw new HalconException("Invalid generic parameter: "+hv_Key);
        }
      }
    }
    //
    //If a model was handed over, get model type.
    if ((int)(new HTuple(hv_DLModelHandle.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_ModelType.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
      if ((int)((new HTuple(hv_ModelType.TupleNotEqual("segmentation"))).TupleAnd(
          new HTuple(hv_ModelType.TupleNotEqual("detection")))) != 0)
      {
        throw new HalconException("Invalid model type");
      }
    }
    else
    {
      //
      //If no model was handed over, results are not displayed.
      hv_IncludeResults.Dispose();
      hv_IncludeResults = 0;
      //Conclude the model type from the existing keys.
      hv_Samples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_Samples);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_KeysExist.Dispose();
      HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", (new HTuple("bbox_label_id")).TupleConcat(
          "segmentation_file_name"), out hv_KeysExist);
      }
      if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
      {
        hv_ModelType.Dispose();
        hv_ModelType = "detection";
      }
      else if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
      {
        hv_ModelType.Dispose();
        hv_ModelType = "segmentation";
      }
      else
      {
        throw new HalconException("Cannot conclude model type from DLDataset.");
      }
    }
    //
    //** Generate results for a random subset of NumSamples-many samples: ***
    //
    //Select random samples.
    hv_DLSamples.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
    hv_SampleIndices.Dispose();
    find_dl_samples(hv_DLSamples, "split", hv_Split, "or", out hv_SampleIndices);
    {
    HTuple ExpTmpOutVar_0;
    tuple_shuffle(hv_SampleIndices, out ExpTmpOutVar_0);
    hv_SampleIndices.Dispose();
    hv_SampleIndices = ExpTmpOutVar_0;
    }
    //
    //Calculate the result for the selected samples.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleSelectRange(
        0,hv_NumSamples-1);
    hv_SampleIndices.Dispose();
    hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
    }
    }
    //
    if ((int)(hv_IncludeResults) != 0)
    {
      hv_BatchSize.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
      //It is necessary to fill up SampleIndices to a multiple of BatchSize.
      if ((int)(new HTuple(((hv_NumSamples%hv_BatchSize)).TupleNotEqual(0))) != 0)
      {
        hv_FillUp.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FillUp = hv_BatchSize-(hv_NumSamples%hv_BatchSize);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleConcat(
            HTuple.TupleGenConst(hv_FillUp,hv_SampleIndices.TupleSelect((new HTuple(hv_SampleIndices.TupleLength()
            ))-1)));
        hv_SampleIndices.Dispose();
        hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
        }
        }
      }
      hv_DLSamples.Dispose();
      read_dl_samples(hv_DLDataset, hv_SampleIndices, out hv_DLSamples);
      hv_DLResult.Dispose();
      hv_DLResult = new HTuple();
      HTuple end_val92 = ((new HTuple(hv_SampleIndices.TupleLength()
          ))/hv_BatchSize)-1;
      HTuple step_val92 = 1;
      for (hv_Batch=0; hv_Batch.Continue(end_val92, step_val92); hv_Batch = hv_Batch.TupleAdd(step_val92))
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DLResultBatch.Dispose();
        HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamples.TupleSelectRange(
            hv_Batch*hv_BatchSize,((hv_Batch+1)*hv_BatchSize)-1), new HTuple(), out hv_DLResultBatch);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_DLResult = hv_DLResult.TupleConcat(
            hv_DLResultBatch);
        hv_DLResult.Dispose();
        hv_DLResult = ExpTmpLocalVar_DLResult;
        }
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DLResult = hv_DLResult.TupleSelectRange(
          0,hv_NumSamples-1);
      hv_DLResult.Dispose();
      hv_DLResult = ExpTmpLocalVar_DLResult;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DLSamples = hv_DLSamples.TupleSelectRange(
          0,hv_NumSamples-1);
      hv_DLSamples.Dispose();
      hv_DLSamples = ExpTmpLocalVar_DLSamples;
      }
      }
    }
    else
    {
      hv_DLSamples.Dispose();
      read_dl_samples(hv_DLDataset, hv_SampleIndices, out hv_DLSamples);
    }
    //
    //** Generate the tiled image and the tiled result data: ***
    //
    hv_ClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
    //For segmentation models, we need a class ID that is not present in class_ids, to
    //mark regions without region visualization.
    hv_BackGroundClass.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_BackGroundClass = (hv_ClassIDs.TupleMax()
        )+1;
    }
    hv_RGB.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RGB = new HTuple();
    hv_RGB = hv_RGB.TupleConcat((("0x"+(hv_BackGroundColor.TupleSubstr(
        1,2)))).TupleNumber());
    hv_RGB = hv_RGB.TupleConcat((("0x"+(hv_BackGroundColor.TupleSubstr(
        3,4)))).TupleNumber());
    hv_RGB = hv_RGB.TupleConcat((("0x"+(hv_BackGroundColor.TupleSubstr(
        5,6)))).TupleNumber());
    }
    //
    ho_FinalRows.Dispose();
    HOperatorSet.GenEmptyObj(out ho_FinalRows);
    //
    //Generate the tiled sample image.
    ho_SampleImages.Dispose();
    HOperatorSet.GenEmptyObj(out ho_SampleImages);
    HTuple end_val114 = hv_NumSamples-1;
    HTuple step_val114 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val114, step_val114); hv_Index = hv_Index.TupleAdd(step_val114))
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_SampleImage.Dispose();
      HOperatorSet.GetDictObject(out ho_SampleImage, hv_DLSamples.TupleSelect(hv_Index), 
          "image");
      }
      hv_Channels.Dispose();
      HOperatorSet.CountChannels(ho_SampleImage, out hv_Channels);
      if ((int)(new HTuple(hv_Channels.TupleNotEqual(3))) != 0)
      {
        //For any number of channels, that is not three, just use the first channel.
        ho_FirstChannel.Dispose();
        HOperatorSet.AccessChannel(ho_SampleImage, out ho_FirstChannel, 1);
        ho_SampleImage.Dispose();
        HOperatorSet.Compose3(ho_FirstChannel, ho_FirstChannel, ho_FirstChannel, 
            out ho_SampleImage);
      }
      //Convert the images back to byte.
      ho_ImageScaled.Dispose();
      HOperatorSet.ScaleImage(ho_SampleImage, out ho_ImageScaled, 1, 127);
      ho_ImageConverted.Dispose();
      HOperatorSet.ConvertImageType(ho_ImageScaled, out ho_ImageConverted, "byte");
      //Add the image to to the tuple SampleImages.
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_SampleImages, ho_ImageConverted, out ExpTmpOutVar_0
          );
      ho_SampleImages.Dispose();
      ho_SampleImages = ExpTmpOutVar_0;
      }
    }
    //Tile the images in a row.
    hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetImageSize(ho_SampleImages, out hv_Width, out hv_Height);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Crop.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), -1, out hv_Crop);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OffsetRow.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), 0, out hv_OffsetRow);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_TiledImageRow.Dispose();
    HOperatorSet.TileImagesOffset(ho_SampleImages, out ho_TiledImageRow, hv_OffsetRow, 
        (((new HTuple(0)).TupleConcat(((hv_Width+hv_SpacingCol)).TupleCumul()))).TupleSelectRange(
        0,(new HTuple(hv_Width.TupleLength()))-1), hv_Crop, hv_Crop, hv_Crop, hv_Crop, 
        (((((hv_Width+hv_SpacingCol)).TupleCumul())).TupleSelect((new HTuple(hv_Width.TupleLength()
        ))-1))-hv_SpacingCol, hv_Height.TupleMax());
    }
    //
    //Generate the columns of images for the tiled output.
    if ((int)(hv_IncludeImage) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0);
      ho_FinalRows.Dispose();
      ho_FinalRows = ExpTmpOutVar_0;
      }
    }
    if ((int)(hv_IncludeGroundTruth) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0);
      ho_FinalRows.Dispose();
      ho_FinalRows = ExpTmpOutVar_0;
      }
    }
    if ((int)(hv_IncludeResults) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0);
      ho_FinalRows.Dispose();
      ho_FinalRows = ExpTmpOutVar_0;
      }
    }
    hv_TiledWidth.Dispose();hv_TiledHeight.Dispose();
    HOperatorSet.GetImageSize(ho_FinalRows, out hv_TiledWidth, out hv_TiledHeight);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_TiledImage.Dispose();
    HOperatorSet.TileImagesOffset(ho_FinalRows, out ho_TiledImage, (((new HTuple(0)).TupleConcat(
        ((hv_TiledHeight+hv_SpacingRow)).TupleCumul()))).TupleSelectRange(0,(new HTuple(hv_TiledHeight.TupleLength()
        ))-1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()),0), 
        HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()),-1), HTuple.TupleGenConst(
        new HTuple(hv_TiledHeight.TupleLength()),-1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()
        ),-1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()),-1), 
        hv_TiledWidth.TupleMax(), (((((hv_TiledHeight+hv_SpacingRow)).TupleCumul()
        )).TupleSelect((new HTuple(hv_TiledHeight.TupleLength()))-1))-hv_SpacingRow);
    }
    //Fill up with the background color.
    ho_Domain.Dispose();
    HOperatorSet.GetDomain(ho_TiledImage, out ho_Domain);
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.FullDomain(ho_TiledImage, out ExpTmpOutVar_0);
    ho_TiledImage.Dispose();
    ho_TiledImage = ExpTmpOutVar_0;
    }
    ho_RegionComplement.Dispose();
    HOperatorSet.Complement(ho_Domain, out ho_RegionComplement);
    HOperatorSet.OverpaintRegion(ho_TiledImage, ho_RegionComplement, hv_RGB, "fill");
    //
    //Generate the tiled data (segmentation regions / detection bounding boxes).
    if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
    {
      //
      //The tiled segmentation result image is constructed in the same way as the tiled sample image.
      ho_FinalRows.Dispose();
      HOperatorSet.GenEmptyObj(out ho_FinalRows);
      if ((int)(hv_IncludeImage) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Image.Dispose();
        HOperatorSet.GenImageConst(out ho_Image, "real", hv_TiledWidth.TupleSelect(
            0), hv_TiledHeight.TupleSelect(0));
        }
        //For the top (image) row, set the (virtual) background class as segmentation result.
        ho_ImageCleared.Dispose();
        HOperatorSet.GenImageProto(ho_Image, out ho_ImageCleared, hv_BackGroundClass);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_FinalRows, ho_ImageCleared, out ExpTmpOutVar_0);
        ho_FinalRows.Dispose();
        ho_FinalRows = ExpTmpOutVar_0;
        }
      }
      //
      if ((int)(hv_IncludeGroundTruth) != 0)
      {
        ho_TiledImageRow.Dispose();
        gen_tiled_segmentation_image(out ho_TiledImageRow, hv_DLSamples, hv_SpacingCol, 
            hv_Width, hv_Height);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
            );
        ho_FinalRows.Dispose();
        ho_FinalRows = ExpTmpOutVar_0;
        }
      }
      //
      if ((int)(hv_IncludeResults) != 0)
      {
        ho_TiledImageRow.Dispose();
        gen_tiled_segmentation_image(out ho_TiledImageRow, hv_DLResult, hv_SpacingCol, 
            hv_Width, hv_Height);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
            );
        ho_FinalRows.Dispose();
        ho_FinalRows = ExpTmpOutVar_0;
        }
      }
      hv_TiledWidth.Dispose();hv_TiledHeight.Dispose();
      HOperatorSet.GetImageSize(ho_FinalRows, out hv_TiledWidth, out hv_TiledHeight);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_TiledResult.Dispose();
      HOperatorSet.TileImagesOffset(ho_FinalRows, out ho_TiledResult, (((new HTuple(0)).TupleConcat(
          ((hv_TiledHeight+hv_SpacingRow)).TupleCumul()))).TupleSelectRange(0,(new HTuple(hv_TiledHeight.TupleLength()
          ))-1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()),0), 
          HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()),-1), HTuple.TupleGenConst(
          new HTuple(hv_TiledHeight.TupleLength()),-1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()
          ),-1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()),-1), 
          hv_TiledWidth.TupleMax(), (((((hv_TiledHeight+hv_SpacingRow)).TupleCumul()
          )).TupleSelect((new HTuple(hv_TiledHeight.TupleLength()))-1))-hv_SpacingRow);
      }
      //Fill up with the background color.
      ho_Domain.Dispose();
      HOperatorSet.GetDomain(ho_TiledResult, out ho_Domain);
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.FullDomain(ho_TiledResult, out ExpTmpOutVar_0);
      ho_TiledResult.Dispose();
      ho_TiledResult = ExpTmpOutVar_0;
      }
      ho_RegionComplement.Dispose();
      HOperatorSet.Complement(ho_Domain, out ho_RegionComplement);
      HOperatorSet.OverpaintRegion(ho_TiledResult, ho_RegionComplement, hv_BackGroundClass, 
          "fill");
      //
    }
    else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
    {
      //
      //For detection results the detected boxes must be moved
      //to the positions of the respective image.
      hv_TopOffset.Dispose();
      hv_TopOffset = 0;
      if ((int)(hv_IncludeImage) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TopOffset = (hv_TopOffset+hv_SpacingRow)+(hv_TiledHeight.TupleSelect(
            0));
        hv_TopOffset.Dispose();
        hv_TopOffset = ExpTmpLocalVar_TopOffset;
        }
        }
      }
      //Move the ground truth labels.
      hv_GTLabel.Dispose();
      hv_GTLabel = new HTuple();
      hv_GTCol1.Dispose();
      hv_GTCol1 = new HTuple();
      hv_GTRow1.Dispose();
      hv_GTRow1 = new HTuple();
      hv_GTCol2.Dispose();
      hv_GTCol2 = new HTuple();
      hv_GTRow2.Dispose();
      hv_GTRow2 = new HTuple();
      if ((int)(hv_IncludeGroundTruth) != 0)
      {
        hv_LeftOffset.Dispose();
        hv_LeftOffset = 0;
        HTuple end_val197 = hv_NumSamples-1;
        HTuple step_val197 = 1;
        for (hv_Index=0; hv_Index.Continue(end_val197, step_val197); hv_Index = hv_Index.TupleAdd(step_val197))
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LabelId.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_label_id", 
              out hv_LabelId);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_GTLabel = hv_GTLabel.TupleConcat(
              hv_LabelId);
          hv_GTLabel.Dispose();
          hv_GTLabel = ExpTmpLocalVar_GTLabel;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Col1.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_col1", 
              out hv_Col1);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_GTCol1 = hv_GTCol1.TupleConcat(
              hv_Col1+hv_LeftOffset);
          hv_GTCol1.Dispose();
          hv_GTCol1 = ExpTmpLocalVar_GTCol1;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Row1.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_row1", 
              out hv_Row1);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_GTRow1 = hv_GTRow1.TupleConcat(
              hv_Row1+hv_TopOffset);
          hv_GTRow1.Dispose();
          hv_GTRow1 = ExpTmpLocalVar_GTRow1;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Col2.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_col2", 
              out hv_Col2);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_GTCol2 = hv_GTCol2.TupleConcat(
              hv_Col2+hv_LeftOffset);
          hv_GTCol2.Dispose();
          hv_GTCol2 = ExpTmpLocalVar_GTCol2;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Row2.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_row2", 
              out hv_Row2);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_GTRow2 = hv_GTRow2.TupleConcat(
              hv_Row2+hv_TopOffset);
          hv_GTRow2.Dispose();
          hv_GTRow2 = ExpTmpLocalVar_GTRow2;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_LeftOffset = (hv_LeftOffset+hv_SpacingCol)+(hv_Width.TupleSelect(
              hv_Index));
          hv_LeftOffset.Dispose();
          hv_LeftOffset = ExpTmpLocalVar_LeftOffset;
          }
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TopOffset = (hv_TopOffset+hv_SpacingRow)+(hv_TiledHeight.TupleSelect(
            0));
        hv_TopOffset.Dispose();
        hv_TopOffset = ExpTmpLocalVar_TopOffset;
        }
        }
      }
      hv_ResClass.Dispose();
      hv_ResClass = new HTuple();
      hv_ResConfidence.Dispose();
      hv_ResConfidence = new HTuple();
      hv_ResCol1.Dispose();
      hv_ResCol1 = new HTuple();
      hv_ResRow1.Dispose();
      hv_ResRow1 = new HTuple();
      hv_ResCol2.Dispose();
      hv_ResCol2 = new HTuple();
      hv_ResRow2.Dispose();
      hv_ResRow2 = new HTuple();
      //Move the result labels.
      if ((int)(hv_IncludeResults) != 0)
      {
        hv_LeftOffset.Dispose();
        hv_LeftOffset = 0;
        HTuple end_val221 = hv_NumSamples-1;
        HTuple step_val221 = 1;
        for (hv_Index=0; hv_Index.Continue(end_val221, step_val221); hv_Index = hv_Index.TupleAdd(step_val221))
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassId.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_class_id", 
              out hv_ClassId);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ResClass = hv_ResClass.TupleConcat(
              hv_ClassId);
          hv_ResClass.Dispose();
          hv_ResClass = ExpTmpLocalVar_ResClass;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Confidence.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_confidence", 
              out hv_Confidence);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ResConfidence = hv_ResConfidence.TupleConcat(
              hv_Confidence);
          hv_ResConfidence.Dispose();
          hv_ResConfidence = ExpTmpLocalVar_ResConfidence;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Col1.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_col1", 
              out hv_Col1);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ResCol1 = hv_ResCol1.TupleConcat(
              hv_Col1+hv_LeftOffset);
          hv_ResCol1.Dispose();
          hv_ResCol1 = ExpTmpLocalVar_ResCol1;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Row1.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_row1", 
              out hv_Row1);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ResRow1 = hv_ResRow1.TupleConcat(
              hv_Row1+hv_TopOffset);
          hv_ResRow1.Dispose();
          hv_ResRow1 = ExpTmpLocalVar_ResRow1;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Col2.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_col2", 
              out hv_Col2);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ResCol2 = hv_ResCol2.TupleConcat(
              hv_Col2+hv_LeftOffset);
          hv_ResCol2.Dispose();
          hv_ResCol2 = ExpTmpLocalVar_ResCol2;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Row2.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_row2", 
              out hv_Row2);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ResRow2 = hv_ResRow2.TupleConcat(
              hv_Row2+hv_TopOffset);
          hv_ResRow2.Dispose();
          hv_ResRow2 = ExpTmpLocalVar_ResRow2;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_LeftOffset = (hv_LeftOffset+hv_SpacingCol)+(hv_Width.TupleSelect(
              hv_Index));
          hv_LeftOffset.Dispose();
          hv_LeftOffset = ExpTmpLocalVar_LeftOffset;
          }
          }
        }
      }
    }
    //
    //** Generate a TiledDLSample and a TiledDLResult to display them with dev_display_dl_data: ***
    //
    //Generate a tiled DLSample.
    hv_TiledDLSample.Dispose();
    gen_dl_samples_from_images(ho_TiledImage, out hv_TiledDLSample);
    if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
    {
      HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_label_id", hv_GTLabel);
      HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_col1", hv_GTCol1);
      HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_row1", hv_GTRow1);
      HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_col2", hv_GTCol2);
      HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_row2", hv_GTRow2);
    }
    //Generate a tiled DLResult.
    hv_TiledDLResult.Dispose();
    HOperatorSet.CreateDict(out hv_TiledDLResult);
    if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
    {
      HOperatorSet.SetDictObject(ho_TiledResult, hv_TiledDLResult, "segmentation_image");
    }
    else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
    {
      HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_class_id", hv_ResClass);
      HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_confidence", hv_ResConfidence);
      HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_col1", hv_ResCol1);
      HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_row1", hv_ResRow1);
      HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_col2", hv_ResCol2);
      HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_row2", hv_ResRow2);
    }
    //
    //Set display parameters.
    hv_GenParam_COPY_INP_TMP.Dispose();
    HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
    //Pinch off all text display from dev_display_dl_data for a clutterless visualization.
    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_bottom_desc", 0);
    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_legend", 0);
    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_labels", 0);
    //
    //Initialize the window for displaying the tiled comparison of input and result.
    hv_WindowHandleDict.Dispose();
    HOperatorSet.CreateDict(out hv_WindowHandleDict);
    if ((int)(new HTuple((new HTuple(hv_WindowHandle_COPY_INP_TMP.TupleLength())).TupleEqual(
        0))) != 0)
    {
      hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetImageSize(ho_TiledImage, out hv_Width, out hv_Height);
      hv_WindowHandle_COPY_INP_TMP.Dispose();
      dev_open_window_fit_size(hv_WindowRow, hv_WindowCol, hv_Width, hv_Height, hv_WindowWidth, 
          hv_WindowHeight, out hv_WindowHandle_COPY_INP_TMP);
    }
    hv_Flush.Dispose();
    HOperatorSet.GetWindowParam(hv_WindowHandle_COPY_INP_TMP, "flush", out hv_Flush);
    if ((int)(new HTuple(hv_Flush.TupleEqual("true"))) != 0)
    {
      HOperatorSet.SetWindowParam(hv_WindowHandle_COPY_INP_TMP, "flush", "false");
    }
    HOperatorSet.SetWindowParam(hv_WindowHandle_COPY_INP_TMP, "background_color", 
        hv_BackGroundColor);
    HDevWindowStack.SetActive(hv_WindowHandle_COPY_INP_TMP);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
    }
    hv_WindowHandleOut.Dispose();
    hv_WindowHandleOut = new HTuple(hv_WindowHandle_COPY_INP_TMP);
    if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
    {
      hv_KeyForDisplay.Dispose();
      hv_KeyForDisplay = "segmentation_image_result";
    }
    else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
    {
      hv_KeyForDisplay.Dispose();
      hv_KeyForDisplay = "bbox_both";
    }
    HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_KeyForDisplay, hv_WindowHandle_COPY_INP_TMP);
    //
    //Display the tiled image.
    dev_display_dl_data(hv_TiledDLSample, hv_TiledDLResult, hv_DLDataset, hv_KeyForDisplay, 
        hv_GenParam_COPY_INP_TMP, hv_WindowHandleDict);
    if ((int)(new HTuple(hv_Flush.TupleEqual("true"))) != 0)
    {
      //Only flush the window, if 'flush' is 'true'. Otherwise the caller
      //(who set flush to 'false' on purpose) is responsible for flushing.
      HOperatorSet.FlushBuffer(hv_WindowHandle_COPY_INP_TMP);
    }
    HOperatorSet.SetWindowParam(hv_WindowHandle_COPY_INP_TMP, "flush", hv_Flush);
    //
    ho_FinalRows.Dispose();
    ho_SampleImages.Dispose();
    ho_SampleImage.Dispose();
    ho_FirstChannel.Dispose();
    ho_ImageScaled.Dispose();
    ho_ImageConverted.Dispose();
    ho_TiledImageRow.Dispose();
    ho_TiledImage.Dispose();
    ho_Domain.Dispose();
    ho_RegionComplement.Dispose();
    ho_Image.Dispose();
    ho_ImageCleared.Dispose();
    ho_TiledResult.Dispose();

    hv_GenParam_COPY_INP_TMP.Dispose();
    hv_WindowHandle_COPY_INP_TMP.Dispose();
    hv_BackGroundColor.Dispose();
    hv_SpacingRow.Dispose();
    hv_SpacingCol.Dispose();
    hv_WindowRow.Dispose();
    hv_WindowCol.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();
    hv_IncludeImage.Dispose();
    hv_IncludeGroundTruth.Dispose();
    hv_IncludeResults.Dispose();
    hv_Keys.Dispose();
    hv_Index.Dispose();
    hv_Key.Dispose();
    hv_Value.Dispose();
    hv_ModelType.Dispose();
    hv_Samples.Dispose();
    hv_KeysExist.Dispose();
    hv_DLSamples.Dispose();
    hv_SampleIndices.Dispose();
    hv_BatchSize.Dispose();
    hv_FillUp.Dispose();
    hv_DLResult.Dispose();
    hv_Batch.Dispose();
    hv_DLResultBatch.Dispose();
    hv_ClassIDs.Dispose();
    hv_BackGroundClass.Dispose();
    hv_RGB.Dispose();
    hv_Channels.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_Crop.Dispose();
    hv_OffsetRow.Dispose();
    hv_TiledWidth.Dispose();
    hv_TiledHeight.Dispose();
    hv_TopOffset.Dispose();
    hv_GTLabel.Dispose();
    hv_GTCol1.Dispose();
    hv_GTRow1.Dispose();
    hv_GTCol2.Dispose();
    hv_GTRow2.Dispose();
    hv_LeftOffset.Dispose();
    hv_LabelId.Dispose();
    hv_Col1.Dispose();
    hv_Row1.Dispose();
    hv_Col2.Dispose();
    hv_Row2.Dispose();
    hv_ResClass.Dispose();
    hv_ResConfidence.Dispose();
    hv_ResCol1.Dispose();
    hv_ResRow1.Dispose();
    hv_ResCol2.Dispose();
    hv_ResRow2.Dispose();
    hv_ClassId.Dispose();
    hv_Confidence.Dispose();
    hv_TiledDLSample.Dispose();
    hv_TiledDLResult.Dispose();
    hv_WindowHandleDict.Dispose();
    hv_Flush.Dispose();
    hv_KeyForDisplay.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Display the ground truth bounding boxes of DLSample. 
  public void dev_display_ground_truth_detection (HTuple hv_DLSample, HTuple hv_SampleKeys, 
      HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_BboxColors, HTuple hv_BboxLabelColor, 
      HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_WindowHandle, out HTuple hv_BboxIDs)
  {



    // Local iconic variables 

    HObject ho_BboxRegion=null, ho_RectangleSelected=null;

    // Local control variables 

    HTuple hv_BboxRow1 = new HTuple(), hv_BboxCol1 = new HTuple();
    HTuple hv_BboxRow2 = new HTuple(), hv_BboxCol2 = new HTuple();
    HTuple hv_BboxLabels = new HTuple(), hv_DrawMode = new HTuple();
    HTuple hv_BboxClassIDs = new HTuple(), hv_IndexBbox = new HTuple();
    HTuple hv_ClassID = new HTuple(), hv_TxtColor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_BboxRegion);
    HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
    hv_BboxIDs = new HTuple();
    //
    //This procedure displays the ground truth bounding boxes of DLSample.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_row1"))).TupleNotEqual(-1))) != 0)
    {
      hv_BboxRow1.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BboxRow1);
      hv_BboxCol1.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BboxCol1);
      hv_BboxRow2.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BboxRow2);
      hv_BboxCol2.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BboxCol2);
      hv_BboxLabels.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
    }
    else
    {
      throw new HalconException("Ground truth bounding box data could not be found in DLSample.");
    }
    if ((int)(new HTuple((new HTuple(hv_BboxLabels.TupleLength())).TupleGreater(0))) != 0)
    {
      //Generate bounding box regions. (Convert from pixel centered, subpixel-precise to pixel-precise format).
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_BboxRegion.Dispose();
      HOperatorSet.GenRectangle1(out ho_BboxRegion, hv_BboxRow1+.5, hv_BboxCol1+.5, 
          hv_BboxRow2-.5, hv_BboxCol2-.5);
      }
      //
      hv_DrawMode.Dispose();
      HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
      }
      //
      //Collect the ClassIDs of the bounding boxes.
      hv_BboxIDs.Dispose();
      hv_BboxIDs = new HTuple();
      hv_BboxClassIDs.Dispose();
      hv_BboxClassIDs = new HTuple();
      //
      //Draw the bounding boxes.
      for (hv_IndexBbox=0; (int)hv_IndexBbox<=(int)((new HTuple(hv_BboxRow1.TupleLength()
          ))-1); hv_IndexBbox = (int)hv_IndexBbox + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_RectangleSelected.Dispose();
        HOperatorSet.SelectObj(ho_BboxRegion, out ho_RectangleSelected, hv_IndexBbox+1);
        }
        hv_ClassID.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassID = hv_ClassIDs.TupleFind(
            hv_BboxLabels.TupleSelect(hv_IndexBbox));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BboxClassIDs = hv_BboxClassIDs.TupleConcat(
            hv_ClassID);
        hv_BboxClassIDs.Dispose();
        hv_BboxClassIDs = ExpTmpLocalVar_BboxClassIDs;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BboxIDs = hv_BboxIDs.TupleConcat(
            hv_ClassID);
        hv_BboxIDs.Dispose();
        hv_BboxIDs = ExpTmpLocalVar_BboxIDs;
        }
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
              hv_ClassID))+"60");
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive());
        }
      }
      //
      //Draw text of bounding boxes.
      if ((int)(hv_ShowLabels) != 0)
      {
        //For better visibility the text is displayed after all bounding boxes are drawn.
        for (hv_IndexBbox=0; (int)hv_IndexBbox<=(int)((new HTuple(hv_BboxRow1.TupleLength()
            ))-1); hv_IndexBbox = (int)hv_IndexBbox + 1)
        {
          hv_ClassID.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassID = hv_BboxClassIDs.TupleSelect(
              hv_IndexBbox);
          }
          if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
          {
            hv_TxtColor.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TxtColor = hv_BboxColors.TupleSelect(
                hv_ClassID);
            }
          }
          else
          {
            hv_TxtColor.Dispose();
            hv_TxtColor = new HTuple(hv_TextColor);
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_BboxLabels.TupleSelect(
                hv_IndexBbox), "image", hv_BboxRow1.TupleSelect(hv_IndexBbox), hv_BboxCol1.TupleSelect(
                hv_IndexBbox), hv_TextColor, ((new HTuple("box_color")).TupleConcat(
                "shadow")).TupleConcat("border_radius"), hv_BboxLabelColor.TupleConcat(
                (new HTuple("false")).TupleConcat(0)));
            }
          }
        }
      }
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
      }
    }
    else
    {
      //Do nothing if there are no ground truth bounding boxes.
      hv_BboxIDs.Dispose();
      hv_BboxIDs = new HTuple();
    }
    ho_BboxRegion.Dispose();
    ho_RectangleSelected.Dispose();

    hv_BboxRow1.Dispose();
    hv_BboxCol1.Dispose();
    hv_BboxRow2.Dispose();
    hv_BboxCol2.Dispose();
    hv_BboxLabels.Dispose();
    hv_DrawMode.Dispose();
    hv_BboxClassIDs.Dispose();
    hv_IndexBbox.Dispose();
    hv_ClassID.Dispose();
    hv_TxtColor.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Initialize the visualization of the training progress. 
  public void dev_display_init_train_dl_model (HTuple hv_DLModelHandle, HTuple hv_TrainParam, 
      out HTuple hv_DisplayData)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DisplayParam = new HTuple(), hv_DisplayEnabled = new HTuple();
    HTuple hv_DisplayIntervalSeconds = new HTuple(), hv_Time = new HTuple();
    HTuple hv_WindowWidthText = new HTuple(), hv_WindowHeightText = new HTuple();
    HTuple hv_WindowWidthImagesMax = new HTuple(), hv_WindowHeightImagesMax = new HTuple();
    HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
    HTuple hv_WindowYImages = new HTuple(), hv_WindowXImages = new HTuple();
    HTuple hv_TiledParamDict = new HTuple(), hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    hv_DisplayData = new HTuple();
    //
    //This procedure initializes the visualization of the training progress.
    //
    //Initialize display data.
    hv_DisplayData.Dispose();
    HOperatorSet.CreateDict(out hv_DisplayData);
    hv_DisplayParam.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainParam, "display_param", out hv_DisplayParam);
    HOperatorSet.SetDictTuple(hv_DisplayData, "display_param", hv_DisplayParam);
    hv_DisplayEnabled.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayParam, "enabled", out hv_DisplayEnabled);
    HOperatorSet.SetDictTuple(hv_DisplayData, "enabled", hv_DisplayEnabled);

    //Set last_display in order to display the next iteration.
    hv_DisplayIntervalSeconds.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainParam, "update_interval_seconds", out hv_DisplayIntervalSeconds);
    hv_Time.Dispose();
    HOperatorSet.CountSeconds(out hv_Time);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetDictTuple(hv_DisplayData, "last_update", hv_Time-(hv_DisplayIntervalSeconds*2));
    }

    if ((int)(hv_DisplayEnabled.TupleNot()) != 0)
    {

      hv_DisplayParam.Dispose();
      hv_DisplayEnabled.Dispose();
      hv_DisplayIntervalSeconds.Dispose();
      hv_Time.Dispose();
      hv_WindowWidthText.Dispose();
      hv_WindowHeightText.Dispose();
      hv_WindowWidthImagesMax.Dispose();
      hv_WindowHeightImagesMax.Dispose();
      hv_WindowBGColor.Dispose();
      hv_WindowHandleText.Dispose();
      hv_WindowYImages.Dispose();
      hv_WindowXImages.Dispose();
      hv_TiledParamDict.Dispose();
      hv_Exception.Dispose();

      return;
    }
    //
    hv_WindowWidthText.Dispose();
    hv_WindowWidthText = 700;
    hv_WindowHeightText.Dispose();
    hv_WindowHeightText = 750;
    hv_WindowWidthImagesMax.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowWidthImagesMax = 1200-hv_WindowWidthText;
    }
    hv_WindowHeightImagesMax.Dispose();
    hv_WindowHeightImagesMax = new HTuple(hv_WindowHeightText);
    hv_WindowBGColor.Dispose();
    hv_WindowBGColor = "light gray";
    //
    //Open and setup text window.
    HOperatorSet.SetWindowAttr("background_color",hv_WindowBGColor);
    HOperatorSet.OpenWindow(0,0,hv_WindowWidthText,hv_WindowHeightText,0,"visible","",out hv_WindowHandleText);
    HDevWindowStack.Push(hv_WindowHandleText);
    set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
    HOperatorSet.SetDictTuple(hv_DisplayData, "window_text", hv_WindowHandleText);
    HOperatorSet.SetDictTuple(hv_DisplayData, "window_text_width", hv_WindowWidthText);
    HOperatorSet.SetDictTuple(hv_DisplayData, "window_text_height", hv_WindowHeightText);
    //
    //Configure images window, which is opened later by another procedure.
    hv_WindowYImages.Dispose();
    hv_WindowYImages = 0;
    hv_WindowXImages.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowXImages = hv_WindowWidthText+10;
    }
    HOperatorSet.SetDictTuple(hv_DisplayData, "window_images", new HTuple());
    hv_TiledParamDict.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayParam, "tiled_param", out hv_TiledParamDict);
    //Only set values if they are not already given
    try
    {
      hv_WindowYImages.Dispose();
      HOperatorSet.GetDictTuple(hv_TiledParamDict, "window_row", out hv_WindowYImages);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      HOperatorSet.SetDictTuple(hv_TiledParamDict, "window_row", hv_WindowYImages);
    }
    try
    {
      hv_WindowXImages.Dispose();
      HOperatorSet.GetDictTuple(hv_TiledParamDict, "window_col", out hv_WindowXImages);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      HOperatorSet.SetDictTuple(hv_TiledParamDict, "window_col", hv_WindowXImages);
    }
    try
    {
      hv_WindowWidthImagesMax.Dispose();
      HOperatorSet.GetDictTuple(hv_TiledParamDict, "window_width", out hv_WindowWidthImagesMax);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      HOperatorSet.SetDictTuple(hv_TiledParamDict, "window_width", hv_WindowWidthImagesMax);
    }
    try
    {
      hv_WindowHeightImagesMax.Dispose();
      HOperatorSet.GetDictTuple(hv_TiledParamDict, "window_height", out hv_WindowHeightImagesMax);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      HOperatorSet.SetDictTuple(hv_TiledParamDict, "window_height", hv_WindowHeightImagesMax);
    }
    HOperatorSet.SetDictTuple(hv_DisplayData, "window_images_x", hv_WindowXImages);
    HOperatorSet.SetDictTuple(hv_DisplayData, "window_images_y", hv_WindowYImages);
    HOperatorSet.SetDictTuple(hv_DisplayData, "window_images_genparam", hv_TiledParamDict);

    HOperatorSet.SetDictTuple(hv_DisplayData, "last_change_plot", hv_Time);
    HOperatorSet.SetDictTuple(hv_DisplayData, "plot_eval", 0);
    HDevWindowStack.SetActive(hv_WindowHandleText);


    hv_DisplayParam.Dispose();
    hv_DisplayEnabled.Dispose();
    hv_DisplayIntervalSeconds.Dispose();
    hv_Time.Dispose();
    hv_WindowWidthText.Dispose();
    hv_WindowHeightText.Dispose();
    hv_WindowWidthImagesMax.Dispose();
    hv_WindowHeightImagesMax.Dispose();
    hv_WindowBGColor.Dispose();
    hv_WindowHandleText.Dispose();
    hv_WindowYImages.Dispose();
    hv_WindowXImages.Dispose();
    hv_TiledParamDict.Dispose();
    hv_Exception.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Display a color bar next to an image. 
  public void dev_display_map_color_bar (HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
      HTuple hv_MapColorBarWidth, HTuple hv_Colors, HTuple hv_MaxValue, HTuple hv_WindowImageRatio, 
      HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    HObject ho_Rectangle=null;

    // Local control variables 

    HTuple hv_ClipRegion = new HTuple(), hv_ColorIndex = new HTuple();
    HTuple hv_RectHeight = new HTuple(), hv_DrawMode = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
    HTuple hv__ = new HTuple(), hv_TextHeight = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    //
    //This procedure displays a color bar next to the image
    //specified with ImageWidth and ImageHeight.
    //
    hv_ClipRegion.Dispose();
    HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
    HOperatorSet.SetSystem("clip_region", "false");
    //
    //Display the color bar.
    hv_ColorIndex.Dispose();
    hv_ColorIndex = 0;
    hv_RectHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RectHeight = (1.0*hv_ImageHeight)/(new HTuple(hv_Colors.TupleLength()
        ));
    }
    //Set draw mode to fill
    hv_DrawMode.Dispose();
    HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
    }
    HTuple end_val13 = 0;
    HTuple step_val13 = -hv_RectHeight;
    for (hv_Row=hv_ImageHeight-1; hv_Row.Continue(end_val13, step_val13); hv_Row = hv_Row.TupleAdd(step_val13))
    {
      //The color bar consists of multiple rectangle1.
      hv_Row1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row1 = hv_Row-hv_RectHeight;
      }
      hv_Column1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Column1 = hv_ImageWidth+(20/hv_WindowImageRatio);
      }
      hv_Row2.Dispose();
      hv_Row2 = new HTuple(hv_Row);
      hv_Column2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Column2 = (hv_ImageWidth+20)+(hv_MapColorBarWidth/hv_WindowImageRatio);
      }
      ho_Rectangle.Dispose();
      HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, 
          hv_Column2);
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
            hv_ColorIndex));
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Rectangle, HDevWindowStack.GetActive());
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ColorIndex = hv_ColorIndex+1;
      hv_ColorIndex.Dispose();
      hv_ColorIndex = ExpTmpLocalVar_ColorIndex;
      }
      }
    }
    //
    //Display labels for color bar.
    hv__.Dispose();hv__.Dispose();hv__.Dispose();hv_TextHeight.Dispose();
    HOperatorSet.GetStringExtents(hv_WindowHandle, "0123456789", out hv__, out hv__, 
        out hv__, out hv_TextHeight);
    for (hv_Index=(double)(0); (double)hv_Index<=1; hv_Index = (double)hv_Index + 0.2)
    {
      hv_Text.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Text = ((hv_MaxValue-(hv_Index*hv_MaxValue))).TupleString(
          ".1f");
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image", hv_Index*(hv_ImageHeight-(2*(hv_TextHeight/hv_WindowImageRatio))), 
            hv_ImageWidth+(40/hv_WindowImageRatio), "black", "box", "false");
        }
      }
    }
    //
    HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
    }
    ho_Rectangle.Dispose();

    hv_ClipRegion.Dispose();
    hv_ColorIndex.Dispose();
    hv_RectHeight.Dispose();
    hv_DrawMode.Dispose();
    hv_Row.Dispose();
    hv_Row1.Dispose();
    hv_Column1.Dispose();
    hv_Row2.Dispose();
    hv_Column2.Dispose();
    hv__.Dispose();
    hv_TextHeight.Dispose();
    hv_Index.Dispose();
    hv_Text.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Display a matrix inside a window 
  public void dev_display_matrix (HTuple hv_Matrix, HTuple hv_ColumnNames, HTuple hv_RowNames, 
      HTuple hv_WindowHandle, HTuple hv_GenParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumRows = new HTuple(), hv_NumColumns = new HTuple();
    HTuple hv_DisplayColumnWidth = new HTuple(), hv_DisplayColor = new HTuple();
    HTuple hv_IdxsNoDisplay = new HTuple(), hv_AxisTitles = new HTuple();
    HTuple hv_ValueColors = new HTuple(), hv_NumberFormat = new HTuple();
    HTuple hv_Title = new HTuple(), hv_AxisColor = new HTuple();
    HTuple hv_GenParamKeys = new HTuple(), hv_KeyExists = new HTuple();
    HTuple hv_ValueTmp = new HTuple(), hv_ColStringWidths = new HTuple();
    HTuple hv_AllNames = new HTuple(), hv_MaxStringWidth = new HTuple();
    HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
    HTuple hv_RowStart = new HTuple(), hv_RowDistance = new HTuple();
    HTuple hv_RowEnd = new HTuple(), hv_ColumnStart = new HTuple();
    HTuple hv_ColumnOffset = new HTuple(), hv_ColumnEnd = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_WidthLimit = new HTuple(), hv_HeightLimit = new HTuple();
    HTuple hv_TextRow = new HTuple(), hv_TextColumn = new HTuple();
    HTuple hv_RowStartTmp = new HTuple(), hv_ColumnDistance = new HTuple();
    HTuple hv_Index = new HTuple(), hv_TitleAscent = new HTuple();
    HTuple hv_TitleDescent = new HTuple(), hv_TitleWidth = new HTuple();
    HTuple hv_TitleHeight = new HTuple(), hv_AxisTitleRowX = new HTuple();
    HTuple hv_MatrixText = new HTuple(), hv_IdxsDisplay = new HTuple();
    // Initialize local and output iconic variables 
    //
    //Display a matrix in a window.
    //
    //GenParam (all are optional):
    //  - display_column_width: Either 'equal' or 'minimal'. For 'equal', all columns have the same width
    //                          that equals the width of the longest row or column-name.
    //  - display_color:        If true, the values will be displayed with the colors that are given by
    //                          'value_colors'.
    //                          Else, all values are displayed in white.
    //  - idxs_no_display:      Indices of the matrix that should not be displayed. The indices should be
    //                          given in row-major order, according to get_full_matrix. If not given or if
    //                          set to an empty tuple, all matrix values are displayed.
    //  - axis_titles:          Titles for the matrix x- and y-axis that are displayed at the top-right
    //                          and bottom-left of the matrix, respectively. Should be a tuple of length
    //                          two or an empty tuple if no axis titles should be displayed.
    //  - value_colors:         Tuple containing the hex color-string for each value of the matrix. If a
    //                          single value is given, this color is used for all values, else it must have
    //                          the length of the number of values in the matrix. Is ignored if
    //                          display_color is false.
    //  - number_format:        Format of the numbers when they are converted to strings for display.
    //                          Default: 2.0f
    //  - title:                Title of the displayed matrix, if given shown in the top-left.
    //  - row_col_names_color:  Color of column and row names. Default: 'light gray'
    //
    //
    //Get the matrix dimensions.
    hv_NumRows.Dispose();hv_NumColumns.Dispose();
    HOperatorSet.GetSizeMatrix(hv_Matrix, out hv_NumRows, out hv_NumColumns);
    //Set defaults params.
    hv_DisplayColumnWidth.Dispose();
    hv_DisplayColumnWidth = "equal";
    hv_DisplayColor.Dispose();
    hv_DisplayColor = 0;
    hv_IdxsNoDisplay.Dispose();
    hv_IdxsNoDisplay = new HTuple();
    hv_AxisTitles.Dispose();
    hv_AxisTitles = new HTuple();
    hv_ValueColors.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ValueColors = HTuple.TupleGenConst(
        hv_NumRows*hv_NumColumns,"white");
    }
    hv_NumberFormat.Dispose();
    hv_NumberFormat = "2.0f";
    hv_Title.Dispose();
    hv_Title = new HTuple();
    hv_AxisColor.Dispose();
    hv_AxisColor = "light gray";
    //Get parameters and overwrite
    hv_GenParamKeys.Dispose();
    hv_GenParamKeys = new HTuple();
    hv_GenParamKeys[0] = "display_column_width";
    hv_GenParamKeys[1] = "display_color";
    hv_GenParamKeys[2] = "idxs_no_display";
    hv_GenParamKeys[3] = "axis_titles";
    hv_GenParamKeys[4] = "value_colors";
    hv_GenParamKeys[5] = "number_format";
    hv_GenParamKeys[6] = "title";
    hv_GenParamKeys[7] = "row_col_names_color";
    if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
    {
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, out hv_KeyExists);
      //DisplayColumnWidth.
      if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, "display_column_width", out hv_ValueTmp);
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple((new HTuple(((new HTuple("equal")).TupleConcat(
            "minimal")).TupleFind(hv_ValueTmp))).TupleEqual(-1)))) != 0)
        {
          throw new HalconException("Invalid value for 'display_column_width'");
        }
        else
        {
          hv_DisplayColumnWidth.Dispose();
          hv_DisplayColumnWidth = new HTuple(hv_ValueTmp);
        }
      }
      //DisplayColor.
      if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, "display_color", out hv_ValueTmp);
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
            hv_ValueTmp))).TupleEqual(-1)))) != 0)
        {
          throw new HalconException("Invalid value for 'display_color'");
        }
        else
        {
          hv_DisplayColor.Dispose();
          hv_DisplayColor = new HTuple(hv_ValueTmp);
        }
      }
      //ValueIdxsNoDisplay.
      if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, "idxs_no_display", out hv_ValueTmp);
        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
            0))) != 0)
        {
          if ((int)((new HTuple((new HTuple((new HTuple(((hv_ValueTmp.TupleMin())).TupleLess(
              0))).TupleOr(new HTuple(((hv_ValueTmp.TupleMax())).TupleGreater((hv_NumRows*hv_NumColumns)-1))))).TupleOr(
              ((hv_ValueTmp.TupleIsInt())).TupleNot()))).TupleOr(new HTuple((new HTuple(hv_ValueTmp.TupleLength()
              )).TupleGreater(hv_NumRows*hv_NumColumns)))) != 0)
          {
            throw new HalconException("Invalid value for 'idxs_no_display'");
          }
        }
        hv_IdxsNoDisplay.Dispose();
        hv_IdxsNoDisplay = new HTuple(hv_ValueTmp);
      }
      //AxisTitles.
      if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, "axis_titles", out hv_ValueTmp);
        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
            0))) != 0)
        {
          if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
              2))).TupleOr(new HTuple(((hv_ValueTmp.TupleIsStringElem())).TupleNotEqual(
              HTuple.TupleGenConst(new HTuple(hv_ValueTmp.TupleLength()),1))))) != 0)
          {
            throw new HalconException("Invalid value for 'axis_titles'");
          }
        }
        hv_AxisTitles.Dispose();
        hv_AxisTitles = new HTuple(hv_ValueTmp);
      }
      //ValueColors.
      if ((int)(((hv_KeyExists.TupleSelect(4))).TupleAnd(hv_DisplayColor)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, "value_colors", out hv_ValueTmp);
        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
            0))) != 0)
        {
          if ((int)((new HTuple((new HTuple((new HTuple(hv_ValueTmp.TupleLength()
              )).TupleNotEqual(hv_NumColumns*hv_NumRows))).TupleAnd(new HTuple((new HTuple(hv_ValueTmp.TupleLength()
              )).TupleNotEqual(1))))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot()
              )) != 0)
          {
            throw new HalconException("Invalid value for 'value_colors'");
          }
          if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleEqual(
              1))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ValueTmp = HTuple.TupleGenConst(
                hv_NumRows*hv_NumColumns,hv_ValueTmp);
            hv_ValueTmp.Dispose();
            hv_ValueTmp = ExpTmpLocalVar_ValueTmp;
            }
            }
          }
        }
        hv_ValueColors.Dispose();
        hv_ValueColors = new HTuple(hv_ValueTmp);
      }
      //NumberFormat.
      if ((int)(hv_KeyExists.TupleSelect(5)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, "number_format", out hv_ValueTmp);
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
        {
          throw new HalconException("Invalid value for 'number_format'");
        }
        else
        {
          hv_NumberFormat.Dispose();
          hv_NumberFormat = new HTuple(hv_ValueTmp);
        }
      }
      //Title.
      if ((int)(hv_KeyExists.TupleSelect(6)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, "title", out hv_ValueTmp);
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
        {
          throw new HalconException("Invalid value for 'title'");
        }
        else
        {
          hv_Title.Dispose();
          hv_Title = new HTuple(hv_ValueTmp);
        }
      }
      //Color of column and row names.
      if ((int)(hv_KeyExists.TupleSelect(7)) != 0)
      {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, "row_col_names_color", out hv_ValueTmp);
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
        {
          throw new HalconException("Invalid value for 'row_col_names_color'");
        }
        else
        {
          hv_AxisColor.Dispose();
          hv_AxisColor = new HTuple(hv_ValueTmp);
        }
      }
    }
    //
    //
    //Calculate the width of row and column-name-strings.
    hv_ColStringWidths.Dispose();
    hv_ColStringWidths = new HTuple();
    hv_AllNames.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_AllNames = new HTuple();
    hv_AllNames = hv_AllNames.TupleConcat(hv_ColumnNames, hv_RowNames);
    }
    hv_MaxStringWidth.Dispose();
    hv_MaxStringWidth = 0;
    for (hv_StringIndex=0; (int)hv_StringIndex<=(int)((new HTuple(hv_AllNames.TupleLength()
        ))-1); hv_StringIndex = (int)hv_StringIndex + 1)
    {
      hv_String.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_String = hv_AllNames.TupleSelect(
          hv_StringIndex);
      }
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_StringWidth.Dispose();hv_StringHeight.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent, out hv_Descent, 
          out hv_StringWidth, out hv_StringHeight);
      if ((int)(new HTuple(hv_StringIndex.TupleLess(new HTuple(hv_ColumnNames.TupleLength()
          )))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ColStringWidths = hv_ColStringWidths.TupleConcat(
            hv_StringWidth);
        hv_ColStringWidths.Dispose();
        hv_ColStringWidths = ExpTmpLocalVar_ColStringWidths;
        }
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
          hv_StringWidth);
      hv_MaxStringWidth.Dispose();
      hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
      }
      }
    }
    //The columns should have a minimum width for 4 characters.
    hv_Ascent.Dispose();hv_Descent.Dispose();hv_StringWidth.Dispose();hv_StringHeight.Dispose();
    HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent, 
        out hv_StringWidth, out hv_StringHeight);
    //Update the maximum string width.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
        hv_StringWidth);
    hv_MaxStringWidth.Dispose();
    hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
    }
    }
    //
    //Set params for nice display, e.g. distances from window border and row- and column-offsets.
    hv_RowStart.Dispose();
    hv_RowStart = 80;
    hv_RowDistance.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RowDistance = hv_StringHeight+10;
    }
    hv_RowEnd.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RowEnd = hv_StringHeight*7;
    }
    hv_ColumnStart.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColumnStart = 50+hv_MaxStringWidth;
    }
    hv_ColumnOffset.Dispose();
    hv_ColumnOffset = 30;
    hv_ColumnEnd.Dispose();
    hv_ColumnEnd = new HTuple(hv_ColumnOffset);
    //
    //Adapt the window size to fit the confusion matrix.
    if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
    {
      //Every column of the confusion matrix is as narrow as possible
      //based to the respective string widths.
      hv_Width.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Width = (((hv_ColStringWidths.TupleSum()
          )+(hv_ColumnOffset*hv_NumColumns))+hv_ColumnStart)+hv_ColumnEnd;
      }
    }
    else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
    {
      //Every column of the confusion matrix should have the same width.
      //based on the maximum string width.
      hv_Width.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Width = (((hv_MaxStringWidth+hv_ColumnOffset)*hv_NumColumns)+hv_ColumnStart)+hv_ColumnEnd;
      }
    }
    hv_Height.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Height = ((hv_RowDistance*hv_NumRows)+hv_RowStart)+hv_RowEnd;
    }
    HDevWindowStack.SetActive(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
    }
    //
    //Set reasonable limits for graphics window (adapt if necessary).
    hv_WidthLimit.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WidthLimit = new HTuple();
    hv_WidthLimit[0] = 450;
    hv_WidthLimit = hv_WidthLimit.TupleConcat(hv_Width);
    }
    hv_HeightLimit.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HeightLimit = new HTuple();
    hv_HeightLimit[0] = 250;
    hv_HeightLimit = hv_HeightLimit.TupleConcat(hv_Height);
    }
    dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
    //
    //
    //Calculate row and column coordinates for display of values.
    hv_TextRow.Dispose();
    hv_TextRow = new HTuple();
    hv_TextColumn.Dispose();
    hv_TextColumn = new HTuple();
    hv_RowStartTmp.Dispose();
    hv_RowStartTmp = 0;
    hv_ColumnDistance.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColumnDistance = new HTuple();
    hv_ColumnDistance[0] = 0;
    hv_ColumnDistance = hv_ColumnDistance.TupleConcat((((hv_ColStringWidths.TupleSelectRange(
        0,hv_NumColumns-2))+hv_ColumnOffset)).TupleCumul());
    }
    if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
    {
      hv_ColumnDistance.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColumnDistance = HTuple.TupleGenSequence(
          0,hv_NumColumns-1,1)*(hv_MaxStringWidth+hv_ColumnOffset);
      }
    }
    HTuple end_val174 = hv_NumRows-1;
    HTuple step_val174 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val174, step_val174); hv_Index = hv_Index.TupleAdd(step_val174))
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
          HTuple.TupleGenConst(hv_NumColumns,hv_RowStartTmp));
      hv_TextRow.Dispose();
      hv_TextRow = ExpTmpLocalVar_TextRow;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_RowStartTmp = hv_RowStartTmp+hv_RowDistance;
      hv_RowStartTmp.Dispose();
      hv_RowStartTmp = ExpTmpLocalVar_RowStartTmp;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
          hv_ColumnDistance);
      hv_TextColumn.Dispose();
      hv_TextColumn = ExpTmpLocalVar_TextColumn;
      }
      }
    }
    //Display the confusion matrix with a margin from the top and left.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_TextColumn = hv_TextColumn+hv_ColumnStart;
    hv_TextColumn.Dispose();
    hv_TextColumn = ExpTmpLocalVar_TextColumn;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_TextRow = hv_TextRow+hv_RowStart;
    hv_TextRow.Dispose();
    hv_TextRow = ExpTmpLocalVar_TextRow;
    }
    }
    //
    //Display axis titles.
    if ((int)(new HTuple((new HTuple(hv_AxisTitles.TupleLength())).TupleGreater(0))) != 0)
    {
      if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
      {
        hv_TitleAscent.Dispose();hv_TitleDescent.Dispose();hv_TitleWidth.Dispose();hv_TitleHeight.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_TitleAscent, 
            out hv_TitleDescent, out hv_TitleWidth, out hv_TitleHeight);
        hv_AxisTitleRowX.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AxisTitleRowX = 2*(hv_TitleHeight.TupleCeil()
            );
        }
      }
      else
      {
        hv_AxisTitleRowX.Dispose();
        hv_AxisTitleRowX = "top";
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
            0), "window", hv_AxisTitleRowX, "right", "white", "box", "false");
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
            1), "window", "bottom", "left", "white", "box", "false");
        }
      }
    }
    //
    //Display title.
    if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
    {
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "window", "top", 
            "left", "white", "box", "false");
      }
    }
    //
    //Display row names.
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_RowNames, "window", hv_TextRow.TupleSelect(
          HTuple.TupleGenSequence(0,hv_NumColumns*(hv_NumRows-1),hv_NumColumns)), 
          HTuple.TupleGenConst(hv_NumRows,((hv_TextColumn.TupleSelect(0))-hv_MaxStringWidth)-hv_ColumnOffset), 
          hv_AxisColor, "box", "false");
      }
    }
    //
    //Display column names.
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ColumnNames, "window", 
          HTuple.TupleGenConst(hv_NumColumns,(hv_TextRow.TupleSelect(0))-hv_RowDistance), 
          hv_TextColumn.TupleSelectRange(0,hv_NumColumns-1), hv_AxisColor, "box", 
          "false");
      }
    }
    //
    //
    //Align the numbers right.
    hv_MatrixText.Dispose();
    HOperatorSet.GetFullMatrix(hv_Matrix, out hv_MatrixText);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
        hv_NumberFormat);
    hv_MatrixText.Dispose();
    hv_MatrixText = ExpTmpLocalVar_MatrixText;
    }
    }
    //
    //
    //Handle no-display indices.
    hv_IdxsDisplay.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IdxsDisplay = (HTuple.TupleGenSequence(
        0,(new HTuple(hv_MatrixText.TupleLength()))-1,1)).TupleDifference(hv_IdxsNoDisplay);
    }
    //
    //Display confusion matrix.
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText.TupleSelect(
          hv_IdxsDisplay), "window", hv_TextRow.TupleSelect(hv_IdxsDisplay), hv_TextColumn.TupleSelect(
          hv_IdxsDisplay), hv_ValueColors.TupleSelect(hv_IdxsDisplay), "box", "false");
      }
    }

    hv_NumRows.Dispose();
    hv_NumColumns.Dispose();
    hv_DisplayColumnWidth.Dispose();
    hv_DisplayColor.Dispose();
    hv_IdxsNoDisplay.Dispose();
    hv_AxisTitles.Dispose();
    hv_ValueColors.Dispose();
    hv_NumberFormat.Dispose();
    hv_Title.Dispose();
    hv_AxisColor.Dispose();
    hv_GenParamKeys.Dispose();
    hv_KeyExists.Dispose();
    hv_ValueTmp.Dispose();
    hv_ColStringWidths.Dispose();
    hv_AllNames.Dispose();
    hv_MaxStringWidth.Dispose();
    hv_StringIndex.Dispose();
    hv_String.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_StringWidth.Dispose();
    hv_StringHeight.Dispose();
    hv_RowStart.Dispose();
    hv_RowDistance.Dispose();
    hv_RowEnd.Dispose();
    hv_ColumnStart.Dispose();
    hv_ColumnOffset.Dispose();
    hv_ColumnEnd.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_WidthLimit.Dispose();
    hv_HeightLimit.Dispose();
    hv_TextRow.Dispose();
    hv_TextColumn.Dispose();
    hv_RowStartTmp.Dispose();
    hv_ColumnDistance.Dispose();
    hv_Index.Dispose();
    hv_TitleAscent.Dispose();
    hv_TitleDescent.Dispose();
    hv_TitleWidth.Dispose();
    hv_TitleHeight.Dispose();
    hv_AxisTitleRowX.Dispose();
    hv_MatrixText.Dispose();
    hv_IdxsDisplay.Dispose();

    return;
  }

  // Chapter: Matching / Correlation-Based
  // Short Description: Display the results of Correlation-Based Matching. 
  public void dev_display_ncc_matching_results (HTuple hv_ModelID, HTuple hv_Color, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Angle, HTuple hv_Model)
  {



        // Local iconic variables 

        HObject ho_ModelRegion=null, ho_ModelContours=null;
        HObject ho_ContoursAffinTrans=null, ho_Cross=null;

        // Local control variables 

        HTuple hv_NumMatches = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Match = new HTuple(), hv_HomMat2DIdentity = new HTuple();
        HTuple hv_HomMat2DRotate = new HTuple(), hv_HomMat2DTranslate = new HTuple();
        HTuple hv_RowTrans = new HTuple(), hv_ColTrans = new HTuple();
        HTuple   hv_Model_COPY_INP_TMP = new HTuple(hv_Model);

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ModelRegion);
        HOperatorSet.GenEmptyObj(out ho_ModelContours);
        HOperatorSet.GenEmptyObj(out ho_ContoursAffinTrans);
        HOperatorSet.GenEmptyObj(out ho_Cross);
    //This procedure displays the results of Correlation-Based Matching.
    //
    hv_NumMatches.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumMatches = new HTuple(hv_Row.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumMatches.TupleGreater(0))) != 0)
    {
      if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength())).TupleEqual(
          0))) != 0)
      {
        hv_Model_COPY_INP_TMP.Dispose();
        HOperatorSet.TupleGenConst(hv_NumMatches, 0, out hv_Model_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength()
          )).TupleEqual(1))) != 0)
      {
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleGenConst(hv_NumMatches, hv_Model_COPY_INP_TMP, out ExpTmpOutVar_0);
        hv_Model_COPY_INP_TMP.Dispose();
        hv_Model_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ModelID.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ModelRegion.Dispose();
        HOperatorSet.GetNccModelRegion(out ho_ModelRegion, hv_ModelID.TupleSelect(
            hv_Index));
        }
        ho_ModelContours.Dispose();
        HOperatorSet.GenContourRegionXld(ho_ModelRegion, out ho_ModelContours, "border_holes");
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
              hv_Index%(new HTuple(hv_Color.TupleLength()))));
          }
        }
        HTuple end_val13 = hv_NumMatches-1;
        HTuple step_val13 = 1;
        for (hv_Match=0; hv_Match.Continue(end_val13, step_val13); hv_Match = hv_Match.TupleAdd(step_val13))
        {
          if ((int)(new HTuple(hv_Index.TupleEqual(hv_Model_COPY_INP_TMP.TupleSelect(
              hv_Match)))) != 0)
          {
            hv_HomMat2DIdentity.Dispose();
            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HomMat2DRotate.Dispose();
            HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, hv_Angle.TupleSelect(
                hv_Match), 0, 0, out hv_HomMat2DRotate);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HomMat2DTranslate.Dispose();
            HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_Row.TupleSelect(
                hv_Match), hv_Column.TupleSelect(hv_Match), out hv_HomMat2DTranslate);
            }
            ho_ContoursAffinTrans.Dispose();
            HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_ContoursAffinTrans, 
                hv_HomMat2DTranslate);
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ContoursAffinTrans, HDevWindowStack.GetActive()
                  );
            }
            hv_RowTrans.Dispose();hv_ColTrans.Dispose();
            HOperatorSet.AffineTransPixel(hv_HomMat2DTranslate, 0, 0, out hv_RowTrans, 
                out hv_ColTrans);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Cross.Dispose();
            HOperatorSet.GenCrossContourXld(out ho_Cross, hv_RowTrans, hv_ColTrans, 
                6, hv_Angle.TupleSelect(hv_Match));
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
            }
          }
        }
      }
    }
    ho_ModelRegion.Dispose();
    ho_ModelContours.Dispose();
    ho_ContoursAffinTrans.Dispose();
    ho_Cross.Dispose();

    hv_Model_COPY_INP_TMP.Dispose();
    hv_NumMatches.Dispose();
    hv_Index.Dispose();
    hv_Match.Dispose();
    hv_HomMat2DIdentity.Dispose();
    hv_HomMat2DRotate.Dispose();
    hv_HomMat2DTranslate.Dispose();
    hv_RowTrans.Dispose();
    hv_ColTrans.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Draw a pie chart into the active window handle. 
  public void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
      HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Sectors, ho_Sector=null;

    // Local control variables 

    HTuple hv_Title = new HTuple(), hv_TitleColor = new HTuple();
    HTuple hv_GenParamKeys = new HTuple(), hv_KeyExists = new HTuple();
    HTuple hv_Value = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_FullCircleAngle = new HTuple(), hv_StartAngle = new HTuple();
    HTuple hv_K = new HTuple(), hv_EndAngle = new HTuple();
    HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DRotate = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple   hv_Colors_COPY_INP_TMP = new HTuple(hv_Colors);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Sectors);
    HOperatorSet.GenEmptyObj(out ho_Sector);
    //
    //Draw a pie-chart into the active window.
    //
    if ((int)(new HTuple((new HTuple(hv_Colors_COPY_INP_TMP.TupleLength())).TupleEqual(
        0))) != 0)
    {
      //Generate random colors.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Colors_COPY_INP_TMP.Dispose();
      get_distinct_colors(new HTuple(hv_Ratios.TupleLength()), 1, 0, 220, out hv_Colors_COPY_INP_TMP);
      }
    }
    //
    //Set default parameters.
    hv_Title.Dispose();
    hv_Title = new HTuple();
    hv_TitleColor.Dispose();
    hv_TitleColor = "white";
    //Get generic parameters.
    if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
    {
      hv_GenParamKeys.Dispose();
      hv_GenParamKeys = new HTuple();
      hv_GenParamKeys[0] = "title";
      hv_GenParamKeys[1] = "title_color";
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, out hv_KeyExists);
      //
      //Title.
      if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(0), out hv_Value);
        }
        if ((int)((new HTuple(((hv_Value.TupleIsString())).TupleNot())).TupleOr(new HTuple(((hv_Value.TupleStrlen()
            )).TupleLess(1)))) != 0)
        {
          throw new HalconException("Invalid value for key 'title'");
        }
        hv_Title.Dispose();
        hv_Title = new HTuple(hv_Value);
      }
      //Title.
      if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(1), out hv_Value);
        }
        if ((int)(((hv_Value.TupleIsString())).TupleNot()) != 0)
        {
          throw new HalconException("Invalid value for key 'title_color'");
        }
        try
        {
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Value);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          throw new HalconException("Invalid value for key 'title_color'");
        }
        hv_TitleColor.Dispose();
        hv_TitleColor = new HTuple(hv_Value);
      }
    }
    hv_FullCircleAngle.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_FullCircleAngle = 2*3.14159;
    }
    hv_StartAngle.Dispose();
    hv_StartAngle = 0;
    //Generate circle-sectors.
    ho_Sectors.Dispose();
    HOperatorSet.GenEmptyObj(out ho_Sectors);
    for (hv_K=0; (int)hv_K<=(int)((new HTuple(hv_Ratios.TupleLength()))-1); hv_K = (int)hv_K + 1)
    {
      if ((int)(new HTuple(((hv_Ratios.TupleSelect(hv_K))).TupleGreater(0))) != 0)
      {
        hv_EndAngle.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_EndAngle = hv_StartAngle+((hv_Ratios.TupleSelect(
            hv_K))*hv_FullCircleAngle);
        }
        ho_Sector.Dispose();
        HOperatorSet.GenCircleSector(out ho_Sector, hv_Row, hv_Column, hv_Radius, 
            hv_StartAngle, hv_EndAngle);
        hv_StartAngle.Dispose();
        hv_StartAngle = new HTuple(hv_EndAngle);
      }
      else
      {
        ho_Sector.Dispose();
        HOperatorSet.GenEmptyRegion(out ho_Sector);
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_Sectors, ho_Sector, out ExpTmpOutVar_0);
      ho_Sectors.Dispose();
      ho_Sectors = ExpTmpOutVar_0;
      }
    }
    //Rotate 90 degrees such that the first sector starts at the top.
    hv_HomMat2DIdentity.Dispose();
    HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HomMat2DRotate.Dispose();
    HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, 0.25*hv_FullCircleAngle, hv_Row, 
        hv_Column, out hv_HomMat2DRotate);
    }
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.AffineTransRegion(ho_Sectors, out ExpTmpOutVar_0, hv_HomMat2DRotate, 
        "nearest_neighbor");
    ho_Sectors.Dispose();
    ho_Sectors = ExpTmpOutVar_0;
    }
    //
    //Display sectors.
    HDevWindowStack.SetActive(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors_COPY_INP_TMP);
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_Sectors, HDevWindowStack.GetActive());
    }
    //(Optional) title.
    if ((int)(new HTuple(hv_Title.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_Ascent, out hv_Descent, 
          out hv_Width, out hv_Height);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_TitleColor);
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "image", (((hv_Row-hv_Radius)-hv_Height)-hv_Ascent)-hv_Descent, 
            hv_Column-(hv_Width/2), "white", "box", "false");
        }
      }
    }
    //
    ho_Sectors.Dispose();
    ho_Sector.Dispose();

    hv_Colors_COPY_INP_TMP.Dispose();
    hv_Title.Dispose();
    hv_TitleColor.Dispose();
    hv_GenParamKeys.Dispose();
    hv_KeyExists.Dispose();
    hv_Value.Dispose();
    hv_Exception.Dispose();
    hv_FullCircleAngle.Dispose();
    hv_StartAngle.Dispose();
    hv_K.Dispose();
    hv_EndAngle.Dispose();
    hv_HomMat2DIdentity.Dispose();
    hv_HomMat2DRotate.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Display the confusion matrix given by ConfusionMatrix. 
  public void dev_display_pixel_confusion_matrix (HTuple hv_ConfusionMatrix, HTuple hv_ClassNames, 
      HTuple hv_GenParam, HTuple hv_WindowHandles)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DisplayAbsoluteMatrix = new HTuple();
    HTuple hv_DisplayRelativeMatrix = new HTuple(), hv_DisplayColor = new HTuple();
    HTuple hv_DisplayColumnWidth = new HTuple(), hv_RowColNameColor = new HTuple();
    HTuple hv_GenParamKeys = new HTuple(), hv_KeyExists = new HTuple();
    HTuple hv_ValueTmp = new HTuple(), hv_DisplayColumnWidthTmp = new HTuple();
    HTuple hv_NumRows = new HTuple(), hv_NumColumns = new HTuple();
    HTuple hv_Values = new HTuple(), hv_ConfusionMatrixRelative = new HTuple();
    HTuple hv_C = new HTuple(), hv_RowValues = new HTuple();
    HTuple hv_ValueColors = new HTuple(), hv_DiagonalColor = new HTuple();
    HTuple hv_Seq = new HTuple(), hv_DiagonalIndices = new HTuple();
    HTuple hv_GenParamDisplay = new HTuple(), hv_MatrixMaxID = new HTuple();
    HTuple hv_MaxValue = new HTuple(), hv_NumberFormat = new HTuple();
    HTuple hv_ValuesRelative = new HTuple();
    // Initialize local and output iconic variables 
    //
    //This procedure displays the confusion matrix given by ConfusionMatrix.
    //Thereby, the matrix can be displayed with absolute or
    //relative values.
    //
    //Set the default values for generic parameters.
    hv_DisplayAbsoluteMatrix.Dispose();
    hv_DisplayAbsoluteMatrix = 1;
    hv_DisplayRelativeMatrix.Dispose();
    hv_DisplayRelativeMatrix = 0;
    hv_DisplayColor.Dispose();
    hv_DisplayColor = 1;
    hv_DisplayColumnWidth.Dispose();
    hv_DisplayColumnWidth = "equal";
    hv_RowColNameColor.Dispose();
    hv_RowColNameColor = "light gray";
    //
    //Parse generic parameters.
    if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
    {
      hv_GenParamKeys.Dispose();
      hv_GenParamKeys = new HTuple();
      hv_GenParamKeys[0] = "display_color";
      hv_GenParamKeys[1] = "display_relative_matrix";
      hv_GenParamKeys[2] = "display_absolute_matrix";
      hv_GenParamKeys[3] = "display_column_width";
      hv_GenParamKeys[4] = "row_col_names_color";
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, out hv_KeyExists);
      //DisplayColor
      if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(0), out hv_ValueTmp);
        }
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
            hv_ValueTmp))).TupleEqual(-1)))) != 0)
        {
          throw new HalconException("Invalid value for 'display_color'");
        }
        else
        {
          hv_DisplayColor.Dispose();
          hv_DisplayColor = new HTuple(hv_ValueTmp);
        }
      }
      //DisplayRelativeMatrix.
      if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(1), out hv_ValueTmp);
        }
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
            hv_ValueTmp))).TupleEqual(-1)))) != 0)
        {
          throw new HalconException("Invalid value for 'display_relative_matrix'");
        }
        else
        {
          hv_DisplayRelativeMatrix.Dispose();
          hv_DisplayRelativeMatrix = new HTuple(hv_ValueTmp);
        }
      }
      //DisplayAbsoluteMatrix.
      if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(2), out hv_ValueTmp);
        }
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
            hv_ValueTmp))).TupleEqual(-1)))) != 0)
        {
          throw new HalconException("Invalid value for 'display_absolute_matrix'");
        }
        else
        {
          hv_DisplayAbsoluteMatrix.Dispose();
          hv_DisplayAbsoluteMatrix = new HTuple(hv_ValueTmp);
        }
      }
      //DisplayColumnWidth.
      if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DisplayColumnWidthTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(3), out hv_DisplayColumnWidthTmp);
        }
        if ((int)((new HTuple((new HTuple(hv_DisplayColumnWidthTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple((new HTuple(((new HTuple("equal")).TupleConcat(
            "minimal")).TupleFind(hv_DisplayColumnWidthTmp))).TupleEqual(-1)))) != 0)
        {
          throw new HalconException("Invalid value for 'display_column_width'");
        }
        else
        {
          hv_DisplayColumnWidth.Dispose();
          hv_DisplayColumnWidth = new HTuple(hv_DisplayColumnWidthTmp);
        }
      }
      //Color for row and column names.
      if ((int)(hv_KeyExists.TupleSelect(4)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ValueTmp.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(4), out hv_ValueTmp);
        }
        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
        {
          throw new HalconException("Invalid value for 'row_col_names_color'");
        }
        hv_RowColNameColor.Dispose();
        hv_RowColNameColor = new HTuple(hv_ValueTmp);
      }
    }
    //
    if ((int)((new HTuple(hv_DisplayRelativeMatrix.TupleOr(hv_DisplayAbsoluteMatrix))).TupleNot()
        ) != 0)
    {
      throw new HalconException("At least one of 'display_absolute_matrix' and 'display_relative_matrix' should be true");
    }
    if ((int)(new HTuple(((hv_DisplayRelativeMatrix+hv_DisplayAbsoluteMatrix)).TupleNotEqual(
        new HTuple(hv_WindowHandles.TupleLength())))) != 0)
    {
      throw new HalconException("Wrong number of WindowHandles");
    }
    //
    //Calculate the confusion matrix with absolute values
    //and the confusion matrix with relative errors.
    hv_NumRows.Dispose();hv_NumColumns.Dispose();
    HOperatorSet.GetSizeMatrix(hv_ConfusionMatrix, out hv_NumRows, out hv_NumColumns);
    hv_Values.Dispose();
    HOperatorSet.GetFullMatrix(hv_ConfusionMatrix, out hv_Values);
    //
    if ((int)(hv_DisplayRelativeMatrix) != 0)
    {
      //Calculate relative matrix for display and in order to set colors correctly.
      hv_ConfusionMatrixRelative.Dispose();
      HOperatorSet.CopyMatrix(hv_ConfusionMatrix, out hv_ConfusionMatrixRelative);
      //For each class:
      for (hv_C=0; (int)hv_C<=(int)((new HTuple(hv_ClassNames.TupleLength()))-1); hv_C = (int)hv_C + 1)
      {
        //Get the total number of predictions and calculate the relative values.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RowValues.Dispose();
        HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, HTuple.TupleGenConst(hv_NumColumns,
            hv_C), HTuple.TupleGenSequence(0,hv_NumColumns-1,1), out hv_RowValues);
        }
        if ((int)(new HTuple(((hv_RowValues.TupleSum())).TupleGreater(0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ConfusionMatrixRelative, HTuple.TupleGenConst(
              hv_NumColumns,hv_C), HTuple.TupleGenSequence(0,hv_NumColumns-1,1), 
              (hv_RowValues.TupleReal())/(hv_RowValues.TupleSum()));
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ConfusionMatrixRelative, HTuple.TupleGenConst(
              hv_NumColumns,hv_C), HTuple.TupleGenSequence(0,hv_NumColumns-1,1), 
              hv_RowValues.TupleReal());
          }
        }
      }
    }
    //
    //Set color for displayed confusion matrix.
    hv_ValueColors.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ValueColors = HTuple.TupleGenConst(
        new HTuple(hv_Values.TupleLength()),"#666666");
    }
    if ((int)(hv_DisplayColor) != 0)
    {
      //Display off-diagonal values in red.
      hv_ValueColors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ValueColors = HTuple.TupleGenConst(
          new HTuple(hv_Values.TupleLength()),"#ff4500");
      }
      //Display diagonal values in green.
      hv_DiagonalColor.Dispose();
      hv_DiagonalColor = "#00ff00";
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Seq.Dispose();
      HOperatorSet.TupleGenSequence(0, hv_NumColumns-1, 1, out hv_Seq);
      }
      hv_DiagonalIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DiagonalIndices = (hv_NumColumns*hv_Seq)+hv_Seq;
      }
      if (hv_ValueColors == null)
        hv_ValueColors = new HTuple();
      hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
    }
    //
    //Display the matrix.
    //
    //Create GenParam for matrix display.
    hv_GenParamDisplay.Dispose();
    HOperatorSet.CreateDict(out hv_GenParamDisplay);
    HOperatorSet.SetDictTuple(hv_GenParamDisplay, "display_column_width", hv_DisplayColumnWidth);
    HOperatorSet.SetDictTuple(hv_GenParamDisplay, "display_color", hv_DisplayColor);
    HOperatorSet.SetDictTuple(hv_GenParamDisplay, "axis_titles", (new HTuple("Ground truth")).TupleConcat(
        "Predicted"));
    HOperatorSet.SetDictTuple(hv_GenParamDisplay, "value_colors", hv_ValueColors);
    HOperatorSet.SetDictTuple(hv_GenParamDisplay, "row_col_names_color", hv_RowColNameColor);
    if ((int)(hv_DisplayAbsoluteMatrix) != 0)
    {
      //Display absolute matrix.
      //Calculate proper number format.
      hv_MatrixMaxID.Dispose();
      HOperatorSet.MaxMatrix(hv_ConfusionMatrix, "full", out hv_MatrixMaxID);
      hv_MaxValue.Dispose();
      HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
      if ((int)(new HTuple(hv_MaxValue.TupleGreater(0))) != 0)
      {
        hv_NumberFormat.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumberFormat = (((((hv_MaxValue.TupleLog10()
            )).TupleCeil())).TupleInt())+".0f";
        }
      }
      else
      {
        hv_NumberFormat.Dispose();
        hv_NumberFormat = "1.0f";
      }
      HOperatorSet.SetDictTuple(hv_GenParamDisplay, "number_format", hv_NumberFormat);
      //Set title.
      HOperatorSet.SetDictTuple(hv_GenParamDisplay, "title", new HTuple("Pixel confusion matrix, absolute"));
      //Display the matrix.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      dev_display_matrix(hv_ConfusionMatrix, hv_ClassNames, hv_ClassNames, hv_WindowHandles.TupleSelect(
          0), hv_GenParamDisplay);
      }
    }
    //
    if ((int)(hv_DisplayRelativeMatrix) != 0)
    {
      //Display relative matrix.
      //Convert relative matrix values to percent.
      hv_ValuesRelative.Dispose();
      HOperatorSet.GetFullMatrix(hv_ConfusionMatrixRelative, out hv_ValuesRelative);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetFullMatrix(hv_ConfusionMatrixRelative, 100*hv_ValuesRelative);
      }
      //Set number format.
      hv_NumberFormat.Dispose();
      hv_NumberFormat = "2.1f";
      HOperatorSet.SetDictTuple(hv_GenParamDisplay, "number_format", hv_NumberFormat);
      //Set title.
      HOperatorSet.SetDictTuple(hv_GenParamDisplay, "title", new HTuple("Pixel confusion matrix, relative [%]"));
      //Display the matrix.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      dev_display_matrix(hv_ConfusionMatrixRelative, hv_ClassNames, hv_ClassNames, 
          hv_WindowHandles.TupleSelect(hv_DisplayAbsoluteMatrix), hv_GenParamDisplay);
      }
    }


    hv_DisplayAbsoluteMatrix.Dispose();
    hv_DisplayRelativeMatrix.Dispose();
    hv_DisplayColor.Dispose();
    hv_DisplayColumnWidth.Dispose();
    hv_RowColNameColor.Dispose();
    hv_GenParamKeys.Dispose();
    hv_KeyExists.Dispose();
    hv_ValueTmp.Dispose();
    hv_DisplayColumnWidthTmp.Dispose();
    hv_NumRows.Dispose();
    hv_NumColumns.Dispose();
    hv_Values.Dispose();
    hv_ConfusionMatrixRelative.Dispose();
    hv_C.Dispose();
    hv_RowValues.Dispose();
    hv_ValueColors.Dispose();
    hv_DiagonalColor.Dispose();
    hv_Seq.Dispose();
    hv_DiagonalIndices.Dispose();
    hv_GenParamDisplay.Dispose();
    hv_MatrixMaxID.Dispose();
    hv_MaxValue.Dispose();
    hv_NumberFormat.Dispose();
    hv_ValuesRelative.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Display result bounding boxes. 
  public void dev_display_result_detection (HTuple hv_DLResult, HTuple hv_ResultKeys, 
      HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_TextConf, HTuple hv_Colors, 
      HTuple hv_BoxLabelColor, HTuple hv_WindowImageRatio, HTuple hv_TextPositionRow, 
      HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_WindowHandle, out HTuple hv_BboxIDs)
  {



    // Local iconic variables 

    HObject ho_Rectangle=null, ho_RectangleSelected=null;

    // Local control variables 

    HTuple hv_BboxRow1 = new HTuple(), hv_BboxCol1 = new HTuple();
    HTuple hv_BboxRow2 = new HTuple(), hv_BboxCol2 = new HTuple();
    HTuple hv_BboxClasses = new HTuple(), hv_DrawMode = new HTuple();
    HTuple hv_Style = new HTuple(), hv_BboxClassIDs = new HTuple();
    HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
    HTuple hv_LineWidth = new HTuple(), hv_Text = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv__ = new HTuple(), hv_TextRow = new HTuple();
    HTuple hv_TxtColor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
    hv_BboxIDs = new HTuple();
    //
    //This procedure displays the bounding boxes defined by DLResult.
    //The ClassIDs are necessary to display bounding boxes from the same class
    //always with the same color.
    //
    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_class_id"))).TupleNotEqual(
        -1))) != 0)
    {
      hv_BboxRow1.Dispose();
      HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row1", out hv_BboxRow1);
      hv_BboxCol1.Dispose();
      HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col1", out hv_BboxCol1);
      hv_BboxRow2.Dispose();
      HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row2", out hv_BboxRow2);
      hv_BboxCol2.Dispose();
      HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col2", out hv_BboxCol2);
      hv_BboxClasses.Dispose();
      HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
    }
    else
    {
      throw new HalconException("Result bounding box data could not be found in DLResult.");
    }
    if ((int)(new HTuple((new HTuple(hv_BboxClasses.TupleLength())).TupleGreater(
        0))) != 0)
    {
      //Generate bbox regions. (Convert from XLD to pixel-precise format).
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_Rectangle.Dispose();
      HOperatorSet.GenRectangle1(out ho_Rectangle, hv_BboxRow1+.5, hv_BboxCol1+.5, 
          hv_BboxRow2-.5, hv_BboxCol2-.5);
      }
      //
      hv_DrawMode.Dispose();
      HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
      }
      hv_Style.Dispose();
      HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_Style);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
      }
      //
      //Collect ClassIDs of the bounding boxes.
      hv_BboxIDs.Dispose();
      hv_BboxIDs = new HTuple();
      hv_BboxClassIDs.Dispose();
      hv_BboxClassIDs = new HTuple();
      //
      //Draw bounding boxes.
      for (hv_IndexBbox=0; (int)hv_IndexBbox<=(int)((new HTuple(hv_BboxRow1.TupleLength()
          ))-1); hv_IndexBbox = (int)hv_IndexBbox + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_RectangleSelected.Dispose();
        HOperatorSet.SelectObj(ho_Rectangle, out ho_RectangleSelected, hv_IndexBbox+1);
        }
        hv_ClassID.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassID = hv_ClassIDs.TupleFind(
            hv_BboxClasses.TupleSelect(hv_IndexBbox));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BboxClassIDs = hv_BboxClassIDs.TupleConcat(
            hv_ClassID);
        hv_BboxClassIDs.Dispose();
        hv_BboxClassIDs = ExpTmpLocalVar_BboxClassIDs;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BboxIDs = hv_BboxIDs.TupleConcat(
            hv_ClassID);
        hv_BboxIDs.Dispose();
        hv_BboxIDs = ExpTmpLocalVar_BboxIDs;
        }
        }
        hv_LineWidth.Dispose();
        HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_LineWidth);
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), ((hv_LineWidth+2)).TupleInt()
              );
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), "black");
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive());
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth.TupleInt()
              );
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
              hv_ClassID));
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive());
        }
      }
      //
      //Draw text of bounding boxes.
      if ((int)(hv_ShowLabels) != 0)
      {
        //For better visibility the text is displayed after all bboxes are drawn.
        for (hv_IndexBbox=0; (int)hv_IndexBbox<=(int)((new HTuple(hv_BboxRow1.TupleLength()
            ))-1); hv_IndexBbox = (int)hv_IndexBbox + 1)
        {
          hv_ClassID.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassID = hv_BboxClassIDs.TupleSelect(
              hv_IndexBbox);
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = (hv_BboxClasses.TupleSelect(
              hv_IndexBbox))+(hv_TextConf.TupleSelect(hv_IndexBbox));
          }
          hv_Ascent.Dispose();hv_Descent.Dispose();hv__.Dispose();hv__.Dispose();
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Text, out hv_Ascent, 
              out hv_Descent, out hv__, out hv__);
          if ((int)(new HTuple(hv_TextPositionRow.TupleEqual("bottom"))) != 0)
          {
            hv_TextRow.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextRow = (hv_BboxRow2.TupleSelect(
                hv_IndexBbox))-((hv_Ascent+hv_Descent)/hv_WindowImageRatio);
            }
          }
          else
          {
            hv_TextRow.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextRow = hv_BboxRow1.TupleSelect(
                hv_IndexBbox);
            }
          }
          if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
          {
            hv_TxtColor.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TxtColor = hv_Colors.TupleSelect(
                hv_ClassID);
            }
          }
          else
          {
            hv_TxtColor.Dispose();
            hv_TxtColor = new HTuple(hv_TextColor);
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image", 
                hv_TextRow, hv_BboxCol1.TupleSelect(hv_IndexBbox), hv_TxtColor, (
                (new HTuple("box_color")).TupleConcat("shadow")).TupleConcat("border_radius"), 
                hv_BoxLabelColor.TupleConcat((new HTuple("false")).TupleConcat(0)));
            }
          }
        }
      }
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
      }
      HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style);
    }
    else
    {
      //Do nothing if no results are present.
      hv_BboxIDs.Dispose();
      hv_BboxIDs = new HTuple();
    }
    ho_Rectangle.Dispose();
    ho_RectangleSelected.Dispose();

    hv_BboxRow1.Dispose();
    hv_BboxCol1.Dispose();
    hv_BboxRow2.Dispose();
    hv_BboxCol2.Dispose();
    hv_BboxClasses.Dispose();
    hv_DrawMode.Dispose();
    hv_Style.Dispose();
    hv_BboxClassIDs.Dispose();
    hv_IndexBbox.Dispose();
    hv_ClassID.Dispose();
    hv_LineWidth.Dispose();
    hv_Text.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv__.Dispose();
    hv_TextRow.Dispose();
    hv_TxtColor.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Visualize the results of an evaluation for a model of type segmentation. 
  public void dev_display_segmentation_evaluation (HTuple hv_EvaluationResult, HTuple hv_EvalParam, 
      HTuple hv_GenParam, HTuple hv_WindowHandleDict)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DisplayConfusionAbsolute = new HTuple();
    HTuple hv_DisplayConfusionRelative = new HTuple(), hv_DisplayMeasures = new HTuple();
    HTuple hv_MeasureColor = new HTuple(), hv_RowColNameColor = new HTuple();
    HTuple hv_DisplayColor = new HTuple(), hv_GenParamKeys = new HTuple();
    HTuple hv_Keys = new HTuple(), hv_KeyIndex = new HTuple();
    HTuple hv_KeyExists = new HTuple(), hv_SupportedModes = new HTuple();
    HTuple hv_Value = new HTuple(), hv_ValueIndex = new HTuple();
    HTuple hv_RGB = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_KeysExist = new HTuple(), hv_ClassIDs = new HTuple();
    HTuple hv_ClassNames = new HTuple(), hv_MaxChars = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Str = new HTuple();
    HTuple hv_IsString = new HTuple(), hv_Length = new HTuple();
    HTuple hv_SubStr = new HTuple(), hv_PixelConfMatrix = new HTuple();
    HTuple hv_MeanIoU = new HTuple(), hv_ClassIoU = new HTuple();
    HTuple hv_PixelAccuracy = new HTuple(), hv_MeanAccuracy = new HTuple();
    HTuple hv_ClassPixelAccuracy = new HTuple(), hv_MeasureKeys = new HTuple();
    HTuple hv_MeasureKeysExist = new HTuple(), hv_MeasuresDisplayed = new HTuple();
    HTuple hv_GenParamMeasures = new HTuple(), hv_NumRows = new HTuple();
    HTuple hv_RowNames = new HTuple(), hv_IdxsNoDisplay = new HTuple();
    HTuple hv_ClassMeasures = new HTuple(), hv_ValidClassIoUs = new HTuple();
    HTuple hv_RowIndex = new HTuple(), hv_ValidClassPixelAccuracy = new HTuple();
    HTuple hv_IdxsNoDisplay1 = new HTuple(), hv_IdxsNoDisplay2 = new HTuple();
    HTuple hv_ColNames = new HTuple(), hv_WindowMeasuresExists = new HTuple();
    HTuple hv_WindowHandleMeasures = new HTuple(), hv_Measures = new HTuple();
    HTuple hv_WindowHandlesConfusion = new HTuple(), hv_GenParamConfusion = new HTuple();
    HTuple hv_WindowConfAbsoluteExists = new HTuple(), hv_WindowHandleConfusionAbsolute = new HTuple();
    HTuple hv_WindowConfRelativeExists = new HTuple(), hv_WindowHandleConfusionRelative = new HTuple();
    HTuple hv_WindowHandleKeys = new HTuple(), hv_WindowHandleKeysExist = new HTuple();
    HTuple hv_ColConfusion = new HTuple(), hv_RowConfusion = new HTuple();
    HTuple hv_WidthConf = new HTuple(), hv_HeightConf = new HTuple();
    HTuple hv__ = new HTuple(), hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    // Initialize local and output iconic variables 
    //
    //This procedure visualizes the evaluation results for a model of type segmentation.
    //
    //Set the default values.
    hv_DisplayConfusionAbsolute.Dispose();
    hv_DisplayConfusionAbsolute = 0;
    hv_DisplayConfusionRelative.Dispose();
    hv_DisplayConfusionRelative = 0;
    hv_DisplayMeasures.Dispose();
    hv_DisplayMeasures = 1;
    hv_MeasureColor.Dispose();
    hv_MeasureColor = "white";
    hv_RowColNameColor.Dispose();
    hv_RowColNameColor = "light gray";
    hv_DisplayColor.Dispose();
    hv_DisplayColor = 1;
    //
    //Handle the generic parameters.
    if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
    {
      hv_GenParamKeys.Dispose();
      hv_GenParamKeys = new HTuple();
      hv_GenParamKeys[0] = "display_mode";
      hv_GenParamKeys[1] = "measure_color";
      hv_GenParamKeys[2] = "row_col_names_color";
      hv_GenParamKeys[3] = "display_color_confusion_matrix";
      hv_Keys.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_Keys);
      for (hv_KeyIndex=0; (int)hv_KeyIndex<=(int)((new HTuple(hv_Keys.TupleLength()
          ))-1); hv_KeyIndex = (int)hv_KeyIndex + 1)
      {
        if ((int)(new HTuple(((hv_GenParamKeys.TupleFind(hv_Keys.TupleSelect(hv_KeyIndex)))).TupleEqual(
            -1))) != 0)
        {
          throw new HalconException(("Invalid GenParam key '"+(hv_Keys.TupleSelect(
              hv_KeyIndex)))+"'");
        }
      }
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, out hv_KeyExists);
      //Set display mode.
      if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
      {
        hv_SupportedModes.Dispose();
        hv_SupportedModes = new HTuple();
        hv_SupportedModes[0] = "absolute_confusion_matrix";
        hv_SupportedModes[1] = "relative_confusion_matrix";
        hv_SupportedModes[2] = "measures";
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(0), out hv_Value);
        }
        if ((int)(new HTuple((new HTuple(hv_Value.TupleLength())).TupleEqual(0))) != 0)
        {
          throw new HalconException("GenParam key 'display_mode' cannot be an empty tuple");
        }
        hv_DisplayConfusionAbsolute.Dispose();
        hv_DisplayConfusionAbsolute = 0;
        hv_DisplayConfusionRelative.Dispose();
        hv_DisplayConfusionRelative = 0;
        hv_DisplayMeasures.Dispose();
        hv_DisplayMeasures = 0;
        for (hv_ValueIndex=0; (int)hv_ValueIndex<=(int)((new HTuple(hv_Value.TupleLength()
            ))-1); hv_ValueIndex = (int)hv_ValueIndex + 1)
        {
          if ((int)(new HTuple(((hv_Value.TupleSelect(hv_ValueIndex))).TupleEqual(
              hv_SupportedModes.TupleSelect(0)))) != 0)
          {
            hv_DisplayConfusionAbsolute.Dispose();
            hv_DisplayConfusionAbsolute = 1;
          }
          else if ((int)(new HTuple(((hv_Value.TupleSelect(hv_ValueIndex))).TupleEqual(
              hv_SupportedModes.TupleSelect(1)))) != 0)
          {
            hv_DisplayConfusionRelative.Dispose();
            hv_DisplayConfusionRelative = 1;
          }
          else if ((int)(new HTuple(((hv_Value.TupleSelect(hv_ValueIndex))).TupleEqual(
              hv_SupportedModes.TupleSelect(2)))) != 0)
          {
            hv_DisplayMeasures.Dispose();
            hv_DisplayMeasures = 1;
          }
          else
          {
            throw new HalconException("Invalid value for GenParam key 'display_mode'");
          }
        }
      }
      //Set MeasureColor.
      if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(1), out hv_Value);
        }
        if ((int)(new HTuple((new HTuple(hv_Value.TupleLength())).TupleNotEqual(1))) != 0)
        {
          throw new HalconException("GenParam 'measure_color' must be a single value");
        }
        try
        {
          hv_RGB.Dispose();
          color_string_to_rgb(hv_Value, out hv_RGB);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          throw new HalconException("GenParam 'measure_color' must be a valid color string");
        }
        hv_MeasureColor.Dispose();
        hv_MeasureColor = new HTuple(hv_Value);
      }
      //Set color for row and column names.
      if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(2), out hv_Value);
        }
        if ((int)(new HTuple((new HTuple(hv_Value.TupleLength())).TupleNotEqual(1))) != 0)
        {
          throw new HalconException("GenParam 'row_col_names_color' must be a single value");
        }
        try
        {
          hv_RGB.Dispose();
          color_string_to_rgb(hv_Value, out hv_RGB);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          throw new HalconException("GenParam 'row_col_names_color' must be a valid color string");
        }
        hv_RowColNameColor.Dispose();
        hv_RowColNameColor = new HTuple(hv_Value);
      }
      //Set DisplayColor.
      if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(3), out hv_Value);
        }
        if ((int)((new HTuple(hv_Value.TupleNotEqual(1))).TupleAnd(new HTuple(hv_Value.TupleNotEqual(
            0)))) != 0)
        {
          throw new HalconException("GenParam 'display_color_confusion_matrix' should be either true or false");
        }
        hv_DisplayColor.Dispose();
        hv_DisplayColor = new HTuple(hv_Value);
      }
    }
    //
    //Get the class names.
    hv_KeysExist.Dispose();
    HOperatorSet.GetDictParam(hv_EvalParam, "key_exists", (new HTuple("class_names")).TupleConcat(
        "class_ids"), out hv_KeysExist);
    if ((int)(((hv_KeysExist.TupleSum())).TupleNot()) != 0)
    {
      throw new HalconException("EvalParam must contain at least one of the keys 'class_names' or 'class_ids'");
    }
    else if ((int)(((hv_KeysExist.TupleSelect(0))).TupleNot()) != 0)
    {
      //If class names are not given, use class IDs instead.
      hv_ClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParam, "class_ids", out hv_ClassIDs);
      hv_ClassNames.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassNames = "class_"+hv_ClassIDs;
      }
    }
    else
    {
      //Get the class names from the EvalParam dict.
      hv_ClassNames.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParam, "class_names", out hv_ClassNames);
    }
    //
    //Cut class names for better visualization.
    if ((int)(new HTuple(hv_ClassNames.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_MaxChars.Dispose();
      hv_MaxChars = 14;
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ClassNames.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        hv_Str.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Str = hv_ClassNames.TupleSelect(
            hv_Index);
        }
        hv_IsString.Dispose();
        HOperatorSet.TupleIsString(hv_Str, out hv_IsString);
        if ((int)(hv_IsString) != 0)
        {
          hv_Length.Dispose();
          HOperatorSet.TupleStrlen(hv_Str, out hv_Length);
          if ((int)(new HTuple(hv_Length.TupleGreater(hv_MaxChars))) != 0)
          {
            hv_SubStr.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_SubStr = (hv_Str.TupleSubstr(
                0,hv_MaxChars-3))+"...";
            }
            if (hv_ClassNames == null)
              hv_ClassNames = new HTuple();
            hv_ClassNames[hv_Index] = hv_SubStr;
          }
        }
      }
    }
    //
    //Get the evaluation results.
    //Initialize the result variables.
    hv_PixelConfMatrix.Dispose();
    hv_PixelConfMatrix = new HTuple();
    hv_MeanIoU.Dispose();
    hv_MeanIoU = new HTuple();
    hv_ClassIoU.Dispose();
    hv_ClassIoU = new HTuple();
    hv_PixelAccuracy.Dispose();
    hv_PixelAccuracy = new HTuple();
    hv_MeanAccuracy.Dispose();
    hv_MeanAccuracy = new HTuple();
    hv_ClassPixelAccuracy.Dispose();
    hv_ClassPixelAccuracy = new HTuple();
    //
    //Get some evaluation params.
    hv_MeasureKeys.Dispose();
    hv_MeasureKeys = new HTuple();
    hv_MeasureKeys[0] = "pixel_confusion_matrix";
    hv_MeasureKeys[1] = "mean_iou";
    hv_MeasureKeys[2] = "class_iou";
    hv_MeasureKeys[3] = "pixel_accuracy";
    hv_MeasureKeys[4] = "mean_accuracy";
    hv_MeasureKeys[5] = "class_pixel_accuracy";
    hv_MeasureKeysExist.Dispose();
    HOperatorSet.GetDictParam(hv_EvaluationResult, "key_exists", hv_MeasureKeys, 
        out hv_MeasureKeysExist);
    //
    //Check the input evaluation results for necessary entries.
    if ((int)(new HTuple(((hv_MeasureKeysExist.TupleSum())).TupleEqual(0))) != 0)
    {
      throw new HalconException("There are no valid keys given in EvaluationResult.");
    }
    if ((int)((new HTuple((((hv_MeasureKeysExist.TupleSum())-(hv_MeasureKeysExist.TupleSelect(
        0)))).TupleEqual(0))).TupleAnd(hv_DisplayMeasures)) != 0)
    {
      throw new HalconException("There are no measures given in EvaluationResult");
    }
    //
    //Pixel confusion matrix.
    if ((int)(hv_MeasureKeysExist.TupleSelect(0)) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PixelConfMatrix.Dispose();
      HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_MeasureKeys.TupleSelect(0), 
          out hv_PixelConfMatrix);
      }
    }
    else
    {
      if ((int)(hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)) != 0)
      {
        throw new HalconException("'pixel_confusion_matrix' has to be set as measure in evaluation for this visualization");
      }
    }
    //Mean IoU.
    if ((int)(hv_MeasureKeysExist.TupleSelect(1)) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MeanIoU.Dispose();
      HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_MeasureKeys.TupleSelect(1), 
          out hv_MeanIoU);
      }
    }
    //Class IoU.
    if ((int)(hv_MeasureKeysExist.TupleSelect(2)) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassIoU.Dispose();
      HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_MeasureKeys.TupleSelect(2), 
          out hv_ClassIoU);
      }
    }
    //Pixel accuracy.
    if ((int)(hv_MeasureKeysExist.TupleSelect(3)) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PixelAccuracy.Dispose();
      HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_MeasureKeys.TupleSelect(3), 
          out hv_PixelAccuracy);
      }
    }
    //Mean accuracy.
    if ((int)(hv_MeasureKeysExist.TupleSelect(4)) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MeanAccuracy.Dispose();
      HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_MeasureKeys.TupleSelect(4), 
          out hv_MeanAccuracy);
      }
    }
    //Class pixel accuracy.
    if ((int)(hv_MeasureKeysExist.TupleSelect(5)) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassPixelAccuracy.Dispose();
      HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_MeasureKeys.TupleSelect(5), 
          out hv_ClassPixelAccuracy);
      }
    }
    //
    //
    hv_MeasuresDisplayed.Dispose();
    hv_MeasuresDisplayed = 0;
    //
    //Set parameters for the visualization of measures.
    if ((int)(hv_DisplayMeasures) != 0)
    {
      hv_GenParamMeasures.Dispose();
      HOperatorSet.CreateDict(out hv_GenParamMeasures);
      HOperatorSet.SetDictTuple(hv_GenParamMeasures, "title", "Measures");
      HOperatorSet.SetDictTuple(hv_GenParamMeasures, "number_format", "0.3f");
      HOperatorSet.SetDictTuple(hv_GenParamMeasures, "display_column_width", "minimal");
      HOperatorSet.SetDictTuple(hv_GenParamMeasures, "value_colors", hv_MeasureColor);
      HOperatorSet.SetDictTuple(hv_GenParamMeasures, "display_color", 1);
      HOperatorSet.SetDictTuple(hv_GenParamMeasures, "row_col_names_color", hv_RowColNameColor);
      //
      //Visualize class measures.
      if ((int)((new HTuple(hv_ClassIoU.TupleNotEqual(new HTuple()))).TupleOr(new HTuple(hv_ClassPixelAccuracy.TupleNotEqual(
          new HTuple())))) != 0)
      {
        //Create matrix.
        hv_NumRows.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumRows = ((new HTuple(hv_ClassIoU.TupleNotEqual(
            new HTuple())))+(new HTuple(hv_ClassPixelAccuracy.TupleNotEqual(new HTuple()))))+(2*(new HTuple(hv_PixelAccuracy.TupleNotEqual(
            new HTuple()))));
        }
        hv_RowNames.Dispose();
        hv_RowNames = new HTuple();
        hv_IdxsNoDisplay.Dispose();
        hv_IdxsNoDisplay = new HTuple();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassMeasures.Dispose();
        HOperatorSet.CreateMatrix(hv_NumRows, (new HTuple(hv_ClassNames.TupleLength()
            ))+1, 0.0, out hv_ClassMeasures);
        }
        if ((int)(new HTuple(hv_ClassIoU.TupleNotEqual(new HTuple()))) != 0)
        {
          //Add row for class IoU.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ClassMeasures, HTuple.TupleGenConst(new HTuple(hv_ClassNames.TupleLength()
              ),0), HTuple.TupleGenSequence(0,(new HTuple(hv_ClassNames.TupleLength()
              ))-1,1), hv_ClassIoU);
          }
          hv_ValidClassIoUs.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ValidClassIoUs = hv_ClassIoU.TupleSelect(
              ((hv_ClassIoU.TupleGreaterElem(-1))).TupleFind(1));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ClassMeasures, 0, new HTuple(hv_ClassNames.TupleLength()
              ), hv_ValidClassIoUs.TupleMean());
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_RowNames = hv_RowNames.TupleConcat(
              "IoU");
          hv_RowNames.Dispose();
          hv_RowNames = ExpTmpLocalVar_RowNames;
          }
          }
        }
        if ((int)(new HTuple(hv_ClassPixelAccuracy.TupleNotEqual(new HTuple()))) != 0)
        {
          //Add row for class pixel accuracy.
          hv_RowIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_RowIndex = new HTuple(hv_ClassIoU.TupleNotEqual(
              new HTuple()));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ClassMeasures, HTuple.TupleGenConst(new HTuple(hv_ClassNames.TupleLength()
              ),hv_RowIndex), HTuple.TupleGenSequence(0,(new HTuple(hv_ClassNames.TupleLength()
              ))-1,1), hv_ClassPixelAccuracy);
          }
          hv_ValidClassPixelAccuracy.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ValidClassPixelAccuracy = hv_ClassPixelAccuracy.TupleSelect(
              ((hv_ClassPixelAccuracy.TupleGreaterElem(-1))).TupleFind(1));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ClassMeasures, hv_RowIndex, new HTuple(hv_ClassNames.TupleLength()
              ), hv_ValidClassPixelAccuracy.TupleMean());
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_RowNames = hv_RowNames.TupleConcat(
              "Pixel Acc.");
          hv_RowNames.Dispose();
          hv_RowNames = ExpTmpLocalVar_RowNames;
          }
          }
        }
        if ((int)(new HTuple(hv_PixelAccuracy.TupleNotEqual(new HTuple()))) != 0)
        {
          //Add row for overall pixel accuracy.
          hv_RowIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_RowIndex = (new HTuple(hv_ClassIoU.TupleNotEqual(
              new HTuple())))+(new HTuple(hv_ClassPixelAccuracy.TupleNotEqual(new HTuple())));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetValueMatrix(hv_ClassMeasures, hv_RowIndex+1, 0, hv_PixelAccuracy);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_RowNames = hv_RowNames.TupleConcat(
              (new HTuple("")).TupleConcat("Pixel Acc. (overall)"));
          hv_RowNames.Dispose();
          hv_RowNames = ExpTmpLocalVar_RowNames;
          }
          }
          hv_IdxsNoDisplay1.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IdxsNoDisplay1 = HTuple.TupleGenSequence(
              hv_RowIndex*((new HTuple(hv_ClassNames.TupleLength()))+1),((hv_RowIndex+1)*((new HTuple(hv_ClassNames.TupleLength()
              ))+1))-1,1);
          }
          hv_IdxsNoDisplay2.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IdxsNoDisplay2 = HTuple.TupleGenSequence(
              ((hv_RowIndex+1)*((new HTuple(hv_ClassNames.TupleLength()))+1))+1,((hv_RowIndex+2)*((new HTuple(hv_ClassNames.TupleLength()
              ))+1))-1,1);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_IdxsNoDisplay = ((hv_IdxsNoDisplay.TupleConcat(
              hv_IdxsNoDisplay1))).TupleConcat(hv_IdxsNoDisplay2);
          hv_IdxsNoDisplay.Dispose();
          hv_IdxsNoDisplay = ExpTmpLocalVar_IdxsNoDisplay;
          }
          }
        }
        //Add GenParamMeasures parameter for displaying the matrix.
        HOperatorSet.SetDictTuple(hv_GenParamMeasures, "idxs_no_display", hv_IdxsNoDisplay);
        //Add 'mean' to column names.
        hv_ColNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ColNames = new HTuple();
        hv_ColNames = hv_ColNames.TupleConcat(hv_ClassNames);
        hv_ColNames = hv_ColNames.TupleConcat("mean");
        }
        //
        //Check if there already is a window handle.
        hv_WindowMeasuresExists.Dispose();
        HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_measures", 
            out hv_WindowMeasuresExists);
        if ((int)(hv_WindowMeasuresExists) != 0)
        {
          hv_WindowHandleMeasures.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_measures", out hv_WindowHandleMeasures);
          HDevWindowStack.SetActive(hv_WindowHandleMeasures);
        }
        else
        {
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(0,0,512,512,0,"visible","",out hv_WindowHandleMeasures);
          HDevWindowStack.Push(hv_WindowHandleMeasures);
          HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_measures", hv_WindowHandleMeasures);
        }
        //
        //Display.
        dev_display_matrix(hv_ClassMeasures, hv_ColNames, hv_RowNames, hv_WindowHandleMeasures, 
            hv_GenParamMeasures);
        //
        hv_MeasuresDisplayed.Dispose();
        hv_MeasuresDisplayed = 1;
      }
      //
      //Visualize mean measures.
      if ((int)((new HTuple(hv_MeasuresDisplayed.TupleNot())).TupleAnd((new HTuple((new HTuple(hv_MeanIoU.TupleNotEqual(
          new HTuple()))).TupleOr(new HTuple(hv_PixelAccuracy.TupleNotEqual(new HTuple()))))).TupleOr(
          new HTuple(hv_MeanAccuracy.TupleNotEqual(new HTuple()))))) != 0)
      {
        //Create matrix.
        hv_NumRows.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumRows = ((new HTuple(hv_MeanIoU.TupleNotEqual(
            new HTuple())))+(new HTuple(hv_PixelAccuracy.TupleNotEqual(new HTuple()))))+(new HTuple(hv_MeanAccuracy.TupleNotEqual(
            new HTuple())));
        }
        hv_RowNames.Dispose();
        hv_RowNames = new HTuple();
        hv_Measures.Dispose();
        HOperatorSet.CreateMatrix(hv_NumRows, 1, 0.0, out hv_Measures);
        if ((int)(new HTuple(hv_MeanIoU.TupleNotEqual(new HTuple()))) != 0)
        {
          HOperatorSet.SetValueMatrix(hv_Measures, 0, 0, hv_MeanIoU);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_RowNames = hv_RowNames.TupleConcat(
              "Mean IoU");
          hv_RowNames.Dispose();
          hv_RowNames = ExpTmpLocalVar_RowNames;
          }
          }
        }
        if ((int)(new HTuple(hv_MeanAccuracy.TupleNotEqual(new HTuple()))) != 0)
        {
          hv_RowIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_RowIndex = new HTuple(hv_MeanIoU.TupleNotEqual(
              new HTuple()));
          }
          HOperatorSet.SetValueMatrix(hv_Measures, hv_RowIndex, 0, hv_MeanAccuracy);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_RowNames = hv_RowNames.TupleConcat(
              "Mean Class Pixel Acc.");
          hv_RowNames.Dispose();
          hv_RowNames = ExpTmpLocalVar_RowNames;
          }
          }
        }
        if ((int)(new HTuple(hv_PixelAccuracy.TupleNotEqual(new HTuple()))) != 0)
        {
          hv_RowIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_RowIndex = (new HTuple(hv_MeanIoU.TupleNotEqual(
              new HTuple())))+(new HTuple(hv_MeanAccuracy.TupleNotEqual(new HTuple())));
          }
          HOperatorSet.SetValueMatrix(hv_Measures, hv_RowIndex, 0, hv_PixelAccuracy);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_RowNames = hv_RowNames.TupleConcat(
              "Pixel Acc. (overall)");
          hv_RowNames.Dispose();
          hv_RowNames = ExpTmpLocalVar_RowNames;
          }
          }
        }
        //
        //Check if there already is a window handle.
        hv_WindowMeasuresExists.Dispose();
        HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_measures", 
            out hv_WindowMeasuresExists);
        if ((int)(hv_WindowMeasuresExists) != 0)
        {
          hv_WindowHandleMeasures.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_measures", out hv_WindowHandleMeasures);
          HDevWindowStack.SetActive(hv_WindowHandleMeasures);
        }
        else
        {
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(0,0,512,512,0,"visible","",out hv_WindowHandleMeasures);
          HDevWindowStack.Push(hv_WindowHandleMeasures);
          HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_measures", hv_WindowHandleMeasures);
        }
        //
        //Display.
        dev_display_matrix(hv_Measures, "", hv_RowNames, hv_WindowHandleMeasures, 
            hv_GenParamMeasures);
        //
        hv_MeasuresDisplayed.Dispose();
        hv_MeasuresDisplayed = 1;
      }
      //
    }
    //
    //Visualize the pixel confusion matrix.
    if ((int)(hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)) != 0)
    {
      //Collect the window handles.
      hv_WindowHandlesConfusion.Dispose();
      hv_WindowHandlesConfusion = new HTuple();
      //Set the display parameters.
      hv_GenParamConfusion.Dispose();
      HOperatorSet.CreateDict(out hv_GenParamConfusion);
      HOperatorSet.SetDictTuple(hv_GenParamConfusion, "display_relative_matrix", 
          hv_DisplayConfusionRelative);
      HOperatorSet.SetDictTuple(hv_GenParamConfusion, "display_absolute_matrix", 
          hv_DisplayConfusionAbsolute);
      HOperatorSet.SetDictTuple(hv_GenParamConfusion, "display_color", hv_DisplayColor);
      HOperatorSet.SetDictTuple(hv_GenParamConfusion, "row_col_names_color", hv_RowColNameColor);
      if ((int)(hv_DisplayConfusionAbsolute) != 0)
      {
        //Check if there already is a window handle.
        hv_WindowConfAbsoluteExists.Dispose();
        HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_confusion_absolute", 
            out hv_WindowConfAbsoluteExists);
        if ((int)(hv_WindowConfAbsoluteExists) != 0)
        {
          hv_WindowHandleConfusionAbsolute.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_confusion_absolute", 
              out hv_WindowHandleConfusionAbsolute);
          HDevWindowStack.SetActive(hv_WindowHandleConfusionAbsolute);
        }
        else
        {
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(0,0,512,512,0,"visible","",out hv_WindowHandleConfusionAbsolute);
          HDevWindowStack.Push(hv_WindowHandleConfusionAbsolute);
          HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_confusion_absolute", 
              hv_WindowHandleConfusionAbsolute);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_WindowHandlesConfusion = hv_WindowHandlesConfusion.TupleConcat(
            hv_WindowHandleConfusionAbsolute);
        hv_WindowHandlesConfusion.Dispose();
        hv_WindowHandlesConfusion = ExpTmpLocalVar_WindowHandlesConfusion;
        }
        }
      }
      if ((int)(hv_DisplayConfusionRelative) != 0)
      {
        //Check if there already is a window handle.
        hv_WindowConfRelativeExists.Dispose();
        HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_confusion_relative", 
            out hv_WindowConfRelativeExists);
        if ((int)(hv_WindowConfRelativeExists) != 0)
        {
          hv_WindowHandleConfusionRelative.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_confusion_relative", 
              out hv_WindowHandleConfusionRelative);
          HDevWindowStack.SetActive(hv_WindowHandleConfusionRelative);
        }
        else
        {
          HOperatorSet.SetWindowAttr("background_color","black");
          HOperatorSet.OpenWindow(0,0,512,512,0,"visible","",out hv_WindowHandleConfusionRelative);
          HDevWindowStack.Push(hv_WindowHandleConfusionRelative);
          HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_confusion_relative", 
              hv_WindowHandleConfusionRelative);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_WindowHandlesConfusion = hv_WindowHandlesConfusion.TupleConcat(
            hv_WindowHandleConfusionRelative);
        hv_WindowHandlesConfusion.Dispose();
        hv_WindowHandlesConfusion = ExpTmpLocalVar_WindowHandlesConfusion;
        }
        }
      }
      hv_ColNames.Dispose();
      hv_ColNames = new HTuple(hv_ClassNames);
      dev_display_pixel_confusion_matrix(hv_PixelConfMatrix, hv_ColNames, hv_GenParamConfusion, 
          hv_WindowHandlesConfusion);
    }
    //
    //Rearrange windows.
    hv_WindowHandleKeys.Dispose();
    hv_WindowHandleKeys = new HTuple();
    hv_WindowHandleKeys[0] = "window_measures";
    hv_WindowHandleKeys[1] = "window_confusion_absolute";
    hv_WindowHandleKeys[2] = "window_confusion_relative";
    hv_WindowHandleKeysExist.Dispose();
    HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", hv_WindowHandleKeys, 
        out hv_WindowHandleKeysExist);
    if ((int)(new HTuple(((hv_WindowHandleKeysExist.TupleSum())).TupleGreater(1))) != 0)
    {
      hv_ColConfusion.Dispose();
      hv_ColConfusion = new HTuple();
      hv_ColConfusion[0] = 0;
      hv_ColConfusion[1] = 0;
      hv_RowConfusion.Dispose();
      hv_RowConfusion = new HTuple();
      hv_RowConfusion[0] = 0;
      hv_RowConfusion[1] = 0;
      hv_WidthConf.Dispose();
      hv_WidthConf = -1;
      hv_HeightConf.Dispose();
      hv_HeightConf = -1;
      if ((int)(hv_MeasuresDisplayed) != 0)
      {
        hv__.Dispose();hv__.Dispose();hv_Width.Dispose();hv_Height.Dispose();
        HOperatorSet.GetWindowExtents(hv_WindowHandleMeasures, out hv__, out hv__, 
            out hv_Width, out hv_Height);
        hv_RowConfusion.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RowConfusion = new HTuple();
        hv_RowConfusion = hv_RowConfusion.TupleConcat(hv_Height+55);
        hv_RowConfusion = hv_RowConfusion.TupleConcat(hv_Height+55);
        }
      }
      if ((int)(hv_DisplayConfusionAbsolute) != 0)
      {
        hv_Row.Dispose();hv_Column.Dispose();hv_WidthConf.Dispose();hv_HeightConf.Dispose();
        HOperatorSet.GetWindowExtents(hv_WindowHandleConfusionAbsolute, out hv_Row, 
            out hv_Column, out hv_WidthConf, out hv_HeightConf);
        HDevWindowStack.SetActive(hv_WindowHandleConfusionAbsolute);
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_RowConfusion.TupleSelect(
              0), hv_ColConfusion.TupleSelect(0), hv_WidthConf, hv_HeightConf);
          }
        }
        // dev_get_preferences(...); only in hdevelop
        if (hv_ColConfusion == null)
          hv_ColConfusion = new HTuple();
        hv_ColConfusion[1] = hv_WidthConf+8;
      }
      if ((int)(hv_DisplayConfusionRelative) != 0)
      {
        HDevWindowStack.SetActive(hv_WindowHandleConfusionRelative);
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_RowConfusion.TupleSelect(
              1), hv_ColConfusion.TupleSelect(1), hv_WidthConf, hv_HeightConf);
          }
        }
      }
    }
    //

    hv_DisplayConfusionAbsolute.Dispose();
    hv_DisplayConfusionRelative.Dispose();
    hv_DisplayMeasures.Dispose();
    hv_MeasureColor.Dispose();
    hv_RowColNameColor.Dispose();
    hv_DisplayColor.Dispose();
    hv_GenParamKeys.Dispose();
    hv_Keys.Dispose();
    hv_KeyIndex.Dispose();
    hv_KeyExists.Dispose();
    hv_SupportedModes.Dispose();
    hv_Value.Dispose();
    hv_ValueIndex.Dispose();
    hv_RGB.Dispose();
    hv_Exception.Dispose();
    hv_KeysExist.Dispose();
    hv_ClassIDs.Dispose();
    hv_ClassNames.Dispose();
    hv_MaxChars.Dispose();
    hv_Index.Dispose();
    hv_Str.Dispose();
    hv_IsString.Dispose();
    hv_Length.Dispose();
    hv_SubStr.Dispose();
    hv_PixelConfMatrix.Dispose();
    hv_MeanIoU.Dispose();
    hv_ClassIoU.Dispose();
    hv_PixelAccuracy.Dispose();
    hv_MeanAccuracy.Dispose();
    hv_ClassPixelAccuracy.Dispose();
    hv_MeasureKeys.Dispose();
    hv_MeasureKeysExist.Dispose();
    hv_MeasuresDisplayed.Dispose();
    hv_GenParamMeasures.Dispose();
    hv_NumRows.Dispose();
    hv_RowNames.Dispose();
    hv_IdxsNoDisplay.Dispose();
    hv_ClassMeasures.Dispose();
    hv_ValidClassIoUs.Dispose();
    hv_RowIndex.Dispose();
    hv_ValidClassPixelAccuracy.Dispose();
    hv_IdxsNoDisplay1.Dispose();
    hv_IdxsNoDisplay2.Dispose();
    hv_ColNames.Dispose();
    hv_WindowMeasuresExists.Dispose();
    hv_WindowHandleMeasures.Dispose();
    hv_Measures.Dispose();
    hv_WindowHandlesConfusion.Dispose();
    hv_GenParamConfusion.Dispose();
    hv_WindowConfAbsoluteExists.Dispose();
    hv_WindowHandleConfusionAbsolute.Dispose();
    hv_WindowConfRelativeExists.Dispose();
    hv_WindowHandleConfusionRelative.Dispose();
    hv_WindowHandleKeys.Dispose();
    hv_WindowHandleKeysExist.Dispose();
    hv_ColConfusion.Dispose();
    hv_RowConfusion.Dispose();
    hv_WidthConf.Dispose();
    hv_HeightConf.Dispose();
    hv__.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Display the ground truth/result segmentation as regions. 
  public void dev_display_segmentation_regions (HObject ho_SegmentationImage, HTuple hv_ClassIDs, 
      HTuple hv_ColorsSegmentation, HTuple hv_ExcludeClassIDs, out HTuple hv_ImageClassIDs)
  {




    // Local iconic variables 

    HObject ho_Regions, ho_SelectedRegion=null;

    // Local control variables 

    HTuple hv_IncludedClassIDs = new HTuple();
    HTuple hv_Area = new HTuple(), hv_Index = new HTuple();
    HTuple hv_ClassID = new HTuple(), hv_IndexColor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Regions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegion);
    hv_ImageClassIDs = new HTuple();
    //
    //This procedure displays the ground truth/result segmentation
    //given in SegmentationImage as regions. The ClassIDs are necessary to
    //display ground truth/result segmentations from the same class
    //always with the same color. It is possible to exclude certain ClassIDs
    //from being displayed. The displayed classes are returned in ImageClassIDs.
    //
    //
    //Remove excluded class IDs from the list.
    hv_IncludedClassIDs.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IncludedClassIDs = hv_ClassIDs.TupleDifference(
        hv_ExcludeClassIDs);
    }
    //
    //Get a region for each class ID.
    ho_Regions.Dispose();
    HOperatorSet.Threshold(ho_SegmentationImage, out ho_Regions, hv_IncludedClassIDs, 
        hv_IncludedClassIDs);
    //
    //Get classes with non-empty regions.
    hv_Area.Dispose();
    HOperatorSet.RegionFeatures(ho_Regions, "area", out hv_Area);
    hv_ImageClassIDs.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ImageClassIDs = hv_IncludedClassIDs.TupleSelectMask(
        hv_Area.TupleGreaterElem(0));
    }
    //
    //Display all non-empty class regions in distinct colors.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_IncludedClassIDs.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      if ((int)(new HTuple(((hv_Area.TupleSelect(hv_Index))).TupleGreater(0))) != 0)
      {
        //Use class ID to determine region color.
        hv_ClassID.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassID = hv_IncludedClassIDs.TupleSelect(
            hv_Index);
        }
        hv_IndexColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_IndexColor = hv_ClassIDs.TupleFindFirst(
            hv_ClassID);
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorsSegmentation.TupleSelect(
              hv_IndexColor));
          }
        }
        //Display the segmentation region.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_SelectedRegion.Dispose();
        HOperatorSet.SelectObj(ho_Regions, out ho_SelectedRegion, hv_Index+1);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_SelectedRegion, HDevWindowStack.GetActive());
        }
      }
    }
    ho_Regions.Dispose();
    ho_SelectedRegion.Dispose();

    hv_IncludedClassIDs.Dispose();
    hv_Area.Dispose();
    hv_Index.Dispose();
    hv_ClassID.Dispose();
    hv_IndexColor.Dispose();

    return;
  }

  // Chapter: Matching / Shape-Based
  // Short Description: Display the results of Shape-Based Matching. 
  public void dev_display_shape_matching_results (HTuple hv_ModelID, HTuple hv_Color, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Angle, HTuple hv_ScaleR, HTuple hv_ScaleC, 
      HTuple hv_Model)
  {



        // Local iconic variables 

        HObject ho_ModelContours=null, ho_ContoursAffinTrans=null;

        // Local control variables 

        HTuple hv_NumMatches = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Match = new HTuple(), hv_HomMat2DIdentity = new HTuple();
        HTuple hv_HomMat2DScale = new HTuple(), hv_HomMat2DRotate = new HTuple();
        HTuple hv_HomMat2DTranslate = new HTuple();
        HTuple   hv_Model_COPY_INP_TMP = new HTuple(hv_Model);
        HTuple   hv_ScaleC_COPY_INP_TMP = new HTuple(hv_ScaleC);
        HTuple   hv_ScaleR_COPY_INP_TMP = new HTuple(hv_ScaleR);

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ModelContours);
        HOperatorSet.GenEmptyObj(out ho_ContoursAffinTrans);
    //This procedure displays the results of Shape-Based Matching.
    //
    hv_NumMatches.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumMatches = new HTuple(hv_Row.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumMatches.TupleGreater(0))) != 0)
    {
      if ((int)(new HTuple((new HTuple(hv_ScaleR_COPY_INP_TMP.TupleLength())).TupleEqual(
          1))) != 0)
      {
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleGenConst(hv_NumMatches, hv_ScaleR_COPY_INP_TMP, out ExpTmpOutVar_0);
        hv_ScaleR_COPY_INP_TMP.Dispose();
        hv_ScaleR_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      if ((int)(new HTuple((new HTuple(hv_ScaleC_COPY_INP_TMP.TupleLength())).TupleEqual(
          1))) != 0)
      {
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleGenConst(hv_NumMatches, hv_ScaleC_COPY_INP_TMP, out ExpTmpOutVar_0);
        hv_ScaleC_COPY_INP_TMP.Dispose();
        hv_ScaleC_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength())).TupleEqual(
          0))) != 0)
      {
        hv_Model_COPY_INP_TMP.Dispose();
        HOperatorSet.TupleGenConst(hv_NumMatches, 0, out hv_Model_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength()
          )).TupleEqual(1))) != 0)
      {
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleGenConst(hv_NumMatches, hv_Model_COPY_INP_TMP, out ExpTmpOutVar_0);
        hv_Model_COPY_INP_TMP.Dispose();
        hv_Model_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ModelID.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ModelContours.Dispose();
        HOperatorSet.GetShapeModelContours(out ho_ModelContours, hv_ModelID.TupleSelect(
            hv_Index), 1);
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
              hv_Index%(new HTuple(hv_Color.TupleLength()))));
          }
        }
        HTuple end_val18 = hv_NumMatches-1;
        HTuple step_val18 = 1;
        for (hv_Match=0; hv_Match.Continue(end_val18, step_val18); hv_Match = hv_Match.TupleAdd(step_val18))
        {
          if ((int)(new HTuple(hv_Index.TupleEqual(hv_Model_COPY_INP_TMP.TupleSelect(
              hv_Match)))) != 0)
          {
            hv_HomMat2DIdentity.Dispose();
            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HomMat2DScale.Dispose();
            HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, hv_ScaleR_COPY_INP_TMP.TupleSelect(
                hv_Match), hv_ScaleC_COPY_INP_TMP.TupleSelect(hv_Match), 0, 0, out hv_HomMat2DScale);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HomMat2DRotate.Dispose();
            HOperatorSet.HomMat2dRotate(hv_HomMat2DScale, hv_Angle.TupleSelect(hv_Match), 
                0, 0, out hv_HomMat2DRotate);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HomMat2DTranslate.Dispose();
            HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_Row.TupleSelect(
                hv_Match), hv_Column.TupleSelect(hv_Match), out hv_HomMat2DTranslate);
            }
            ho_ContoursAffinTrans.Dispose();
            HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_ContoursAffinTrans, 
                hv_HomMat2DTranslate);
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ContoursAffinTrans, HDevWindowStack.GetActive()
                  );
            }
          }
        }
      }
    }
    ho_ModelContours.Dispose();
    ho_ContoursAffinTrans.Dispose();

    hv_Model_COPY_INP_TMP.Dispose();
    hv_ScaleC_COPY_INP_TMP.Dispose();
    hv_ScaleR_COPY_INP_TMP.Dispose();
    hv_NumMatches.Dispose();
    hv_Index.Dispose();
    hv_Match.Dispose();
    hv_HomMat2DIdentity.Dispose();
    hv_HomMat2DScale.Dispose();
    hv_HomMat2DRotate.Dispose();
    hv_HomMat2DTranslate.Dispose();

    return;
  }

  public void dev_display_surface_matching_results (HTuple hv_WindowHandle1, HTuple hv_SurfaceMatchingResultID, 
      HTuple hv_ObjectModel3DModel, HTuple hv_ObjectModel3DScene, HTuple hv_Score, 
      HTuple hv_Pose, HTuple hv_EdgesTrained)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_SampledEdges = new HTuple(), hv_KeyPoints = new HTuple();
    HTuple hv_SampledScene = new HTuple(), hv_Instructions = new HTuple();
    HTuple hv_Colors = new HTuple(), hv_Number = new HTuple();
    HTuple hv_ObjectModel3DResult = new HTuple(), hv_ColorsVis = new HTuple();
    HTuple hv_Message = new HTuple(), hv_PoseOut = new HTuple();
    // Initialize local and output iconic variables 
    //Get Matching data
    if ((int)(new HTuple(hv_EdgesTrained.TupleEqual("true"))) != 0)
    {
      hv_SampledEdges.Dispose();
      HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_edges", 
          new HTuple(), out hv_SampledEdges);
    }
    hv_KeyPoints.Dispose();
    HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "key_points", 
        new HTuple(), out hv_KeyPoints);
    hv_SampledScene.Dispose();
    HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", 
        new HTuple(), out hv_SampledScene);
    //
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[0] = "Rotate: Left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[1] = "Zoom:   Shift + left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[2] = "Move:   Ctrl  + left button";
    //
    //Generate color vector for visualization
    hv_Colors.Dispose();
    hv_Colors = new HTuple();
    hv_Colors[0] = "red";
    hv_Colors[1] = "green";
    hv_Colors[2] = "blue";
    hv_Colors[3] = "cyan";
    hv_Colors[4] = "magenta";
    hv_Colors[5] = "yellow";
    hv_Colors[6] = "medium slate blue";
    hv_Colors[7] = "coral";
    hv_Colors[8] = "slate blue";
    hv_Colors[9] = "orange red";
    hv_Colors[10] = "dark olive green";
    //
    //Number of Matches
    hv_Number.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Number = new HTuple(hv_Score.TupleLength()
        );
    }
    //
    //Move the model into the scene
    hv_ObjectModel3DResult.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_ObjectModel3DModel, hv_Pose, out hv_ObjectModel3DResult);
    hv_ColorsVis.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColorsVis = hv_Colors.TupleSelect(
        HTuple.TupleGenSequence(0,hv_Number-1,1)%(new HTuple(hv_Colors.TupleLength()
        )));
    }
    //
    //Visualize results
    if ((int)(new HTuple(hv_EdgesTrained.TupleEqual("true"))) != 0)
    {
      hv_Message.Dispose();
      hv_Message = "Original scene points (gray)";
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[1] = "Sampled scene points (cyan)";
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[2] = "Key points (yellow)";
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[3] = "Sampled 3d edges (green)";
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[4] = hv_Number+" objects are found ";
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PoseOut.Dispose();
      visualize_object_model_3d(hv_WindowHandle1, ((((((hv_ObjectModel3DScene.TupleConcat(
          hv_SampledEdges))).TupleConcat(hv_SampledScene))).TupleConcat(hv_KeyPoints))).TupleConcat(
          hv_ObjectModel3DResult), new HTuple(), new HTuple(), (((("color_"+HTuple.TupleGenSequence(
          0,hv_Number+3,1))).TupleConcat(new HTuple("point_size_")+(((new HTuple(0)).TupleConcat(
          1)).TupleConcat(2)).TupleConcat(3)))).TupleConcat((new HTuple("disp_pose")).TupleConcat(
          "alpha")), ((((((new HTuple("gray")).TupleConcat("green")).TupleConcat(
          "cyan")).TupleConcat("yellow")).TupleConcat(hv_ColorsVis))).TupleConcat(
          (((((new HTuple(1.0)).TupleConcat(3.0)).TupleConcat(3.0)).TupleConcat(5.0)).TupleConcat(
          "true")).TupleConcat(0.5)), hv_Message, ((((new HTuple("")).TupleConcat(
          "")).TupleConcat("")).TupleConcat("")).TupleConcat(hv_Score), hv_Instructions, 
          out hv_PoseOut);
      }
    }
    else
    {
      hv_Message.Dispose();
      hv_Message = "Final Results:";
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[1] = "Original scene points (gray)";
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[2] = "Sampled scene points (cyan)";
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[3] = "Key points (yellow)";
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[4] = hv_Number+" objects are found";
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PoseOut.Dispose();
      visualize_object_model_3d(hv_WindowHandle1, ((((hv_ObjectModel3DScene.TupleConcat(
          hv_SampledScene))).TupleConcat(hv_KeyPoints))).TupleConcat(hv_ObjectModel3DResult), 
          new HTuple(), new HTuple(), (((("color_"+HTuple.TupleGenSequence(0,hv_Number+2,1))).TupleConcat(
          new HTuple("point_size_")+((new HTuple(0)).TupleConcat(1)).TupleConcat(
          2)))).TupleConcat((new HTuple("disp_pose")).TupleConcat("alpha")), ((((
          (new HTuple("gray")).TupleConcat("cyan")).TupleConcat("yellow")).TupleConcat(
          hv_ColorsVis))).TupleConcat(((((new HTuple(1.0)).TupleConcat(3.0)).TupleConcat(
          5.0)).TupleConcat("true")).TupleConcat(0.5)), hv_Message, (((new HTuple("")).TupleConcat(
          "")).TupleConcat("")).TupleConcat(hv_Score), hv_Instructions, out hv_PoseOut);
      }
    }
    HDevWindowStack.SetActive(hv_WindowHandle1);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
    }

    hv_SampledEdges.Dispose();
    hv_KeyPoints.Dispose();
    hv_SampledScene.Dispose();
    hv_Instructions.Dispose();
    hv_Colors.Dispose();
    hv_Number.Dispose();
    hv_ObjectModel3DResult.Dispose();
    hv_ColorsVis.Dispose();
    hv_Message.Dispose();
    hv_PoseOut.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Display a legend according to the generic parameters. 
  public void dev_display_tiled_legend (HTuple hv_WindowImages, HTuple hv_GenParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_LegendText = new HTuple(), hv_Flag = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_PosTexts = new HTuple();
    HTuple hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    //
    //This procedure displays a legend of dev_display_dl_data_tiled
    //according to the generic parameters.
    //
    hv_LegendText.Dispose();
    hv_LegendText = new HTuple();
    try
    {
      hv_Flag.Dispose();
      HOperatorSet.GetDictTuple(hv_GenParam, "display_input", out hv_Flag);
      if ((int)(hv_Flag) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
            "input");
        hv_LegendText.Dispose();
        hv_LegendText = ExpTmpLocalVar_LegendText;
        }
        }
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
          "input");
      hv_LegendText.Dispose();
      hv_LegendText = ExpTmpLocalVar_LegendText;
      }
      }
    }

    try
    {
      hv_Flag.Dispose();
      HOperatorSet.GetDictTuple(hv_GenParam, "display_ground_truth", out hv_Flag);
      if ((int)(hv_Flag) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
            "ground truth");
        hv_LegendText.Dispose();
        hv_LegendText = ExpTmpLocalVar_LegendText;
        }
        }
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
          "ground truth");
      hv_LegendText.Dispose();
      hv_LegendText = ExpTmpLocalVar_LegendText;
      }
      }
    }
    try
    {
      hv_Flag.Dispose();
      HOperatorSet.GetDictTuple(hv_GenParam, "display_result", out hv_Flag);
      if ((int)(hv_Flag) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
            "result");
        hv_LegendText.Dispose();
        hv_LegendText = ExpTmpLocalVar_LegendText;
        }
        }
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
          "result");
      hv_LegendText.Dispose();
      hv_LegendText = ExpTmpLocalVar_LegendText;
      }
      }
    }
    if ((int)(new HTuple((new HTuple(hv_LegendText.TupleLength())).TupleEqual(3))) != 0)
    {
      hv_PosTexts.Dispose();
      hv_PosTexts = new HTuple();
      hv_PosTexts[0] = "Top:    ";
      hv_PosTexts[1] = "Center: ";
      hv_PosTexts[2] = "Bottom: ";
    }
    else if ((int)(new HTuple((new HTuple(hv_LegendText.TupleLength())).TupleEqual(
        2))) != 0)
    {
      hv_PosTexts.Dispose();
      hv_PosTexts = new HTuple();
      hv_PosTexts[0] = "Top:    ";
      hv_PosTexts[1] = "Bottom: ";
    }
    else
    {
      hv_PosTexts.Dispose();
      hv_PosTexts = "";
    }
    HDevWindowStack.SetActive(hv_WindowImages);
    hv_Text.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Text = hv_PosTexts+hv_LegendText;
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "bottom", 
          "right", "black", new HTuple(), new HTuple());
    }

    hv_LegendText.Dispose();
    hv_Flag.Dispose();
    hv_Exception.Dispose();
    hv_PosTexts.Dispose();
    hv_Text.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Update the various texts and plots during training. 
  public void dev_display_update_train_dl_model (HTuple hv_TrainParam, HTuple hv_DisplayData, 
      HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_TrainInfo, HTuple hv_EvaluationInfos, 
      HTuple hv_Epochs, HTuple hv_Loss, HTuple hv_EvalEpochs, HTuple hv_EvalValues)
  {



    // Local iconic variables 

    HObject ho_PlotBackground;

    // Local control variables 

    HTuple hv_DisplayEnabled = new HTuple(), hv_DisplayParam = new HTuple();
    HTuple hv_WindowText = new HTuple(), hv_WindowHandle = new HTuple();
    HTuple hv_ChangePlotIntervalSeconds = new HTuple(), hv_LastChange = new HTuple();
    HTuple hv_Seconds = new HTuple(), hv_PlotEval = new HTuple();
    HTuple hv_TextPlot = new HTuple(), hv_PlotHeadline = new HTuple();
    HTuple hv_PartRow1 = new HTuple(), hv_PartColumn1 = new HTuple();
    HTuple hv_PartRow2 = new HTuple(), hv_PartColumn2 = new HTuple();
    HTuple hv__ = new HTuple(), hv_Height = new HTuple(), hv_PlotHeight = new HTuple();
    HTuple hv_TicksX = new HTuple(), hv_TicksY = new HTuple();
    HTuple hv_StartY = new HTuple(), hv_EndY = new HTuple();
    HTuple hv_YAxisLabel = new HTuple(), hv_BestEvaluationData = new HTuple();
    HTuple hv_BestEvaluationComparisonKeys = new HTuple();
    HTuple hv_Offset = new HTuple(), hv_LogMin = new HTuple();
    HTuple hv_LogMax = new HTuple(), hv_Scale = new HTuple();
    HTuple hv_LogOffset = new HTuple(), hv_LogY = new HTuple();
    HTuple hv_TextModelParams = new HTuple(), hv_ModelParams = new HTuple();
    HTuple hv_StatusModelParamsLeft = new HTuple(), hv_StatusModelParamsRight = new HTuple();
    HTuple hv_Index = new HTuple(), hv_ParName = new HTuple();
    HTuple hv_Tuple = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_TupleStr = new HTuple(), hv_StatusEvaluationLeft = new HTuple();
    HTuple hv_StatusEvaluationRight = new HTuple(), hv_BestEvaluationValue = new HTuple();
    HTuple hv_BestEvaluationInfo = new HTuple(), hv_BestEvaluationEpoch = new HTuple();
    HTuple hv_NumEpochs = new HTuple(), hv_BestEvaluationComparisonKeysStr = new HTuple();
    HTuple hv_StatusTrainLeft = new HTuple(), hv_StatusTrainRight = new HTuple();
    HTuple hv_EpochReal = new HTuple(), hv_MeanLoss = new HTuple();
    HTuple hv_MeanLossStr = new HTuple(), hv_StartEpoch = new HTuple();
    HTuple hv_StartTime = new HTuple(), hv_SecondsElapsed = new HTuple();
    HTuple hv_SecondsRemaining = new HTuple(), hv_ProgressPercent = new HTuple();
    HTuple hv_ProgressPerSecond = new HTuple(), hv_TimeElapsedString = new HTuple();
    HTuple hv_TimeRemainingString = new HTuple(), hv_StatusLeft = new HTuple();
    HTuple hv_StatusRight = new HTuple(), hv_MaxChars = new HTuple();
    HTuple hv_Str = new HTuple(), hv_IsString = new HTuple();
    HTuple hv_Length = new HTuple(), hv_SubStr = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
    HTuple hv_WindowTextWidth = new HTuple(), hv_WindowTextHeight = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_PlotBackground);
    //
    //This procedure updates the various texts and plots.
    //It uses precomputed information (TrainInfo, EvaluationInfos,...).
    //
    hv_DisplayEnabled.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayData, "enabled", out hv_DisplayEnabled);
    if ((int)(hv_DisplayEnabled.TupleNot()) != 0)
    {
      ho_PlotBackground.Dispose();

      hv_DisplayEnabled.Dispose();
      hv_DisplayParam.Dispose();
      hv_WindowText.Dispose();
      hv_WindowHandle.Dispose();
      hv_ChangePlotIntervalSeconds.Dispose();
      hv_LastChange.Dispose();
      hv_Seconds.Dispose();
      hv_PlotEval.Dispose();
      hv_TextPlot.Dispose();
      hv_PlotHeadline.Dispose();
      hv_PartRow1.Dispose();
      hv_PartColumn1.Dispose();
      hv_PartRow2.Dispose();
      hv_PartColumn2.Dispose();
      hv__.Dispose();
      hv_Height.Dispose();
      hv_PlotHeight.Dispose();
      hv_TicksX.Dispose();
      hv_TicksY.Dispose();
      hv_StartY.Dispose();
      hv_EndY.Dispose();
      hv_YAxisLabel.Dispose();
      hv_BestEvaluationData.Dispose();
      hv_BestEvaluationComparisonKeys.Dispose();
      hv_Offset.Dispose();
      hv_LogMin.Dispose();
      hv_LogMax.Dispose();
      hv_Scale.Dispose();
      hv_LogOffset.Dispose();
      hv_LogY.Dispose();
      hv_TextModelParams.Dispose();
      hv_ModelParams.Dispose();
      hv_StatusModelParamsLeft.Dispose();
      hv_StatusModelParamsRight.Dispose();
      hv_Index.Dispose();
      hv_ParName.Dispose();
      hv_Tuple.Dispose();
      hv_Exception.Dispose();
      hv_TupleStr.Dispose();
      hv_StatusEvaluationLeft.Dispose();
      hv_StatusEvaluationRight.Dispose();
      hv_BestEvaluationValue.Dispose();
      hv_BestEvaluationInfo.Dispose();
      hv_BestEvaluationEpoch.Dispose();
      hv_NumEpochs.Dispose();
      hv_BestEvaluationComparisonKeysStr.Dispose();
      hv_StatusTrainLeft.Dispose();
      hv_StatusTrainRight.Dispose();
      hv_EpochReal.Dispose();
      hv_MeanLoss.Dispose();
      hv_MeanLossStr.Dispose();
      hv_StartEpoch.Dispose();
      hv_StartTime.Dispose();
      hv_SecondsElapsed.Dispose();
      hv_SecondsRemaining.Dispose();
      hv_ProgressPercent.Dispose();
      hv_ProgressPerSecond.Dispose();
      hv_TimeElapsedString.Dispose();
      hv_TimeRemainingString.Dispose();
      hv_StatusLeft.Dispose();
      hv_StatusRight.Dispose();
      hv_MaxChars.Dispose();
      hv_Str.Dispose();
      hv_IsString.Dispose();
      hv_Length.Dispose();
      hv_SubStr.Dispose();
      hv_Row1.Dispose();
      hv_Column1.Dispose();
      hv_Row2.Dispose();
      hv_Column2.Dispose();
      hv_WindowTextWidth.Dispose();
      hv_WindowTextHeight.Dispose();

      return;
    }
    //
    hv_DisplayParam.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayData, "display_param", out hv_DisplayParam);
    //
    hv_WindowText.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayData, "window_text", out hv_WindowText);
    HOperatorSet.SetWindowParam(hv_WindowText, "flush", "false");
    //Only switch to window if the current window is not the text window (performance).
    if (HDevWindowStack.IsOpen())
    {
      hv_WindowHandle = HDevWindowStack.GetActive();
    }
    if ((int)(new HTuple(hv_WindowHandle.TupleNotEqual(hv_WindowText))) != 0)
    {
      HDevWindowStack.SetActive(hv_WindowText);
      hv_WindowHandle.Dispose();
      hv_WindowHandle = new HTuple(hv_WindowText);
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
    }
    //
    hv_ChangePlotIntervalSeconds.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayParam, "change_plot_interval_seconds", out hv_ChangePlotIntervalSeconds);
    hv_LastChange.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayData, "last_change_plot", out hv_LastChange);
    hv_Seconds.Dispose();
    HOperatorSet.CountSeconds(out hv_Seconds);
    hv_PlotEval.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayData, "plot_eval", out hv_PlotEval);
    if ((int)(new HTuple(((hv_Seconds-hv_LastChange)).TupleGreaterEqual(hv_ChangePlotIntervalSeconds))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PlotEval = (new HTuple(hv_PlotEval.TupleNot()
          )).TupleAnd(new HTuple((new HTuple(hv_EvalEpochs.TupleLength())).TupleGreaterEqual(
          2)));
      hv_PlotEval.Dispose();
      hv_PlotEval = ExpTmpLocalVar_PlotEval;
      }
      }
      HOperatorSet.SetDictTuple(hv_DisplayData, "plot_eval", hv_PlotEval);
      HOperatorSet.SetDictTuple(hv_DisplayData, "last_change_plot", hv_Seconds);
    }
    //
    if ((int)(hv_PlotEval) != 0)
    {
      hv_TextPlot.Dispose();
      hv_TextPlot = "2/2";
    }
    else
    {
      hv_TextPlot.Dispose();
      hv_TextPlot = "1/2";
    }
    hv_PlotHeadline.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PlotHeadline = ("Showing plot "+hv_TextPlot)+":";
    }
    //
    hv_PartRow1.Dispose();hv_PartColumn1.Dispose();hv_PartRow2.Dispose();hv_PartColumn2.Dispose();
    HOperatorSet.GetPart(hv_WindowText, out hv_PartRow1, out hv_PartColumn1, out hv_PartRow2, 
        out hv_PartColumn2);
    hv__.Dispose();hv__.Dispose();hv__.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv__, 
        out hv_Height);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_PlotBackground.Dispose();
    HOperatorSet.GenRectangle1(out ho_PlotBackground, 470, 9, hv_PartRow2-6, hv_PartColumn2-10);
    }
    hv_PlotHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PlotHeight = (((hv_PartRow2-30)-480)*hv_Height)/((hv_PartRow2-hv_PartRow1)+1);
    }
    if ((int)(hv_PlotEval) != 0)
    {
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "white");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_PlotBackground, HDevWindowStack.GetActive());
      }
      hv_TicksX.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TicksX = (new HTuple(0.1)).TupleMax2(
          ((hv_EvalEpochs.TupleMax())-(hv_EvalEpochs.TupleMin()))*0.15);
      }
      hv_TicksY.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TicksY = (new HTuple(0.0001)).TupleMax2(
          ((hv_EvalValues.TupleMax())-(hv_EvalValues.TupleMin()))*0.10);
      }
      hv_StartY.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_StartY = (hv_EvalValues.TupleMin()
          )-(((hv_EvalValues.TupleMax())-(hv_EvalValues.TupleMin()))*0.1);
      }
      hv_EndY.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EndY = (hv_EvalValues.TupleMax()
          )+(((hv_EvalValues.TupleMax())-(hv_EvalValues.TupleMin()))*0.1);
      }

      hv_YAxisLabel.Dispose();
      hv_YAxisLabel = "Evaluation value";
      hv_BestEvaluationData.Dispose();
      HOperatorSet.GetDictTuple(hv_TrainInfo, "best_evaluation", out hv_BestEvaluationData);
      if ((int)(new HTuple((new HTuple(hv_BestEvaluationData.TupleLength())).TupleGreater(
          0))) != 0)
      {
        hv_BestEvaluationComparisonKeys.Dispose();
        HOperatorSet.GetDictTuple(hv_BestEvaluationData, "comparison_keys", out hv_BestEvaluationComparisonKeys);
        hv_YAxisLabel.Dispose();
        hv_YAxisLabel = "Evaluation value";
        if ((int)(new HTuple((new HTuple(hv_BestEvaluationComparisonKeys.TupleLength()
            )).TupleGreater(1))) != 0)
        {
          hv_YAxisLabel.Dispose();
          pretty_print_tuple(hv_BestEvaluationComparisonKeys, out hv_YAxisLabel);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_YAxisLabel = ("mean("+hv_YAxisLabel)+")";
          hv_YAxisLabel.Dispose();
          hv_YAxisLabel = ExpTmpLocalVar_YAxisLabel;
          }
          }
        }
        else
        {
          hv_YAxisLabel.Dispose();
          hv_YAxisLabel = new HTuple(hv_BestEvaluationComparisonKeys);
        }
      }
      //Use a smaller, non-bold font for the plot
      set_display_font(hv_WindowText, 12, "mono", "false", "false");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      plot_tuple_no_window_handling(hv_WindowText, hv_EvalEpochs, hv_EvalValues, 
          "Epochs", hv_YAxisLabel, "#36a2eb", ((((((((((new HTuple("axes_color")).TupleConcat(
          "ticks_x")).TupleConcat("ticks_y")).TupleConcat("start_y")).TupleConcat(
          "end_y")).TupleConcat("margin_top")).TupleConcat("margin_bottom")).TupleConcat(
          "margin_left")).TupleConcat("margin_right")).TupleConcat("line_width")).TupleConcat(
          "axes_color"), (((((((((new HTuple("black")).TupleConcat(hv_TicksX))).TupleConcat(
          hv_TicksY))).TupleConcat(hv_StartY))).TupleConcat(hv_EndY))).TupleConcat(
          (((((new HTuple(480)).TupleConcat(30)).TupleConcat(65)).TupleConcat(35)).TupleConcat(
          3)).TupleConcat("#898b8f")));
      }
      set_display_font(hv_WindowText, 16, "mono", "true", "false");
    }
    else
    {
      if ((int)(new HTuple((new HTuple(hv_Epochs.TupleLength())).TupleGreater(3))) != 0)
      {
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), "white");
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_PlotBackground, HDevWindowStack.GetActive());
        }
        //
        hv_TicksX.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TicksX = (new HTuple(0.1)).TupleMax2(
            ((hv_Epochs.TupleMax())-(hv_Epochs.TupleMin()))*0.15);
        }
        //
        //Set StartY and EndY, such that there is a margin on top and bottom to
        //avoid that the plot overlaps with the axis captions. (With respect to
        //the logarithmic plotting of the Loss function)
        //Set this offset in window coordinates:
        hv_Offset.Dispose();
        hv_Offset = 15;
        //Calculate min max values to determine the correct offset in log
        //coordinates.
        hv_LogMin.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LogMin = (((new HTuple(0.00001)).TupleMax2(
            hv_Loss.TupleMin()))).TupleLog10();
        }
        hv_LogMax.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LogMax = (((new HTuple(0.00001)).TupleMax2(
            hv_Loss.TupleMax()))).TupleLog10();
        }
        //
        if ((int)(new HTuple(((((hv_LogMax-hv_LogMin)).TupleFabs())).TupleLess(0.0001))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_LogMin = hv_LogMin-0.00005;
          hv_LogMin.Dispose();
          hv_LogMin = ExpTmpLocalVar_LogMin;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_LogMax = hv_LogMax+0.00005;
          hv_LogMax.Dispose();
          hv_LogMax = ExpTmpLocalVar_LogMax;
          }
          }
        }
        //
        hv_Scale.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Scale = (hv_LogMax-hv_LogMin)/hv_PlotHeight;
        }
        hv_LogOffset.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LogOffset = hv_Offset*hv_Scale;
        }
        hv_StartY.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_StartY = (new HTuple(10)).TuplePow(
            hv_LogMin-hv_LogOffset);
        }
        hv_EndY.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_EndY = (new HTuple(10)).TuplePow(
            hv_LogMax+hv_LogOffset);
        }
        hv_TicksY.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TicksY = (hv_PlotHeight/10)*hv_Scale;
        }
        //
        //Use a smaller, non-bold font for the plot
        set_display_font(hv_WindowText, 12, "mono", "false", "false");
        hv_LogY.Dispose();
        hv_LogY = "true";
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        plot_tuple_no_window_handling(hv_WindowText, hv_Epochs, hv_Loss, "Epochs", 
            "Loss", "#ff6384", (((((((((((new HTuple("log_y")).TupleConcat("axes_color")).TupleConcat(
            "ticks_x")).TupleConcat("ticks_y")).TupleConcat("start_y")).TupleConcat(
            "end_y")).TupleConcat("margin_top")).TupleConcat("margin_bottom")).TupleConcat(
            "margin_left")).TupleConcat("margin_right")).TupleConcat("line_width")).TupleConcat(
            "axes_color"), ((((((((((hv_LogY.TupleConcat("black"))).TupleConcat(hv_TicksX))).TupleConcat(
            hv_TicksY))).TupleConcat(hv_StartY))).TupleConcat(hv_EndY))).TupleConcat(
            (((((new HTuple(480)).TupleConcat(30)).TupleConcat(65)).TupleConcat(35)).TupleConcat(
            3)).TupleConcat("#898b8f")));
        }
        set_display_font(hv_WindowText, 16, "mono", "true", "false");
      }
      else
      {
        hv_PlotHeadline.Dispose();
        hv_PlotHeadline = "Waiting for data to initialize the plot...";
      }
    }

    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_PlotHeadline, "image", 
          445, 9, "black", "box", "false");
    }
    //
    //Model parameter status.
    hv_TextModelParams.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayParam, "status_model_params", out hv_TextModelParams);
    hv_ModelParams.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainInfo, "model_params", out hv_ModelParams);
    hv_StatusModelParamsLeft.Dispose();
    hv_StatusModelParamsLeft = new HTuple();
    hv_StatusModelParamsRight.Dispose();
    hv_StatusModelParamsRight = new HTuple();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_TextModelParams.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_ParName.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ParName = hv_TextModelParams.TupleSelect(
          hv_Index);
      }
      try
      {
        hv_Tuple.Dispose();
        HOperatorSet.GetDictTuple(hv_ModelParams, hv_ParName, out hv_Tuple);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        continue;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusModelParamsLeft = hv_StatusModelParamsLeft.TupleConcat(
          ("'"+hv_ParName)+"'");
      hv_StatusModelParamsLeft.Dispose();
      hv_StatusModelParamsLeft = ExpTmpLocalVar_StatusModelParamsLeft;
      }
      }

      hv_TupleStr.Dispose();
      pretty_print_tuple(hv_Tuple, out hv_TupleStr);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusModelParamsRight = hv_StatusModelParamsRight.TupleConcat(
          hv_TupleStr);
      hv_StatusModelParamsRight.Dispose();
      hv_StatusModelParamsRight = ExpTmpLocalVar_StatusModelParamsRight;
      }
      }
    }
    if ((int)(new HTuple((new HTuple(hv_StatusModelParamsLeft.TupleLength())).TupleGreater(
        0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusModelParamsLeft = (new HTuple("Model parameters:")).TupleConcat(
          "  "+hv_StatusModelParamsLeft);
      hv_StatusModelParamsLeft.Dispose();
      hv_StatusModelParamsLeft = ExpTmpLocalVar_StatusModelParamsLeft;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusModelParamsRight = (new HTuple(" ")).TupleConcat(
          hv_StatusModelParamsRight);
      hv_StatusModelParamsRight.Dispose();
      hv_StatusModelParamsRight = ExpTmpLocalVar_StatusModelParamsRight;
      }
      }
    }
    //
    //Evaluation status.
    hv_StatusEvaluationLeft.Dispose();
    hv_StatusEvaluationLeft = new HTuple();
    hv_StatusEvaluationRight.Dispose();
    hv_StatusEvaluationRight = new HTuple();
    hv_BestEvaluationData.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainInfo, "best_evaluation", out hv_BestEvaluationData);
    if ((int)(new HTuple((new HTuple(hv_BestEvaluationData.TupleLength())).TupleGreater(
        0))) != 0)
    {
      hv_BestEvaluationComparisonKeys.Dispose();
      HOperatorSet.GetDictTuple(hv_BestEvaluationData, "comparison_keys", out hv_BestEvaluationComparisonKeys);
      hv_BestEvaluationValue.Dispose();
      HOperatorSet.GetDictTuple(hv_BestEvaluationData, "best_value", out hv_BestEvaluationValue);
      hv_BestEvaluationInfo.Dispose();
      HOperatorSet.GetDictTuple(hv_BestEvaluationData, "best_info", out hv_BestEvaluationInfo);
      hv_BestEvaluationEpoch.Dispose();
      HOperatorSet.GetDictTuple(hv_BestEvaluationInfo, "epoch", out hv_BestEvaluationEpoch);
      hv_NumEpochs.Dispose();
      HOperatorSet.GetDictTuple(hv_TrainInfo, "num_epochs", out hv_NumEpochs);
      if ((int)(new HTuple((new HTuple(hv_BestEvaluationComparisonKeys.TupleLength()
          )).TupleGreater(1))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
            "Measures");
        hv_StatusEvaluationLeft.Dispose();
        hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
        }
        }
        hv_BestEvaluationComparisonKeysStr.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BestEvaluationComparisonKeysStr = new HTuple(new HTuple("multiple (")+(new HTuple(hv_BestEvaluationComparisonKeys.TupleLength()
            )))+")";
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
            "Measure");
        hv_StatusEvaluationLeft.Dispose();
        hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
        }
        }
        hv_BestEvaluationComparisonKeysStr.Dispose();
        hv_BestEvaluationComparisonKeysStr = new HTuple(hv_BestEvaluationComparisonKeys);
      }

      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusEvaluationRight = hv_StatusEvaluationRight.TupleConcat(
          hv_BestEvaluationComparisonKeysStr);
      hv_StatusEvaluationRight.Dispose();
      hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
      }
      }

      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
          "Best value");
      hv_StatusEvaluationLeft.Dispose();
      hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusEvaluationRight = hv_StatusEvaluationRight.TupleConcat(
          hv_BestEvaluationValue.TupleString("0.3f"));
      hv_StatusEvaluationRight.Dispose();
      hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
      }
      }

      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
          "Best epoch");
      hv_StatusEvaluationLeft.Dispose();
      hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusEvaluationRight = hv_StatusEvaluationRight.TupleConcat(
          hv_BestEvaluationEpoch.TupleString("0.1f"));
      hv_StatusEvaluationRight.Dispose();
      hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
      }
      }

      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusEvaluationLeft = (new HTuple("Evaluation:")).TupleConcat(
          "  "+hv_StatusEvaluationLeft);
      hv_StatusEvaluationLeft.Dispose();
      hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StatusEvaluationRight = (new HTuple(" ")).TupleConcat(
          hv_StatusEvaluationRight);
      hv_StatusEvaluationRight.Dispose();
      hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
      }
      }
    }
    //
    //Train status.
    hv_StatusTrainLeft.Dispose();
    hv_StatusTrainLeft = new HTuple();
    hv_StatusTrainRight.Dispose();
    hv_StatusTrainRight = new HTuple();
    hv_EpochReal.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainInfo, "epoch", out hv_EpochReal);
    hv_NumEpochs.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainInfo, "num_epochs", out hv_NumEpochs);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
        "Epoch");
    hv_StatusTrainLeft.Dispose();
    hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_StatusTrainRight = hv_StatusTrainRight.TupleConcat(
        ((hv_EpochReal.TupleString(".1f"))+" of ")+hv_NumEpochs);
    hv_StatusTrainRight.Dispose();
    hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
    }
    }
    hv_MeanLoss.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainInfo, "mean_loss", out hv_MeanLoss);
    if ((int)(new HTuple((new HTuple(hv_MeanLoss.TupleLength())).TupleEqual(0))) != 0)
    {
      hv_MeanLossStr.Dispose();
      hv_MeanLossStr = "";
    }
    else
    {
      hv_MeanLossStr.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MeanLossStr = hv_MeanLoss.TupleString(
          "0.4f");
      }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
        "Loss");
    hv_StatusTrainLeft.Dispose();
    hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_StatusTrainRight = hv_StatusTrainRight.TupleConcat(
        hv_MeanLossStr);
    hv_StatusTrainRight.Dispose();
    hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
    }
    }
    //Elapsed and remaining time.
    hv_StartEpoch.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainInfo, "start_epoch", out hv_StartEpoch);
    hv_StartTime.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainInfo, "start_time", out hv_StartTime);
    hv_SecondsElapsed.Dispose();hv_SecondsRemaining.Dispose();hv_ProgressPercent.Dispose();hv_ProgressPerSecond.Dispose();
    estimate_progress(hv_StartTime, hv_StartEpoch, hv_EpochReal, hv_NumEpochs, out hv_SecondsElapsed, 
        out hv_SecondsRemaining, out hv_ProgressPercent, out hv_ProgressPerSecond);
    hv_TimeElapsedString.Dispose();
    timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
    hv_TimeRemainingString.Dispose();
    timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
        (new HTuple("Time elapsed")).TupleConcat("Time left"));
    hv_StatusTrainLeft.Dispose();
    hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_StatusTrainRight = ((hv_StatusTrainRight.TupleConcat(
        hv_TimeElapsedString))).TupleConcat(hv_TimeRemainingString);
    hv_StatusTrainRight.Dispose();
    hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
    }
    }
    //Indent train status items.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_StatusTrainLeft = (new HTuple("Train status:")).TupleConcat(
        "  "+hv_StatusTrainLeft);
    hv_StatusTrainLeft.Dispose();
    hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_StatusTrainRight = (new HTuple(" ")).TupleConcat(
        hv_StatusTrainRight);
    hv_StatusTrainRight.Dispose();
    hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
    }
    }
    //
    //Combine all.
    hv_StatusLeft.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_StatusLeft = new HTuple();
    hv_StatusLeft[0] = "train_dl_model";
    hv_StatusLeft[1] = " ";
    hv_StatusLeft[2] = " ";
    hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusTrainLeft);
    hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
    hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusEvaluationLeft);
    hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
    hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusModelParamsLeft);
    }
    hv_StatusRight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_StatusRight = new HTuple();
    hv_StatusRight[0] = " ";
    hv_StatusRight[1] = " ";
    hv_StatusRight[2] = " ";
    hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusTrainRight);
    hv_StatusRight = hv_StatusRight.TupleConcat(" ");
    hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusEvaluationRight);
    hv_StatusRight = hv_StatusRight.TupleConcat(" ");
    hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusModelParamsRight);
    }
    //
    //Cut strings with too many chars.
    hv_MaxChars.Dispose();
    hv_MaxChars = 14;
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_StatusRight.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_Str.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Str = hv_StatusRight.TupleSelect(
          hv_Index);
      }
      hv_IsString.Dispose();
      HOperatorSet.TupleIsString(hv_Str, out hv_IsString);
      if ((int)(hv_IsString) != 0)
      {
        hv_Length.Dispose();
        HOperatorSet.TupleStrlen(hv_Str, out hv_Length);
        if ((int)(new HTuple(hv_Length.TupleGreater(hv_MaxChars))) != 0)
        {
          hv_SubStr.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SubStr = (hv_Str.TupleSubstr(
              0,hv_MaxChars-3))+"...";
          }
          if (hv_StatusRight == null)
            hv_StatusRight = new HTuple();
          hv_StatusRight[hv_Index] = hv_SubStr;
        }
      }
    }
    //
    //Display the text.
    hv_WindowText.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayData, "window_text", out hv_WindowText);
    //
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_StatusLeft, "window", 
          "top", "left", "black", "box", "false");
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_StatusRight, "window", 
          "top", "right", "black", "box", "false");
    }
    HOperatorSet.FlushBuffer(hv_WindowText);
    HOperatorSet.SetWindowParam(hv_WindowText, "flush", "true");
    hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
    HOperatorSet.GetPart(hv_WindowText, out hv_Row1, out hv_Column1, out hv_Row2, 
        out hv_Column2);
    hv_WindowTextWidth.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayData, "window_text_width", out hv_WindowTextWidth);
    hv_WindowTextHeight.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayData, "window_text_height", out hv_WindowTextHeight);
    if ((int)((new HTuple(((hv_WindowTextWidth-1)).TupleNotEqual(hv_Column2-hv_Column1))).TupleOr(
        new HTuple(((hv_WindowTextHeight-1)).TupleNotEqual(hv_Row2-hv_Row1)))) != 0)
    {
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), hv_Row1, hv_Column1, (hv_Row1+hv_WindowTextHeight)-1, 
            (hv_Column1+hv_WindowTextWidth)-1);
        }
      }
    }
    //
    ho_PlotBackground.Dispose();

    hv_DisplayEnabled.Dispose();
    hv_DisplayParam.Dispose();
    hv_WindowText.Dispose();
    hv_WindowHandle.Dispose();
    hv_ChangePlotIntervalSeconds.Dispose();
    hv_LastChange.Dispose();
    hv_Seconds.Dispose();
    hv_PlotEval.Dispose();
    hv_TextPlot.Dispose();
    hv_PlotHeadline.Dispose();
    hv_PartRow1.Dispose();
    hv_PartColumn1.Dispose();
    hv_PartRow2.Dispose();
    hv_PartColumn2.Dispose();
    hv__.Dispose();
    hv_Height.Dispose();
    hv_PlotHeight.Dispose();
    hv_TicksX.Dispose();
    hv_TicksY.Dispose();
    hv_StartY.Dispose();
    hv_EndY.Dispose();
    hv_YAxisLabel.Dispose();
    hv_BestEvaluationData.Dispose();
    hv_BestEvaluationComparisonKeys.Dispose();
    hv_Offset.Dispose();
    hv_LogMin.Dispose();
    hv_LogMax.Dispose();
    hv_Scale.Dispose();
    hv_LogOffset.Dispose();
    hv_LogY.Dispose();
    hv_TextModelParams.Dispose();
    hv_ModelParams.Dispose();
    hv_StatusModelParamsLeft.Dispose();
    hv_StatusModelParamsRight.Dispose();
    hv_Index.Dispose();
    hv_ParName.Dispose();
    hv_Tuple.Dispose();
    hv_Exception.Dispose();
    hv_TupleStr.Dispose();
    hv_StatusEvaluationLeft.Dispose();
    hv_StatusEvaluationRight.Dispose();
    hv_BestEvaluationValue.Dispose();
    hv_BestEvaluationInfo.Dispose();
    hv_BestEvaluationEpoch.Dispose();
    hv_NumEpochs.Dispose();
    hv_BestEvaluationComparisonKeysStr.Dispose();
    hv_StatusTrainLeft.Dispose();
    hv_StatusTrainRight.Dispose();
    hv_EpochReal.Dispose();
    hv_MeanLoss.Dispose();
    hv_MeanLossStr.Dispose();
    hv_StartEpoch.Dispose();
    hv_StartTime.Dispose();
    hv_SecondsElapsed.Dispose();
    hv_SecondsRemaining.Dispose();
    hv_ProgressPercent.Dispose();
    hv_ProgressPerSecond.Dispose();
    hv_TimeElapsedString.Dispose();
    hv_TimeRemainingString.Dispose();
    hv_StatusLeft.Dispose();
    hv_StatusRight.Dispose();
    hv_MaxChars.Dispose();
    hv_Str.Dispose();
    hv_IsString.Dispose();
    hv_Length.Dispose();
    hv_SubStr.Dispose();
    hv_Row1.Dispose();
    hv_Column1.Dispose();
    hv_Row2.Dispose();
    hv_Column2.Dispose();
    hv_WindowTextWidth.Dispose();
    hv_WindowTextHeight.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Display a map of weights. 
  public void dev_display_weight_regions (HObject ho_ImageWeight, HTuple hv_DrawTransparency, 
      HTuple hv_SegMaxWeight, out HTuple hv_Colors)
  {




    // Local iconic variables 

    HObject ho_Domain, ho_WeightsRegion=null;

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
    HTuple hv_GrayVal = new HTuple(), hv_GrayValWeight = new HTuple();
    HTuple hv_ColorIndex = new HTuple(), hv_ClassColor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Domain);
    HOperatorSet.GenEmptyObj(out ho_WeightsRegion);
    hv_Colors = new HTuple();
    //
    //This procedure displays a map of the weights
    //given in ImageWeight as regions.
    //The transparency can be adjusted.
    //The used colors are returned.
    //
    //Define colors.
    hv_NumColors.Dispose();
    hv_NumColors = 20;
    hv_Colors.Dispose();
    get_distinct_colors(hv_NumColors, 0, 0, 160, out hv_Colors);
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.TupleInverse(hv_Colors, out ExpTmpOutVar_0);
    hv_Colors.Dispose();
    hv_Colors = ExpTmpOutVar_0;
    }
    hv_WeightsColorsAlpha.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WeightsColorsAlpha = hv_Colors+hv_DrawTransparency;
    }
    //
    //Get gay values of ImageWeight.
    ho_Domain.Dispose();
    HOperatorSet.GetDomain(ho_ImageWeight, out ho_Domain);
    hv_Rows.Dispose();hv_Columns.Dispose();
    HOperatorSet.GetRegionPoints(ho_Domain, out hv_Rows, out hv_Columns);
    hv_GrayVal.Dispose();
    HOperatorSet.GetGrayval(ho_ImageWeight, hv_Rows, hv_Columns, out hv_GrayVal);
    //
    //Check that the gray values of the image
    //are below the specified maximum.
    if ((int)(new HTuple(((hv_GrayVal.TupleMax())).TupleGreater(hv_SegMaxWeight))) != 0)
    {
      throw new HalconException(((("The maximum weight ("+(hv_GrayVal.TupleMax()
          ))+") in the weight image is greater than the given SegMaxWeight (")+hv_SegMaxWeight)+").");
    }
    //
    while ((int)(new HTuple(hv_GrayVal.TupleNotEqual(new HTuple()))) != 0)
    {
      //Go through all gray value 'groups',
      //starting from the maximum.
      hv_GrayValWeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_GrayValWeight = hv_GrayVal.TupleMax()
          ;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_GrayVal = hv_GrayVal.TupleRemove(
          hv_GrayVal.TupleFind(hv_GrayValWeight));
      hv_GrayVal.Dispose();
      hv_GrayVal = ExpTmpLocalVar_GrayVal;
      }
      }
      ho_WeightsRegion.Dispose();
      HOperatorSet.Threshold(ho_ImageWeight, out ho_WeightsRegion, hv_GrayValWeight, 
          hv_GrayValWeight);
      //
      //Visualize the respective group.
      hv_ColorIndex.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColorIndex = (((((hv_GrayValWeight/hv_SegMaxWeight)*(hv_NumColors-1))).TupleCeil()
          )).TupleInt();
      }
      hv_ClassColor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassColor = hv_WeightsColorsAlpha.TupleSelect(
          hv_ColorIndex);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ClassColor);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_WeightsRegion, HDevWindowStack.GetActive());
      }
    }
    ho_Domain.Dispose();
    ho_WeightsRegion.Dispose();

    hv_NumColors.Dispose();
    hv_WeightsColorsAlpha.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_GrayVal.Dispose();
    hv_GrayValWeight.Dispose();
    hv_ColorIndex.Dispose();
    hv_ClassColor.Dispose();

    return;
  }

  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
  public void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_ResizeFactor = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_TempWidth = new HTuple();
    HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandle = new HTuple();
    //This procedure opens a new graphics window and adjusts the size
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct image aspect ratio.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority,
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth.Dispose();
      hv_MinWidth = 500;
      hv_MaxWidth.Dispose();
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth.Dispose();
      hv_MinWidth = 0;
      hv_MaxWidth.Dispose();
      hv_MaxWidth = new HTuple(hv_WidthLimit);
    }
    else
    {
      hv_MinWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinWidth = hv_WidthLimit.TupleSelect(
          0);
      }
      hv_MaxWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxWidth = hv_WidthLimit.TupleSelect(
          1);
      }
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight.Dispose();
      hv_MinHeight = 400;
      hv_MaxHeight.Dispose();
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight.Dispose();
      hv_MinHeight = 0;
      hv_MaxHeight.Dispose();
      hv_MaxHeight = new HTuple(hv_HeightLimit);
    }
    else
    {
      hv_MinHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinHeight = hv_HeightLimit.TupleSelect(
          0);
      }
      hv_MaxHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxHeight = hv_HeightLimit.TupleSelect(
          1);
      }
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor.Dispose();
    hv_ResizeFactor = 1;
    hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_ImageHeight)))) != 0)
    {
      hv_ResizeFactor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
          )/hv_ImageWidth)).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight))).TupleMax()
          ;
      }
    }
    hv_TempWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
    }
    hv_TempHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
    }
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal()
          )/hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin()
          );
      hv_ResizeFactor.Dispose();
      hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
      }
      }
    }
    hv_WindowWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
    }
    hv_WindowHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
    }
    //Resize window
    HOperatorSet.SetWindowAttr("background_color","black");
    HOperatorSet.OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",out hv_WindowHandle);
    HDevWindowStack.Push(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
      }
    }

    hv_MinWidth.Dispose();
    hv_MaxWidth.Dispose();
    hv_MinHeight.Dispose();
    hv_MaxHeight.Dispose();
    hv_ResizeFactor.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_TempWidth.Dispose();
    hv_TempHeight.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();

    return;
  }

  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
  public void dev_open_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
      HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
    HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandle = new HTuple();
    //This procedure open a new graphic window
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct aspect ratio
    //given by Width and Height.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority.
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth.Dispose();
      hv_MinWidth = 500;
      hv_MaxWidth.Dispose();
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth.Dispose();
      hv_MinWidth = 0;
      hv_MaxWidth.Dispose();
      hv_MaxWidth = new HTuple(hv_WidthLimit);
    }
    else
    {
      hv_MinWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinWidth = hv_WidthLimit.TupleSelect(
          0);
      }
      hv_MaxWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxWidth = hv_WidthLimit.TupleSelect(
          1);
      }
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight.Dispose();
      hv_MinHeight = 400;
      hv_MaxHeight.Dispose();
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight.Dispose();
      hv_MinHeight = 0;
      hv_MaxHeight.Dispose();
      hv_MaxHeight = new HTuple(hv_HeightLimit);
    }
    else
    {
      hv_MinHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinHeight = hv_HeightLimit.TupleSelect(
          0);
      }
      hv_MaxHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxHeight = hv_HeightLimit.TupleSelect(
          1);
      }
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor.Dispose();
    hv_ResizeFactor = 1;
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_Height)))) != 0)
    {
      hv_ResizeFactor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
          )/hv_Width)).TupleConcat((hv_MinHeight.TupleReal())/hv_Height))).TupleMax()
          ;
      }
    }
    hv_TempWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TempWidth = hv_Width*hv_ResizeFactor;
    }
    hv_TempHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TempHeight = hv_Height*hv_ResizeFactor;
    }
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal()
          )/hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin()
          );
      hv_ResizeFactor.Dispose();
      hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
      }
      }
    }
    hv_WindowWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowWidth = hv_Width*hv_ResizeFactor;
    }
    hv_WindowHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowHeight = hv_Height*hv_ResizeFactor;
    }
    //Resize window
    HOperatorSet.SetWindowAttr("background_color","black");
    HOperatorSet.OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",out hv_WindowHandle);
    HDevWindowStack.Push(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height-1, hv_Width-1);
      }
    }

    hv_MinWidth.Dispose();
    hv_MaxWidth.Dispose();
    hv_MinHeight.Dispose();
    hv_MaxHeight.Dispose();
    hv_ResizeFactor.Dispose();
    hv_TempWidth.Dispose();
    hv_TempHeight.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();

    return;
  }

  // Chapter: Develop
  // Short Description: Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image 
  public void dev_resize_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_WidthLimit, HTuple hv_HeightLimit)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_ResizeFactor = new HTuple(), hv_Pointer = new HTuple();
    HTuple hv_Type = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_TempWidth = new HTuple();
    HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple();
    // Initialize local and output iconic variables 
    //This procedure adjusts the size of the current window
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct image aspect ratio.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority,
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth.Dispose();
      hv_MinWidth = 500;
      hv_MaxWidth.Dispose();
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth.Dispose();
      hv_MinWidth = 0;
      hv_MaxWidth.Dispose();
      hv_MaxWidth = new HTuple(hv_WidthLimit);
    }
    else
    {
      hv_MinWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinWidth = hv_WidthLimit.TupleSelect(
          0);
      }
      hv_MaxWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxWidth = hv_WidthLimit.TupleSelect(
          1);
      }
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight.Dispose();
      hv_MinHeight = 400;
      hv_MaxHeight.Dispose();
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight.Dispose();
      hv_MinHeight = 0;
      hv_MaxHeight.Dispose();
      hv_MaxHeight = new HTuple(hv_HeightLimit);
    }
    else
    {
      hv_MinHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinHeight = hv_HeightLimit.TupleSelect(
          0);
      }
      hv_MaxHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxHeight = hv_HeightLimit.TupleSelect(
          1);
      }
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor.Dispose();
    hv_ResizeFactor = 1;
    hv_Pointer.Dispose();hv_Type.Dispose();hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
    HOperatorSet.GetImagePointer1(ho_Image, out hv_Pointer, out hv_Type, out hv_ImageWidth, 
        out hv_ImageHeight);
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_ImageHeight)))) != 0)
    {
      hv_ResizeFactor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
          )/hv_ImageWidth)).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight))).TupleMax()
          ;
      }
    }
    hv_TempWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
    }
    hv_TempHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
    }
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal()
          )/hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin()
          );
      hv_ResizeFactor.Dispose();
      hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
      }
      }
    }
    hv_WindowWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
    }
    hv_WindowHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
    }
    //Resize window
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_Row, hv_Column, 
          hv_WindowWidth, hv_WindowHeight);
    }
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
      }
    }

    hv_MinWidth.Dispose();
    hv_MaxWidth.Dispose();
    hv_MinHeight.Dispose();
    hv_MaxHeight.Dispose();
    hv_ResizeFactor.Dispose();
    hv_Pointer.Dispose();
    hv_Type.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_TempWidth.Dispose();
    hv_TempHeight.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();

    return;
  }

  // Chapter: Develop
  // Short Description: Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
  public void dev_resize_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
      HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
    HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple();
    // Initialize local and output iconic variables 
    //This procedure adjusts the size of the current window
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct aspect ratio
    //given by Width and Height.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority.
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth.Dispose();
      hv_MinWidth = 500;
      hv_MaxWidth.Dispose();
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth.Dispose();
      hv_MinWidth = 0;
      hv_MaxWidth.Dispose();
      hv_MaxWidth = new HTuple(hv_WidthLimit);
    }
    else
    {
      hv_MinWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinWidth = hv_WidthLimit.TupleSelect(
          0);
      }
      hv_MaxWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxWidth = hv_WidthLimit.TupleSelect(
          1);
      }
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight.Dispose();
      hv_MinHeight = 400;
      hv_MaxHeight.Dispose();
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight.Dispose();
      hv_MinHeight = 0;
      hv_MaxHeight.Dispose();
      hv_MaxHeight = new HTuple(hv_HeightLimit);
    }
    else
    {
      hv_MinHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinHeight = hv_HeightLimit.TupleSelect(
          0);
      }
      hv_MaxHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxHeight = hv_HeightLimit.TupleSelect(
          1);
      }
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor.Dispose();
    hv_ResizeFactor = 1;
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_Height)))) != 0)
    {
      hv_ResizeFactor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
          )/hv_Width)).TupleConcat((hv_MinHeight.TupleReal())/hv_Height))).TupleMax()
          ;
      }
    }
    hv_TempWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TempWidth = hv_Width*hv_ResizeFactor;
    }
    hv_TempHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TempHeight = hv_Height*hv_ResizeFactor;
    }
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal()
          )/hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin()
          );
      hv_ResizeFactor.Dispose();
      hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
      }
      }
    }
    hv_WindowWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowWidth = hv_Width*hv_ResizeFactor;
    }
    hv_WindowHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowHeight = hv_Height*hv_ResizeFactor;
    }
    //Resize window
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_Row, hv_Column, 
          hv_WindowWidth, hv_WindowHeight);
    }
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height-1, hv_Width-1);
      }
    }

    hv_MinWidth.Dispose();
    hv_MaxWidth.Dispose();
    hv_MinHeight.Dispose();
    hv_MaxHeight.Dispose();
    hv_ResizeFactor.Dispose();
    hv_TempWidth.Dispose();
    hv_TempHeight.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();

    return;
  }

  // Chapter: Develop
  // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
  public void dev_update_off ()
  {

    // Initialize local and output iconic variables 
    //This procedure sets different update settings to 'off'.
    //This is useful to get the best performance and reduce overhead.
    //
    // dev_update_pc(...); only in hdevelop
    // dev_update_var(...); only in hdevelop
    // dev_update_window(...); only in hdevelop


    return;
  }

  // Chapter: Develop
  // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'on'. 
  public void dev_update_on ()
  {

    // Initialize local and output iconic variables 
    //This procedure sets different update settings to 'on'.
    //
    // dev_update_pc(...); only in hdevelop
    // dev_update_var(...); only in hdevelop
    // dev_update_window(...); only in hdevelop


    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Display the axes of a 3d coordinate system 
  public void disp_3d_coord_system (HTuple hv_WindowHandle, HTuple hv_CamParam, HTuple hv_Pose, 
      HTuple hv_CoordAxesLength)
  {



    // Local iconic variables 

    HObject ho_Arrows;

    // Local control variables 

    HTuple hv_CameraType = new HTuple(), hv_IsTelecentric = new HTuple();
    HTuple hv_TransWorld2Cam = new HTuple(), hv_OrigCamX = new HTuple();
    HTuple hv_OrigCamY = new HTuple(), hv_OrigCamZ = new HTuple();
    HTuple hv_Row0 = new HTuple(), hv_Column0 = new HTuple();
    HTuple hv_X = new HTuple(), hv_Y = new HTuple(), hv_Z = new HTuple();
    HTuple hv_RowAxX = new HTuple(), hv_ColumnAxX = new HTuple();
    HTuple hv_RowAxY = new HTuple(), hv_ColumnAxY = new HTuple();
    HTuple hv_RowAxZ = new HTuple(), hv_ColumnAxZ = new HTuple();
    HTuple hv_Distance = new HTuple(), hv_HeadLength = new HTuple();
    HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
    HTuple hv_Blue = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Arrows);
    //This procedure displays a 3D coordinate system.
    //It needs the procedure gen_arrow_contour_xld.
    //
    //Input parameters:
    //WindowHandle: The window where the coordinate system shall be displayed
    //CamParam: The camera paramters
    //Pose: The pose to be displayed
    //CoordAxesLength: The length of the coordinate axes in world coordinates
    //
    //Check, if Pose is a correct pose tuple.
    if ((int)(new HTuple((new HTuple(hv_Pose.TupleLength())).TupleNotEqual(7))) != 0)
    {
      ho_Arrows.Dispose();

      hv_CameraType.Dispose();
      hv_IsTelecentric.Dispose();
      hv_TransWorld2Cam.Dispose();
      hv_OrigCamX.Dispose();
      hv_OrigCamY.Dispose();
      hv_OrigCamZ.Dispose();
      hv_Row0.Dispose();
      hv_Column0.Dispose();
      hv_X.Dispose();
      hv_Y.Dispose();
      hv_Z.Dispose();
      hv_RowAxX.Dispose();
      hv_ColumnAxX.Dispose();
      hv_RowAxY.Dispose();
      hv_ColumnAxY.Dispose();
      hv_RowAxZ.Dispose();
      hv_ColumnAxZ.Dispose();
      hv_Distance.Dispose();
      hv_HeadLength.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();

      return;
    }
    hv_CameraType.Dispose();
    get_cam_par_data(hv_CamParam, "camera_type", out hv_CameraType);
    hv_IsTelecentric.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IsTelecentric = new HTuple(((hv_CameraType.TupleStrstr(
        "telecentric"))).TupleNotEqual(-1));
    }
    if ((int)((new HTuple(((hv_Pose.TupleSelect(2))).TupleEqual(0.0))).TupleAnd(hv_IsTelecentric.TupleNot()
        )) != 0)
    {
      //For projective cameras:
      //Poses with Z position zero cannot be projected
      //(that would lead to a division by zero error).
      ho_Arrows.Dispose();

      hv_CameraType.Dispose();
      hv_IsTelecentric.Dispose();
      hv_TransWorld2Cam.Dispose();
      hv_OrigCamX.Dispose();
      hv_OrigCamY.Dispose();
      hv_OrigCamZ.Dispose();
      hv_Row0.Dispose();
      hv_Column0.Dispose();
      hv_X.Dispose();
      hv_Y.Dispose();
      hv_Z.Dispose();
      hv_RowAxX.Dispose();
      hv_ColumnAxX.Dispose();
      hv_RowAxY.Dispose();
      hv_ColumnAxY.Dispose();
      hv_RowAxZ.Dispose();
      hv_ColumnAxZ.Dispose();
      hv_Distance.Dispose();
      hv_HeadLength.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();

      return;
    }
    //Convert to pose to a transformation matrix
    hv_TransWorld2Cam.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_Pose, out hv_TransWorld2Cam);
    //Project the world origin into the image
    hv_OrigCamX.Dispose();hv_OrigCamY.Dispose();hv_OrigCamZ.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_TransWorld2Cam, 0, 0, 0, out hv_OrigCamX, 
        out hv_OrigCamY, out hv_OrigCamZ);
    hv_Row0.Dispose();hv_Column0.Dispose();
    HOperatorSet.Project3dPoint(hv_OrigCamX, hv_OrigCamY, hv_OrigCamZ, hv_CamParam, 
        out hv_Row0, out hv_Column0);
    //Project the coordinate axes into the image
    hv_X.Dispose();hv_Y.Dispose();hv_Z.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_TransWorld2Cam, hv_CoordAxesLength, 0, 0, 
        out hv_X, out hv_Y, out hv_Z);
    hv_RowAxX.Dispose();hv_ColumnAxX.Dispose();
    HOperatorSet.Project3dPoint(hv_X, hv_Y, hv_Z, hv_CamParam, out hv_RowAxX, out hv_ColumnAxX);
    hv_X.Dispose();hv_Y.Dispose();hv_Z.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_TransWorld2Cam, 0, hv_CoordAxesLength, 0, 
        out hv_X, out hv_Y, out hv_Z);
    hv_RowAxY.Dispose();hv_ColumnAxY.Dispose();
    HOperatorSet.Project3dPoint(hv_X, hv_Y, hv_Z, hv_CamParam, out hv_RowAxY, out hv_ColumnAxY);
    hv_X.Dispose();hv_Y.Dispose();hv_Z.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_TransWorld2Cam, 0, 0, hv_CoordAxesLength, 
        out hv_X, out hv_Y, out hv_Z);
    hv_RowAxZ.Dispose();hv_ColumnAxZ.Dispose();
    HOperatorSet.Project3dPoint(hv_X, hv_Y, hv_Z, hv_CamParam, out hv_RowAxZ, out hv_ColumnAxZ);
    //
    //Generate an XLD contour for each axis
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Distance.Dispose();
    HOperatorSet.DistancePp(((hv_Row0.TupleConcat(hv_Row0))).TupleConcat(hv_Row0), 
        ((hv_Column0.TupleConcat(hv_Column0))).TupleConcat(hv_Column0), ((hv_RowAxX.TupleConcat(
        hv_RowAxY))).TupleConcat(hv_RowAxZ), ((hv_ColumnAxX.TupleConcat(hv_ColumnAxY))).TupleConcat(
        hv_ColumnAxZ), out hv_Distance);
    }
    hv_HeadLength.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HeadLength = (((((((hv_Distance.TupleMax()
        )/12.0)).TupleConcat(5.0))).TupleMax())).TupleInt();
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_Arrows.Dispose();
    gen_arrow_contour_xld(out ho_Arrows, ((hv_Row0.TupleConcat(hv_Row0))).TupleConcat(
        hv_Row0), ((hv_Column0.TupleConcat(hv_Column0))).TupleConcat(hv_Column0), 
        ((hv_RowAxX.TupleConcat(hv_RowAxY))).TupleConcat(hv_RowAxZ), ((hv_ColumnAxX.TupleConcat(
        hv_ColumnAxY))).TupleConcat(hv_ColumnAxZ), hv_HeadLength, hv_HeadLength);
    }
    //
    //Display coordinate system
    HOperatorSet.DispXld(ho_Arrows, hv_WindowHandle);
    //
    hv_Red.Dispose();hv_Green.Dispose();hv_Blue.Dispose();
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red.TupleSelect(0), hv_Green.TupleSelect(
        0), hv_Blue.TupleSelect(0));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetTposition(hv_WindowHandle, hv_RowAxX+3, hv_ColumnAxX+3);
    }
    HOperatorSet.WriteString(hv_WindowHandle, "X");
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red.TupleSelect(1%(new HTuple(hv_Red.TupleLength()
        ))), hv_Green.TupleSelect(1%(new HTuple(hv_Green.TupleLength()))), hv_Blue.TupleSelect(
        1%(new HTuple(hv_Blue.TupleLength()))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetTposition(hv_WindowHandle, hv_RowAxY+3, hv_ColumnAxY+3);
    }
    HOperatorSet.WriteString(hv_WindowHandle, "Y");
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red.TupleSelect(2%(new HTuple(hv_Red.TupleLength()
        ))), hv_Green.TupleSelect(2%(new HTuple(hv_Green.TupleLength()))), hv_Blue.TupleSelect(
        2%(new HTuple(hv_Blue.TupleLength()))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetTposition(hv_WindowHandle, hv_RowAxZ+3, hv_ColumnAxZ+3);
    }
    HOperatorSet.WriteString(hv_WindowHandle, "Z");
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    ho_Arrows.Dispose();

    hv_CameraType.Dispose();
    hv_IsTelecentric.Dispose();
    hv_TransWorld2Cam.Dispose();
    hv_OrigCamX.Dispose();
    hv_OrigCamY.Dispose();
    hv_OrigCamZ.Dispose();
    hv_Row0.Dispose();
    hv_Column0.Dispose();
    hv_X.Dispose();
    hv_Y.Dispose();
    hv_Z.Dispose();
    hv_RowAxX.Dispose();
    hv_ColumnAxX.Dispose();
    hv_RowAxY.Dispose();
    hv_ColumnAxY.Dispose();
    hv_RowAxZ.Dispose();
    hv_ColumnAxZ.Dispose();
    hv_Distance.Dispose();
    hv_HeadLength.Dispose();
    hv_Red.Dispose();
    hv_Green.Dispose();
    hv_Blue.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Displays a continue button. 
  public void disp_buttons (HTuple hv_Parameters, HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_gButtons = new HTuple(), hv_idx = new HTuple();
    HTuple hv_Message = new HTuple();
    // Initialize local and output iconic variables 
    //This procedure displays all Buttons in the window.
    //
    //Input parameters:
    //WindowHandle: The window, where the text shall be displayed
    //
    //Use the buttons set in the global variable gButtons.
    hv_gButtons.Dispose();
    HOperatorSet.GetMessageTuple(hv_Parameters, "gButtons", out hv_gButtons);

    for (hv_idx=0; (int)hv_idx<=(int)((new HTuple(hv_gButtons.TupleLength()))-1); hv_idx = (int)hv_idx + 5)
    {
      //Display the continue button
      hv_Message.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Message = hv_gButtons.TupleSelect(
          hv_idx+0);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      disp_text_button(hv_WindowHandle, hv_Message, "window", hv_gButtons.TupleSelect(
          hv_idx+2), hv_gButtons.TupleSelect(hv_idx+1), "black", "#f28f26");
      }
      //Debug the computed area
      //gen_rectangle1 (Rectangle, gButtons[idx + 2], gButtons[idx + 1], gButtons[idx + 4], gButtons[idx + 3])
      //set_color (WindowHandle, 'white')
      //set_color (WindowHandle, '#ffffFFEE')
      //disp_obj (Rectangle, WindowHandle)
    }

    hv_gButtons.Dispose();
    hv_idx.Dispose();
    hv_Message.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Displays a continue button. 
  public void disp_continue_button (HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ContinueMessage = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv_TextWidth = new HTuple(), hv_TextHeight = new HTuple();
    // Initialize local and output iconic variables 
    //This procedure displays a 'Continue' text button
    //in the lower right corner of the screen.
    //It uses the procedure disp_message.
    //
    //Input parameters:
    //WindowHandle: The window, where the text shall be displayed
    //
    //Use the continue message set in the global variable gTerminationButtonLabel.
    //If this variable is not defined, set a standard text instead.
    //global tuple gTerminationButtonLabel
    try
    {
      hv_ContinueMessage.Dispose();
      hv_ContinueMessage = new HTuple(ExpGetGlobalVar_gTerminationButtonLabel());
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_ContinueMessage.Dispose();
      hv_ContinueMessage = "Continue";
    }
    //Display the continue button
    hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width, 
        out hv_Height);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
    HOperatorSet.GetStringExtents(hv_WindowHandle, (" "+hv_ContinueMessage)+" ", 
        out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    disp_text_button(hv_WindowHandle, hv_ContinueMessage, "window", (hv_Height-hv_TextHeight)-22, 
        (hv_Width-hv_TextWidth)-12, "black", "#f28f26");
    }

    hv_ContinueMessage.Dispose();
    hv_Exception.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_TextWidth.Dispose();
    hv_TextHeight.Dispose();

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
  public void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_GenParamName = new HTuple(), hv_GenParamValue = new HTuple();
    HTuple hv_ContinueMessage = new HTuple();
    HTuple   hv_Color_COPY_INP_TMP = new HTuple(hv_Color);

    // Initialize local and output iconic variables 
    //This procedure displays 'Press Run (F5) to continue' in the
    //lower right corner of the screen.
    //It uses the procedure disp_message.
    //
    //Input parameters:
    //WindowHandle: The window, where the text shall be displayed
    //Color: defines the text color.
    //   If set to '' or 'auto', the currently set color is used.
    //Box: If set to 'true', the text is displayed in a box.
    //
    //Convert the parameter Box to generic parameters.
    hv_GenParamName.Dispose();
    hv_GenParamName = new HTuple();
    hv_GenParamValue.Dispose();
    hv_GenParamValue = new HTuple();
    if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
    {
      if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
      {
        //Display no box
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "box");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            "false");
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
      {
        //Set a color other than the default.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "box_color");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            hv_Box.TupleSelect(0));
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
    }
    if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
    {
      if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
      {
        //Display no shadow.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "shadow");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            "false");
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
      {
        //Set a shadow color other than the default.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "shadow_color");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            hv_Box.TupleSelect(1));
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
    }
    //
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
    {
      //disp_text does not accept an empty string for Color.
      hv_Color_COPY_INP_TMP.Dispose();
      hv_Color_COPY_INP_TMP = new HTuple();
    }
    //
    //Display the message.
    hv_ContinueMessage.Dispose();
    hv_ContinueMessage = "Press Run (F5) to continue";
    HOperatorSet.DispText(hv_WindowHandle, hv_ContinueMessage, "window", "bottom", 
        "right", hv_Color_COPY_INP_TMP, hv_GenParamName, hv_GenParamValue);

    hv_Color_COPY_INP_TMP.Dispose();
    hv_GenParamName.Dispose();
    hv_GenParamValue.Dispose();
    hv_ContinueMessage.Dispose();

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure displays 'End of program' in the lower right corner of the screen. 
  public void disp_end_of_program_message (HTuple hv_WindowHandle, HTuple hv_Color, 
      HTuple hv_Box)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_GenParamName = new HTuple(), hv_GenParamValue = new HTuple();
    HTuple hv_EndMessage = new HTuple();
    HTuple   hv_Color_COPY_INP_TMP = new HTuple(hv_Color);

    // Initialize local and output iconic variables 
    //This procedure displays 'End of program' in the
    //lower right corner of the screen.
    //It uses the procedure disp_message.
    //
    //Input parameters:
    //WindowHandle: The window, where the text shall be displayed
    //Color: defines the text color.
    //   If set to '' or 'auto', the currently set color is used.
    //Box: If set to 'true', the text is displayed in a box.
    //
    //Convert the parameter Box to generic parameters.
    hv_GenParamName.Dispose();
    hv_GenParamName = new HTuple();
    hv_GenParamValue.Dispose();
    hv_GenParamValue = new HTuple();
    if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
    {
      if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
      {
        //Display no box
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "box");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            "false");
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
      {
        //Set a color other than the default.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "box_color");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            hv_Box.TupleSelect(0));
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
    }
    if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
    {
      if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
      {
        //Display no shadow.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "shadow");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            "false");
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
      {
        //Set a shadow color other than the default.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "shadow_color");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            hv_Box.TupleSelect(1));
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
    }
    //
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
    {
      //disp_text does not accept an empty string for Color.
      hv_Color_COPY_INP_TMP.Dispose();
      hv_Color_COPY_INP_TMP = new HTuple();
    }
    //
    //Display the message.
    hv_EndMessage.Dispose();
    hv_EndMessage = "      End of program      ";
    HOperatorSet.DispText(hv_WindowHandle, hv_EndMessage, "window", "bottom", "right", 
        hv_Color_COPY_INP_TMP, hv_GenParamName, hv_GenParamValue);

    hv_Color_COPY_INP_TMP.Dispose();
    hv_GenParamName.Dispose();
    hv_GenParamValue.Dispose();
    hv_EndMessage.Dispose();

    return;
  }

  public void disp_menu_ext (HObject ho_MenuRegions, HTuple hv_WindowHandleMenu, 
      HTuple hv_MenuText, HTuple hv_CasesDone, HTuple hv_CurrentCase)
  {




    // Local iconic variables 

    HObject ho_MenuRegion=null, ho_RegionBorder=null;
    HObject ho_Contour=null;

    // Local control variables 

    HTuple hv_NumberRegions = new HTuple(), hv_NumberTexts = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Width1 = new HTuple(), hv_Height1 = new HTuple();
    HTuple hv_i = new HTuple(), hv_Text = new HTuple(), hv_Rows = new HTuple();
    HTuple hv_Cols = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_Done = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_Col = new HTuple();
    HTuple hv_Scale = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_MenuRegion);
    HOperatorSet.GenEmptyObj(out ho_RegionBorder);
    HOperatorSet.GenEmptyObj(out ho_Contour);
    //Display the previously created menu buttons
    hv_NumberRegions.Dispose();
    HOperatorSet.CountObj(ho_MenuRegions, out hv_NumberRegions);
    hv_NumberTexts.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumberTexts = new HTuple(hv_MenuText.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumberRegions.TupleLess(hv_NumberTexts))) != 0)
    {
      throw new HalconException((("Too few regions for the given number of texts: "+hv_NumberRegions)+" vs. ")+hv_NumberTexts);
    }

    HOperatorSet.ClearWindow(hv_WindowHandleMenu);
    hv_Row.Dispose();hv_Column.Dispose();hv_Width1.Dispose();hv_Height1.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandleMenu, out hv_Row, out hv_Column, 
        out hv_Width1, out hv_Height1);

    HTuple end_val10 = hv_NumberTexts;
    HTuple step_val10 = 1;
    for (hv_i=1; hv_i.Continue(end_val10, step_val10); hv_i = hv_i.TupleAdd(step_val10))
    {
      ho_MenuRegion.Dispose();
      HOperatorSet.SelectObj(ho_MenuRegions, out ho_MenuRegion, hv_i);
      hv_Text.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Text = hv_MenuText.TupleSelect(
          hv_i-1);
      }
      HOperatorSet.SetColor(hv_WindowHandleMenu, "light gray");
      HDevWindowStack.SetActive(hv_WindowHandleMenu);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "light gray");
      }
      HOperatorSet.DispRegion(ho_MenuRegion, hv_WindowHandleMenu);
      hv_Rows.Dispose();hv_Cols.Dispose();
      HOperatorSet.GetRegionContour(ho_MenuRegion, out hv_Rows, out hv_Cols);
      HOperatorSet.SetColor(hv_WindowHandleMenu, "dim gray");
      ho_RegionBorder.Dispose();
      HOperatorSet.GenRegionPoints(out ho_RegionBorder, hv_Rows, hv_Cols);
      HOperatorSet.DispRegion(ho_RegionBorder, hv_WindowHandleMenu);
      //
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices.Dispose();
      HOperatorSet.TupleFind(hv_CasesDone, hv_i-1, out hv_Indices);
      }
      hv_Done.Dispose();
      hv_Done = 0;
      if ((int)(new HTuple(((hv_i-1)).TupleEqual(hv_CurrentCase))) != 0)
      {
        HOperatorSet.SetColor(hv_WindowHandleMenu, "#FA8072");
      }
      else if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(
          new HTuple(hv_Indices.TupleNotEqual(new HTuple())))) != 0)
      {
        HOperatorSet.SetColor(hv_WindowHandleMenu, "#228B22");
        hv_Done.Dispose();
        hv_Done = 1;
      }
      else
      {
        HOperatorSet.SetColor(hv_WindowHandleMenu, "#B22222");
      }
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandleMenu, hv_Text, out hv_Ascent, 
          out hv_Descent, out hv_Width, out hv_Height);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetTposition(hv_WindowHandleMenu, (hv_Rows.TupleMin())+6, (((hv_Cols.TupleMax()
          )+(hv_Cols.TupleMin()))/2)-(hv_Width/2));
      }
      HOperatorSet.WriteString(hv_WindowHandleMenu, hv_Text);
      if ((int)(hv_Done) != 0)
      {
        hv_Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row = 0.5*((hv_Rows.TupleMax()
            )+(hv_Rows.TupleMin()));
        }
        hv_Col.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Col = ((((hv_Cols.TupleMax()
            )+(hv_Cols.TupleMin()))/2)+(hv_Width/2))+15;
        }
        hv_Scale.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Scale = (hv_Rows.TupleMax()
            )-(hv_Rows.TupleMin());
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Contour.Dispose();
        HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_Row+((((((-hv_Scale)*0.2)).TupleConcat(
            0))).TupleConcat((-hv_Scale)*0.35)), hv_Col+((((new HTuple(0)).TupleConcat(
            hv_Scale*0.12))).TupleConcat(hv_Scale*0.24)));
        }
        HOperatorSet.SetLineWidth(hv_WindowHandleMenu, 2);
        HOperatorSet.DispObj(ho_Contour, hv_WindowHandleMenu);
      }
    }
    ho_MenuRegion.Dispose();
    ho_RegionBorder.Dispose();
    ho_Contour.Dispose();

    hv_NumberRegions.Dispose();
    hv_NumberTexts.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width1.Dispose();
    hv_Height1.Dispose();
    hv_i.Dispose();
    hv_Text.Dispose();
    hv_Rows.Dispose();
    hv_Cols.Dispose();
    hv_Indices.Dispose();
    hv_Done.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_Col.Dispose();
    hv_Scale.Dispose();

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure writes a text message. 
  public void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_GenParamName = new HTuple(), hv_GenParamValue = new HTuple();
    HTuple   hv_Color_COPY_INP_TMP = new HTuple(hv_Color);
    HTuple   hv_Column_COPY_INP_TMP = new HTuple(hv_Column);
    HTuple   hv_CoordSystem_COPY_INP_TMP = new HTuple(hv_CoordSystem);
    HTuple   hv_Row_COPY_INP_TMP = new HTuple(hv_Row);

    // Initialize local and output iconic variables 
    //This procedure displays text in a graphics window.
    //
    //Input parameters:
    //WindowHandle: The WindowHandle of the graphics window, where
    //   the message should be displayed
    //String: A tuple of strings containing the text message to be displayed
    //CoordSystem: If set to 'window', the text position is given
    //   with respect to the window coordinate system.
    //   If set to 'image', image coordinates are used.
    //   (This may be useful in zoomed images.)
    //Row: The row coordinate of the desired text position
    //   A tuple of values is allowed to display text at different
    //   positions.
    //Column: The column coordinate of the desired text position
    //   A tuple of values is allowed to display text at different
    //   positions.
    //Color: defines the color of the text as string.
    //   If set to [], '' or 'auto' the currently set color is used.
    //   If a tuple of strings is passed, the colors are used cyclically...
    //   - if |Row| == |Column| == 1: for each new textline
    //   = else for each text position.
    //Box: If Box[0] is set to 'true', the text is written within an orange box.
    //     If set to' false', no box is displayed.
    //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
    //       the text is written in a box of that color.
    //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
    //       'true' -> display a shadow in a default color
    //       'false' -> display no shadow
    //       otherwise -> use given string as color string for the shadow color
    //
    //It is possible to display multiple text strings in a single call.
    //In this case, some restrictions apply:
    //- Multiple text positions can be defined by specifying a tuple
    //  with multiple Row and/or Column coordinates, i.e.:
    //  - |Row| == n, |Column| == n
    //  - |Row| == n, |Column| == 1
    //  - |Row| == 1, |Column| == n
    //- If |Row| == |Column| == 1,
    //  each element of String is display in a new textline.
    //- If multiple positions or specified, the number of Strings
    //  must match the number of positions, i.e.:
    //  - Either |String| == n (each string is displayed at the
    //                          corresponding position),
    //  - or     |String| == 1 (The string is displayed n times).
    //
    //
    //Convert the parameters for disp_text.
    if ((int)((new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
        new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
    {

      hv_Color_COPY_INP_TMP.Dispose();
      hv_Column_COPY_INP_TMP.Dispose();
      hv_CoordSystem_COPY_INP_TMP.Dispose();
      hv_Row_COPY_INP_TMP.Dispose();
      hv_GenParamName.Dispose();
      hv_GenParamValue.Dispose();

      return;
    }
    if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Row_COPY_INP_TMP.Dispose();
      hv_Row_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Column_COPY_INP_TMP.Dispose();
      hv_Column_COPY_INP_TMP = 12;
    }
    //
    //Convert the parameter Box to generic parameters.
    hv_GenParamName.Dispose();
    hv_GenParamName = new HTuple();
    hv_GenParamValue.Dispose();
    hv_GenParamValue = new HTuple();
    if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
    {
      if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
      {
        //Display no box
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "box");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            "false");
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
      {
        //Set a color other than the default.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "box_color");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            hv_Box.TupleSelect(0));
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
    }
    if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
    {
      if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
      {
        //Display no shadow.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "shadow");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            "false");
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
      {
        //Set a shadow color other than the default.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
            "shadow_color");
        hv_GenParamName.Dispose();
        hv_GenParamName = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
            hv_Box.TupleSelect(1));
        hv_GenParamValue.Dispose();
        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
    }
    //Restore default CoordSystem behavior.
    if ((int)(new HTuple(hv_CoordSystem_COPY_INP_TMP.TupleNotEqual("window"))) != 0)
    {
      hv_CoordSystem_COPY_INP_TMP.Dispose();
      hv_CoordSystem_COPY_INP_TMP = "image";
    }
    //
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
    {
      //disp_text does not accept an empty string for Color.
      hv_Color_COPY_INP_TMP.Dispose();
      hv_Color_COPY_INP_TMP = new HTuple();
    }
    //
    HOperatorSet.DispText(hv_WindowHandle, hv_String, hv_CoordSystem_COPY_INP_TMP, 
        hv_Row_COPY_INP_TMP, hv_Column_COPY_INP_TMP, hv_Color_COPY_INP_TMP, hv_GenParamName, 
        hv_GenParamValue);

    hv_Color_COPY_INP_TMP.Dispose();
    hv_Column_COPY_INP_TMP.Dispose();
    hv_CoordSystem_COPY_INP_TMP.Dispose();
    hv_Row_COPY_INP_TMP.Dispose();
    hv_GenParamName.Dispose();
    hv_GenParamValue.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: This procedure calls disp_object_model_3d and a fallback solution if there is no OpenGL Available. 
  public void disp_object_model_3d_safe (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
      HTuple hv_CamParam, HTuple hv_Pose, HTuple hv_GenParamName, HTuple hv_GenParamValue)
  {



    // Local iconic variables 

    HObject ho_ModelContours=null;

    // Local control variables 

    HTuple hv_Exception = new HTuple(), hv_Center = new HTuple();
    HTuple hv_CPLength = new HTuple(), hv_RowNotUsed = new HTuple();
    HTuple hv_ColumnNotUsed = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_CamParamValue = new HTuple();
    HTuple hv_CamWidth = new HTuple(), hv_CamHeight = new HTuple();
    HTuple hv_Scale = new HTuple(), hv_NumModels = new HTuple();
    HTuple hv_PoseEstimated = new HTuple(), hv_Poses = new HTuple();
    HTuple hv_HomMat3Ds = new HTuple(), hv_Sequence = new HTuple();
    HTuple hv_Indices = new HTuple();
    HTuple   hv_CamParam_COPY_INP_TMP = new HTuple(hv_CamParam);
    HTuple   hv_Pose_COPY_INP_TMP = new HTuple(hv_Pose);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ModelContours);
    try
    {
      HOperatorSet.DispObjectModel3d(hv_WindowHandle, hv_ObjectModel3D, hv_CamParam_COPY_INP_TMP, 
          hv_Pose_COPY_INP_TMP, hv_GenParamName, hv_GenParamValue);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      //Read and check the parameter PoseIn for each object
      hv_Center.Dispose();
      get_object_models_center(hv_ObjectModel3D, out hv_Center);
      hv_CPLength.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CPLength = new HTuple(hv_CamParam_COPY_INP_TMP.TupleLength()
          );
      }
      hv_RowNotUsed.Dispose();hv_ColumnNotUsed.Dispose();hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowNotUsed, out hv_ColumnNotUsed, 
          out hv_Width, out hv_Height);
      if ((int)(new HTuple(hv_CPLength.TupleEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamParam_COPY_INP_TMP.Dispose();
        gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width/2, hv_Height/2, 
            hv_Width, hv_Height, out hv_CamParam_COPY_INP_TMP);
        }
      }
      else
      {
        hv_CamParamValue.Dispose();
        get_cam_par_data(hv_CamParam_COPY_INP_TMP, (((((new HTuple("sx")).TupleConcat(
            "sy")).TupleConcat("cx")).TupleConcat("cy")).TupleConcat("image_width")).TupleConcat(
            "image_height"), out hv_CamParamValue);
        hv_CamWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamWidth = ((hv_CamParamValue.TupleSelect(
            4))).TupleReal();
        }
        hv_CamHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamHeight = ((hv_CamParamValue.TupleSelect(
            5))).TupleReal();
        }
        hv_Scale.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Scale = ((((hv_Width/hv_CamWidth)).TupleConcat(
            hv_Height/hv_CamHeight))).TupleMin();
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "sx", (hv_CamParamValue.TupleSelect(
            0))/hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "sy", (hv_CamParamValue.TupleSelect(
            1))/hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "cx", (hv_CamParamValue.TupleSelect(
            2))*hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "cy", (hv_CamParamValue.TupleSelect(
            3))*hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "image_width", (((hv_CamParamValue.TupleSelect(
            4))*hv_Scale)).TupleInt(), out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "image_height", (((hv_CamParamValue.TupleSelect(
            5))*hv_Scale)).TupleInt(), out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      hv_NumModels.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumModels = new HTuple(hv_ObjectModel3D.TupleLength()
          );
      }
      if ((int)(new HTuple((new HTuple(hv_Pose_COPY_INP_TMP.TupleLength())).TupleEqual(
          0))) != 0)
      {
        //If no pose was specified by the caller, automatically calculate
        //a pose that is appropriate for the visualization.
        //Set the initial model reference pose. The orientation is parallel
        //to the object coordinate system, the position is at the center
        //of gravity of all models.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Pose_COPY_INP_TMP.Dispose();
        HOperatorSet.CreatePose(-(hv_Center.TupleSelect(0)), -(hv_Center.TupleSelect(
            1)), -(hv_Center.TupleSelect(2)), 0, 0, 0, "Rp+T", "gba", "point", out hv_Pose_COPY_INP_TMP);
        }
        hv_PoseEstimated.Dispose();
        determine_optimum_pose_distance(hv_ObjectModel3D, hv_CamParam_COPY_INP_TMP, 
            0.9, hv_Pose_COPY_INP_TMP, out hv_PoseEstimated);
        hv_Poses.Dispose();
        hv_Poses = new HTuple();
        hv_HomMat3Ds.Dispose();
        hv_HomMat3Ds = new HTuple();
        hv_Sequence.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Sequence = HTuple.TupleGenSequence(
            0,(hv_NumModels*7)-1,1);
        }
        hv_Poses.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Poses = hv_PoseEstimated.TupleSelect(
            hv_Sequence%7);
        }
      }
      else if ((int)(new HTuple((new HTuple(hv_Pose_COPY_INP_TMP.TupleLength()
          )).TupleEqual(7))) != 0)
      {
        hv_Poses.Dispose();
        hv_Poses = new HTuple();
        hv_HomMat3Ds.Dispose();
        hv_HomMat3Ds = new HTuple();
        hv_Sequence.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Sequence = HTuple.TupleGenSequence(
            0,(hv_NumModels*7)-1,1);
        }
        hv_Poses.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Poses = hv_Pose_COPY_INP_TMP.TupleSelect(
            hv_Sequence%7);
        }
      }
      else
      {
        if ((int)(new HTuple((new HTuple(hv_Pose_COPY_INP_TMP.TupleLength())).TupleNotEqual(
            (new HTuple(hv_ObjectModel3D.TupleLength()))*7))) != 0)
        {
          //Error: Wrong number of values of input control parameter 'PoseIn'
          // stop(...); only in hdevelop
        }
        else
        {
          hv_Poses.Dispose();
          hv_Poses = new HTuple(hv_Pose_COPY_INP_TMP);
        }
      }
      hv_Indices.Dispose();
      HOperatorSet.TupleFind(hv_GenParamName, "disp_background", out hv_Indices);
      if ((int)(new HTuple(hv_Indices.TupleGreater(0))) != 0)
      {
        if ((int)(new HTuple(((hv_GenParamValue.TupleSelect(hv_Indices))).TupleEqual(
            "true"))) != 0)
        {
          //display background do not clear background
        }
        else
        {
          HDevWindowStack.SetActive(hv_WindowHandle);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
          }
        }
      }
      else
      {
        //No indication of  'disp_background' clear window
        HDevWindowStack.SetActive(hv_WindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
      }
      ho_ModelContours.Dispose();
      disp_object_model_no_opengl(out ho_ModelContours, hv_ObjectModel3D, hv_GenParamName, 
          hv_GenParamValue, hv_WindowHandle, hv_CamParam_COPY_INP_TMP, hv_Poses);
    }
    ho_ModelContours.Dispose();

    hv_CamParam_COPY_INP_TMP.Dispose();
    hv_Pose_COPY_INP_TMP.Dispose();
    hv_Exception.Dispose();
    hv_Center.Dispose();
    hv_CPLength.Dispose();
    hv_RowNotUsed.Dispose();
    hv_ColumnNotUsed.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_CamParamValue.Dispose();
    hv_CamWidth.Dispose();
    hv_CamHeight.Dispose();
    hv_Scale.Dispose();
    hv_NumModels.Dispose();
    hv_PoseEstimated.Dispose();
    hv_Poses.Dispose();
    hv_HomMat3Ds.Dispose();
    hv_Sequence.Dispose();
    hv_Indices.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Can replace disp_object_model_3d if there is no OpenGL available. 
  public void disp_object_model_no_opengl (out HObject ho_ModelContours, HTuple hv_ObjectModel3DID, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandleBuffer, 
      HTuple hv_CamParam, HTuple hv_PosesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Idx = new HTuple(), hv_CustomParamName = new HTuple();
    HTuple hv_CustomParamValue = new HTuple(), hv_Font = new HTuple();
    HTuple hv_IndicesDispBackGround = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_ImageWidth = new HTuple(), hv_HasPolygons = new HTuple();
    HTuple hv_HasTri = new HTuple(), hv_HasPoints = new HTuple();
    HTuple hv_HasLines = new HTuple(), hv_NumPoints = new HTuple();
    HTuple hv_IsPrimitive = new HTuple(), hv_Center = new HTuple();
    HTuple hv_Diameter = new HTuple(), hv_OpenGlHiddenSurface = new HTuple();
    HTuple hv_CenterX = new HTuple(), hv_CenterY = new HTuple();
    HTuple hv_CenterZ = new HTuple(), hv_PosObjectsZ = new HTuple();
    HTuple hv_I = new HTuple(), hv_Pose = new HTuple(), hv_HomMat3DObj = new HTuple();
    HTuple hv_PosObjCenterX = new HTuple(), hv_PosObjCenterY = new HTuple();
    HTuple hv_PosObjCenterZ = new HTuple(), hv_PosObjectsX = new HTuple();
    HTuple hv_PosObjectsY = new HTuple(), hv_Color = new HTuple();
    HTuple hv_Indices1 = new HTuple(), hv_Indices2 = new HTuple();
    HTuple hv_J = new HTuple(), hv_Indices3 = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_SampledObjectModel3D = new HTuple();
    HTuple hv_X = new HTuple(), hv_Y = new HTuple(), hv_Z = new HTuple();
    HTuple hv_HomMat3D1 = new HTuple(), hv_Qx = new HTuple();
    HTuple hv_Qy = new HTuple(), hv_Qz = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_ObjectModel3DConvexHull = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ModelContours);
    //This procedure allows to use project_object_model_3d to simulate a disp_object_model_3d
    //call for small objects. Large objects are sampled down to display.
    hv_Idx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Idx = hv_GenParamName.TupleFind(
        "point_size");
    }
    if ((int)((new HTuple(hv_Idx.TupleLength())).TupleAnd(new HTuple(hv_Idx.TupleNotEqual(
        -1)))) != 0)
    {
      hv_CustomParamName.Dispose();
      hv_CustomParamName = "point_size";
      hv_CustomParamValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CustomParamValue = hv_GenParamValue.TupleSelect(
          hv_Idx);
      }
      if ((int)(new HTuple(hv_CustomParamValue.TupleEqual(1))) != 0)
      {
        hv_CustomParamValue.Dispose();
        hv_CustomParamValue = 0;
      }
    }
    else
    {
      hv_CustomParamName.Dispose();
      hv_CustomParamName = new HTuple();
      hv_CustomParamValue.Dispose();
      hv_CustomParamValue = new HTuple();
    }
    hv_Font.Dispose();
    HOperatorSet.GetFont(hv_WindowHandleBuffer, out hv_Font);
    hv_IndicesDispBackGround.Dispose();
    HOperatorSet.TupleFind(hv_GenParamName, "disp_background", out hv_IndicesDispBackGround);
    if ((int)(new HTuple(hv_IndicesDispBackGround.TupleNotEqual(-1))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices.Dispose();
      HOperatorSet.TupleFind(hv_GenParamName.TupleSelect(hv_IndicesDispBackGround), 
          "false", out hv_Indices);
      }
      if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
      {
        HOperatorSet.ClearWindow(hv_WindowHandleBuffer);
      }
    }
    set_display_font(hv_WindowHandleBuffer, 11, "mono", "false", "false");
    hv_ImageWidth.Dispose();
    get_cam_par_data(hv_CamParam, "image_width", out hv_ImageWidth);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    disp_message(hv_WindowHandleBuffer, "OpenGL missing!", "image", 5, hv_ImageWidth-130, 
        "red", "false");
    }
    HOperatorSet.SetFont(hv_WindowHandleBuffer, hv_Font);
    hv_HasPolygons.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID, "has_polygons", out hv_HasPolygons);
    hv_HasTri.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID, "has_triangles", out hv_HasTri);
    hv_HasPoints.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID, "has_points", out hv_HasPoints);
    hv_HasLines.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID, "has_lines", out hv_HasLines);
    hv_NumPoints.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID, "num_points", out hv_NumPoints);
    hv_IsPrimitive.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID, "has_primitive_data", 
        out hv_IsPrimitive);
    hv_Center.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID, "center", out hv_Center);
    hv_Diameter.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID, "diameter", out hv_Diameter);
    hv_OpenGlHiddenSurface.Dispose();
    HOperatorSet.GetSystem("opengl_hidden_surface_removal_enable", out hv_OpenGlHiddenSurface);
    HOperatorSet.SetSystem("opengl_hidden_surface_removal_enable", "false");
    //Sort the objects by inverse z
    hv_CenterX.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CenterX = hv_Center.TupleSelect(
        HTuple.TupleGenSequence(0,(new HTuple(hv_Center.TupleLength()))-1,3));
    }
    hv_CenterY.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CenterY = hv_Center.TupleSelect(
        HTuple.TupleGenSequence(0,(new HTuple(hv_Center.TupleLength()))-1,3)+1);
    }
    hv_CenterZ.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CenterZ = hv_Center.TupleSelect(
        HTuple.TupleGenSequence(0,(new HTuple(hv_Center.TupleLength()))-1,3)+2);
    }
    hv_PosObjectsZ.Dispose();
    hv_PosObjectsZ = new HTuple();
    if ((int)(new HTuple((new HTuple(hv_PosesOut.TupleLength())).TupleGreater(7))) != 0)
    {
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_ObjectModel3DID.TupleLength()))-1); hv_I = (int)hv_I + 1)
      {
        hv_Pose.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Pose = hv_PosesOut.TupleSelectRange(
            hv_I*7,(hv_I*7)+6);
        }
        hv_HomMat3DObj.Dispose();
        HOperatorSet.PoseToHomMat3d(hv_Pose, out hv_HomMat3DObj);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PosObjCenterX.Dispose();hv_PosObjCenterY.Dispose();hv_PosObjCenterZ.Dispose();
        HOperatorSet.AffineTransPoint3d(hv_HomMat3DObj, hv_CenterX.TupleSelect(hv_I), 
            hv_CenterY.TupleSelect(hv_I), hv_CenterZ.TupleSelect(hv_I), out hv_PosObjCenterX, 
            out hv_PosObjCenterY, out hv_PosObjCenterZ);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_PosObjectsZ = hv_PosObjectsZ.TupleConcat(
            hv_PosObjCenterZ);
        hv_PosObjectsZ.Dispose();
        hv_PosObjectsZ = ExpTmpLocalVar_PosObjectsZ;
        }
        }
      }
    }
    else
    {
      hv_Pose.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Pose = hv_PosesOut.TupleSelectRange(
          0,6);
      }
      hv_HomMat3DObj.Dispose();
      HOperatorSet.PoseToHomMat3d(hv_Pose, out hv_HomMat3DObj);
      hv_PosObjectsX.Dispose();hv_PosObjectsY.Dispose();hv_PosObjectsZ.Dispose();
      HOperatorSet.AffineTransPoint3d(hv_HomMat3DObj, hv_CenterX, hv_CenterY, hv_CenterZ, 
          out hv_PosObjectsX, out hv_PosObjectsY, out hv_PosObjectsZ);
    }
    hv_Idx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Idx = (new HTuple(hv_PosObjectsZ.TupleSortIndex()
        )).TupleInverse();
    }
    hv_Color.Dispose();
    hv_Color = "white";
    HOperatorSet.SetColor(hv_WindowHandleBuffer, hv_Color);
    if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleGreater(
        0))) != 0)
    {
      hv_Indices1.Dispose();
      HOperatorSet.TupleFind(hv_GenParamName, "colored", out hv_Indices1);
      hv_Indices2.Dispose();
      HOperatorSet.TupleFind(hv_GenParamName, "color", out hv_Indices2);
      if ((int)(new HTuple(((hv_Indices1.TupleSelect(0))).TupleNotEqual(-1))) != 0)
      {
        if ((int)(new HTuple(((hv_GenParamValue.TupleSelect(hv_Indices1.TupleSelect(
            0)))).TupleEqual(3))) != 0)
        {
          hv_Color.Dispose();
          hv_Color = new HTuple();
          hv_Color[0] = "red";
          hv_Color[1] = "green";
          hv_Color[2] = "blue";
        }
        else if ((int)(new HTuple(((hv_GenParamValue.TupleSelect(hv_Indices1.TupleSelect(
            0)))).TupleEqual(6))) != 0)
        {
          hv_Color.Dispose();
          hv_Color = new HTuple();
          hv_Color[0] = "red";
          hv_Color[1] = "green";
          hv_Color[2] = "blue";
          hv_Color[3] = "cyan";
          hv_Color[4] = "magenta";
          hv_Color[5] = "yellow";
        }
        else if ((int)(new HTuple(((hv_GenParamValue.TupleSelect(hv_Indices1.TupleSelect(
            0)))).TupleEqual(12))) != 0)
        {
          hv_Color.Dispose();
          hv_Color = new HTuple();
          hv_Color[0] = "red";
          hv_Color[1] = "green";
          hv_Color[2] = "blue";
          hv_Color[3] = "cyan";
          hv_Color[4] = "magenta";
          hv_Color[5] = "yellow";
          hv_Color[6] = "coral";
          hv_Color[7] = "slate blue";
          hv_Color[8] = "spring green";
          hv_Color[9] = "orange red";
          hv_Color[10] = "pink";
          hv_Color[11] = "gold";
        }
      }
      else if ((int)(new HTuple(((hv_Indices2.TupleSelect(0))).TupleNotEqual(
          -1))) != 0)
      {
        hv_Color.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Color = hv_GenParamValue.TupleSelect(
            hv_Indices2.TupleSelect(0));
        }
      }
    }
    for (hv_J=0; (int)hv_J<=(int)((new HTuple(hv_ObjectModel3DID.TupleLength()))-1); hv_J = (int)hv_J + 1)
    {
      hv_I.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_I = hv_Idx.TupleSelect(
          hv_J);
      }
      if ((int)((new HTuple((new HTuple((new HTuple(((hv_HasPolygons.TupleSelect(
          hv_I))).TupleEqual("true"))).TupleOr(new HTuple(((hv_HasTri.TupleSelect(
          hv_I))).TupleEqual("true"))))).TupleOr(new HTuple(((hv_HasPoints.TupleSelect(
          hv_I))).TupleEqual("true"))))).TupleOr(new HTuple(((hv_HasLines.TupleSelect(
          hv_I))).TupleEqual("true")))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleGreater(
            0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Indices3.Dispose();
          HOperatorSet.TupleFind(hv_GenParamName, "color_"+hv_I, out hv_Indices3);
          }
          if ((int)(new HTuple(((hv_Indices3.TupleSelect(0))).TupleNotEqual(-1))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(hv_WindowHandleBuffer, hv_GenParamValue.TupleSelect(
                hv_Indices3.TupleSelect(0)));
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(hv_WindowHandleBuffer, hv_Color.TupleSelect(hv_I%(new HTuple(hv_Color.TupleLength()
                ))));
            }
          }
        }
        if ((int)(new HTuple((new HTuple(hv_PosesOut.TupleLength())).TupleGreaterEqual(
            (hv_I*7)+6))) != 0)
        {
          hv_Pose.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Pose = hv_PosesOut.TupleSelectRange(
              hv_I*7,(hv_I*7)+6);
          }
        }
        else
        {
          hv_Pose.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Pose = hv_PosesOut.TupleSelectRange(
              0,6);
          }
        }
        if ((int)(new HTuple(((hv_NumPoints.TupleSelect(hv_I))).TupleLess(10000))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ModelContours.Dispose();
          HOperatorSet.ProjectObjectModel3d(out ho_ModelContours, hv_ObjectModel3DID.TupleSelect(
              hv_I), hv_CamParam, hv_Pose, hv_CustomParamName, hv_CustomParamValue);
          }
          HOperatorSet.DispObj(ho_ModelContours, hv_WindowHandleBuffer);
        }
        else
        {
          hv_HomMat3D.Dispose();
          HOperatorSet.PoseToHomMat3d(hv_Pose, out hv_HomMat3D);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SampledObjectModel3D.Dispose();
          HOperatorSet.SampleObjectModel3d(hv_ObjectModel3DID.TupleSelect(hv_I), 
              "fast", 0.01*(hv_Diameter.TupleSelect(hv_I)), new HTuple(), new HTuple(), 
              out hv_SampledObjectModel3D);
          }
          ho_ModelContours.Dispose();
          HOperatorSet.ProjectObjectModel3d(out ho_ModelContours, hv_SampledObjectModel3D, 
              hv_CamParam, hv_Pose, "point_size", 1);
          hv_X.Dispose();
          HOperatorSet.GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_x", 
              out hv_X);
          hv_Y.Dispose();
          HOperatorSet.GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_y", 
              out hv_Y);
          hv_Z.Dispose();
          HOperatorSet.GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_z", 
              out hv_Z);
          hv_HomMat3D1.Dispose();
          HOperatorSet.PoseToHomMat3d(hv_Pose, out hv_HomMat3D1);
          hv_Qx.Dispose();hv_Qy.Dispose();hv_Qz.Dispose();
          HOperatorSet.AffineTransPoint3d(hv_HomMat3D1, hv_X, hv_Y, hv_Z, out hv_Qx, 
              out hv_Qy, out hv_Qz);
          hv_Row.Dispose();hv_Column.Dispose();
          HOperatorSet.Project3dPoint(hv_Qx, hv_Qy, hv_Qz, hv_CamParam, out hv_Row, 
              out hv_Column);
          HOperatorSet.DispObj(ho_ModelContours, hv_WindowHandleBuffer);
          HOperatorSet.ClearObjectModel3d(hv_SampledObjectModel3D);
        }
      }
      else
      {
        if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleGreater(
            0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Indices3.Dispose();
          HOperatorSet.TupleFind(hv_GenParamName, "color_"+hv_I, out hv_Indices3);
          }
          if ((int)(new HTuple(((hv_Indices3.TupleSelect(0))).TupleNotEqual(-1))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(hv_WindowHandleBuffer, hv_GenParamValue.TupleSelect(
                hv_Indices3.TupleSelect(0)));
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(hv_WindowHandleBuffer, hv_Color.TupleSelect(hv_I%(new HTuple(hv_Color.TupleLength()
                ))));
            }
          }
        }
        if ((int)(new HTuple((new HTuple(hv_PosesOut.TupleLength())).TupleGreaterEqual(
            (hv_I*7)+6))) != 0)
        {
          hv_Pose.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Pose = hv_PosesOut.TupleSelectRange(
              hv_I*7,(hv_I*7)+6);
          }
        }
        else
        {
          hv_Pose.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Pose = hv_PosesOut.TupleSelectRange(
              0,6);
          }
        }
        if ((int)(new HTuple(((hv_IsPrimitive.TupleSelect(hv_I))).TupleEqual("true"))) != 0)
        {
          try
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ObjectModel3DConvexHull.Dispose();
            HOperatorSet.ConvexHullObjectModel3d(hv_ObjectModel3DID.TupleSelect(hv_I), 
                out hv_ObjectModel3DConvexHull);
            }
            if ((int)(new HTuple(((hv_NumPoints.TupleSelect(hv_I))).TupleLess(10000))) != 0)
            {
              ho_ModelContours.Dispose();
              HOperatorSet.ProjectObjectModel3d(out ho_ModelContours, hv_ObjectModel3DConvexHull, 
                  hv_CamParam, hv_Pose, hv_CustomParamName, hv_CustomParamValue);
              HOperatorSet.DispObj(ho_ModelContours, hv_WindowHandleBuffer);
            }
            else
            {
              hv_HomMat3D.Dispose();
              HOperatorSet.PoseToHomMat3d(hv_Pose, out hv_HomMat3D);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SampledObjectModel3D.Dispose();
              HOperatorSet.SampleObjectModel3d(hv_ObjectModel3DConvexHull, "fast", 
                  0.01*(hv_Diameter.TupleSelect(hv_I)), new HTuple(), new HTuple(), 
                  out hv_SampledObjectModel3D);
              }
              ho_ModelContours.Dispose();
              HOperatorSet.ProjectObjectModel3d(out ho_ModelContours, hv_SampledObjectModel3D, 
                  hv_CamParam, hv_Pose, "point_size", 1);
              HOperatorSet.DispObj(ho_ModelContours, hv_WindowHandleBuffer);
              HOperatorSet.ClearObjectModel3d(hv_SampledObjectModel3D);
            }
            HOperatorSet.ClearObjectModel3d(hv_ObjectModel3DConvexHull);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
          }
        }
      }
    }
    HOperatorSet.SetSystem("opengl_hidden_surface_removal_enable", hv_OpenGlHiddenSurface);

    hv_Idx.Dispose();
    hv_CustomParamName.Dispose();
    hv_CustomParamValue.Dispose();
    hv_Font.Dispose();
    hv_IndicesDispBackGround.Dispose();
    hv_Indices.Dispose();
    hv_ImageWidth.Dispose();
    hv_HasPolygons.Dispose();
    hv_HasTri.Dispose();
    hv_HasPoints.Dispose();
    hv_HasLines.Dispose();
    hv_NumPoints.Dispose();
    hv_IsPrimitive.Dispose();
    hv_Center.Dispose();
    hv_Diameter.Dispose();
    hv_OpenGlHiddenSurface.Dispose();
    hv_CenterX.Dispose();
    hv_CenterY.Dispose();
    hv_CenterZ.Dispose();
    hv_PosObjectsZ.Dispose();
    hv_I.Dispose();
    hv_Pose.Dispose();
    hv_HomMat3DObj.Dispose();
    hv_PosObjCenterX.Dispose();
    hv_PosObjCenterY.Dispose();
    hv_PosObjCenterZ.Dispose();
    hv_PosObjectsX.Dispose();
    hv_PosObjectsY.Dispose();
    hv_Color.Dispose();
    hv_Indices1.Dispose();
    hv_Indices2.Dispose();
    hv_J.Dispose();
    hv_Indices3.Dispose();
    hv_HomMat3D.Dispose();
    hv_SampledObjectModel3D.Dispose();
    hv_X.Dispose();
    hv_Y.Dispose();
    hv_Z.Dispose();
    hv_HomMat3D1.Dispose();
    hv_Qx.Dispose();
    hv_Qy.Dispose();
    hv_Qz.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_ObjectModel3DConvexHull.Dispose();
    hv_Exception.Dispose();

    return;
  }

  public void disp_slider (HTuple hv_WindowHandle, HTuple hv_Row, HTuple hv_TotalHeight, 
      HTuple hv_ColLabel, HTuple hv_ColValue, HTuple hv_ColSliderStart, HTuple hv_ColSliderEnd, 
      HTuple hv_Label, HTuple hv_ValueStart, HTuple hv_ValueEnd, HTuple hv_ValueCurr, 
      HTuple hv_FormatString)
  {



    // Local iconic variables 

    HObject ho_ButtonRegion, ho_RegionBorder;

    // Local control variables 

    HTuple hv_BarHeight = new HTuple(), hv_ButtonHeight = new HTuple();
    HTuple hv_ButtonWidth = new HTuple(), hv_RowMid = new HTuple();
    HTuple hv_SliderPosRel = new HTuple(), hv_SliderColMid = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Cols = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ButtonRegion);
    HOperatorSet.GenEmptyObj(out ho_RegionBorder);
    hv_BarHeight.Dispose();
    hv_BarHeight = 2;
    hv_ButtonHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonHeight = hv_TotalHeight*0.6;
    }
    hv_ButtonWidth.Dispose();
    hv_ButtonWidth = 3;

    hv_RowMid.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RowMid = hv_Row+(hv_TotalHeight/2);
    }
    if (HDevWindowStack.IsOpen())
    {
      //dev_get_window (WindowHandle)
    }
    if (HDevWindowStack.IsOpen())
    {
      //dev_clear_window ()
    }

    //The long bar of the slider
    HOperatorSet.SetColor(hv_WindowHandle, "light gray");
    HOperatorSet.DispLine(hv_WindowHandle, hv_RowMid, hv_ColSliderStart, hv_RowMid, 
        hv_ColSliderEnd);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.DispLine(hv_WindowHandle, hv_RowMid-(hv_ButtonHeight/2), hv_ColSliderStart, 
        hv_RowMid+(hv_ButtonHeight/2), hv_ColSliderStart);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.DispLine(hv_WindowHandle, hv_RowMid-(hv_ButtonHeight/2), hv_ColSliderEnd, 
        hv_RowMid+(hv_ButtonHeight/2), hv_ColSliderEnd);
    }

    //The slider itself
    hv_SliderPosRel.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SliderPosRel = ((hv_ValueCurr-hv_ValueStart)*1.0)/(hv_ValueEnd-hv_ValueStart);
    }
    if ((int)(new HTuple(hv_SliderPosRel.TupleLess(0))) != 0)
    {
      hv_SliderPosRel.Dispose();
      hv_SliderPosRel = 0;
    }
    else if ((int)(new HTuple(hv_SliderPosRel.TupleGreater(1))) != 0)
    {
      hv_SliderPosRel.Dispose();
      hv_SliderPosRel = 1;
    }
    hv_SliderColMid.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SliderColMid = hv_ColSliderStart+(hv_SliderPosRel*(hv_ColSliderEnd-hv_ColSliderStart));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_ButtonRegion.Dispose();
    HOperatorSet.GenRectangle1(out ho_ButtonRegion, hv_RowMid-(hv_ButtonHeight/2), 
        hv_SliderColMid-(hv_ButtonWidth/2), hv_RowMid+(hv_ButtonHeight/2), hv_SliderColMid+(hv_ButtonWidth/2));
    }
    HOperatorSet.SetDraw(hv_WindowHandle, "fill");
    HOperatorSet.SetColor(hv_WindowHandle, "dark olive green");
    HOperatorSet.DispRegion(ho_ButtonRegion, hv_WindowHandle);
    hv_Rows.Dispose();hv_Cols.Dispose();
    HOperatorSet.GetRegionContour(ho_ButtonRegion, out hv_Rows, out hv_Cols);
    HOperatorSet.SetColor(hv_WindowHandle, "dim gray");
    ho_RegionBorder.Dispose();
    HOperatorSet.GenRegionPoints(out ho_RegionBorder, hv_Rows, hv_Cols);
    HOperatorSet.DispRegion(ho_RegionBorder, hv_WindowHandle);

    //Label
    HOperatorSet.DispText(hv_WindowHandle, hv_Label, "window", hv_Row, hv_ColLabel, 
        "white", "box", "false");

    //Value
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.DispText(hv_WindowHandle, hv_ValueCurr.TupleString(hv_FormatString), 
        "window", hv_Row, hv_ColValue, "white", "box", "false");
    }

    ho_ButtonRegion.Dispose();
    ho_RegionBorder.Dispose();

    hv_BarHeight.Dispose();
    hv_ButtonHeight.Dispose();
    hv_ButtonWidth.Dispose();
    hv_RowMid.Dispose();
    hv_SliderPosRel.Dispose();
    hv_SliderColMid.Dispose();
    hv_Rows.Dispose();
    hv_Cols.Dispose();

    return;

  }

  // Chapter: Graphics / Text
  // Short Description: This procedure writes a text message. 
  public void disp_text_button (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_TextColor, HTuple hv_ButtonColor)
  {



    // Local iconic variables 

    HObject ho_UpperLeft, ho_LowerRight, ho_Rectangle;

    // Local control variables 

    HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
    HTuple hv_Blue = new HTuple(), hv_Row1Part = new HTuple();
    HTuple hv_Column1Part = new HTuple(), hv_Row2Part = new HTuple();
    HTuple hv_Column2Part = new HTuple(), hv_RowWin = new HTuple();
    HTuple hv_ColumnWin = new HTuple(), hv_WidthWin = new HTuple();
    HTuple hv_HeightWin = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_Fac = new HTuple(), hv_RGB = new HTuple(), hv_RGBL = new HTuple();
    HTuple hv_RGBD = new HTuple(), hv_ButtonColorBorderL = new HTuple();
    HTuple hv_ButtonColorBorderD = new HTuple(), hv_MaxAscent = new HTuple();
    HTuple hv_MaxDescent = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MaxHeight = new HTuple(), hv_R1 = new HTuple();
    HTuple hv_C1 = new HTuple(), hv_FactorRow = new HTuple();
    HTuple hv_FactorColumn = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_W = new HTuple();
    HTuple hv_H = new HTuple(), hv_FrameHeight = new HTuple();
    HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
    HTuple hv_C2 = new HTuple(), hv_ClipRegion = new HTuple();
    HTuple hv_DrawMode = new HTuple(), hv_BorderWidth = new HTuple();
    HTuple hv_CurrentColor = new HTuple();
    HTuple   hv_Column_COPY_INP_TMP = new HTuple(hv_Column);
    HTuple   hv_Row_COPY_INP_TMP = new HTuple(hv_Row);
    HTuple   hv_String_COPY_INP_TMP = new HTuple(hv_String);
    HTuple   hv_TextColor_COPY_INP_TMP = new HTuple(hv_TextColor);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_UpperLeft);
    HOperatorSet.GenEmptyObj(out ho_LowerRight);
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    //This procedure displays text in a graphics window.
    //
    //Input parameters:
    //WindowHandle: The WindowHandle of the graphics window, where
    //   the message should be displayed
    //String: A tuple of strings containing the text message to be displayed
    //CoordSystem: If set to 'window', the text position is given
    //   with respect to the window coordinate system.
    //   If set to 'image', image coordinates are used.
    //   (This may be useful in zoomed images.)
    //Row: The row coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //Column: The column coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //Color: defines the color of the text as string.
    //   If set to [], '' or 'auto' the currently set color is used.
    //   If a tuple of strings is passed, the colors are used cyclically
    //   for each new textline.
    //ButtonColor: Must be set to a color string (e.g. 'white', '#FF00CC', etc.).
    //             The text is written in a box of that color.
    //
    //Prepare window.
    hv_Red.Dispose();hv_Green.Dispose();hv_Blue.Dispose();
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    hv_Row1Part.Dispose();hv_Column1Part.Dispose();hv_Row2Part.Dispose();hv_Column2Part.Dispose();
    HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part, 
        out hv_Column2Part);
    hv_RowWin.Dispose();hv_ColumnWin.Dispose();hv_WidthWin.Dispose();hv_HeightWin.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin, 
        out hv_WidthWin, out hv_HeightWin);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
    }
    //
    //Default settings.
    if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Row_COPY_INP_TMP.Dispose();
      hv_Row_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Column_COPY_INP_TMP.Dispose();
      hv_Column_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_TextColor_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_TextColor_COPY_INP_TMP.Dispose();
      hv_TextColor_COPY_INP_TMP = "";
    }
    //
    try
    {
      hv_RGB.Dispose();
      color_string_to_rgb(hv_ButtonColor, out hv_RGB);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_Exception.Dispose();
      hv_Exception = "Wrong value of control parameter ButtonColor (must be a valid color string)";
      throw new HalconException(hv_Exception);
    }
    hv_Fac.Dispose();
    hv_Fac = 0.4;
    hv_RGBL.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RGBL = hv_RGB+(((((255.0-hv_RGB)*hv_Fac)+0.5)).TupleInt()
        );
    }
    hv_RGBD.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RGBD = hv_RGB-((((hv_RGB*hv_Fac)+0.5)).TupleInt()
        );
    }
    hv_ButtonColorBorderL.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonColorBorderL = "#"+(((""+(hv_RGBL.TupleString(
        "02x")))).TupleSum());
    }
    hv_ButtonColorBorderD.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonColorBorderD = "#"+(((""+(hv_RGBD.TupleString(
        "02x")))).TupleSum());
    }
    //
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_String = (((""+hv_String_COPY_INP_TMP)+"")).TupleSplit(
        "\n");
    hv_String_COPY_INP_TMP.Dispose();
    hv_String_COPY_INP_TMP = ExpTmpLocalVar_String;
    }
    }
    //
    //Estimate extentions of text depending on font size.
    hv_MaxAscent.Dispose();hv_MaxDescent.Dispose();hv_MaxWidth.Dispose();hv_MaxHeight.Dispose();
    HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent, 
        out hv_MaxWidth, out hv_MaxHeight);
    if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
    {
      hv_R1.Dispose();
      hv_R1 = new HTuple(hv_Row_COPY_INP_TMP);
      hv_C1.Dispose();
      hv_C1 = new HTuple(hv_Column_COPY_INP_TMP);
    }
    else
    {
      //Transform image to window coordinates.
      hv_FactorRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FactorRow = (1.0*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
      }
      hv_FactorColumn.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FactorColumn = (1.0*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
      }
      hv_R1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_R1 = ((hv_Row_COPY_INP_TMP-hv_Row1Part)+0.5)*hv_FactorRow;
      }
      hv_C1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_C1 = ((hv_Column_COPY_INP_TMP-hv_Column1Part)+0.5)*hv_FactorColumn;
      }
    }
    //
    //Display text box depending on text size.
    //
    //Calculate box extents.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_String = (" "+hv_String_COPY_INP_TMP)+" ";
    hv_String_COPY_INP_TMP.Dispose();
    hv_String_COPY_INP_TMP = ExpTmpLocalVar_String;
    }
    }
    hv_Width.Dispose();
    hv_Width = new HTuple();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_W.Dispose();hv_H.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
          hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Width = hv_Width.TupleConcat(
          hv_W);
      hv_Width.Dispose();
      hv_Width = ExpTmpLocalVar_Width;
      }
      }
    }
    hv_FrameHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_FrameHeight = hv_MaxHeight*(new HTuple(hv_String_COPY_INP_TMP.TupleLength()
        ));
    }
    hv_FrameWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_FrameWidth = (((new HTuple(0)).TupleConcat(
        hv_Width))).TupleMax();
    }
    hv_R2.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_R2 = hv_R1+hv_FrameHeight;
    }
    hv_C2.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_C2 = hv_C1+hv_FrameWidth;
    }
    //Display rectangles.
    hv_ClipRegion.Dispose();
    HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
    HOperatorSet.SetSystem("clip_region", "false");
    hv_DrawMode.Dispose();
    HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
    HOperatorSet.SetDraw(hv_WindowHandle, "fill");
    hv_BorderWidth.Dispose();
    hv_BorderWidth = 2;
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_UpperLeft.Dispose();
    HOperatorSet.GenRegionPolygonFilled(out ho_UpperLeft, ((((((((hv_R1-hv_BorderWidth)).TupleConcat(
        hv_R1-hv_BorderWidth))).TupleConcat(hv_R1))).TupleConcat(hv_R2))).TupleConcat(
        hv_R2+hv_BorderWidth), ((((((((hv_C1-hv_BorderWidth)).TupleConcat(hv_C2+hv_BorderWidth))).TupleConcat(
        hv_C2))).TupleConcat(hv_C1))).TupleConcat(hv_C1-hv_BorderWidth));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_LowerRight.Dispose();
    HOperatorSet.GenRegionPolygonFilled(out ho_LowerRight, ((((((((hv_R2+hv_BorderWidth)).TupleConcat(
        hv_R1-hv_BorderWidth))).TupleConcat(hv_R1))).TupleConcat(hv_R2))).TupleConcat(
        hv_R2+hv_BorderWidth), ((((((((hv_C2+hv_BorderWidth)).TupleConcat(hv_C2+hv_BorderWidth))).TupleConcat(
        hv_C2))).TupleConcat(hv_C1))).TupleConcat(hv_C1-hv_BorderWidth));
    }
    ho_Rectangle.Dispose();
    HOperatorSet.GenRectangle1(out ho_Rectangle, hv_R1, hv_C1, hv_R2, hv_C2);
    HOperatorSet.SetColor(hv_WindowHandle, hv_ButtonColorBorderL);
    HOperatorSet.DispObj(ho_UpperLeft, hv_WindowHandle);
    HOperatorSet.SetColor(hv_WindowHandle, hv_ButtonColorBorderD);
    HOperatorSet.DispObj(ho_LowerRight, hv_WindowHandle);
    HOperatorSet.SetColor(hv_WindowHandle, hv_ButtonColor);
    HOperatorSet.DispObj(ho_Rectangle, hv_WindowHandle);
    HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
    HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
    //Write text.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_CurrentColor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentColor = hv_TextColor_COPY_INP_TMP.TupleSelect(
          hv_Index%(new HTuple(hv_TextColor_COPY_INP_TMP.TupleLength())));
      }
      if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
          "auto")))) != 0)
      {
        HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
      }
      else
      {
        HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
      }
      hv_Row_COPY_INP_TMP.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row_COPY_INP_TMP = hv_R1+(hv_MaxHeight*hv_Index);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.DispText(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(hv_Index), 
          "window", hv_Row_COPY_INP_TMP, hv_C1, hv_CurrentColor, "box", "false");
      }
    }
    //Reset changed window settings.
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, 
        hv_Column2Part);
    ho_UpperLeft.Dispose();
    ho_LowerRight.Dispose();
    ho_Rectangle.Dispose();

    hv_Column_COPY_INP_TMP.Dispose();
    hv_Row_COPY_INP_TMP.Dispose();
    hv_String_COPY_INP_TMP.Dispose();
    hv_TextColor_COPY_INP_TMP.Dispose();
    hv_Red.Dispose();
    hv_Green.Dispose();
    hv_Blue.Dispose();
    hv_Row1Part.Dispose();
    hv_Column1Part.Dispose();
    hv_Row2Part.Dispose();
    hv_Column2Part.Dispose();
    hv_RowWin.Dispose();
    hv_ColumnWin.Dispose();
    hv_WidthWin.Dispose();
    hv_HeightWin.Dispose();
    hv_Exception.Dispose();
    hv_Fac.Dispose();
    hv_RGB.Dispose();
    hv_RGBL.Dispose();
    hv_RGBD.Dispose();
    hv_ButtonColorBorderL.Dispose();
    hv_ButtonColorBorderD.Dispose();
    hv_MaxAscent.Dispose();
    hv_MaxDescent.Dispose();
    hv_MaxWidth.Dispose();
    hv_MaxHeight.Dispose();
    hv_R1.Dispose();
    hv_C1.Dispose();
    hv_FactorRow.Dispose();
    hv_FactorColumn.Dispose();
    hv_Width.Dispose();
    hv_Index.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_W.Dispose();
    hv_H.Dispose();
    hv_FrameHeight.Dispose();
    hv_FrameWidth.Dispose();
    hv_R2.Dispose();
    hv_C2.Dispose();
    hv_ClipRegion.Dispose();
    hv_DrawMode.Dispose();
    hv_BorderWidth.Dispose();
    hv_CurrentColor.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  public void disp_title_and_information (HTuple hv_Parameters, HTuple hv_WindowHandle, 
      HTuple hv_Title, HTuple hv_Information)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_gInfoDecor = new HTuple(), hv_gInfoPos = new HTuple();
    HTuple hv_gTitlePos = new HTuple(), hv_gTitleDecor = new HTuple();
    HTuple hv_WinRow = new HTuple(), hv_WinColumn = new HTuple();
    HTuple hv_WinWidth = new HTuple(), hv_WinHeight = new HTuple();
    HTuple hv_NumTitleLines = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_TextWidth = new HTuple();
    HTuple hv_NumInfoLines = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple();
    HTuple   hv_Information_COPY_INP_TMP = new HTuple(hv_Information);
    HTuple   hv_Title_COPY_INP_TMP = new HTuple(hv_Title);

    // Initialize local and output iconic variables 
    //
    hv_gInfoDecor.Dispose();
    HOperatorSet.GetMessageTuple(hv_Parameters, "gInfoDecor", out hv_gInfoDecor);
    hv_gInfoPos.Dispose();
    HOperatorSet.GetMessageTuple(hv_Parameters, "gInfoPos", out hv_gInfoPos);
    hv_gTitlePos.Dispose();
    HOperatorSet.GetMessageTuple(hv_Parameters, "gTitlePos", out hv_gTitlePos);
    hv_gTitleDecor.Dispose();
    HOperatorSet.GetMessageTuple(hv_Parameters, "gTitleDecor", out hv_gTitleDecor);
    //
    hv_WinRow.Dispose();hv_WinColumn.Dispose();hv_WinWidth.Dispose();hv_WinHeight.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_WinRow, out hv_WinColumn, 
        out hv_WinWidth, out hv_WinHeight);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Title = (((""+hv_Title_COPY_INP_TMP)+"")).TupleSplit(
        "\n");
    hv_Title_COPY_INP_TMP.Dispose();
    hv_Title_COPY_INP_TMP = ExpTmpLocalVar_Title;
    }
    }
    hv_NumTitleLines.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumTitleLines = new HTuple(hv_Title_COPY_INP_TMP.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumTitleLines.TupleGreater(0))) != 0)
    {
      hv_Row.Dispose();
      hv_Row = 12;
      if ((int)(new HTuple(hv_gTitlePos.TupleEqual("UpperLeft"))) != 0)
      {
        hv_Column.Dispose();
        hv_Column = 12;
      }
      else if ((int)(new HTuple(hv_gTitlePos.TupleEqual("UpperCenter"))) != 0)
      {
        hv_TextWidth.Dispose();
        max_line_width(hv_WindowHandle, hv_Title_COPY_INP_TMP, out hv_TextWidth);
        hv_Column.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column = (hv_WinWidth/2)-(hv_TextWidth/2);
        }
      }
      else if ((int)(new HTuple(hv_gTitlePos.TupleEqual("UpperRight"))) != 0)
      {
        if ((int)(new HTuple(((hv_gTitleDecor.TupleSelect(1))).TupleEqual("true"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextWidth.Dispose();
          max_line_width(hv_WindowHandle, hv_Title_COPY_INP_TMP+"  ", out hv_TextWidth);
          }
        }
        else
        {
          hv_TextWidth.Dispose();
          max_line_width(hv_WindowHandle, hv_Title_COPY_INP_TMP, out hv_TextWidth);
        }
        hv_Column.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column = (hv_WinWidth-hv_TextWidth)-10;
        }
      }
      else
      {
        //Unknown position!
        // stop(...); only in hdevelop
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      disp_message(hv_WindowHandle, hv_Title_COPY_INP_TMP, "window", hv_Row, hv_Column, 
          hv_gTitleDecor.TupleSelect(0), hv_gTitleDecor.TupleSelect(1));
      }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Information = (((""+hv_Information_COPY_INP_TMP)+"")).TupleSplit(
        "\n");
    hv_Information_COPY_INP_TMP.Dispose();
    hv_Information_COPY_INP_TMP = ExpTmpLocalVar_Information;
    }
    }
    hv_NumInfoLines.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumInfoLines = new HTuple(hv_Information_COPY_INP_TMP.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumInfoLines.TupleGreater(0))) != 0)
    {
      if ((int)(new HTuple(hv_gInfoPos.TupleEqual("UpperLeft"))) != 0)
      {
        hv_Row.Dispose();
        hv_Row = 12;
        hv_Column.Dispose();
        hv_Column = 12;
      }
      else if ((int)(new HTuple(hv_gInfoPos.TupleEqual("UpperRight"))) != 0)
      {
        if ((int)(new HTuple(((hv_gInfoDecor.TupleSelect(1))).TupleEqual("true"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextWidth.Dispose();
          max_line_width(hv_WindowHandle, hv_Information_COPY_INP_TMP+"  ", out hv_TextWidth);
          }
        }
        else
        {
          hv_TextWidth.Dispose();
          max_line_width(hv_WindowHandle, hv_Information_COPY_INP_TMP, out hv_TextWidth);
        }
        hv_Row.Dispose();
        hv_Row = 12;
        hv_Column.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column = (hv_WinWidth-hv_TextWidth)-12;
        }
      }
      else if ((int)(new HTuple(hv_gInfoPos.TupleEqual("LowerLeft"))) != 0)
      {
        hv_Ascent.Dispose();hv_Descent.Dispose();hv_Width.Dispose();hv_Height.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Information_COPY_INP_TMP, 
            out hv_Ascent, out hv_Descent, out hv_Width, out hv_Height);
        hv_Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row = (hv_WinHeight-((((new HTuple(0)).TupleMax2(
            hv_NumInfoLines-1))*(hv_Ascent+hv_Descent))+hv_Height))-70;
        }
        hv_Column.Dispose();
        hv_Column = 12;
      }
      else
      {
        //Unknown position!
        // stop(...); only in hdevelop
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      disp_message(hv_WindowHandle, hv_Information_COPY_INP_TMP, "window", hv_Row, 
          hv_Column, hv_gInfoDecor.TupleSelect(0), hv_gInfoDecor.TupleSelect(1));
      }
    }
    //

    hv_Information_COPY_INP_TMP.Dispose();
    hv_Title_COPY_INP_TMP.Dispose();
    hv_gInfoDecor.Dispose();
    hv_gInfoPos.Dispose();
    hv_gTitlePos.Dispose();
    hv_gTitleDecor.Dispose();
    hv_WinRow.Dispose();
    hv_WinColumn.Dispose();
    hv_WinWidth.Dispose();
    hv_WinHeight.Dispose();
    hv_NumTitleLines.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_TextWidth.Dispose();
    hv_NumInfoLines.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  public void disp_title_and_information_visualize_object_model_3d (HTuple hv_WindowHandle, 
      HTuple hv_Title, HTuple hv_Information)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WinRow = new HTuple(), hv_WinColumn = new HTuple();
    HTuple hv_WinWidth = new HTuple(), hv_WinHeight = new HTuple();
    HTuple hv_NumTitleLines = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_TextWidth = new HTuple();
    HTuple hv_NumInfoLines = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple();
    HTuple   hv_Information_COPY_INP_TMP = new HTuple(hv_Information);
    HTuple   hv_Title_COPY_INP_TMP = new HTuple(hv_Title);

    // Initialize local and output iconic variables 
    //
    //global tuple gInfoDecor
    //global tuple gInfoPos
    //global tuple gTitlePos
    //global tuple gTitleDecor
    //
    hv_WinRow.Dispose();hv_WinColumn.Dispose();hv_WinWidth.Dispose();hv_WinHeight.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_WinRow, out hv_WinColumn, 
        out hv_WinWidth, out hv_WinHeight);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Title = (((""+hv_Title_COPY_INP_TMP)+"")).TupleSplit(
        "\n");
    hv_Title_COPY_INP_TMP.Dispose();
    hv_Title_COPY_INP_TMP = ExpTmpLocalVar_Title;
    }
    }
    hv_NumTitleLines.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumTitleLines = new HTuple(hv_Title_COPY_INP_TMP.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumTitleLines.TupleGreater(0))) != 0)
    {
      hv_Row.Dispose();
      hv_Row = 12;
      if ((int)(new HTuple(ExpGetGlobalVar_gTitlePos().TupleEqual("UpperLeft"))) != 0)
      {
        hv_Column.Dispose();
        hv_Column = 12;
      }
      else if ((int)(new HTuple(ExpGetGlobalVar_gTitlePos().TupleEqual("UpperCenter"))) != 0)
      {
        hv_TextWidth.Dispose();
        max_line_width_visualize_object_model_3d(hv_WindowHandle, hv_Title_COPY_INP_TMP, 
            out hv_TextWidth);
        hv_Column.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column = (hv_WinWidth/2)-(hv_TextWidth/2);
        }
      }
      else if ((int)(new HTuple(ExpGetGlobalVar_gTitlePos().TupleEqual("UpperRight"))) != 0)
      {
        if ((int)(new HTuple(((ExpGetGlobalVar_gTitleDecor().TupleSelect(1))).TupleEqual(
            "true"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextWidth.Dispose();
          max_line_width_visualize_object_model_3d(hv_WindowHandle, hv_Title_COPY_INP_TMP+"  ", 
              out hv_TextWidth);
          }
        }
        else
        {
          hv_TextWidth.Dispose();
          max_line_width_visualize_object_model_3d(hv_WindowHandle, hv_Title_COPY_INP_TMP, 
              out hv_TextWidth);
        }
        hv_Column.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column = (hv_WinWidth-hv_TextWidth)-10;
        }
      }
      else
      {
        //Unknown position!
        // stop(...); only in hdevelop
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      disp_message(hv_WindowHandle, hv_Title_COPY_INP_TMP, "window", hv_Row, hv_Column, 
          ExpGetGlobalVar_gTitleDecor().TupleSelect(0), ExpGetGlobalVar_gTitleDecor().TupleSelect(
          1));
      }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Information = (((""+hv_Information_COPY_INP_TMP)+"")).TupleSplit(
        "\n");
    hv_Information_COPY_INP_TMP.Dispose();
    hv_Information_COPY_INP_TMP = ExpTmpLocalVar_Information;
    }
    }
    hv_NumInfoLines.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumInfoLines = new HTuple(hv_Information_COPY_INP_TMP.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumInfoLines.TupleGreater(0))) != 0)
    {
      if ((int)(new HTuple(ExpGetGlobalVar_gInfoPos().TupleEqual("UpperLeft"))) != 0)
      {
        hv_Row.Dispose();
        hv_Row = 12;
        hv_Column.Dispose();
        hv_Column = 12;
      }
      else if ((int)(new HTuple(ExpGetGlobalVar_gInfoPos().TupleEqual("UpperRight"))) != 0)
      {
        if ((int)(new HTuple(((ExpGetGlobalVar_gInfoDecor().TupleSelect(1))).TupleEqual(
            "true"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextWidth.Dispose();
          max_line_width_visualize_object_model_3d(hv_WindowHandle, hv_Information_COPY_INP_TMP+"  ", 
              out hv_TextWidth);
          }
        }
        else
        {
          hv_TextWidth.Dispose();
          max_line_width_visualize_object_model_3d(hv_WindowHandle, hv_Information_COPY_INP_TMP, 
              out hv_TextWidth);
        }
        hv_Row.Dispose();
        hv_Row = 12;
        hv_Column.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column = (hv_WinWidth-hv_TextWidth)-12;
        }
      }
      else if ((int)(new HTuple(ExpGetGlobalVar_gInfoPos().TupleEqual("LowerLeft"))) != 0)
      {
        hv_Ascent.Dispose();hv_Descent.Dispose();hv_Width.Dispose();hv_Height.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Information_COPY_INP_TMP, 
            out hv_Ascent, out hv_Descent, out hv_Width, out hv_Height);
        hv_Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row = (hv_WinHeight-((((new HTuple(0)).TupleMax2(
            hv_NumInfoLines-1))*(hv_Ascent+hv_Descent))+hv_Height))-12;
        }
        hv_Column.Dispose();
        hv_Column = 12;
      }
      else
      {
        //Unknown position!
        // stop(...); only in hdevelop
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      disp_message(hv_WindowHandle, hv_Information_COPY_INP_TMP, "window", hv_Row, 
          hv_Column, ExpGetGlobalVar_gInfoDecor().TupleSelect(0), ExpGetGlobalVar_gInfoDecor().TupleSelect(
          1));
      }
    }
    //

    hv_Information_COPY_INP_TMP.Dispose();
    hv_Title_COPY_INP_TMP.Dispose();
    hv_WinRow.Dispose();
    hv_WinColumn.Dispose();
    hv_WinWidth.Dispose();
    hv_WinHeight.Dispose();
    hv_NumTitleLines.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_TextWidth.Dispose();
    hv_NumInfoLines.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Renders 3D object models in a buffer window. 
  public void dump_image_output (HObject ho_BackgroundImage, HTuple hv_Parameters, 
      HTuple hv_WindowHandleBuffer, HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_CamParam, HTuple hv_Poses, 
      HTuple hv_ColorImage, HTuple hv_Title, HTuple hv_Information, HTuple hv_Labels, 
      HTuple hv_VisualizeTrackball, HTuple hv_DisplayButtons, HTuple hv_TrackballCenterRow, 
      HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel, HTuple hv_SelectedObject, 
      HTuple hv_VisualizeRotationCenter, HTuple hv_RotationCenter, HTuple hv_Type, 
      HTuple hv_Message, HTuple hv_DispViewPoint, HTuple hv_ViewPoint)
  {




    // Local iconic variables 

    HObject ho_ModelContours=null, ho_TrackballContour=null;
    HObject ho_CrossRotCenter=null;

    // Local control variables 

    HTuple hv_gUsesOpenGL = new HTuple(), hv_gAlphaDeselected = new HTuple();
    HTuple hv_gButtons = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Exception1 = new HTuple();
    HTuple hv_DeselectedIdx = new HTuple(), hv_DeselectedName = new HTuple();
    HTuple hv_DeselectedValue = new HTuple(), hv_gLabelsDecor = new HTuple();
    HTuple hv_Pose = new HTuple(), hv_HomMat3D = new HTuple();
    HTuple hv_Center = new HTuple(), hv_CenterCamX = new HTuple();
    HTuple hv_CenterCamY = new HTuple(), hv_CenterCamZ = new HTuple();
    HTuple hv_CenterRow = new HTuple(), hv_CenterCol = new HTuple();
    HTuple hv_Label = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_TextWidth = new HTuple();
    HTuple hv_TextHeight = new HTuple(), hv_gDispObjOffset = new HTuple();
    HTuple hv_RotCenterRow = new HTuple(), hv_RotCenterCol = new HTuple();
    HTuple hv_Orientation = new HTuple(), hv_Colors = new HTuple();
    HTuple hv_Type1 = new HTuple(), hv_Message1 = new HTuple();
    HTuple hv_Type2 = new HTuple(), hv_Message2 = new HTuple();
    HTuple   hv_RotationCenter_COPY_INP_TMP = new HTuple(hv_RotationCenter);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ModelContours);
    HOperatorSet.GenEmptyObj(out ho_TrackballContour);
    HOperatorSet.GenEmptyObj(out ho_CrossRotCenter);
    hv_gUsesOpenGL.Dispose();
    HOperatorSet.GetMessageTuple(hv_Parameters, "gUsesOpenGL", out hv_gUsesOpenGL);
    hv_gAlphaDeselected.Dispose();
    HOperatorSet.GetMessageTuple(hv_Parameters, "gAlphaDeselected", out hv_gAlphaDeselected);
    hv_gButtons.Dispose();
    HOperatorSet.GetMessageTuple(hv_Parameters, "gButtons", out hv_gButtons);

    //
    //Display background image
    HOperatorSet.ClearWindow(hv_WindowHandleBuffer);
    if ((int)(hv_ColorImage) != 0)
    {
      HOperatorSet.DispColor(ho_BackgroundImage, hv_WindowHandleBuffer);
    }
    else
    {
      HOperatorSet.DispImage(ho_BackgroundImage, hv_WindowHandleBuffer);
    }
    //
    //Display objects
    if ((int)(new HTuple(((hv_SelectedObject.TupleSum())).TupleEqual(new HTuple(hv_SelectedObject.TupleLength()
        )))) != 0)
    {
      if ((int)(new HTuple(hv_gUsesOpenGL.TupleEqual("true"))) != 0)
      {
        try
        {
          HOperatorSet.DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          if ((int)((new HTuple((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
              5185))).TupleOr(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
              5188))))).TupleOr(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
              5187)))) != 0)
          {
            hv_gUsesOpenGL.Dispose();
            hv_gUsesOpenGL = "false";
            HOperatorSet.SetMessageTuple(hv_Parameters, "gUsesOpenGL", hv_gUsesOpenGL);
          }
          else
          {
            throw new HalconException(hv_Exception);
          }
        }
      }
      if ((int)(new HTuple(hv_gUsesOpenGL.TupleEqual("false"))) != 0)
      {
        //* NO OpenGL, use fallback
        ho_ModelContours.Dispose();
        disp_object_model_no_opengl(out ho_ModelContours, hv_ObjectModel3DID, hv_GenParamName, 
            hv_GenParamValue, hv_WindowHandleBuffer, hv_CamParam, hv_Poses);
      }
    }
    else
    {
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_AlphaOrig.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        if ((int)(new HTuple(((hv_SelectedObject.TupleSelect(hv_Index))).TupleEqual(
            1))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", hv_AlphaOrig.TupleSelect(
              hv_Index));
          }
        }
        else
        {
          HOperatorSet.SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", hv_gAlphaDeselected);
        }
      }
      try
      {
        if ((int)(new HTuple(hv_gUsesOpenGL.TupleEqual("false"))) != 0)
        {
          throw new HalconException(new HTuple());
        }
        HOperatorSet.DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
      }
      // catch (Exception1) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception1);
        //* NO OpenGL, use fallback
        hv_DeselectedIdx.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DeselectedIdx = hv_SelectedObject.TupleFind(
            0);
        }
        if ((int)(new HTuple(hv_DeselectedIdx.TupleNotEqual(-1))) != 0)
        {
          hv_DeselectedName.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DeselectedName = "color_"+hv_DeselectedIdx;
          }
          hv_DeselectedValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DeselectedValue = HTuple.TupleGenConst(
              new HTuple(hv_DeselectedName.TupleLength()),"gray");
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ModelContours.Dispose();
        disp_object_model_no_opengl(out ho_ModelContours, hv_ObjectModel3DID, hv_GenParamName.TupleConcat(
            hv_DeselectedName), hv_GenParamValue.TupleConcat(hv_DeselectedValue), 
            hv_WindowHandleBuffer, hv_CamParam, hv_Poses);
        }
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_AlphaOrig.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", hv_AlphaOrig.TupleSelect(
            hv_Index));
        }
      }
    }
    //
    //Display labels
    if ((int)(new HTuple(hv_Labels.TupleNotEqual(0))) != 0)
    {
      hv_gLabelsDecor.Dispose();
      HOperatorSet.GetMessageTuple(hv_Parameters, "gLabelsDecor", out hv_gLabelsDecor);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetColor(hv_WindowHandleBuffer, hv_gLabelsDecor.TupleSelect(0));
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ObjectModel3DID.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        //Project the center point of the current model
        hv_Pose.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Pose = hv_Poses.TupleSelectRange(
            hv_Index*7,(hv_Index*7)+6);
        }
        hv_HomMat3D.Dispose();
        HOperatorSet.PoseToHomMat3d(hv_Pose, out hv_HomMat3D);
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Center.Dispose();
          HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID.TupleSelect(hv_Index), 
              "center", out hv_Center);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CenterCamX.Dispose();hv_CenterCamY.Dispose();hv_CenterCamZ.Dispose();
          HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_Center.TupleSelect(0), 
              hv_Center.TupleSelect(1), hv_Center.TupleSelect(2), out hv_CenterCamX, 
              out hv_CenterCamY, out hv_CenterCamZ);
          }
          hv_CenterRow.Dispose();hv_CenterCol.Dispose();
          HOperatorSet.Project3dPoint(hv_CenterCamX, hv_CenterCamY, hv_CenterCamZ, 
              hv_CamParam, out hv_CenterRow, out hv_CenterCol);
          hv_Label.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Label = hv_Labels.TupleSelect(
              hv_Index);
          }
          if ((int)(new HTuple(hv_Label.TupleNotEqual(""))) != 0)
          {
            hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
            HOperatorSet.GetStringExtents(hv_WindowHandleBuffer, hv_Label, out hv_Ascent, 
                out hv_Descent, out hv_TextWidth, out hv_TextHeight);
            hv_gDispObjOffset.Dispose();
            HOperatorSet.GetMessageTuple(hv_Parameters, "gDispObjOffset", out hv_gDispObjOffset);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            disp_message(hv_WindowHandleBuffer, hv_Label, "window", (hv_CenterRow-(hv_TextHeight/2))+(hv_gDispObjOffset.TupleSelect(
                0)), (hv_CenterCol-(hv_TextWidth/2))+(hv_gDispObjOffset.TupleSelect(
                1)), new HTuple(), hv_gLabelsDecor.TupleSelect(1));
            }
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          //Unable to get the center of the 3D object model. It is probably empty -> do not display any label
        }
      }
    }
    //
    //Visualize the trackball if desired
    if ((int)(hv_VisualizeTrackball) != 0)
    {
      HOperatorSet.SetLineWidth(hv_WindowHandleBuffer, 1);
      ho_TrackballContour.Dispose();
      HOperatorSet.GenEllipseContourXld(out ho_TrackballContour, hv_TrackballCenterRow, 
          hv_TrackballCenterCol, 0, hv_TrackballRadiusPixel, hv_TrackballRadiusPixel, 
          0, 6.28318, "positive", 1.5);
      HOperatorSet.SetColor(hv_WindowHandleBuffer, "dim gray");
      HOperatorSet.DispXld(ho_TrackballContour, hv_WindowHandleBuffer);
    }
    //
    //Visualize the rotation center if desired
    if ((int)((new HTuple(hv_VisualizeRotationCenter.TupleNotEqual(0))).TupleAnd(
        new HTuple((new HTuple(hv_RotationCenter_COPY_INP_TMP.TupleLength())).TupleEqual(
        3)))) != 0)
    {
      if ((int)(new HTuple(((hv_RotationCenter_COPY_INP_TMP.TupleSelect(2))).TupleLess(
          1e-10))) != 0)
      {
        if (hv_RotationCenter_COPY_INP_TMP == null)
          hv_RotationCenter_COPY_INP_TMP = new HTuple();
        hv_RotationCenter_COPY_INP_TMP[2] = 1e-10;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RotCenterRow.Dispose();hv_RotCenterCol.Dispose();
      HOperatorSet.Project3dPoint(hv_RotationCenter_COPY_INP_TMP.TupleSelect(0), 
          hv_RotationCenter_COPY_INP_TMP.TupleSelect(1), hv_RotationCenter_COPY_INP_TMP.TupleSelect(
          2), hv_CamParam, out hv_RotCenterRow, out hv_RotCenterCol);
      }
      hv_Orientation.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Orientation = (new HTuple(90)).TupleRad()
          ;
      }
      if ((int)(new HTuple(hv_VisualizeRotationCenter.TupleEqual(1))) != 0)
      {
        hv_Orientation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Orientation = (new HTuple(45)).TupleRad()
            ;
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_CrossRotCenter.Dispose();
      HOperatorSet.GenCrossContourXld(out ho_CrossRotCenter, hv_RotCenterRow, hv_RotCenterCol, 
          hv_TrackballRadiusPixel/25.0, hv_Orientation);
      }
      HOperatorSet.SetLineWidth(hv_WindowHandleBuffer, 3);
      hv_Colors.Dispose();
      HOperatorSet.QueryColor(hv_WindowHandleBuffer, out hv_Colors);
      HOperatorSet.SetColor(hv_WindowHandleBuffer, "light gray");
      HOperatorSet.DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
      HOperatorSet.SetLineWidth(hv_WindowHandleBuffer, 1);
      HOperatorSet.SetColor(hv_WindowHandleBuffer, "dim gray");
      HOperatorSet.DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
    }
    //
    //Display title
    if ((int)(new HTuple((new HTuple(hv_Type.TupleLength())).TupleEqual(1))) != 0)
    {
      hv_Type1.Dispose();
      hv_Type1 = new HTuple(hv_Type);
      hv_Message1.Dispose();
      hv_Message1 = new HTuple(hv_Message);
      write_note(hv_WindowHandleBuffer, hv_Type1, hv_Message1);
    }
    else if ((int)(new HTuple((new HTuple(hv_Type.TupleLength())).TupleEqual(
        2))) != 0)
    {
      hv_Type1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Type1 = hv_Type.TupleSelect(
          0);
      }
      hv_Type2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Type2 = hv_Type.TupleSelect(
          1);
      }
      hv_Message1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Message1 = hv_Message.TupleSelect(
          0);
      }
      hv_Message2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Message2 = hv_Message.TupleSelectRange(
          1,(new HTuple(hv_Message.TupleLength()))-1);
      }
      write_note(hv_WindowHandleBuffer, hv_Type1, hv_Message1);
      HOperatorSet.SetTposition(hv_WindowHandleBuffer, 1, 12);
      write_note(hv_WindowHandleBuffer, hv_Type2, hv_Message2);
    }
    if ((int)(new HTuple(hv_DispViewPoint.TupleEqual("true"))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      disp_message(hv_WindowHandleBuffer, (((("ViewPoint [m]\n   X :"+(((hv_ViewPoint.TupleSelect(
          0))).TupleString(".2f")))+"\n   Y: ")+(((hv_ViewPoint.TupleSelect(1))).TupleString(
          ".2f")))+"\n   Z: ")+(((hv_ViewPoint.TupleSelect(2))).TupleString(".2f")), 
          "window", 300, 12, "#FFA500", "false");
      }
    }

    disp_title_and_information(hv_Parameters, hv_WindowHandleBuffer, hv_Title, hv_Information);
    //
    //Display the 'Exit' button
    if ((int)(new HTuple(hv_DisplayButtons.TupleEqual("true"))) != 0)
    {
      disp_buttons(hv_Parameters, hv_WindowHandleBuffer);
    }
    //
    ho_ModelContours.Dispose();
    ho_TrackballContour.Dispose();
    ho_CrossRotCenter.Dispose();

    hv_RotationCenter_COPY_INP_TMP.Dispose();
    hv_gUsesOpenGL.Dispose();
    hv_gAlphaDeselected.Dispose();
    hv_gButtons.Dispose();
    hv_Exception.Dispose();
    hv_Index.Dispose();
    hv_Exception1.Dispose();
    hv_DeselectedIdx.Dispose();
    hv_DeselectedName.Dispose();
    hv_DeselectedValue.Dispose();
    hv_gLabelsDecor.Dispose();
    hv_Pose.Dispose();
    hv_HomMat3D.Dispose();
    hv_Center.Dispose();
    hv_CenterCamX.Dispose();
    hv_CenterCamY.Dispose();
    hv_CenterCamZ.Dispose();
    hv_CenterRow.Dispose();
    hv_CenterCol.Dispose();
    hv_Label.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_TextWidth.Dispose();
    hv_TextHeight.Dispose();
    hv_gDispObjOffset.Dispose();
    hv_RotCenterRow.Dispose();
    hv_RotCenterCol.Dispose();
    hv_Orientation.Dispose();
    hv_Colors.Dispose();
    hv_Type1.Dispose();
    hv_Message1.Dispose();
    hv_Type2.Dispose();
    hv_Message2.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Renders 3D object models in a buffer window. 
  public void dump_image_output_visualize_object_model_3d (HObject ho_BackgroundImage, 
      HTuple hv_WindowHandleBuffer, HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_CamParam, HTuple hv_Poses, 
      HTuple hv_ColorImage, HTuple hv_Title, HTuple hv_Information, HTuple hv_Labels, 
      HTuple hv_VisualizeTrackball, HTuple hv_DisplayContinueButton, HTuple hv_TrackballCenterRow, 
      HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel, HTuple hv_SelectedObject, 
      HTuple hv_VisualizeRotationCenter, HTuple hv_RotationCenter)
  {




        // Local iconic variables 

        HObject ho_TrackballContour=null, ho_CrossRotCenter=null;
        HObject ho_ModelContours=null;

        // Local control variables 

        HTuple ExpTmpLocalVar_gUsesOpenGL = new HTuple();
        HTuple hv_Exception = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Exception1 = new HTuple(), hv_DeselectedIdx = new HTuple();
        HTuple hv_DeselectedName = new HTuple(), hv_DeselectedValue = new HTuple();
        HTuple hv_Pose = new HTuple(), hv_HomMat3D = new HTuple();
        HTuple hv_Center = new HTuple(), hv_CenterCamX = new HTuple();
        HTuple hv_CenterCamY = new HTuple(), hv_CenterCamZ = new HTuple();
        HTuple hv_CenterRow = new HTuple(), hv_CenterCol = new HTuple();
        HTuple hv_Label = new HTuple(), hv_Ascent = new HTuple();
        HTuple hv_Descent = new HTuple(), hv_TextWidth = new HTuple();
        HTuple hv_TextHeight = new HTuple(), hv_RotCenterRow = new HTuple();
        HTuple hv_RotCenterCol = new HTuple(), hv_Orientation = new HTuple();
        HTuple hv_Colors = new HTuple();
        HTuple   hv_RotationCenter_COPY_INP_TMP = new HTuple(hv_RotationCenter);

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_TrackballContour);
        HOperatorSet.GenEmptyObj(out ho_CrossRotCenter);
        HOperatorSet.GenEmptyObj(out ho_ModelContours);
    //global tuple gAlphaDeselected
    //global tuple gTerminationButtonLabel
    //global tuple gDispObjOffset
    //global tuple gLabelsDecor
    //global tuple gUsesOpenGL
    //
    //Display background image
    HOperatorSet.ClearWindow(hv_WindowHandleBuffer);
    if ((int)(hv_ColorImage) != 0)
    {
      HOperatorSet.DispColor(ho_BackgroundImage, hv_WindowHandleBuffer);
    }
    else
    {
      HOperatorSet.DispImage(ho_BackgroundImage, hv_WindowHandleBuffer);
    }
    //
    //Display objects
    if ((int)(new HTuple(((hv_SelectedObject.TupleSum())).TupleEqual(new HTuple(hv_SelectedObject.TupleLength()
        )))) != 0)
    {
      if ((int)(new HTuple(ExpGetGlobalVar_gUsesOpenGL().TupleEqual("true"))) != 0)
      {
        try
        {
          HOperatorSet.DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          if ((int)((new HTuple((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
              5185))).TupleOr(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
              5188))))).TupleOr(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
              5187)))) != 0)
          {
            ExpTmpLocalVar_gUsesOpenGL = "false";
            ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
          }
          else
          {
            throw new HalconException(hv_Exception);
          }
        }
      }
      if ((int)(new HTuple(ExpGetGlobalVar_gUsesOpenGL().TupleEqual("false"))) != 0)
      {
        //* NO OpenGL, use fallback
        ho_ModelContours.Dispose();
        disp_object_model_no_opengl(out ho_ModelContours, hv_ObjectModel3DID, hv_GenParamName, 
            hv_GenParamValue, hv_WindowHandleBuffer, hv_CamParam, hv_Poses);
      }
    }
    else
    {
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_AlphaOrig.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        if ((int)(new HTuple(((hv_SelectedObject.TupleSelect(hv_Index))).TupleEqual(
            1))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", hv_AlphaOrig.TupleSelect(
              hv_Index));
          }
        }
        else
        {
          HOperatorSet.SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", ExpGetGlobalVar_gAlphaDeselected());
        }
      }
      try
      {
        if ((int)(new HTuple(ExpGetGlobalVar_gUsesOpenGL().TupleEqual("false"))) != 0)
        {
          throw new HalconException(new HTuple());
        }
        HOperatorSet.DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
      }
      // catch (Exception1) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception1);
        //* NO OpenGL, use fallback
        hv_DeselectedIdx.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DeselectedIdx = hv_SelectedObject.TupleFind(
            0);
        }
        if ((int)(new HTuple(hv_DeselectedIdx.TupleNotEqual(-1))) != 0)
        {
          hv_DeselectedName.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DeselectedName = "color_"+hv_DeselectedIdx;
          }
          hv_DeselectedValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DeselectedValue = HTuple.TupleGenConst(
              new HTuple(hv_DeselectedName.TupleLength()),"gray");
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ModelContours.Dispose();
        disp_object_model_no_opengl(out ho_ModelContours, hv_ObjectModel3DID, hv_GenParamName.TupleConcat(
            hv_DeselectedName), hv_GenParamValue.TupleConcat(hv_DeselectedValue), 
            hv_WindowHandleBuffer, hv_CamParam, hv_Poses);
        }
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_AlphaOrig.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", hv_AlphaOrig.TupleSelect(
            hv_Index));
        }
      }
    }
    //
    //Display labels
    if ((int)(new HTuple(hv_Labels.TupleNotEqual(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetColor(hv_WindowHandleBuffer, ExpGetGlobalVar_gLabelsDecor().TupleSelect(
          0));
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ObjectModel3DID.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        //Project the center point of the current model
        hv_Pose.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Pose = hv_Poses.TupleSelectRange(
            hv_Index*7,(hv_Index*7)+6);
        }
        hv_HomMat3D.Dispose();
        HOperatorSet.PoseToHomMat3d(hv_Pose, out hv_HomMat3D);
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Center.Dispose();
          HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID.TupleSelect(hv_Index), 
              "center", out hv_Center);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CenterCamX.Dispose();hv_CenterCamY.Dispose();hv_CenterCamZ.Dispose();
          HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_Center.TupleSelect(0), 
              hv_Center.TupleSelect(1), hv_Center.TupleSelect(2), out hv_CenterCamX, 
              out hv_CenterCamY, out hv_CenterCamZ);
          }
          hv_CenterRow.Dispose();hv_CenterCol.Dispose();
          HOperatorSet.Project3dPoint(hv_CenterCamX, hv_CenterCamY, hv_CenterCamZ, 
              hv_CamParam, out hv_CenterRow, out hv_CenterCol);
          hv_Label.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Label = hv_Labels.TupleSelect(
              hv_Index);
          }
          if ((int)(new HTuple(hv_Label.TupleNotEqual(""))) != 0)
          {
            hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
            HOperatorSet.GetStringExtents(hv_WindowHandleBuffer, hv_Label, out hv_Ascent, 
                out hv_Descent, out hv_TextWidth, out hv_TextHeight);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            disp_message(hv_WindowHandleBuffer, hv_Label, "window", (hv_CenterRow-(hv_TextHeight/2))+(ExpGetGlobalVar_gDispObjOffset().TupleSelect(
                0)), (hv_CenterCol-(hv_TextWidth/2))+(ExpGetGlobalVar_gDispObjOffset().TupleSelect(
                1)), new HTuple(), ExpGetGlobalVar_gLabelsDecor().TupleSelect(1));
            }
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          //The 3D object model might not have a center because it is empty
          //-> do not display any label
        }
      }
    }
    //
    //Visualize the trackball if desired
    if ((int)(hv_VisualizeTrackball) != 0)
    {
      HOperatorSet.SetLineWidth(hv_WindowHandleBuffer, 1);
      ho_TrackballContour.Dispose();
      HOperatorSet.GenEllipseContourXld(out ho_TrackballContour, hv_TrackballCenterRow, 
          hv_TrackballCenterCol, 0, hv_TrackballRadiusPixel, hv_TrackballRadiusPixel, 
          0, 6.28318, "positive", 1.5);
      HOperatorSet.SetColor(hv_WindowHandleBuffer, "dim gray");
      HOperatorSet.DispXld(ho_TrackballContour, hv_WindowHandleBuffer);
    }
    //
    //Visualize the rotation center if desired
    if ((int)((new HTuple(hv_VisualizeRotationCenter.TupleNotEqual(0))).TupleAnd(
        new HTuple((new HTuple(hv_RotationCenter_COPY_INP_TMP.TupleLength())).TupleEqual(
        3)))) != 0)
    {
      if ((int)(new HTuple(((hv_RotationCenter_COPY_INP_TMP.TupleSelect(2))).TupleLess(
          1e-10))) != 0)
      {
        if (hv_RotationCenter_COPY_INP_TMP == null)
          hv_RotationCenter_COPY_INP_TMP = new HTuple();
        hv_RotationCenter_COPY_INP_TMP[2] = 1e-10;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RotCenterRow.Dispose();hv_RotCenterCol.Dispose();
      HOperatorSet.Project3dPoint(hv_RotationCenter_COPY_INP_TMP.TupleSelect(0), 
          hv_RotationCenter_COPY_INP_TMP.TupleSelect(1), hv_RotationCenter_COPY_INP_TMP.TupleSelect(
          2), hv_CamParam, out hv_RotCenterRow, out hv_RotCenterCol);
      }
      hv_Orientation.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Orientation = (new HTuple(90)).TupleRad()
          ;
      }
      if ((int)(new HTuple(hv_VisualizeRotationCenter.TupleEqual(1))) != 0)
      {
        hv_Orientation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Orientation = (new HTuple(45)).TupleRad()
            ;
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_CrossRotCenter.Dispose();
      HOperatorSet.GenCrossContourXld(out ho_CrossRotCenter, hv_RotCenterRow, hv_RotCenterCol, 
          hv_TrackballRadiusPixel/25.0, hv_Orientation);
      }
      HOperatorSet.SetLineWidth(hv_WindowHandleBuffer, 3);
      hv_Colors.Dispose();
      HOperatorSet.QueryColor(hv_WindowHandleBuffer, out hv_Colors);
      HOperatorSet.SetColor(hv_WindowHandleBuffer, "light gray");
      HOperatorSet.DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
      HOperatorSet.SetLineWidth(hv_WindowHandleBuffer, 1);
      HOperatorSet.SetColor(hv_WindowHandleBuffer, "dim gray");
      HOperatorSet.DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
    }
    //
    //Display title
    disp_title_and_information_visualize_object_model_3d(hv_WindowHandleBuffer, hv_Title, 
        hv_Information);
    //
    //Display the 'Exit' button
    if ((int)(new HTuple(hv_DisplayContinueButton.TupleEqual("true"))) != 0)
    {
      disp_continue_button(hv_WindowHandleBuffer);
    }
    //
    ho_TrackballContour.Dispose();
    ho_CrossRotCenter.Dispose();
    ho_ModelContours.Dispose();

    hv_RotationCenter_COPY_INP_TMP.Dispose();
    hv_Exception.Dispose();
    hv_Index.Dispose();
    hv_Exception1.Dispose();
    hv_DeselectedIdx.Dispose();
    hv_DeselectedName.Dispose();
    hv_DeselectedValue.Dispose();
    hv_Pose.Dispose();
    hv_HomMat3D.Dispose();
    hv_Center.Dispose();
    hv_CenterCamX.Dispose();
    hv_CenterCamY.Dispose();
    hv_CenterCamZ.Dispose();
    hv_CenterRow.Dispose();
    hv_CenterCol.Dispose();
    hv_Label.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_TextWidth.Dispose();
    hv_TextHeight.Dispose();
    hv_RotCenterRow.Dispose();
    hv_RotCenterCol.Dispose();
    hv_Orientation.Dispose();
    hv_Colors.Dispose();

    return;
  }

  // Chapter: 3D Reconstruction / Multi-View Stereo
  // Short Description: Estimate a bounding box for 3D reconstruction based on a stereo setup. 
  public void estimate_bounding_box_3d_reconstruction (HTuple hv_StereoModelID, HTuple hv_ObjectHeight, 
      out HTuple hv_BoundingBox)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_PlaneConeIntersections, ho_ContourFrom=null;
    HObject ho_ContourTo=null, ho_RectangleFrom=null, ho_RectangleTo=null;
    HObject ho_ContoursIntersection=null, ho_PlaneConeIntersectionUnion;
    HObject ho_ObjectSelected=null;

    // Local control variables 

    HTuple hv_CameraSetupModelID = new HTuple();
    HTuple hv_ReferenceCamera = new HTuple(), hv_From = new HTuple();
    HTuple hv_To = new HTuple(), hv_NumCameras = new HTuple();
    HTuple hv_ObjectModel3DCone = new HTuple(), hv_DistanceCameras = new HTuple();
    HTuple hv_CameraIndex = new HTuple(), hv_CamPose = new HTuple();
    HTuple hv_DistanceCamera = new HTuple(), hv_ConeLength = new HTuple();
    HTuple hv_Type = new HTuple(), hv_ObjectModel3D = new HTuple();
    HTuple hv_Index1 = new HTuple(), hv_ObjectModel3DIntersectionFrom = new HTuple();
    HTuple hv_ObjectModel3DIntersectionTo = new HTuple(), hv_XFrom = new HTuple();
    HTuple hv_YFrom = new HTuple(), hv_XTo = new HTuple();
    HTuple hv_YTo = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Phi = new HTuple(), hv_Length1 = new HTuple();
    HTuple hv_Length2 = new HTuple(), hv_Number = new HTuple();
    HTuple hv_Index2 = new HTuple(), hv_RowContour = new HTuple();
    HTuple hv_ColumnContour = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_PlaneConeIntersections);
    HOperatorSet.GenEmptyObj(out ho_ContourFrom);
    HOperatorSet.GenEmptyObj(out ho_ContourTo);
    HOperatorSet.GenEmptyObj(out ho_RectangleFrom);
    HOperatorSet.GenEmptyObj(out ho_RectangleTo);
    HOperatorSet.GenEmptyObj(out ho_ContoursIntersection);
    HOperatorSet.GenEmptyObj(out ho_PlaneConeIntersectionUnion);
    HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
    hv_BoundingBox = new HTuple();
    //The goal of this procedure is to estimate bounding box parameters
    //for 3D reconstruction. This is done by intersecting the
    //cones of sight of the cameras with a plane defined by the pose
    //of the reference calibration plate.
    //
    if ((int)(new HTuple(hv_ObjectHeight.TupleEqual(0))) != 0)
    {
      throw new HalconException("Object height must not be zero.");
    }
    //Check whether the coordinate system has been moved by setting a pose
    //with the parameter 'coord_transf_pose' in set_camera_setup_param.
    //If this is not the case, the origin is still in one of the cameras.
    //However, this procedures needs the origin to be in a calibration plate.
    hv_CameraSetupModelID.Dispose();
    HOperatorSet.GetStereoModelParam(hv_StereoModelID, "camera_setup_model", out hv_CameraSetupModelID);
    hv_ReferenceCamera.Dispose();
    HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, "general", "reference_camera", 
        out hv_ReferenceCamera);
    if ((int)(new HTuple(hv_ReferenceCamera.TupleNotEqual(-1))) != 0)
    {
      throw new HalconException("Please set the 'coord_transf_pose' to the pose of an calibration plate that lies horizontally in the image using the get_calib_data and set_camera_setup_param.");
    }
    //Check whether the image pairs have been set.
    hv_From.Dispose();hv_To.Dispose();
    HOperatorSet.GetStereoModelImagePairs(hv_StereoModelID, out hv_From, out hv_To);
    if ((int)((new HTuple((new HTuple(hv_From.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple((new HTuple(hv_To.TupleLength())).TupleEqual(0)))) != 0)
    {
      throw new HalconException("Please define the image pairs first with 'get_stereo_model_image_pairs.'");
    }
    //
    //First, we generate 3D object models that represent the cones of sight of the cameras,
    //like in the procedure gen_camera_setup_object_model_3d.
    hv_NumCameras.Dispose();
    HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, "general", "num_cameras", 
        out hv_NumCameras);
    hv_ObjectModel3DCone.Dispose();
    hv_ObjectModel3DCone = new HTuple();
    hv_DistanceCameras.Dispose();
    hv_DistanceCameras = new HTuple();
    HTuple end_val28 = hv_NumCameras-1;
    HTuple step_val28 = 1;
    for (hv_CameraIndex=0; hv_CameraIndex.Continue(end_val28, step_val28); hv_CameraIndex = hv_CameraIndex.TupleAdd(step_val28))
    {
      hv_CamPose.Dispose();
      HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "pose", 
          out hv_CamPose);
      hv_DistanceCamera.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DistanceCamera = (((((hv_CamPose.TupleSelect(
          0))*(hv_CamPose.TupleSelect(0)))+((hv_CamPose.TupleSelect(1))*(hv_CamPose.TupleSelect(
          1))))+((hv_CamPose.TupleSelect(2))*(hv_CamPose.TupleSelect(2))))).TupleSqrt()
          ;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DistanceCameras = hv_DistanceCameras.TupleConcat(
          hv_DistanceCamera);
      hv_DistanceCameras.Dispose();
      hv_DistanceCameras = ExpTmpLocalVar_DistanceCameras;
      }
      }
      hv_ConeLength.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ConeLength = hv_DistanceCamera*2.0;
      }
      //Distinguish cases with/without projection center.
      hv_Type.Dispose();
      HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "type", 
          out hv_Type);
      if ((int)(hv_Type.TupleRegexpTest("telecentric")) != 0)
      {
        hv_ObjectModel3D.Dispose();
        gen_cone_telecentric_object_model_3d(hv_CameraSetupModelID, hv_CameraIndex, 
            hv_ConeLength, out hv_ObjectModel3D);
      }
      else
      {
        hv_ObjectModel3D.Dispose();
        gen_cone_perspective_object_model_3d(hv_CameraSetupModelID, hv_CameraIndex, 
            hv_ConeLength, out hv_ObjectModel3D);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ObjectModel3DCone = hv_ObjectModel3DCone.TupleConcat(
          hv_ObjectModel3D);
      hv_ObjectModel3DCone.Dispose();
      hv_ObjectModel3DCone = ExpTmpLocalVar_ObjectModel3DCone;
      }
      }
    }
    //
    //Then, we intersect these cones of sight with a plane that lies horizontally
    //in the origin of the stereo setup. We do this simultaneously for the
    //previously defined image pairs.
    ho_PlaneConeIntersections.Dispose();
    HOperatorSet.GenEmptyObj(out ho_PlaneConeIntersections);
    for (hv_Index1=0; (int)hv_Index1<=(int)((new HTuple(hv_From.TupleLength()))-1); hv_Index1 = (int)hv_Index1 + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ObjectModel3DIntersectionFrom.Dispose();
      HOperatorSet.IntersectPlaneObjectModel3d(hv_ObjectModel3DCone.TupleSelect(hv_From.TupleSelect(
          hv_Index1)), ((((((new HTuple(0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(
          0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(0), out hv_ObjectModel3DIntersectionFrom);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ObjectModel3DIntersectionTo.Dispose();
      HOperatorSet.IntersectPlaneObjectModel3d(hv_ObjectModel3DCone.TupleSelect(hv_To.TupleSelect(
          hv_Index1)), ((((((new HTuple(0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(
          0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(0), out hv_ObjectModel3DIntersectionTo);
      }
      //
      //Get the coordinates of the 3D object models that represent the intersection.
      hv_XFrom.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DIntersectionFrom, "point_coord_x", 
          out hv_XFrom);
      hv_YFrom.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DIntersectionFrom, "point_coord_y", 
          out hv_YFrom);
      hv_XTo.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DIntersectionTo, "point_coord_x", 
          out hv_XTo);
      hv_YTo.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DIntersectionTo, "point_coord_y", 
          out hv_YTo);
      //
      //The, we want to intersect the intersections of the image pair. We do this in 2D using XLDs.
      //Generate the XLD of the 'From' intersection.
      ho_ContourFrom.Dispose();
      HOperatorSet.GenContourPolygonXld(out ho_ContourFrom, hv_XFrom, hv_YFrom);
      //Generate the XLD of the 'To' intersection.
      ho_ContourTo.Dispose();
      HOperatorSet.GenContourPolygonXld(out ho_ContourTo, hv_XTo, hv_YTo);
      //
      //The order of the coordinates from get_object_model_3d_params might not be ideal.
      //Thus, we compute the smallest rectangle around the created XLD.
      hv_Row.Dispose();hv_Column.Dispose();hv_Phi.Dispose();hv_Length1.Dispose();hv_Length2.Dispose();
      HOperatorSet.SmallestRectangle2Xld(ho_ContourFrom, out hv_Row, out hv_Column, 
          out hv_Phi, out hv_Length1, out hv_Length2);
      ho_RectangleFrom.Dispose();
      HOperatorSet.GenRectangle2ContourXld(out ho_RectangleFrom, hv_Row, hv_Column, 
          hv_Phi, hv_Length1, hv_Length2);
      hv_Row.Dispose();hv_Column.Dispose();hv_Phi.Dispose();hv_Length1.Dispose();hv_Length2.Dispose();
      HOperatorSet.SmallestRectangle2Xld(ho_ContourTo, out hv_Row, out hv_Column, 
          out hv_Phi, out hv_Length1, out hv_Length2);
      ho_RectangleTo.Dispose();
      HOperatorSet.GenRectangle2ContourXld(out ho_RectangleTo, hv_Row, hv_Column, 
          hv_Phi, hv_Length1, hv_Length2);
      //
      //Intersect and concatenate the intersections
      ho_ContoursIntersection.Dispose();
      HOperatorSet.IntersectionClosedContoursXld(ho_RectangleFrom, ho_RectangleTo, 
          out ho_ContoursIntersection);
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_PlaneConeIntersections, ho_ContoursIntersection, 
          out ExpTmpOutVar_0);
      ho_PlaneConeIntersections.Dispose();
      ho_PlaneConeIntersections = ExpTmpOutVar_0;
      }
      HOperatorSet.ClearObjectModel3d(hv_ObjectModel3DIntersectionFrom);
      HOperatorSet.ClearObjectModel3d(hv_ObjectModel3DIntersectionTo);
    }
    //
    //Union all intersections of all image pairs.
    ho_PlaneConeIntersectionUnion.Dispose();
    HOperatorSet.GenEmptyObj(out ho_PlaneConeIntersectionUnion);
    hv_Number.Dispose();
    HOperatorSet.CountObj(ho_PlaneConeIntersections, out hv_Number);
    HTuple end_val80 = hv_Number;
    HTuple step_val80 = 1;
    for (hv_Index2=1; hv_Index2.Continue(end_val80, step_val80); hv_Index2 = hv_Index2.TupleAdd(step_val80))
    {
      ho_ObjectSelected.Dispose();
      HOperatorSet.SelectObj(ho_PlaneConeIntersections, out ho_ObjectSelected, hv_Index2);
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.Union2ClosedContoursXld(ho_ObjectSelected, ho_PlaneConeIntersectionUnion, 
          out ExpTmpOutVar_0);
      ho_PlaneConeIntersectionUnion.Dispose();
      ho_PlaneConeIntersectionUnion = ExpTmpOutVar_0;
      }
    }
    //
    //Get the coordinates of the resulting XLD, which represents the area
    //in 2D where the reconstruction is possible.
    hv_RowContour.Dispose();hv_ColumnContour.Dispose();
    HOperatorSet.GetContourXld(ho_PlaneConeIntersectionUnion, out hv_RowContour, 
        out hv_ColumnContour);
    //
    //Based on this contour, we can easily access the parameters of the bounding box.
    if ((int)(new HTuple(hv_ObjectHeight.TupleGreater(0))) != 0)
    {
      hv_BoundingBox.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BoundingBox = new HTuple();
      hv_BoundingBox = hv_BoundingBox.TupleConcat(hv_RowContour.TupleMin()
          );
      hv_BoundingBox = hv_BoundingBox.TupleConcat(hv_ColumnContour.TupleMin()
          );
      hv_BoundingBox = hv_BoundingBox.TupleConcat(-hv_ObjectHeight);
      hv_BoundingBox = hv_BoundingBox.TupleConcat(hv_RowContour.TupleMax()
          );
      hv_BoundingBox = hv_BoundingBox.TupleConcat(hv_ColumnContour.TupleMax()
          );
      hv_BoundingBox = hv_BoundingBox.TupleConcat(0);
      }
    }
    else
    {
      hv_BoundingBox.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BoundingBox = new HTuple();
      hv_BoundingBox = hv_BoundingBox.TupleConcat(hv_RowContour.TupleMin()
          );
      hv_BoundingBox = hv_BoundingBox.TupleConcat(hv_ColumnContour.TupleMin()
          );
      hv_BoundingBox = hv_BoundingBox.TupleConcat(0);
      hv_BoundingBox = hv_BoundingBox.TupleConcat(hv_RowContour.TupleMax()
          );
      hv_BoundingBox = hv_BoundingBox.TupleConcat(hv_ColumnContour.TupleMax()
          );
      hv_BoundingBox = hv_BoundingBox.TupleConcat(-hv_ObjectHeight);
      }
    }
    //
    //Clean up.
    HOperatorSet.ClearCameraSetupModel(hv_CameraSetupModelID);
    HOperatorSet.ClearObjectModel3d(hv_ObjectModel3DCone);
    ho_PlaneConeIntersections.Dispose();
    ho_ContourFrom.Dispose();
    ho_ContourTo.Dispose();
    ho_RectangleFrom.Dispose();
    ho_RectangleTo.Dispose();
    ho_ContoursIntersection.Dispose();
    ho_PlaneConeIntersectionUnion.Dispose();
    ho_ObjectSelected.Dispose();

    hv_CameraSetupModelID.Dispose();
    hv_ReferenceCamera.Dispose();
    hv_From.Dispose();
    hv_To.Dispose();
    hv_NumCameras.Dispose();
    hv_ObjectModel3DCone.Dispose();
    hv_DistanceCameras.Dispose();
    hv_CameraIndex.Dispose();
    hv_CamPose.Dispose();
    hv_DistanceCamera.Dispose();
    hv_ConeLength.Dispose();
    hv_Type.Dispose();
    hv_ObjectModel3D.Dispose();
    hv_Index1.Dispose();
    hv_ObjectModel3DIntersectionFrom.Dispose();
    hv_ObjectModel3DIntersectionTo.Dispose();
    hv_XFrom.Dispose();
    hv_YFrom.Dispose();
    hv_XTo.Dispose();
    hv_YTo.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Phi.Dispose();
    hv_Length1.Dispose();
    hv_Length2.Dispose();
    hv_Number.Dispose();
    hv_Index2.Dispose();
    hv_RowContour.Dispose();
    hv_ColumnContour.Dispose();

    return;
  }

  public void estimate_noise_real (HObject ho_Image, HTuple hv_OutlierRemovalAmount, 
      out HTuple hv_Sigma)
  {




    // Local iconic variables 

    HObject ho_ImageFiltered, ho_RegionErosion;

    // Local control variables 

    HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
    HTuple hv_Grayval = new HTuple(), hv_NumToRemove = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageFiltered);
    HOperatorSet.GenEmptyObj(out ho_RegionErosion);
    hv_Sigma = new HTuple();
    //See documentation of estimate_noise for more information
    //about the used immerkaer noise estimation method.

    ho_ImageFiltered.Dispose();
    HOperatorSet.ConvolImage(ho_Image, out ho_ImageFiltered, (((((((((((new HTuple(3)).TupleConcat(
        3)).TupleConcat(1)).TupleConcat(1)).TupleConcat(-2)).TupleConcat(1)).TupleConcat(
        -2)).TupleConcat(4)).TupleConcat(-2)).TupleConcat(1)).TupleConcat(-2)).TupleConcat(
        1), "mirrored");

    //convol_image will use parts of the background, which might have undefined pixels
    //Remove those parts
    ho_RegionErosion.Dispose();
    HOperatorSet.ErosionRectangle1(ho_Image, out ho_RegionErosion, 3, 3);

    hv_Rows.Dispose();hv_Columns.Dispose();
    HOperatorSet.GetRegionPoints(ho_RegionErosion, out hv_Rows, out hv_Columns);
    if ((int)(new HTuple((new HTuple(hv_Rows.TupleLength())).TupleLess(30))) != 0)
    {
      //Too few points for a robust noise estimation
      //This can happen, for example, if the points are very sparse in the XYZ images
      hv_Sigma.Dispose();
      hv_Sigma = -1;
    }
    else
    {
      hv_Grayval.Dispose();
      HOperatorSet.GetGrayval(ho_ImageFiltered, hv_Rows, hv_Columns, out hv_Grayval);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Grayval = hv_Grayval.TupleAbs()
          ;
      hv_Grayval.Dispose();
      hv_Grayval = ExpTmpLocalVar_Grayval;
      }
      }
      //Instead of the original formula, we use the more robust median
      //to avoid false negatives
      if ((int)(new HTuple(hv_OutlierRemovalAmount.TupleGreater(0))) != 0)
      {
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleSort(hv_Grayval, out ExpTmpOutVar_0);
        hv_Grayval.Dispose();
        hv_Grayval = ExpTmpOutVar_0;
        }
        hv_NumToRemove.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumToRemove = ((((new HTuple(hv_Grayval.TupleLength()
            ))*hv_OutlierRemovalAmount)*0.5)).TupleInt();
        }
        //Catch some special cases
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Grayval = hv_Grayval.TupleSelectRange(
              hv_NumToRemove,((new HTuple(hv_Grayval.TupleLength()))-hv_NumToRemove)-1);
          hv_Grayval.Dispose();
          hv_Grayval = ExpTmpLocalVar_Grayval;
          }
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          //Catch the special case when we'd remove all values
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Grayval = hv_Grayval.TupleMedian()
              ;
          hv_Grayval.Dispose();
          hv_Grayval = ExpTmpLocalVar_Grayval;
          }
          }
        }
      }
      hv_Sigma.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Sigma = (((new HTuple(((new HTuple(180)).TupleRad()
          )/2.0)).TupleSqrt())*(1.0/6.0))*(((hv_Grayval.TupleAbs())).TupleMean());
      }
    }

    ho_ImageFiltered.Dispose();
    ho_RegionErosion.Dispose();

    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_Grayval.Dispose();
    hv_NumToRemove.Dispose();
    hv_Exception.Dispose();

    return;

  }

  // Chapter: Time
  // Short Description: Estimate the remaining time for a task given the current progress. 
  public void estimate_progress (HTuple hv_SecondsStart, HTuple hv_ProgressMin, HTuple hv_ProgressCurrent, 
      HTuple hv_ProgressMax, out HTuple hv_SecondsElapsed, out HTuple hv_SecondsRemaining, 
      out HTuple hv_ProgressPercent, out HTuple hv_ProgressPerSecond)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_SecondsNow = new HTuple(), hv_Epsilon = new HTuple();
    HTuple hv_ProgressRemaining = new HTuple();
    // Initialize local and output iconic variables 
    hv_SecondsElapsed = new HTuple();
    hv_SecondsRemaining = new HTuple();
    hv_ProgressPercent = new HTuple();
    hv_ProgressPerSecond = new HTuple();
    //
    //This procedure estimates the remaining time in seconds,
    //given a start time and a progress value.
    //
    //Get current time.
    hv_SecondsNow.Dispose();
    HOperatorSet.CountSeconds(out hv_SecondsNow);
    //
    //Get elapsed time span.
    hv_SecondsElapsed.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SecondsElapsed = hv_SecondsNow-hv_SecondsStart;
    }
    //
    //A very small additive constant to avoid division by zero.
    hv_Epsilon.Dispose();
    hv_Epsilon = 1e-6;
    //
    //Estimate remaining time based on elapsed time.
    hv_ProgressRemaining.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ProgressRemaining = hv_ProgressMax-hv_ProgressCurrent;
    }
    hv_ProgressPerSecond.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ProgressPerSecond = (((hv_ProgressCurrent-hv_ProgressMin)).TupleReal()
        )/((hv_SecondsElapsed.TupleReal())+hv_Epsilon);
    }
    hv_SecondsRemaining.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SecondsRemaining = hv_ProgressRemaining/(hv_ProgressPerSecond+hv_Epsilon);
    }
    //
    //Get current progress in percent.
    hv_ProgressPercent.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ProgressPercent = (100*(((hv_ProgressCurrent-hv_ProgressMin)).TupleReal()
        ))/((((hv_ProgressMax-hv_ProgressMin)).TupleReal())+hv_Epsilon);
    }

    hv_SecondsNow.Dispose();
    hv_Epsilon.Dispose();
    hv_ProgressRemaining.Dispose();

    return;
  }

  public void estimate_visualization_pose (HTuple hv_SampledModel, HTuple hv_WindowHandleModel, 
      out HTuple hv_PoseEstimated)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Center = new HTuple(), hv_RowNotUsed = new HTuple();
    HTuple hv_ColumnNotUsed = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_WPRow1 = new HTuple();
    HTuple hv_WPColumn1 = new HTuple(), hv_WPRow2 = new HTuple();
    HTuple hv_WPColumn2 = new HTuple(), hv_CamParam = new HTuple();
    HTuple hv_PoseIn = new HTuple(), hv_Moments = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_PoseInvert = new HTuple();
    HTuple hv_ObjectModel3DRigidTrans = new HTuple();
    // Initialize local and output iconic variables 
    hv_PoseEstimated = new HTuple();
    hv_Center.Dispose();
    get_object_models_center(hv_SampledModel, out hv_Center);
    if ((int)(new HTuple(hv_Center.TupleEqual(new HTuple()))) != 0)
    {
      hv_Center.Dispose();
      hv_Center = new HTuple();
      hv_Center[0] = 0;
      hv_Center[1] = 0;
      hv_Center[2] = 0;
    }
    hv_RowNotUsed.Dispose();hv_ColumnNotUsed.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandleModel, out hv_RowNotUsed, out hv_ColumnNotUsed, 
        out hv_Width, out hv_Height);
    hv_WPRow1.Dispose();hv_WPColumn1.Dispose();hv_WPRow2.Dispose();hv_WPColumn2.Dispose();
    HOperatorSet.GetPart(hv_WindowHandleModel, out hv_WPRow1, out hv_WPColumn1, out hv_WPRow2, 
        out hv_WPColumn2);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetPart(hv_WindowHandleModel, 0, 0, hv_Height-1, hv_Width-1);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CamParam.Dispose();
    gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width/2, hv_Height/2, 
        hv_Width, hv_Height, out hv_CamParam);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PoseIn.Dispose();
    HOperatorSet.CreatePose(-(hv_Center.TupleSelect(0)), -(hv_Center.TupleSelect(
        1)), -(hv_Center.TupleSelect(2)), 0, 0, 0, "Rp+T", "gba", "point", out hv_PoseIn);
    }
    //
    try
    {
      hv_Moments.Dispose();
      HOperatorSet.MomentsObjectModel3d(hv_SampledModel, "principal_axes", out hv_Moments);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_Moments.Dispose();
      hv_Moments = new HTuple();
      hv_Moments[0] = 0;
      hv_Moments[1] = 0;
      hv_Moments[2] = 0;
      hv_Moments[3] = 0;
      hv_Moments[4] = 0;
      hv_Moments[5] = 0;
      hv_Moments[6] = 0;
    }
    hv_PoseInvert.Dispose();
    HOperatorSet.PoseInvert(hv_Moments, out hv_PoseInvert);
    hv_ObjectModel3DRigidTrans.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_SampledModel, hv_PoseInvert, out hv_ObjectModel3DRigidTrans);
    hv_PoseEstimated.Dispose();
    determine_optimum_pose_distance(hv_ObjectModel3DRigidTrans, hv_CamParam, 0.9, 
        hv_PoseIn, out hv_PoseEstimated);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_PoseEstimated = ((((((((((((hv_PoseEstimated.TupleSelect(
        0))).TupleConcat(-(hv_Moments.TupleSelect(2))))).TupleConcat(hv_PoseEstimated.TupleSelect(
        2)))).TupleConcat((hv_PoseEstimated.TupleSelect(3))-90))).TupleConcat(hv_PoseEstimated.TupleSelect(
        4)))).TupleConcat(hv_PoseEstimated.TupleSelect(5)))).TupleConcat(0);
    hv_PoseEstimated.Dispose();
    hv_PoseEstimated = ExpTmpLocalVar_PoseEstimated;
    }
    }


    hv_Center.Dispose();
    hv_RowNotUsed.Dispose();
    hv_ColumnNotUsed.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_WPRow1.Dispose();
    hv_WPColumn1.Dispose();
    hv_WPRow2.Dispose();
    hv_WPColumn2.Dispose();
    hv_CamParam.Dispose();
    hv_PoseIn.Dispose();
    hv_Moments.Dispose();
    hv_Exception.Dispose();
    hv_PoseInvert.Dispose();
    hv_ObjectModel3DRigidTrans.Dispose();

    return;
  }

  public void estimate_visualization_pose_simple (HTuple hv_SampledModel, HTuple hv_WindowHandleModel, 
      out HTuple hv_PoseEstimated)
  {



    // Local control variables 

    HTuple hv_Center = new HTuple(), hv_RowNotUsed = new HTuple();
    HTuple hv_ColumnNotUsed = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_WPRow1 = new HTuple();
    HTuple hv_WPColumn1 = new HTuple(), hv_WPRow2 = new HTuple();
    HTuple hv_WPColumn2 = new HTuple(), hv_CamParam = new HTuple();
    HTuple hv_PoseIn = new HTuple();
    // Initialize local and output iconic variables 
    hv_PoseEstimated = new HTuple();
    hv_Center.Dispose();
    get_object_models_center(hv_SampledModel, out hv_Center);
    hv_RowNotUsed.Dispose();hv_ColumnNotUsed.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandleModel, out hv_RowNotUsed, out hv_ColumnNotUsed, 
        out hv_Width, out hv_Height);
    hv_WPRow1.Dispose();hv_WPColumn1.Dispose();hv_WPRow2.Dispose();hv_WPColumn2.Dispose();
    HOperatorSet.GetPart(hv_WindowHandleModel, out hv_WPRow1, out hv_WPColumn1, out hv_WPRow2, 
        out hv_WPColumn2);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetPart(hv_WindowHandleModel, 0, 0, hv_Height-1, hv_Width-1);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CamParam.Dispose();
    gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width/2, hv_Height/2, 
        hv_Width, hv_Height, out hv_CamParam);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PoseIn.Dispose();
    HOperatorSet.CreatePose(-(hv_Center.TupleSelect(0)), -(hv_Center.TupleSelect(
        1)), -(hv_Center.TupleSelect(2)), 0, 0, 0, "Rp+T", "gba", "point", out hv_PoseIn);
    }
    //
    hv_PoseEstimated.Dispose();
    determine_optimum_pose_distance(hv_SampledModel, hv_CamParam, 0.9, hv_PoseIn, 
        out hv_PoseEstimated);


    hv_Center.Dispose();
    hv_RowNotUsed.Dispose();
    hv_ColumnNotUsed.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_WPRow1.Dispose();
    hv_WPColumn1.Dispose();
    hv_WPRow2.Dispose();
    hv_WPColumn2.Dispose();
    hv_CamParam.Dispose();
    hv_PoseIn.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Evaluate the performance of a deep-learning-based classifier. 
  public void evaluate_dl_classifier (HTuple hv_GroundTruthLabels, HTuple hv_DLClassifierHandle, 
      HTuple hv_DLClassifierResultID, HTuple hv_EvaluationMeasureType, HTuple hv_ClassesToEvaluate, 
      out HTuple hv_EvaluationMeasure)
  {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Classes = new HTuple(), hv_TestClassesToEvaluate = new HTuple();
        HTuple hv_NumEvalMeasureTypes = new HTuple(), hv_NumEvalClasses = new HTuple();
        HTuple hv_ComputePrecision = new HTuple(), hv_ComputeRecall = new HTuple();
        HTuple hv_ComputeFScore = new HTuple(), hv_ComputeConfusionMatrix = new HTuple();
        HTuple hv_PredictedClasses = new HTuple(), hv_Index = new HTuple();
        HTuple hv_PredictedClass = new HTuple(), hv_ConfusionMatrix = new HTuple();
        HTuple hv_EvalMeasureTypeIndex = new HTuple(), hv_CurrentEvalMeasure = new HTuple();
        HTuple hv_CurrentEvalClass = new HTuple(), hv_RegExpTopKError = new HTuple();
        HTuple hv_ComputeTopKError = new HTuple(), hv_K = new HTuple();
        HTuple hv_Indices = new HTuple(), hv_TopKError = new HTuple();
        HTuple hv_NumClasses = new HTuple(), hv_IndexClass = new HTuple();
        HTuple hv_ClassPrecisions = new HTuple(), hv_MatrixRowSumID = new HTuple();
        HTuple hv_TruePositive = new HTuple(), hv_SumPredictedClass = new HTuple();
        HTuple hv_ClassPrecision = new HTuple(), hv_Precision = new HTuple();
        HTuple hv_ClassRecalls = new HTuple(), hv_MatrixColumnSumID = new HTuple();
        HTuple hv_SumLabel = new HTuple(), hv_ClassRecall = new HTuple();
        HTuple hv_Recall = new HTuple(), hv_FScore = new HTuple();
        HTuple   hv_ClassesToEvaluate_COPY_INP_TMP = new HTuple(hv_ClassesToEvaluate);
        HTuple   hv_EvaluationMeasureType_COPY_INP_TMP = new HTuple(hv_EvaluationMeasureType);
        HTuple   hv_GroundTruthLabels_COPY_INP_TMP = new HTuple(hv_GroundTruthLabels);

        // Initialize local and output iconic variables 
        hv_EvaluationMeasure = new HTuple();
    //This procedure can be used to compute various evaluation measures
    //to check the performance of your trained
    //deep-learning-based classifier DLClassifierHandle.
    //For this, the GroundTruthLabels must be given. Additionally,
    //the results of the classification must be given in DLClassifierResultID,
    //as returned by apply_dl_classifier and apply_dl_classifier_batchwise.
    //With EvaluationMeasureType, you can choose which evaluation measure
    //to return. With ClassesToEvaluate, you can choose whether to return
    //the result for a single class, a result for every class, or
    //for all classes combined. The result is returned in EvaluationMeasure.
    //
    //Check input.
    //Check whether ClassesToEvaluate is a class or 'global'.
    hv_Classes.Dispose();
    HOperatorSet.GetDlClassifierParam(hv_DLClassifierHandle, "classes", out hv_Classes);
    //
    //Convert the class indices to class labels if necessary
    if ((int)(new HTuple(((((hv_GroundTruthLabels_COPY_INP_TMP.TupleIsIntElem())).TupleFind(
        0))).TupleEqual(-1))) != 0)
    {
      if ((int)((new HTuple(((hv_GroundTruthLabels_COPY_INP_TMP.TupleMin())).TupleLess(
          0))).TupleOr(new HTuple(((hv_GroundTruthLabels_COPY_INP_TMP.TupleMax())).TupleGreater(
          (new HTuple(hv_Classes.TupleLength()))-1)))) != 0)
      {
        throw new HalconException("The Indices of the GroundTruthLabels exceed the range of classes. \nPlease check your data split.");
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_GroundTruthLabels = hv_Classes.TupleSelect(
          hv_GroundTruthLabels_COPY_INP_TMP);
      hv_GroundTruthLabels_COPY_INP_TMP.Dispose();
      hv_GroundTruthLabels_COPY_INP_TMP = ExpTmpLocalVar_GroundTruthLabels;
      }
      }
    }
    if ((int)(new HTuple(((((hv_GroundTruthLabels_COPY_INP_TMP.TupleSort())).TupleUniq()
        )).TupleNotEqual(hv_Classes.TupleSort()))) != 0)
    {
      throw new HalconException("Not all classes are represented in the GroundTruthLabels. \nPlease check your data split.");
    }
    hv_TestClassesToEvaluate.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TestClassesToEvaluate = new HTuple();
    hv_TestClassesToEvaluate[0] = "global";
    hv_TestClassesToEvaluate = hv_TestClassesToEvaluate.TupleConcat(hv_Classes);
    }
    if ((int)(new HTuple(((hv_ClassesToEvaluate_COPY_INP_TMP.TupleDifference(hv_TestClassesToEvaluate))).TupleNotEqual(
        new HTuple()))) != 0)
    {
      throw new HalconException("ClassesToEvaluate invalid.");
    }
    //
    //Count the measure types and modes of ClassesToEvaluate.
    hv_NumEvalMeasureTypes.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumEvalMeasureTypes = new HTuple(hv_EvaluationMeasureType_COPY_INP_TMP.TupleLength()
        );
    }
    hv_NumEvalClasses.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumEvalClasses = new HTuple(hv_ClassesToEvaluate_COPY_INP_TMP.TupleLength()
        );
    }
    //
    //If the numbers are not equal, extend the shorter one.
    if ((int)(new HTuple(hv_NumEvalMeasureTypes.TupleGreater(hv_NumEvalClasses))) != 0)
    {
      if ((int)((new HTuple(hv_NumEvalMeasureTypes.TupleGreater(1))).TupleAnd(new HTuple(hv_NumEvalClasses.TupleGreater(
          1)))) != 0)
      {
        throw new HalconException("Invalid number of elements in EvaluationMeasureType/ClassesToEvaluate.");
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ClassesToEvaluate = HTuple.TupleGenConst(
            hv_NumEvalMeasureTypes,hv_ClassesToEvaluate_COPY_INP_TMP);
        hv_ClassesToEvaluate_COPY_INP_TMP.Dispose();
        hv_ClassesToEvaluate_COPY_INP_TMP = ExpTmpLocalVar_ClassesToEvaluate;
        }
        }
      }
    }
    if ((int)(new HTuple(hv_NumEvalMeasureTypes.TupleLess(hv_NumEvalClasses))) != 0)
    {
      if ((int)((new HTuple(hv_NumEvalMeasureTypes.TupleGreater(1))).TupleAnd(new HTuple(hv_NumEvalClasses.TupleGreater(
          1)))) != 0)
      {
        throw new HalconException("Invalid number of elements in EvaluationMeasureType/ClassesToEvaluate.");
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_EvaluationMeasureType = HTuple.TupleGenConst(
            hv_NumEvalClasses,hv_EvaluationMeasureType_COPY_INP_TMP);
        hv_EvaluationMeasureType_COPY_INP_TMP.Dispose();
        hv_EvaluationMeasureType_COPY_INP_TMP = ExpTmpLocalVar_EvaluationMeasureType;
        }
        }
      }
    }
    //
    //Check whether we need to compute a confusion matrix.
    //We want to do this only once to save run time.
    hv_ComputePrecision.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ComputePrecision = hv_EvaluationMeasureType_COPY_INP_TMP.TupleRegexpTest(
        "precision");
    }
    hv_ComputeRecall.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ComputeRecall = hv_EvaluationMeasureType_COPY_INP_TMP.TupleRegexpTest(
        "recall");
    }
    hv_ComputeFScore.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ComputeFScore = hv_EvaluationMeasureType_COPY_INP_TMP.TupleRegexpTest(
        "f_score");
    }
    hv_ComputeConfusionMatrix.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ComputeConfusionMatrix = (hv_ComputePrecision+hv_ComputeRecall)+hv_ComputeFScore;
    }
    if ((int)(new HTuple(hv_ComputeConfusionMatrix.TupleGreater(0))) != 0)
    {
      //Get the top-1 predicted classes from the result handle(s).
      hv_PredictedClasses.Dispose();
      hv_PredictedClasses = new HTuple();
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_DLClassifierResultID.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PredictedClass.Dispose();
        HOperatorSet.GetDlClassifierResult(hv_DLClassifierResultID.TupleSelect(hv_Index), 
            "all", "predicted_classes", out hv_PredictedClass);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_PredictedClasses = hv_PredictedClasses.TupleConcat(
            hv_PredictedClass);
        hv_PredictedClasses.Dispose();
        hv_PredictedClasses = ExpTmpLocalVar_PredictedClasses;
        }
        }
      }
      //Compute the confusion matrix.
      hv_ConfusionMatrix.Dispose();
      gen_confusion_matrix(hv_GroundTruthLabels_COPY_INP_TMP, hv_PredictedClasses, 
          "display_matrix", "none", new HTuple(), out hv_ConfusionMatrix);
    }
    //
    //Loop through all given measure types.
    hv_EvaluationMeasure.Dispose();
    hv_EvaluationMeasure = new HTuple();
    HTuple end_val69 = (((hv_NumEvalMeasureTypes.TupleConcat(
        hv_NumEvalClasses))).TupleMax())-1;
    HTuple step_val69 = 1;
    for (hv_EvalMeasureTypeIndex=0; hv_EvalMeasureTypeIndex.Continue(end_val69, step_val69); hv_EvalMeasureTypeIndex = hv_EvalMeasureTypeIndex.TupleAdd(step_val69))
    {
      //Select the current combination.
      hv_CurrentEvalMeasure.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentEvalMeasure = hv_EvaluationMeasureType_COPY_INP_TMP.TupleSelect(
          hv_EvalMeasureTypeIndex);
      }
      hv_CurrentEvalClass.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentEvalClass = hv_ClassesToEvaluate_COPY_INP_TMP.TupleSelect(
          hv_EvalMeasureTypeIndex);
      }
      //Set the output accordingly.
      //Check whether to compute the top-k error.
      hv_RegExpTopKError.Dispose();
      hv_RegExpTopKError = "top([0-9]+)_error";
      hv_ComputeTopKError.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ComputeTopKError = hv_CurrentEvalMeasure.TupleRegexpTest(
          hv_RegExpTopKError);
      }
      //Check whether to compute the precision, recall, F-score.
      hv_ComputePrecision.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ComputePrecision = hv_CurrentEvalMeasure.TupleRegexpTest(
          "precision");
      }
      hv_ComputeRecall.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ComputeRecall = hv_CurrentEvalMeasure.TupleRegexpTest(
          "recall");
      }
      hv_ComputeFScore.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ComputeFScore = hv_CurrentEvalMeasure.TupleRegexpTest(
          "f_score");
      }
      //
      if ((int)(hv_ComputeTopKError) != 0)
      {
        //Get the K from the input string 'topK_error'.
        hv_K.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_K = ((hv_CurrentEvalMeasure.TupleRegexpMatch(
            hv_RegExpTopKError))).TupleNumber();
        }
        //Select all labels or only the labels with the respective class.
        if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
        {
          hv_Indices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Indices = HTuple.TupleGenSequence(
              0,(new HTuple(hv_GroundTruthLabels_COPY_INP_TMP.TupleLength()))-1,1);
          }
        }
        else
        {
          hv_Indices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Indices = hv_GroundTruthLabels_COPY_INP_TMP.TupleFind(
              hv_CurrentEvalClass);
          }
        }
        hv_TopKError.Dispose();
        compute_top_k_error(hv_DLClassifierHandle, hv_DLClassifierResultID, hv_GroundTruthLabels_COPY_INP_TMP, 
            hv_Indices, hv_K, out hv_TopKError);
        if (hv_EvaluationMeasure == null)
          hv_EvaluationMeasure = new HTuple();
        hv_EvaluationMeasure[hv_EvalMeasureTypeIndex] = hv_TopKError;
      }
      else if ((int)((new HTuple(hv_ComputePrecision.TupleOr(hv_ComputeRecall))).TupleOr(
          hv_ComputeFScore)) != 0)
      {
        if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
        {
          //Compute the mean of the measures for all classes.
          hv_NumClasses.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_NumClasses = new HTuple(hv_Classes.TupleLength()
              );
          }
          hv_IndexClass.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IndexClass = HTuple.TupleGenSequence(
              0,hv_NumClasses-1,1);
          }
        }
        else
        {
          //Compute the measures for a certain class.
          hv_NumClasses.Dispose();
          hv_NumClasses = 1;
          hv_IndexClass.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IndexClass = hv_Classes.TupleFind(
              hv_CurrentEvalClass);
          }
        }
        if ((int)(hv_ComputePrecision.TupleOr(hv_ComputeFScore)) != 0)
        {
          hv_ClassPrecisions.Dispose();
          hv_ClassPrecisions = new HTuple();
          hv_MatrixRowSumID.Dispose();
          HOperatorSet.SumMatrix(hv_ConfusionMatrix, "rows", out hv_MatrixRowSumID);
          HTuple end_val106 = hv_NumClasses-1;
          HTuple step_val106 = 1;
          for (hv_Index=0; hv_Index.Continue(end_val106, step_val106); hv_Index = hv_Index.TupleAdd(step_val106))
          {
            //Compute the precision for every selected class.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TruePositive.Dispose();
            HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_SumPredictedClass.Dispose();
            HOperatorSet.GetValueMatrix(hv_MatrixRowSumID, hv_IndexClass.TupleSelect(
                hv_Index), 0, out hv_SumPredictedClass);
            }
            if ((int)(new HTuple(hv_SumPredictedClass.TupleEqual(0))) != 0)
            {
              hv_ClassPrecision.Dispose();
              hv_ClassPrecision = 0;
            }
            else
            {
              hv_ClassPrecision.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ClassPrecision = hv_TruePositive/hv_SumPredictedClass;
              }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ClassPrecisions = hv_ClassPrecisions.TupleConcat(
                hv_ClassPrecision);
            hv_ClassPrecisions.Dispose();
            hv_ClassPrecisions = ExpTmpLocalVar_ClassPrecisions;
            }
            }
          }
          hv_Precision.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Precision = hv_ClassPrecisions.TupleMean()
              ;
          }
          HOperatorSet.ClearMatrix(hv_MatrixRowSumID);
          if ((int)(hv_ComputePrecision) != 0)
          {
            if (hv_EvaluationMeasure == null)
              hv_EvaluationMeasure = new HTuple();
            hv_EvaluationMeasure[hv_EvalMeasureTypeIndex] = hv_Precision;
          }
        }
        if ((int)(hv_ComputeRecall.TupleOr(hv_ComputeFScore)) != 0)
        {
          hv_ClassRecalls.Dispose();
          hv_ClassRecalls = new HTuple();
          hv_MatrixColumnSumID.Dispose();
          HOperatorSet.SumMatrix(hv_ConfusionMatrix, "columns", out hv_MatrixColumnSumID);
          HTuple end_val126 = hv_NumClasses-1;
          HTuple step_val126 = 1;
          for (hv_Index=0; hv_Index.Continue(end_val126, step_val126); hv_Index = hv_Index.TupleAdd(step_val126))
          {
            //Compute the recall for every class.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TruePositive.Dispose();
            HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_SumLabel.Dispose();
            HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_IndexClass.TupleSelect(
                hv_Index), out hv_SumLabel);
            }
            hv_ClassRecall.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ClassRecall = hv_TruePositive/hv_SumLabel;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ClassRecalls = hv_ClassRecalls.TupleConcat(
                hv_ClassRecall);
            hv_ClassRecalls.Dispose();
            hv_ClassRecalls = ExpTmpLocalVar_ClassRecalls;
            }
            }
          }
          hv_Recall.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Recall = hv_ClassRecalls.TupleMean()
              ;
          }
          HOperatorSet.ClearMatrix(hv_MatrixColumnSumID);
          if ((int)(hv_ComputeRecall) != 0)
          {
            if (hv_EvaluationMeasure == null)
              hv_EvaluationMeasure = new HTuple();
            hv_EvaluationMeasure[hv_EvalMeasureTypeIndex] = hv_Recall;
          }
        }
        if ((int)(hv_ComputeFScore) != 0)
        {
          //Compute the F-score for a certain class or globally
          //for the averaged precision and recall.
          //Precision and recall were already computed above.
          if ((int)(new HTuple(((hv_Precision+hv_Recall)).TupleEqual(0))) != 0)
          {
            hv_FScore.Dispose();
            hv_FScore = 0.0;
          }
          else
          {
            hv_FScore.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FScore = ((2*hv_Precision)*hv_Recall)/(hv_Precision+hv_Recall);
            }
          }
          if (hv_EvaluationMeasure == null)
            hv_EvaluationMeasure = new HTuple();
          hv_EvaluationMeasure[hv_EvalMeasureTypeIndex] = hv_FScore;
        }
      }
      else
      {
        throw new HalconException(("Invalid option for EvaluationMeasureType: '"+hv_CurrentEvalMeasure)+"'");
      }
    }
    if ((int)(hv_ComputeConfusionMatrix) != 0)
    {
      HOperatorSet.ClearMatrix(hv_ConfusionMatrix);
    }

    hv_ClassesToEvaluate_COPY_INP_TMP.Dispose();
    hv_EvaluationMeasureType_COPY_INP_TMP.Dispose();
    hv_GroundTruthLabels_COPY_INP_TMP.Dispose();
    hv_Classes.Dispose();
    hv_TestClassesToEvaluate.Dispose();
    hv_NumEvalMeasureTypes.Dispose();
    hv_NumEvalClasses.Dispose();
    hv_ComputePrecision.Dispose();
    hv_ComputeRecall.Dispose();
    hv_ComputeFScore.Dispose();
    hv_ComputeConfusionMatrix.Dispose();
    hv_PredictedClasses.Dispose();
    hv_Index.Dispose();
    hv_PredictedClass.Dispose();
    hv_ConfusionMatrix.Dispose();
    hv_EvalMeasureTypeIndex.Dispose();
    hv_CurrentEvalMeasure.Dispose();
    hv_CurrentEvalClass.Dispose();
    hv_RegExpTopKError.Dispose();
    hv_ComputeTopKError.Dispose();
    hv_K.Dispose();
    hv_Indices.Dispose();
    hv_TopKError.Dispose();
    hv_NumClasses.Dispose();
    hv_IndexClass.Dispose();
    hv_ClassPrecisions.Dispose();
    hv_MatrixRowSumID.Dispose();
    hv_TruePositive.Dispose();
    hv_SumPredictedClass.Dispose();
    hv_ClassPrecision.Dispose();
    hv_Precision.Dispose();
    hv_ClassRecalls.Dispose();
    hv_MatrixColumnSumID.Dispose();
    hv_SumLabel.Dispose();
    hv_ClassRecall.Dispose();
    hv_Recall.Dispose();
    hv_FScore.Dispose();

    return;

  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Evaluate the model given by DLModelHandle on the selected samples of DLDataset. 
  public void evaluate_dl_model (HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_SampleSelectMethod, 
      HTuple hv_SampleSelectValues, HTuple hv_GenParam, out HTuple hv_EvaluationResult, 
      out HTuple hv_EvalParams)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ModelType = new HTuple(), hv_ModelClassIDs = new HTuple();
    HTuple hv_BatchSize = new HTuple(), hv_ModelIgnoreClassIDs = new HTuple();
    HTuple hv_ShowProgress = new HTuple(), hv_GenParamKeys = new HTuple();
    HTuple hv_GenParamIndex = new HTuple(), hv_Measures = new HTuple();
    HTuple hv_IoUThreshold = new HTuple(), hv_MaxNumDetections = new HTuple();
    HTuple hv_AreaRanges = new HTuple(), hv_DetailedEvaluation = new HTuple();
    HTuple hv_AllocationBlockLength = new HTuple(), hv_IgnoreClassIDs = new HTuple();
    HTuple hv_AllIgnoreClassIDs = new HTuple(), hv_EvaluateClassIDs = new HTuple();
    HTuple hv_ClassInfoExists = new HTuple(), hv_ClassNames = new HTuple();
    HTuple hv_DatasetClassIDs = new HTuple(), hv_ClassIDsToClassNames = new HTuple();
    HTuple hv_EvaluateClassNames = new HTuple(), hv_DLSamples = new HTuple();
    HTuple hv_SampleIndices = new HTuple(), hv_NumSamples = new HTuple();
    HTuple hv_NumBatches = new HTuple(), hv_RunningMeasures = new HTuple();
    HTuple hv_Progress = new HTuple(), hv_TaskInfo = new HTuple();
    HTuple hv_SecondsStart = new HTuple(), hv_BatchIndex = new HTuple();
    HTuple hv_BatchStart = new HTuple(), hv_BatchEnd = new HTuple();
    HTuple hv_SamplesIndicesBatch = new HTuple(), hv_DLSamplesBatch = new HTuple();
    HTuple hv_DLResultsBatch = new HTuple(), hv_BatchSizeEffective = new HTuple();
    HTuple hv_SecondsElapsed = new HTuple(), hv_SecondsRemaining = new HTuple();
    HTuple hv_ProgressPercent = new HTuple(), hv_ProgressPerSecond = new HTuple();
    HTuple hv_TimeElapsedString = new HTuple(), hv_TimeRemainingString = new HTuple();
    // Initialize local and output iconic variables 
    hv_EvaluationResult = new HTuple();
    hv_EvalParams = new HTuple();
    //This procedure applies the model given by DLModelHandle on the selected samples
    //of DLDataset and evaluates the results against the ground truth annotations
    //to calculate evaluation measures.
    //
    //Input:
    // - DLDataset.
    // - DLModelHandle.
    // - SampleSelectMethod: Method by which the samples are selected.
    // - SampleSelectValues: Identifier used to retrieve the samples from the DLDataset
    //                       for the corresponding selection method.
    // - GenParam: Parameters of the evaluation that should be changed from the default.
    //
    //Output:
    // - EvaluationResult: Dictionary containing the output measures.
    // - EvalParams: Dictionary with the used evaluation parameters.
    //
    //** Initialization: ***
    //
    hv_ModelType.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
    if ((int)((new HTuple(hv_ModelType.TupleNotEqual("detection"))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
        "segmentation")))) != 0)
    {
      throw new HalconException("Unknown model type");
    }
    //
    //Get the class IDs as set in the model.
    hv_ModelClassIDs.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ModelClassIDs);
    //
    //Get the batch size as set in the model.
    hv_BatchSize.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
    //
    //Get model specific information.
    if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
    {
      hv_ModelIgnoreClassIDs.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_class_ids", out hv_ModelIgnoreClassIDs);
    }
    //
    //Generate default parameters.
    hv_EvalParams.Dispose();
    create_evaluation_default_param(hv_ModelType, hv_ModelClassIDs, out hv_EvalParams);
    //
    //By default we do not show the progress of evaluation.
    hv_ShowProgress.Dispose();
    hv_ShowProgress = 0;
    //
    //Set user specified parameters.
    if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_GenParamKeys.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamKeys);
      for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamKeys.TupleLength()
          ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
      {
        if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "measures"))) != 0)
        {
          //Set measures.
          hv_Measures.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "measures", out hv_Measures);
          HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures);
        }
        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "show_progress"))) != 0)
        {
          //Show the progress of the evaluation.
          hv_ShowProgress.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "show_progress", out hv_ShowProgress);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ShowProgress = (new HTuple(hv_ShowProgress.TupleEqual(
              "true"))).TupleOr(new HTuple(hv_ShowProgress.TupleEqual(1)));
          hv_ShowProgress.Dispose();
          hv_ShowProgress = ExpTmpLocalVar_ShowProgress;
          }
          }
        }
        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "iou_threshold"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
        {
          //Set IoU threshold.
          hv_IoUThreshold.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "iou_threshold", out hv_IoUThreshold);
          HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", hv_IoUThreshold);
        }
        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "max_num_detections"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
        {
          //Set maximal number detections.
          hv_MaxNumDetections.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "max_num_detections", out hv_MaxNumDetections);
          HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", hv_MaxNumDetections);
        }
        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "area_ranges"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
        {
          //Set area ranges.
          hv_AreaRanges.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "area_ranges", out hv_AreaRanges);
          HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
        }
        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "detailed_evaluation"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
            "detection")))) != 0)
        {
          //Set detailed evaluation.
          hv_DetailedEvaluation.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "detailed_evaluation", out hv_DetailedEvaluation);
          HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", hv_DetailedEvaluation);
        }
        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "allocation_block_length"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
            "detection")))) != 0)
        {
          //Set length of blocks that are allocated during evaluation.
          hv_AllocationBlockLength.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "allocation_block_length", out hv_AllocationBlockLength);
          HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
        }
        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "ignore_class_ids"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("segmentation")))) != 0)
        {
          //Set ignore class IDs.
          hv_IgnoreClassIDs.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "ignore_class_ids", out hv_IgnoreClassIDs);
          //Merge the specified ignore class IDs with the model ignore class IDs.
          hv_AllIgnoreClassIDs.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AllIgnoreClassIDs = ((((hv_ModelIgnoreClassIDs.TupleConcat(
              hv_IgnoreClassIDs))).TupleSort())).TupleUniq();
          }
          HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", hv_AllIgnoreClassIDs);
          //Remove the ignore class IDs from the model class IDs.
          hv_EvaluateClassIDs.Dispose();
          HOperatorSet.TupleDifference(hv_ModelClassIDs, hv_IgnoreClassIDs, out hv_EvaluateClassIDs);
          HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_EvaluateClassIDs);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_EvaluateClassIDs.TupleLength()
              ));
          }
        }
        else
        {
          throw new HalconException(("Unknown parameter : '"+(hv_GenParamKeys.TupleSelect(
              hv_GenParamIndex)))+"'");
        }
      }
    }
    //
    //Get the class names from the dataset if present.
    hv_ClassInfoExists.Dispose();
    HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", (new HTuple("class_names")).TupleConcat(
        "class_ids"), out hv_ClassInfoExists);
    if ((int)(new HTuple(((hv_ClassInfoExists.TupleSum())).TupleEqual(new HTuple(hv_ClassInfoExists.TupleLength()
        )))) != 0)
    {
      hv_ClassNames.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "class_names", out hv_ClassNames);
      hv_DatasetClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_DatasetClassIDs);
      //Set the class names only for the class IDs that are evaluated.
      hv_EvaluateClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_EvaluateClassIDs);
      hv_ClassIDsToClassNames.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassIDsToClassNames = HTuple.TupleGenConst(
          (hv_DatasetClassIDs.TupleMax())+1,"");
      }
      if (hv_ClassIDsToClassNames == null)
        hv_ClassIDsToClassNames = new HTuple();
      hv_ClassIDsToClassNames[hv_DatasetClassIDs] = hv_ClassNames;
      hv_EvaluateClassNames.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EvaluateClassNames = hv_ClassIDsToClassNames.TupleSelect(
          hv_EvaluateClassIDs);
      }
      //Set the class names to EvalParams.
      HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_EvaluateClassNames);
    }
    //
    //Get indices of samples to read from the dataset.
    hv_DLSamples.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
    //
    //Check if there are samples present in the dataset.
    if ((int)(new HTuple((new HTuple(hv_DLSamples.TupleLength())).TupleEqual(0))) != 0)
    {
      throw new HalconException("The provided set of samples in the dataset must be non-empty.");
    }
    //
    //Check for empty SampleSelectValues.
    if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleEqual(
        0))) != 0)
    {
      if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
      {
        throw new HalconException("The provided set of samples of the 'image_ids' selection must be non-empty.");
      }
      else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
      {
        throw new HalconException("The provided set of samples of the 'sample_indices' selection must be non-empty.");
      }
      else
      {
        throw new HalconException("Provide a name for 'split' selection.");
      }
    }
    //
    //
    //Get the sample indices according to the sample selection method.
    hv_SampleIndices.Dispose();
    hv_SampleIndices = new HTuple();
    if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("split"))) != 0)
    {
      //Get the samples of the split specified.
      hv_SampleIndices.Dispose();
      find_dl_samples(hv_DLSamples, "split", hv_SampleSelectValues, "or", out hv_SampleIndices);
    }
    else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
    {
      //Get the samples specified by 'image_ids'.
      if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleGreater(
          new HTuple(hv_DLSamples.TupleLength())))) != 0)
      {
        throw new HalconException("The number of the image ids provided through 'image_id' is invalid.");
      }
      hv_SampleIndices.Dispose();
      find_dl_samples(hv_DLSamples, "image_id", hv_SampleSelectValues, "or", out hv_SampleIndices);
    }
    else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
    {
      //Get the samples specified by 'sample_indices'.
      if ((int)((new HTuple(((hv_SampleSelectValues.TupleMin())).TupleLess(0))).TupleOr(
          new HTuple(((hv_SampleSelectValues.TupleMax())).TupleGreater((new HTuple(hv_DLSamples.TupleLength()
          ))-1)))) != 0)
      {
        throw new HalconException("The range of the indices provided through 'sample_indices' is invalid.");
      }
      hv_SampleIndices.Dispose();
      hv_SampleIndices = new HTuple(hv_SampleSelectValues);
    }
    else
    {
      throw new HalconException(("Unknown sample selection method : '"+hv_SampleSelectMethod)+"'");
    }
    //
    //Get the number of batches.
    hv_NumSamples.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumSamples = new HTuple(hv_SampleIndices.TupleLength()
        );
    }
    hv_NumBatches.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumBatches = ((((hv_NumSamples/(hv_BatchSize.TupleReal()
        ))).TupleCeil())).TupleInt();
    }
    //
    //Check for empty samples selected by the selection method.
    if ((int)(new HTuple(hv_NumSamples.TupleEqual(0))) != 0)
    {
      throw new HalconException(("No samples present in the dataset that are part of the '"+hv_SampleSelectMethod)+"' selection.");
    }
    //
    //
    //** Running measures are initialized according to evaluation method.
    hv_RunningMeasures.Dispose();
    init_running_evaluation_measures(hv_EvalParams, out hv_RunningMeasures);
    //
    //
    //** Apply model to each image and gather evaluation information: ***
    //
    //Initialize progress variables.
    if ((int)(hv_ShowProgress) != 0)
    {
      hv_Progress.Dispose();
      hv_Progress = new HTuple();
      hv_Progress[0] = "Procedure: evaluate_dl_model";
      hv_Progress[1] = "";
      hv_Progress[2] = "";
      hv_Progress[3] = "";
      if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
      {
        hv_TaskInfo.Dispose();
        hv_TaskInfo = "Task: 1/2: Applying the model and collecting running evaluation measures";
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Progress = hv_Progress.TupleConcat(
            hv_TaskInfo);
        hv_Progress.Dispose();
        hv_Progress = ExpTmpLocalVar_Progress;
        }
        }
      }
      hv_SecondsStart.Dispose();
      HOperatorSet.CountSeconds(out hv_SecondsStart);
      // dev_inspect_ctrl(...); only in hdevelop
    }
    //
    //Loop batchwise over the samples to be evaluated.
    HTuple end_val171 = hv_NumBatches-1;
    HTuple step_val171 = 1;
    for (hv_BatchIndex=0; hv_BatchIndex.Continue(end_val171, step_val171); hv_BatchIndex = hv_BatchIndex.TupleAdd(step_val171))
    {
      hv_BatchStart.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BatchStart = hv_BatchIndex*hv_BatchSize;
      }
      hv_BatchEnd.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BatchEnd = (((hv_BatchStart+hv_BatchSize)-1)).TupleMin2(
          hv_NumSamples-1);
      }
      hv_SamplesIndicesBatch.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SamplesIndicesBatch = hv_SampleIndices.TupleSelectRange(
          hv_BatchStart,hv_BatchEnd);
      }
      //
      //If the batch is too small we fill it up to BatchSize with the last item.
      while ((int)(new HTuple((new HTuple(hv_SamplesIndicesBatch.TupleLength())).TupleLess(
          hv_BatchSize))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_SamplesIndicesBatch = hv_SamplesIndicesBatch.TupleConcat(
            hv_SamplesIndicesBatch.TupleSelect((new HTuple(hv_SamplesIndicesBatch.TupleLength()
            ))-1));
        hv_SamplesIndicesBatch.Dispose();
        hv_SamplesIndicesBatch = ExpTmpLocalVar_SamplesIndicesBatch;
        }
        }
      }
      //Read samples
      hv_DLSamplesBatch.Dispose();
      read_dl_samples(hv_DLDataset, hv_SamplesIndicesBatch, out hv_DLSamplesBatch);
      //
      //Apply the model.
      hv_DLResultsBatch.Dispose();
      HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamplesBatch, new HTuple(), 
          out hv_DLResultsBatch);
      //
      //If the batch has been filled up we remove the additional results.
      hv_BatchSizeEffective.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BatchSizeEffective = (hv_BatchEnd-hv_BatchStart)+1;
      }
      if ((int)(new HTuple(hv_BatchSizeEffective.TupleNotEqual(hv_BatchSize))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_DLResultsBatch = hv_DLResultsBatch.TupleSelectRange(
            0,hv_BatchSizeEffective-1);
        hv_DLResultsBatch.Dispose();
        hv_DLResultsBatch = ExpTmpLocalVar_DLResultsBatch;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_DLSamplesBatch = hv_DLSamplesBatch.TupleSelectRange(
            0,hv_BatchSizeEffective-1);
        hv_DLSamplesBatch.Dispose();
        hv_DLSamplesBatch = ExpTmpLocalVar_DLSamplesBatch;
        }
        }
      }
      //
      //Update the running measures.
      update_running_evaluation_measures(hv_DLSamplesBatch, hv_DLResultsBatch, hv_EvalParams, 
          hv_RunningMeasures);
      //
      //Provide progress information.
      if ((int)(hv_ShowProgress.TupleAnd((new HTuple(((hv_BatchIndex%10)).TupleEqual(
          1))).TupleOr(new HTuple(hv_BatchIndex.TupleEqual(hv_NumBatches-1))))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SecondsElapsed.Dispose();hv_SecondsRemaining.Dispose();hv_ProgressPercent.Dispose();hv_ProgressPerSecond.Dispose();
        estimate_progress(hv_SecondsStart, 0, hv_BatchIndex, hv_NumBatches-1, out hv_SecondsElapsed, 
            out hv_SecondsRemaining, out hv_ProgressPercent, out hv_ProgressPerSecond);
        }
        hv_TimeElapsedString.Dispose();
        timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
        hv_TimeRemainingString.Dispose();
        timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
        if (hv_Progress == null)
          hv_Progress = new HTuple();
        hv_Progress[1] = ("Progress: "+(hv_ProgressPercent.TupleRound()))+" %";
        if (hv_Progress == null)
          hv_Progress = new HTuple();
        hv_Progress[2] = "Time elapsed: "+hv_TimeElapsedString;
        if (hv_Progress == null)
          hv_Progress = new HTuple();
        hv_Progress[3] = "Time left: "+hv_TimeRemainingString;
      }
    }
    //
    //Provide progress information.
    if ((int)(hv_ShowProgress.TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
    {
      hv_Progress.Dispose();
      hv_Progress = new HTuple();
      hv_Progress[0] = "Procedure: evaluate_dl_model";
      hv_Progress[1] = "";
      hv_Progress[2] = "";
      if (hv_Progress == null)
        hv_Progress = new HTuple();
      hv_Progress[1] = "Please wait...";
      if (hv_Progress == null)
        hv_Progress = new HTuple();
      hv_Progress[2] = "Task: 2/2: Calculating final evaluation measures";
    }
    //
    //
    //** Do the actual calculation of measures: ***
    //
    hv_EvaluationResult.Dispose();
    calculate_evaluation_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
    //
    //Close progress inspect.
    if ((int)(hv_ShowProgress) != 0)
    {
      hv_Progress.Dispose();
      hv_Progress = "Done.";
      // dev_close_inspect_ctrl(...); only in hdevelop
    }
    //

    hv_ModelType.Dispose();
    hv_ModelClassIDs.Dispose();
    hv_BatchSize.Dispose();
    hv_ModelIgnoreClassIDs.Dispose();
    hv_ShowProgress.Dispose();
    hv_GenParamKeys.Dispose();
    hv_GenParamIndex.Dispose();
    hv_Measures.Dispose();
    hv_IoUThreshold.Dispose();
    hv_MaxNumDetections.Dispose();
    hv_AreaRanges.Dispose();
    hv_DetailedEvaluation.Dispose();
    hv_AllocationBlockLength.Dispose();
    hv_IgnoreClassIDs.Dispose();
    hv_AllIgnoreClassIDs.Dispose();
    hv_EvaluateClassIDs.Dispose();
    hv_ClassInfoExists.Dispose();
    hv_ClassNames.Dispose();
    hv_DatasetClassIDs.Dispose();
    hv_ClassIDsToClassNames.Dispose();
    hv_EvaluateClassNames.Dispose();
    hv_DLSamples.Dispose();
    hv_SampleIndices.Dispose();
    hv_NumSamples.Dispose();
    hv_NumBatches.Dispose();
    hv_RunningMeasures.Dispose();
    hv_Progress.Dispose();
    hv_TaskInfo.Dispose();
    hv_SecondsStart.Dispose();
    hv_BatchIndex.Dispose();
    hv_BatchStart.Dispose();
    hv_BatchEnd.Dispose();
    hv_SamplesIndicesBatch.Dispose();
    hv_DLSamplesBatch.Dispose();
    hv_DLResultsBatch.Dispose();
    hv_BatchSizeEffective.Dispose();
    hv_SecondsElapsed.Dispose();
    hv_SecondsRemaining.Dispose();
    hv_ProgressPercent.Dispose();
    hv_ProgressPerSecond.Dispose();
    hv_TimeElapsedString.Dispose();
    hv_TimeRemainingString.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
  public void find_dl_samples (HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue, 
      HTuple hv_Mode, out HTuple hv_SampleIndices)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumKeyValues = new HTuple(), hv_SampleIndex = new HTuple();
    HTuple hv_Sample = new HTuple(), hv_KeyExists = new HTuple();
    HTuple hv_Tuple = new HTuple(), hv_Hit = new HTuple();
    HTuple hv_ValueIndex = new HTuple(), hv_Value = new HTuple();
    // Initialize local and output iconic variables 
    hv_SampleIndices = new HTuple();
    //
    //This procedure gets the indices of the samples that contain the
    //requested KeyName matching the requested KeyValue according to the Mode.
    //If there is no match, an empty tuple [] will be returned.
    //
    //Check input parameters.
    if ((int)(new HTuple((new HTuple(hv_KeyName.TupleLength())).TupleNotEqual(1))) != 0)
    {
      throw new HalconException(new HTuple("Invalid KeyName size: ")+(new HTuple(hv_KeyName.TupleLength()
          )));
    }
    if ((int)(new HTuple((new HTuple(hv_Mode.TupleLength())).TupleNotEqual(1))) != 0)
    {
      throw new HalconException(new HTuple("Invalid Mode size: ")+(new HTuple(hv_Mode.TupleLength()
          )));
    }
    if ((int)((new HTuple((new HTuple(hv_Mode.TupleNotEqual("match"))).TupleAnd(new HTuple(hv_Mode.TupleNotEqual(
        "or"))))).TupleAnd(new HTuple(hv_Mode.TupleNotEqual("contain")))) != 0)
    {
      throw new HalconException("Invalid Mode value: "+hv_Mode);
    }
    hv_NumKeyValues.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumKeyValues = new HTuple(hv_KeyValue.TupleLength()
        );
    }
    if ((int)((new HTuple(hv_Mode.TupleEqual("contain"))).TupleAnd(new HTuple(hv_NumKeyValues.TupleLess(
        1)))) != 0)
    {
      throw new HalconException("Invalid KeyValue size for contain Mode: "+hv_NumKeyValues);
    }
    //
    //Find the indices.
    hv_SampleIndices.Dispose();
    hv_SampleIndices = new HTuple();
    for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_Samples.TupleLength()
        ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
    {
      hv_Sample.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Sample = hv_Samples.TupleSelect(
          hv_SampleIndex);
      }
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_Sample, "key_exists", hv_KeyName, out hv_KeyExists);
      if ((int)(hv_KeyExists) != 0)
      {
        hv_Tuple.Dispose();
        HOperatorSet.GetDictTuple(hv_Sample, hv_KeyName, out hv_Tuple);
        if ((int)(new HTuple(hv_Mode.TupleEqual("match"))) != 0)
        {
          //Mode 'match': Tuple must be equal KeyValue.
          hv_Hit.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Hit = new HTuple(hv_Tuple.TupleEqual(
              hv_KeyValue));
          }
        }
        else if ((int)((new HTuple(hv_Mode.TupleEqual("or"))).TupleAnd(
            new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleEqual(1)))) != 0)
        {
          //Mode 'or': Tuple must have only 1 element and it has to be equal to any of KeyValues elements.
          hv_Hit.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Hit = new HTuple(((hv_KeyValue.TupleFindFirst(
              hv_Tuple))).TupleGreaterEqual(0));
          }
        }
        else if ((int)(new HTuple(hv_Mode.TupleEqual("contain"))) != 0)
        {
          //Mode 'contain': Tuple must contain any of the elements in KeyValue.
          HTuple end_val35 = hv_NumKeyValues-1;
          HTuple step_val35 = 1;
          for (hv_ValueIndex=0; hv_ValueIndex.Continue(end_val35, step_val35); hv_ValueIndex = hv_ValueIndex.TupleAdd(step_val35))
          {
            hv_Value.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Value = hv_KeyValue.TupleSelect(
                hv_ValueIndex);
            }
            hv_Hit.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Hit = new HTuple(((hv_Tuple.TupleFindFirst(
                hv_Value))).TupleGreaterEqual(0));
            }
            if ((int)(hv_Hit) != 0)
            {
              break;
            }
          }
        }
        else
        {
          //Unsupported configuration.
          hv_Hit.Dispose();
          hv_Hit = 0;
        }
        if ((int)(hv_Hit) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleConcat(
              hv_SampleIndex);
          hv_SampleIndices.Dispose();
          hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
          }
          }
        }
      }
    }

    hv_NumKeyValues.Dispose();
    hv_SampleIndex.Dispose();
    hv_Sample.Dispose();
    hv_KeyExists.Dispose();
    hv_Tuple.Dispose();
    hv_Hit.Dispose();
    hv_ValueIndex.Dispose();
    hv_Value.Dispose();

    return;
  }

  // Chapter: XLD / Creation
  // Short Description: Creates an arrow shaped XLD contour. 
  public void gen_arrow_contour_xld (out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
      HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_TempArrow=null;

    // Local control variables 

    HTuple hv_Length = new HTuple(), hv_ZeroLengthIndices = new HTuple();
    HTuple hv_DR = new HTuple(), hv_DC = new HTuple(), hv_HalfHeadWidth = new HTuple();
    HTuple hv_RowP1 = new HTuple(), hv_ColP1 = new HTuple();
    HTuple hv_RowP2 = new HTuple(), hv_ColP2 = new HTuple();
    HTuple hv_Index = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Arrow);
    HOperatorSet.GenEmptyObj(out ho_TempArrow);
    //This procedure generates arrow shaped XLD contours,
    //pointing from (Row1, Column1) to (Row2, Column2).
    //If starting and end point are identical, a contour consisting
    //of a single point is returned.
    //
    //input parameteres:
    //Row1, Column1: Coordinates of the arrows' starting points
    //Row2, Column2: Coordinates of the arrows' end points
    //HeadLength, HeadWidth: Size of the arrow heads in pixels
    //
    //output parameter:
    //Arrow: The resulting XLD contour
    //
    //The input tuples Row1, Column1, Row2, and Column2 have to be of
    //the same length.
    //HeadLength and HeadWidth either have to be of the same length as
    //Row1, Column1, Row2, and Column2 or have to be a single element.
    //If one of the above restrictions is violated, an error will occur.
    //
    //
    //Init
    ho_Arrow.Dispose();
    HOperatorSet.GenEmptyObj(out ho_Arrow);
    //
    //Calculate the arrow length
    hv_Length.Dispose();
    HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
    //
    //Mark arrows with identical start and end point
    //(set Length to -1 to avoid division-by-zero exception)
    hv_ZeroLengthIndices.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ZeroLengthIndices = hv_Length.TupleFind(
        0);
    }
    if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
    {
      if (hv_Length == null)
        hv_Length = new HTuple();
      hv_Length[hv_ZeroLengthIndices] = -1;
    }
    //
    //Calculate auxiliary variables.
    hv_DR.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DR = (1.0*(hv_Row2-hv_Row1))/hv_Length;
    }
    hv_DC.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DC = (1.0*(hv_Column2-hv_Column1))/hv_Length;
    }
    hv_HalfHeadWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HalfHeadWidth = hv_HeadWidth/2.0;
    }
    //
    //Calculate end points of the arrow head.
    hv_RowP1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RowP1 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))+(hv_HalfHeadWidth*hv_DC);
    }
    hv_ColP1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColP1 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))-(hv_HalfHeadWidth*hv_DR);
    }
    hv_RowP2.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RowP2 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))-(hv_HalfHeadWidth*hv_DC);
    }
    hv_ColP2.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColP2 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))+(hv_HalfHeadWidth*hv_DR);
    }
    //
    //Finally create output XLD contour for each input point pair
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Length.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
      {
        //Create_ single points for arrows with identical start and end point
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_TempArrow.Dispose();
        HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(hv_Index), 
            hv_Column1.TupleSelect(hv_Index));
        }
      }
      else
      {
        //Create arrow contour
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_TempArrow.Dispose();
        HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
            hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
            hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
            hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)), 
            ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
            hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
            hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
            hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
        }
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
      ho_Arrow.Dispose();
      ho_Arrow = ExpTmpOutVar_0;
      }
    }
    ho_TempArrow.Dispose();

    hv_Length.Dispose();
    hv_ZeroLengthIndices.Dispose();
    hv_DR.Dispose();
    hv_DC.Dispose();
    hv_HalfHeadWidth.Dispose();
    hv_RowP1.Dispose();
    hv_ColP1.Dispose();
    hv_RowP2.Dispose();
    hv_ColP2.Dispose();
    hv_Index.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  public void gen_arrow_object_model_3d (HTuple hv_ArrowThickness, HTuple hv_ArrowStart, 
      HTuple hv_ArrowEnd, out HTuple hv_OM3DArrow)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DirectionVector = new HTuple(), hv_ArrowLength = new HTuple();
    HTuple hv_ConeRadius = new HTuple(), hv_ConeLength = new HTuple();
    HTuple hv_CylinderLength = new HTuple(), hv_pi = new HTuple();
    HTuple hv_X = new HTuple(), hv_Y = new HTuple(), hv_Z = new HTuple();
    HTuple hv_Index = new HTuple(), hv_OM3DConeTmp = new HTuple();
    HTuple hv_OM3DCone = new HTuple(), hv_ZZero = new HTuple();
    HTuple hv_ZTop = new HTuple(), hv_OM3DCylinderTmp = new HTuple();
    HTuple hv_OM3DCylinder = new HTuple(), hv_OM3DArrowTmp = new HTuple();
    HTuple hv_Scale = new HTuple(), hv_OriginX = new HTuple();
    HTuple hv_OriginY = new HTuple(), hv_OriginZ = new HTuple();
    HTuple hv_TargetX = new HTuple(), hv_TargetY = new HTuple();
    HTuple hv_TargetZ = new HTuple(), hv_HomMat3D = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DArrow = new HTuple();
    //
    //This procedure draws an arrow that starts at the point ArrowStart and ends at ArrowEnd.
    //
    //Get parameters.
    hv_DirectionVector.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DirectionVector = (hv_ArrowEnd.TupleSelectRange(
        0,2))-(hv_ArrowStart.TupleSelectRange(0,2));
    }
    hv_ArrowLength.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ArrowLength = (((((hv_DirectionVector.TupleSelect(
        0))*(hv_DirectionVector.TupleSelect(0)))+((hv_DirectionVector.TupleSelect(
        1))*(hv_DirectionVector.TupleSelect(1))))+((hv_DirectionVector.TupleSelect(
        2))*(hv_DirectionVector.TupleSelect(2))))).TupleSqrt();
    }
    hv_ConeRadius.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ConeRadius = 2.0*hv_ArrowThickness;
    }
    hv_ConeLength.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ConeLength = ((((2.0*hv_ConeRadius)).TupleConcat(
        hv_ArrowLength*0.9))).TupleMin();
    }
    hv_CylinderLength.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CylinderLength = hv_ArrowLength-hv_ConeLength;
    }
    //
    //Create cone.
    hv_pi.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_pi = (new HTuple(180)).TupleRad()
        ;
    }
    hv_X.Dispose();
    hv_X = 0;
    hv_Y.Dispose();
    hv_Y = 0;
    hv_Z.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Z = hv_CylinderLength+hv_ConeLength;
    }
    HTuple end_val15 = 2*hv_pi;
    HTuple step_val15 = 0.1;
    for (hv_Index=0; hv_Index.Continue(end_val15, step_val15); hv_Index = hv_Index.TupleAdd(step_val15))
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_X = hv_X.TupleConcat(
          hv_ConeRadius*(hv_Index.TupleCos()));
      hv_X.Dispose();
      hv_X = ExpTmpLocalVar_X;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Y = hv_Y.TupleConcat(
          hv_ConeRadius*(hv_Index.TupleSin()));
      hv_Y.Dispose();
      hv_Y = ExpTmpLocalVar_Y;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Z = hv_Z.TupleConcat(
          hv_CylinderLength);
      hv_Z.Dispose();
      hv_Z = ExpTmpLocalVar_Z;
      }
      }
    }
    hv_OM3DConeTmp.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(hv_X, hv_Y, hv_Z, out hv_OM3DConeTmp);
    hv_OM3DCone.Dispose();
    HOperatorSet.ConvexHullObjectModel3d(hv_OM3DConeTmp, out hv_OM3DCone);
    HOperatorSet.ClearObjectModel3d(hv_OM3DConeTmp);
    //
    //Create cylinder.
    hv_X.Dispose();
    hv_X = new HTuple();
    hv_Y.Dispose();
    hv_Y = new HTuple();
    HTuple end_val27 = 2*hv_pi;
    HTuple step_val27 = 0.1;
    for (hv_Index=0; hv_Index.Continue(end_val27, step_val27); hv_Index = hv_Index.TupleAdd(step_val27))
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_X = hv_X.TupleConcat(
          hv_ArrowThickness*(hv_Index.TupleCos()));
      hv_X.Dispose();
      hv_X = ExpTmpLocalVar_X;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Y = hv_Y.TupleConcat(
          hv_ArrowThickness*(hv_Index.TupleSin()));
      hv_Y.Dispose();
      hv_Y = ExpTmpLocalVar_Y;
      }
      }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ZZero.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_Y.TupleLength()), 0, out hv_ZZero);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ZTop.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_Y.TupleLength()), hv_CylinderLength, 
        out hv_ZTop);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DCylinderTmp.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(hv_X.TupleConcat(hv_X), hv_Y.TupleConcat(
        hv_Y), hv_ZZero.TupleConcat(hv_ZTop), out hv_OM3DCylinderTmp);
    }
    hv_OM3DCylinder.Dispose();
    HOperatorSet.ConvexHullObjectModel3d(hv_OM3DCylinderTmp, out hv_OM3DCylinder);
    HOperatorSet.ClearObjectModel3d(hv_OM3DCylinderTmp);
    //
    //Union cone and cylinder Create arrow.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DArrowTmp.Dispose();
    HOperatorSet.UnionObjectModel3d(hv_OM3DCone.TupleConcat(hv_OM3DCylinder), "points_surface", 
        out hv_OM3DArrowTmp);
    }
    HOperatorSet.ClearObjectModel3d(hv_OM3DCone);
    HOperatorSet.ClearObjectModel3d(hv_OM3DCylinder);
    hv_Scale.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Scale = hv_CylinderLength/hv_ArrowLength;
    }
    hv_OriginX.Dispose();
    hv_OriginX = new HTuple();
    hv_OriginX[0] = 0;
    hv_OriginX[1] = 0;
    hv_OriginX[2] = 0;
    hv_OriginY.Dispose();
    hv_OriginY = new HTuple();
    hv_OriginY[0] = 0;
    hv_OriginY[1] = 0;
    hv_OriginY[2] = 0;
    hv_OriginZ.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OriginZ = new HTuple();
    hv_OriginZ[0] = 0;
    hv_OriginZ = hv_OriginZ.TupleConcat(hv_CylinderLength, hv_ArrowLength);
    }
    hv_TargetX.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TargetX = new HTuple();
    hv_TargetX = hv_TargetX.TupleConcat(hv_ArrowStart.TupleSelect(
        0));
    hv_TargetX = hv_TargetX.TupleConcat((hv_ArrowStart.TupleSelect(0))+(hv_Scale*(hv_DirectionVector.TupleSelect(
        0))));
    hv_TargetX = hv_TargetX.TupleConcat(hv_ArrowEnd.TupleSelect(0));
    }
    hv_TargetY.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TargetY = new HTuple();
    hv_TargetY = hv_TargetY.TupleConcat(hv_ArrowStart.TupleSelect(
        1));
    hv_TargetY = hv_TargetY.TupleConcat((hv_ArrowStart.TupleSelect(1))+(hv_Scale*(hv_DirectionVector.TupleSelect(
        1))));
    hv_TargetY = hv_TargetY.TupleConcat(hv_ArrowEnd.TupleSelect(1));
    }
    hv_TargetZ.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TargetZ = new HTuple();
    hv_TargetZ = hv_TargetZ.TupleConcat(hv_ArrowStart.TupleSelect(
        2));
    hv_TargetZ = hv_TargetZ.TupleConcat((hv_ArrowStart.TupleSelect(2))+(hv_Scale*(hv_DirectionVector.TupleSelect(
        2))));
    hv_TargetZ = hv_TargetZ.TupleConcat(hv_ArrowEnd.TupleSelect(2));
    }
    hv_HomMat3D.Dispose();
    HOperatorSet.VectorToHomMat3d("rigid", hv_OriginX, hv_OriginY, hv_OriginZ, hv_TargetX, 
        hv_TargetY, hv_TargetZ, out hv_HomMat3D);
    hv_OM3DArrow.Dispose();
    HOperatorSet.AffineTransObjectModel3d(hv_OM3DArrowTmp, hv_HomMat3D, out hv_OM3DArrow);
    HOperatorSet.ClearObjectModel3d(hv_OM3DArrowTmp);

    hv_DirectionVector.Dispose();
    hv_ArrowLength.Dispose();
    hv_ConeRadius.Dispose();
    hv_ConeLength.Dispose();
    hv_CylinderLength.Dispose();
    hv_pi.Dispose();
    hv_X.Dispose();
    hv_Y.Dispose();
    hv_Z.Dispose();
    hv_Index.Dispose();
    hv_OM3DConeTmp.Dispose();
    hv_OM3DCone.Dispose();
    hv_ZZero.Dispose();
    hv_ZTop.Dispose();
    hv_OM3DCylinderTmp.Dispose();
    hv_OM3DCylinder.Dispose();
    hv_OM3DArrowTmp.Dispose();
    hv_Scale.Dispose();
    hv_OriginX.Dispose();
    hv_OriginY.Dispose();
    hv_OriginZ.Dispose();
    hv_TargetX.Dispose();
    hv_TargetY.Dispose();
    hv_TargetZ.Dispose();
    hv_HomMat3D.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Create blank train sample dicts for a given model. 
  public void gen_blank_dl_train_samples (HTuple hv_DLModelHandle, out HTuple hv_TrainSamples)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Images=null, ho_Image=null, ho_Target=null;
    HObject ho_Weight=null;

    // Local control variables 

    HTuple hv_BatchSize = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_ImageNumChannels = new HTuple();
    HTuple hv_ClassIDs = new HTuple(), hv_ModelType = new HTuple();
    HTuple hv_I = new HTuple(), hv_Index = new HTuple(), hv_TrainInput = new HTuple();
    HTuple hv_BBoxLabelID = new HTuple(), hv_BBoxCol1 = new HTuple();
    HTuple hv_BBoxCol2 = new HTuple(), hv_BBoxRow1 = new HTuple();
    HTuple hv_BBoxRow2 = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Images);
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_Target);
    HOperatorSet.GenEmptyObj(out ho_Weight);
    hv_TrainSamples = new HTuple();
    //
    //This procedure generates blank input data for the given model.
    //
    //Get model parameters.
    hv_BatchSize.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
    hv_ImageWidth.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_width", out hv_ImageWidth);
    hv_ImageHeight.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_height", out hv_ImageHeight);
    hv_ImageNumChannels.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_num_channels", out hv_ImageNumChannels);
    hv_ClassIDs.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDs);
    hv_ModelType.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
    //
    //Collect train inputs.
    hv_TrainSamples.Dispose();
    hv_TrainSamples = new HTuple();
    //
    HTuple end_val14 = hv_BatchSize-1;
    HTuple step_val14 = 1;
    for (hv_I=0; hv_I.Continue(end_val14, step_val14); hv_I = hv_I.TupleAdd(step_val14))
    {
      //Create blank image.
      ho_Images.Dispose();
      HOperatorSet.GenEmptyObj(out ho_Images);
      HTuple end_val17 = hv_ImageNumChannels-1;
      HTuple step_val17 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val17, step_val17); hv_Index = hv_Index.TupleAdd(step_val17))
      {
        ho_Image.Dispose();
        HOperatorSet.GenImageConst(out ho_Image, "real", hv_ImageWidth, hv_ImageHeight);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_Images, ho_Image, out ExpTmpOutVar_0);
        ho_Images.Dispose();
        ho_Images = ExpTmpOutVar_0;
        }
      }
      ho_Image.Dispose();
      HOperatorSet.ChannelsToImage(ho_Images, out ho_Image);
      //
      //Create train data.
      hv_TrainInput.Dispose();
      HOperatorSet.CreateDict(out hv_TrainInput);
      HOperatorSet.SetDictObject(ho_Image, hv_TrainInput, "image");
      //
      //Add model specific blank training data.
      if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
      {
        //Generate blank weights and targets.
        ho_Target.Dispose();
        HOperatorSet.GenImageConst(out ho_Target, "real", hv_ImageWidth, hv_ImageHeight);
        ho_Weight.Dispose();
        HOperatorSet.GenImageConst(out ho_Weight, "real", hv_ImageWidth, hv_ImageHeight);
        //Fill with first color background.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.OverpaintRegion(ho_Target, ho_Target, hv_ClassIDs.TupleSelect(
            0), "fill");
        }
        HOperatorSet.OverpaintRegion(ho_Weight, ho_Weight, 1, "fill");
        HOperatorSet.SetDictObject(ho_Target, hv_TrainInput, "segmentation_image");
        HOperatorSet.SetDictObject(ho_Weight, hv_TrainInput, "weight_image");
      }
      else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
      {
        //Generate blank bbox labels.
        hv_BBoxLabelID.Dispose();
        hv_BBoxLabelID = new HTuple();
        hv_BBoxCol1.Dispose();
        hv_BBoxCol1 = new HTuple();
        hv_BBoxCol2.Dispose();
        hv_BBoxCol2 = new HTuple();
        hv_BBoxRow1.Dispose();
        hv_BBoxRow1 = new HTuple();
        hv_BBoxRow2.Dispose();
        hv_BBoxRow2 = new HTuple();
        //
        HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_label_id", hv_BBoxLabelID);
        HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_row1", hv_BBoxRow1);
        HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_row2", hv_BBoxRow2);
        HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_col1", hv_BBoxCol1);
        HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_col2", hv_BBoxCol2);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TrainSamples = hv_TrainSamples.TupleConcat(
          hv_TrainInput);
      hv_TrainSamples.Dispose();
      hv_TrainSamples = ExpTmpLocalVar_TrainSamples;
      }
      }
    }
    ho_Images.Dispose();
    ho_Image.Dispose();
    ho_Target.Dispose();
    ho_Weight.Dispose();

    hv_BatchSize.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_ImageNumChannels.Dispose();
    hv_ClassIDs.Dispose();
    hv_ModelType.Dispose();
    hv_I.Dispose();
    hv_Index.Dispose();
    hv_TrainInput.Dispose();
    hv_BBoxLabelID.Dispose();
    hv_BBoxCol1.Dispose();
    hv_BBoxCol2.Dispose();
    hv_BBoxRow1.Dispose();
    hv_BBoxRow2.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate a 3D object model which visualizes the bounding box of a stereo model. 
  public void gen_bounding_box_object_model_3d (HTuple hv_StereoModelID, out HTuple hv_ObjectModel3DBoundingBox)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_BoundingBox = new HTuple(), hv_PX = new HTuple();
    HTuple hv_PY = new HTuple(), hv_PZ = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Faces = new HTuple();

    HTupleVector hvec_Points = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_ObjectModel3DBoundingBox = new HTuple();
    //
    //Consistency check:
    hv_BoundingBox.Dispose();
    HOperatorSet.GetStereoModelParam(hv_StereoModelID, "bounding_box", out hv_BoundingBox);
    if ((int)((new HTuple((new HTuple(((hv_BoundingBox.TupleSelect(3))).TupleLess(
        hv_BoundingBox.TupleSelect(0)))).TupleOr(new HTuple(((hv_BoundingBox.TupleSelect(
        4))).TupleLess(hv_BoundingBox.TupleSelect(1)))))).TupleOr(new HTuple(((hv_BoundingBox.TupleSelect(
        5))).TupleLess(hv_BoundingBox.TupleSelect(2))))) != 0)
    {
      throw new HalconException("Invalid bounding box or bounding box not set yet.");
    }
    //
    //Get the eight corner points from the min/max representation.
    hvec_Points.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points = dh.Take((
        dh.Add(new HTupleVector(1)).Insert(0,dh.Add(new HTupleVector(new HTuple())))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[0] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        0))).TupleConcat(hv_BoundingBox.TupleSelect(1)))).TupleConcat(hv_BoundingBox.TupleSelect(
        2))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[1] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        3))).TupleConcat(hv_BoundingBox.TupleSelect(1)))).TupleConcat(hv_BoundingBox.TupleSelect(
        2))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[2] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        3))).TupleConcat(hv_BoundingBox.TupleSelect(4)))).TupleConcat(hv_BoundingBox.TupleSelect(
        2))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[3] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        0))).TupleConcat(hv_BoundingBox.TupleSelect(4)))).TupleConcat(hv_BoundingBox.TupleSelect(
        2))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[4] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        0))).TupleConcat(hv_BoundingBox.TupleSelect(1)))).TupleConcat(hv_BoundingBox.TupleSelect(
        5))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[5] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        3))).TupleConcat(hv_BoundingBox.TupleSelect(1)))).TupleConcat(hv_BoundingBox.TupleSelect(
        5))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[6] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        3))).TupleConcat(hv_BoundingBox.TupleSelect(4)))).TupleConcat(hv_BoundingBox.TupleSelect(
        5))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[7] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        0))).TupleConcat(hv_BoundingBox.TupleSelect(4)))).TupleConcat(hv_BoundingBox.TupleSelect(
        5))));
    }
    //
    //Sort the corner points by coordinate direction.
    hv_PX.Dispose();
    hv_PX = new HTuple();
    hv_PY.Dispose();
    hv_PY = new HTuple();
    hv_PZ.Dispose();
    hv_PZ = new HTuple();
    for (hv_Index=0; (int)hv_Index<=7; hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PX = hv_PX.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(0));
      hv_PX.Dispose();
      hv_PX = ExpTmpLocalVar_PX;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PY = hv_PY.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(1));
      hv_PY.Dispose();
      hv_PY = ExpTmpLocalVar_PY;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PZ = hv_PZ.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(2));
      hv_PZ.Dispose();
      hv_PZ = ExpTmpLocalVar_PZ;
      }
      }
    }
    hv_ObjectModel3DBoundingBox.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(hv_PX, hv_PY, hv_PZ, out hv_ObjectModel3DBoundingBox);
    //
    //Set the sides of the cuboid.
    hv_Faces.Dispose();
    hv_Faces = new HTuple();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(0)).TupleConcat(1)).TupleConcat(5)).TupleConcat(
        4));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(1)).TupleConcat(2)).TupleConcat(6)).TupleConcat(
        5));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(2)).TupleConcat(3)).TupleConcat(7)).TupleConcat(
        6));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(3)).TupleConcat(0)).TupleConcat(4)).TupleConcat(
        7));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(0)).TupleConcat(1)).TupleConcat(2)).TupleConcat(
        3));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(4)).TupleConcat(5)).TupleConcat(6)).TupleConcat(
        7));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    HOperatorSet.SetObjectModel3dAttribMod(hv_ObjectModel3DBoundingBox, "polygons", 
        new HTuple(), hv_Faces);

    hv_BoundingBox.Dispose();
    hv_PX.Dispose();
    hv_PY.Dispose();
    hv_PZ.Dispose();
    hv_Index.Dispose();
    hv_Faces.Dispose();
    hvec_Points.Dispose();

    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model. 
  public void gen_cam_par_area_scan_division (HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_Sx, 
      HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
      out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera
    //with distortions modeled by the division model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_division";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Focus, hv_Kappa, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model. 
  public void gen_cam_par_area_scan_hypercentric_division (HTuple hv_Focus, HTuple hv_Kappa, 
      HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
      HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera
    //with a hypercentric lens and with distortions modeled by the
    //division model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_hypercentric_division";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Focus, hv_Kappa, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with a hypercentric lens and with distortions modeled by the polynomial model. 
  public void gen_cam_par_area_scan_hypercentric_polynomial (HTuple hv_Focus, HTuple hv_K1, 
      HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Sx, HTuple hv_Sy, 
      HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera
    //with a hypercentric lens and with distortions modeled by the
    //polynomial model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_hypercentric_polynomial";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Focus, hv_K1, hv_K2, hv_K3, hv_P1, hv_P2, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with distortions modeled by the polynomial model. 
  public void gen_cam_par_area_scan_polynomial (HTuple hv_Focus, HTuple hv_K1, HTuple hv_K2, 
      HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, 
      HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera
    //with distortions modeled by the polynomial model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_polynomial";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Focus, hv_K1, hv_K2, hv_K3, hv_P1, hv_P2, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the division model. 
  public void gen_cam_par_area_scan_telecentric_division (HTuple hv_Magnification, 
      HTuple hv_Kappa, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
      HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera
    //with a telecentric lens and with distortions modeled by the
    //division model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_telecentric_division";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Magnification, hv_Kappa, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the polynomial model. 
  public void gen_cam_par_area_scan_telecentric_polynomial (HTuple hv_Magnification, 
      HTuple hv_K1, HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Sx, 
      HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
      out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera
    //with a telecentric lens and with distortions modeled by the
    //polynomial model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_telecentric_polynomial";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Magnification, hv_K1, hv_K2, hv_K3, hv_P1, hv_P2, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the division model. 
  public void gen_cam_par_area_scan_tilt_bilateral_telecentric_division (HTuple hv_Magnification, 
      HTuple hv_Kappa, HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, 
      HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera with
    //a bilateral telecentric tilt lens and with distortions modeled
    //by the division model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_tilt_bilateral_telecentric_division";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Magnification, hv_Kappa, hv_Tilt, hv_Rot, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the polynomial model. 
  public void gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial (HTuple hv_Magnification, 
      HTuple hv_K1, HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Tilt, 
      HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
      HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera with
    //a bilateral telecentric tilt lens and with distortions modeled
    //by the polynomial model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_tilt_bilateral_telecentric_polynomial";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Magnification, hv_K1, hv_K2, hv_K3, hv_P1, hv_P2, hv_Tilt, hv_Rot, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the division model. 
  public void gen_cam_par_area_scan_tilt_division (HTuple hv_Focus, HTuple hv_Kappa, 
      HTuple hv_ImagePlaneDist, HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, 
      HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera with
    //a tilt lens and with distortions modeled by the division model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_tilt_division";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Focus, hv_Kappa, hv_ImagePlaneDist, hv_Tilt, hv_Rot, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the division model. 
  public void gen_cam_par_area_scan_tilt_image_side_telecentric_division (HTuple hv_Focus, 
      HTuple hv_Kappa, HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, 
      HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera with
    //an image-side telecentric tilt lens and with distortions modeled
    //by the division model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_tilt_image_side_telecentric_division";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Focus, hv_Kappa, hv_Tilt, hv_Rot, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the polynomial model. 
  public void gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial (HTuple hv_Focus, 
      HTuple hv_K1, HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_Tilt, 
      HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, 
      HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera with
    //an image-side telecentric tilt lens and with distortions modeled
    //by the polynomial model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_tilt_image_side_telecentric_polynomial";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Focus, hv_K1, hv_K2, hv_K3, hv_P1, hv_P2, hv_Tilt, hv_Rot, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the division model. 
  public void gen_cam_par_area_scan_tilt_object_side_telecentric_division (HTuple hv_Magnification, 
      HTuple hv_Kappa, HTuple hv_ImagePlaneDist, HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, 
      HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
      out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera with
    //an object-side telecentric tilt lens and with distortions modeled
    //by the division model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_tilt_object_side_telecentric_division";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Magnification, hv_Kappa, hv_ImagePlaneDist, hv_Tilt, hv_Rot, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the polynomial model. 
  public void gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial (HTuple hv_Magnification, 
      HTuple hv_K1, HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_ImagePlaneDist, 
      HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, 
      HTuple hv_ImageWidth, HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera with
    //an object-side telecentric tilt lens and with distortions modeled
    //by the polynomial model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_tilt_object_side_telecentric_polynomial";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Magnification, hv_K1, hv_K2, hv_K3, hv_P1, hv_P2, hv_ImagePlaneDist, hv_Tilt, hv_Rot, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the polynomial model. 
  public void gen_cam_par_area_scan_tilt_polynomial (HTuple hv_Focus, HTuple hv_K1, 
      HTuple hv_K2, HTuple hv_K3, HTuple hv_P1, HTuple hv_P2, HTuple hv_ImagePlaneDist, 
      HTuple hv_Tilt, HTuple hv_Rot, HTuple hv_Sx, HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, 
      HTuple hv_ImageWidth, HTuple hv_ImageHeight, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for an area scan camera with
    //a tilt lens and with distortions modeled by the polynomial model.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "area_scan_tilt_polynomial";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Focus, hv_K1, hv_K2, hv_K3, hv_P1, hv_P2, hv_ImagePlaneDist, hv_Tilt, hv_Rot, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight);
    }


    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Generate a camera parameter tuple for a line scan camera. 
  public void gen_cam_par_line_scan (HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_Sx, 
      HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
      HTuple hv_Vx, HTuple hv_Vy, HTuple hv_Vz, out HTuple hv_CameraParam)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_CameraParam = new HTuple();
    //Generate a camera parameter tuple for a line scan camera.
    //
    hv_CameraParam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam = new HTuple();
    hv_CameraParam[0] = "line_scan";
    hv_CameraParam = hv_CameraParam.TupleConcat(hv_Focus, hv_Kappa, hv_Sx, hv_Sy, hv_Cx, hv_Cy, hv_ImageWidth, hv_ImageHeight, hv_Vx, hv_Vy, hv_Vz);
    }


    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate 3D object models for the camera and the robot's tool. 
  public void gen_camera_and_tool_moving_cam_object_model_3d (HTuple hv_ToolInCamPose, 
      HTuple hv_ToolInBasePose, HTuple hv_CameraSize, HTuple hv_ConeLength, HTuple hv_OM3DToolOrig, 
      HTuple hv_CamParam, out HTuple hv_OM3DCamera, out HTuple hv_OM3DTool)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_IdentityPose = new HTuple(), hv_CameraSetupModelID = new HTuple();
    HTuple hv_OM3DCameraOrigin = new HTuple(), hv_OM3DConeOrig = new HTuple();
    HTuple hv_CamInToolPose = new HTuple(), hv_CamInBasePose = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DCamera = new HTuple();
    hv_OM3DTool = new HTuple();
    //This procedure helps visualize the camera and its cone, as well
    //as the robot's tool in their current positions.
    //
    //Visualize Tool.
    hv_OM3DTool.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_OM3DToolOrig, hv_ToolInBasePose, out hv_OM3DTool);
    //
    //Visualize Camera.
    hv_IdentityPose.Dispose();
    HOperatorSet.CreatePose(0, 0, 0, 0, 0, 0, "Rp+T", "gba", "point", out hv_IdentityPose);
    hv_CameraSetupModelID.Dispose();
    HOperatorSet.CreateCameraSetupModel(1, out hv_CameraSetupModelID);
    HOperatorSet.SetCameraSetupCamParam(hv_CameraSetupModelID, 0, new HTuple(), hv_CamParam, 
        hv_IdentityPose);
    hv_OM3DCameraOrigin.Dispose();hv_OM3DConeOrig.Dispose();
    gen_camera_setup_object_model_3d(hv_CameraSetupModelID, hv_CameraSize, hv_ConeLength, 
        out hv_OM3DCameraOrigin, out hv_OM3DConeOrig);
    HOperatorSet.ClearCameraSetupModel(hv_CameraSetupModelID);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_OM3DCameraOrigin = hv_OM3DCameraOrigin.TupleConcat(
        hv_OM3DConeOrig);
    hv_OM3DCameraOrigin.Dispose();
    hv_OM3DCameraOrigin = ExpTmpLocalVar_OM3DCameraOrigin;
    }
    }
    //
    hv_CamInToolPose.Dispose();
    HOperatorSet.PoseInvert(hv_ToolInCamPose, out hv_CamInToolPose);
    hv_CamInBasePose.Dispose();
    HOperatorSet.PoseCompose(hv_ToolInBasePose, hv_CamInToolPose, out hv_CamInBasePose);
    hv_OM3DCamera.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_OM3DCameraOrigin, hv_CamInBasePose, out hv_OM3DCamera);
    HOperatorSet.ClearObjectModel3d(hv_OM3DCameraOrigin);

    hv_IdentityPose.Dispose();
    hv_CameraSetupModelID.Dispose();
    hv_OM3DCameraOrigin.Dispose();
    hv_OM3DConeOrig.Dispose();
    hv_CamInToolPose.Dispose();
    hv_CamInBasePose.Dispose();

    return;
  }

  public void gen_camera_facing_scene (HTuple hv_Viewpoint, HTuple hv_Center, HTuple hv_DiameterModel, 
      out HTuple hv_OM3DCamera)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Direction = new HTuple(), hv_DirectionLength = new HTuple();
    HTuple hv_DirNorm = new HTuple(), hv_Axis = new HTuple();
    HTuple hv_AxisNorm = new HTuple(), hv_HomMat3DIdentity = new HTuple();
    HTuple hv_HomMat3DRotate = new HTuple(), hv_Pose = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DCamera = new HTuple();
    hv_Direction.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Direction = hv_Viewpoint-hv_Center;
    }
    hv_DirectionLength.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DirectionLength = ((((hv_Direction*hv_Direction)).TupleSum()
        )).TupleSqrt();
    }
    if ((int)(new HTuple(hv_DirectionLength.TupleLess(1e-1*hv_DiameterModel))) != 0)
    {
      hv_DirectionLength.Dispose();
      hv_DirectionLength = 0;
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_OM3DCamera.Dispose();
      HOperatorSet.GenSphereObjectModel3d(hv_Viewpoint.TupleConcat((((new HTuple(0)).TupleConcat(
          0)).TupleConcat(0)).TupleConcat(0)), hv_DiameterModel*0.1, out hv_OM3DCamera);
      }
    }
    else
    {
      //Create a rotation such that the camera faces the center of gravity of the scene
      hv_DirNorm.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DirNorm = hv_Direction/hv_DirectionLength;
      }
      if ((int)(new HTuple(((((hv_DirNorm*((new HTuple(0)).TupleConcat(0)).TupleConcat(
          -1))).TupleSum())).TupleGreater(-0.99999))) != 0)
      {
        //Angle between the vectors is > 0.25X
        hv_Axis.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Axis = hv_DirNorm+(
            (new HTuple(0)).TupleConcat(0)).TupleConcat(-1);
        }
        hv_AxisNorm.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AxisNorm = hv_Axis/(((((hv_Axis*hv_Axis)).TupleSum()
            )).TupleSqrt());
        }
      }
      else
      {
        hv_Axis.Dispose();
        hv_Axis = new HTuple();
        hv_Axis[0] = 0;
        hv_Axis[1] = 1;
        hv_Axis[2] = 0;
      }
      hv_HomMat3DIdentity.Dispose();
      HOperatorSet.HomMat3dIdentity(out hv_HomMat3DIdentity);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HomMat3DRotate.Dispose();
      HOperatorSet.HomMat3dRotateLocal(hv_HomMat3DIdentity, (new HTuple(180)).TupleRad()
          , hv_Axis, out hv_HomMat3DRotate);
      }
      hv_Pose.Dispose();
      HOperatorSet.HomMat3dToPose(hv_HomMat3DRotate, out hv_Pose);
      if (hv_Pose == null)
        hv_Pose = new HTuple();
      hv_Pose[HTuple.TupleGenSequence(0,2,1)] = hv_Viewpoint;
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_OM3DCamera.Dispose();
      gen_camera_object_model_3d(hv_Pose, hv_DiameterModel*0.1, out hv_OM3DCamera);
      }
    }

    hv_Direction.Dispose();
    hv_DirectionLength.Dispose();
    hv_DirNorm.Dispose();
    hv_Axis.Dispose();
    hv_AxisNorm.Dispose();
    hv_HomMat3DIdentity.Dispose();
    hv_HomMat3DRotate.Dispose();
    hv_Pose.Dispose();

    return;
  }

  // Short Description: Create a 3D object model that resembles a camera 
  public void gen_camera_object_model_3d (HTuple hv_Pose, HTuple hv_Size, out HTuple hv_OM3DCamera)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OM3DBox = new HTuple(), hv_OM3DBoxTriangulated = new HTuple();
    HTuple hv_Information = new HTuple(), hv_OM3DCylinder = new HTuple();
    HTuple hv_OMSampledCylinder = new HTuple(), hv_CX = new HTuple();
    HTuple hv_CY = new HTuple(), hv_CZ = new HTuple(), hv_Lin = new HTuple();
    HTuple hv_Fac = new HTuple(), hv_OM3DCylinder2 = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DCamera = new HTuple();
    //
    //Create the box
    hv_OM3DBox.Dispose();
    HOperatorSet.GenBoxObjectModel3d(((((((new HTuple(0)).TupleConcat(0)).TupleConcat(
        0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(0), hv_Size, 
        hv_Size, hv_Size, out hv_OM3DBox);
    hv_OM3DBoxTriangulated.Dispose();hv_Information.Dispose();
    HOperatorSet.TriangulateObjectModel3d(hv_OM3DBox, "greedy", new HTuple(), new HTuple(), 
        out hv_OM3DBoxTriangulated, out hv_Information);
    //Create the cone frustum
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DCylinder.Dispose();
    HOperatorSet.GenCylinderObjectModel3d(((((((new HTuple(0)).TupleConcat(0)).TupleConcat(
        0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(0), hv_Size*0.5, 
        hv_Size*0.5, hv_Size*1, out hv_OM3DCylinder);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OMSampledCylinder.Dispose();
    HOperatorSet.SampleObjectModel3d(hv_OM3DCylinder, "fast", hv_Size*0.02, new HTuple(), 
        new HTuple(), out hv_OMSampledCylinder);
    }
    hv_CX.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_OMSampledCylinder, "point_coord_x", out hv_CX);
    hv_CY.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_OMSampledCylinder, "point_coord_y", out hv_CY);
    hv_CZ.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_OMSampledCylinder, "point_coord_z", out hv_CZ);
    hv_Lin.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Lin = (hv_CZ-(hv_Size*0.5))/((hv_CZ.TupleMax()
        )-(hv_CZ.TupleMin()));
    }
    hv_Fac.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Fac = (hv_Lin*0.5)+0.5;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetObjectModel3dAttribMod(hv_OMSampledCylinder, "point_coord_x", 
        new HTuple(), hv_CX*hv_Fac);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetObjectModel3dAttribMod(hv_OMSampledCylinder, "point_coord_y", 
        new HTuple(), hv_CY*hv_Fac);
    }
    hv_OM3DCylinder2.Dispose();
    HOperatorSet.ConvexHullObjectModel3d(hv_OMSampledCylinder, out hv_OM3DCylinder2);
    //
    //Make it a single model and move to desired pose
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DCamera.Dispose();
    HOperatorSet.UnionObjectModel3d(hv_OM3DBoxTriangulated.TupleConcat(hv_OM3DCylinder2), 
        "points_surface", out hv_OM3DCamera);
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.RigidTransObjectModel3d(hv_OM3DCamera, hv_Pose, out ExpTmpOutVar_0);
    hv_OM3DCamera.Dispose();
    hv_OM3DCamera = ExpTmpOutVar_0;
    }

    hv_OM3DBox.Dispose();
    hv_OM3DBoxTriangulated.Dispose();
    hv_Information.Dispose();
    hv_OM3DCylinder.Dispose();
    hv_OMSampledCylinder.Dispose();
    hv_CX.Dispose();
    hv_CY.Dispose();
    hv_CZ.Dispose();
    hv_Lin.Dispose();
    hv_Fac.Dispose();
    hv_OM3DCylinder2.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate a symbolic 3D object model of a camera. 
  public void gen_camera_object_model_3d_reconstruction_3d (HTuple hv_CameraSetupModel, 
      HTuple hv_CamIndex, HTuple hv_CameraSize, out HTuple hv_OM3DCam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_LensePose = new HTuple(), hv_CylinderLength = new HTuple();
    HTuple hv_ObjectModel3DLense = new HTuple(), hv_ObjectModel3DInit = new HTuple();
    HTuple hv_CamParams = new HTuple(), hv_Type = new HTuple();
    HTuple hv_Tilt = new HTuple(), hv_Rot = new HTuple(), hv_HomMat3DIdentity = new HTuple();
    HTuple hv_HomMat3DRotate = new HTuple(), hv_SensorToLenseRotation = new HTuple();
    HTuple hv_ObjectModel3DInitTilted = new HTuple(), hv_BoundingBox = new HTuple();
    HTuple hv_PX = new HTuple(), hv_PY = new HTuple(), hv_QZ = new HTuple();
    HTuple hv_PoseBack = new HTuple(), hv_ObjectModel3DInitTiltedBack = new HTuple();
    HTuple hv_CamPose = new HTuple(), hv_OM3DSensor = new HTuple();
    HTuple hv_OM3DLense = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DCam = new HTuple();
    //
    //Generate a cylinder (lens) and move it behind the origin in direction z.
    hv_LensePose.Dispose();
    HOperatorSet.CreatePose(0.0, 0.0, 0.0, 0, 0, 0, "Rp+T", "gba", "point", out hv_LensePose);
    hv_CylinderLength.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CylinderLength = hv_CameraSize/4.0;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ObjectModel3DLense.Dispose();
    HOperatorSet.GenCylinderObjectModel3d(hv_LensePose, hv_CameraSize/2.0, (-hv_CylinderLength)/2.0, 
        0.0, out hv_ObjectModel3DLense);
    }
    //
    //Generate a box (sensor housing) and tilt it, if necessary.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ObjectModel3DInit.Dispose();
    HOperatorSet.GenBoxObjectModel3d(hv_LensePose, 1.0*hv_CameraSize, 1.0*hv_CameraSize, 
        1.0*hv_CameraSize, out hv_ObjectModel3DInit);
    }
    hv_CamParams.Dispose();
    HOperatorSet.GetCameraSetupParam(hv_CameraSetupModel, hv_CamIndex, "params", 
        out hv_CamParams);
    hv_Type.Dispose();
    HOperatorSet.GetCameraSetupParam(hv_CameraSetupModel, hv_CamIndex, "type", out hv_Type);
    //
    //Distinguish cases with/without tilt.
    if ((int)(hv_Type.TupleRegexpTest("tilt")) != 0)
    {
      hv_Tilt.Dispose();
      get_cam_par_data(hv_CamParams, "tilt", out hv_Tilt);
      hv_Rot.Dispose();
      get_cam_par_data(hv_CamParams, "rot", out hv_Rot);
    }
    else
    {
      hv_Tilt.Dispose();
      hv_Tilt = 0;
      hv_Rot.Dispose();
      hv_Rot = 0;
    }
    hv_HomMat3DIdentity.Dispose();
    HOperatorSet.HomMat3dIdentity(out hv_HomMat3DIdentity);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HomMat3DRotate.Dispose();
    HOperatorSet.HomMat3dRotate(hv_HomMat3DIdentity, hv_Tilt.TupleRad(), ((((((hv_Rot.TupleRad()
        )).TupleCos())).TupleConcat(((hv_Rot.TupleRad())).TupleSin()))).TupleConcat(
        0), 0, 0, 0, out hv_HomMat3DRotate);
    }
    hv_SensorToLenseRotation.Dispose();
    HOperatorSet.HomMat3dToPose(hv_HomMat3DRotate, out hv_SensorToLenseRotation);
    hv_ObjectModel3DInitTilted.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_ObjectModel3DInit, hv_SensorToLenseRotation, 
        out hv_ObjectModel3DInitTilted);
    //
    //Move the sensor to a convenient position behind the lens.
    hv_BoundingBox.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DInitTilted, "bounding_box1", 
        out hv_BoundingBox);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PX.Dispose();hv_PY.Dispose();hv_QZ.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3DRotate, 0.0, 0.0, 0.5*hv_CameraSize, 
        out hv_PX, out hv_PY, out hv_QZ);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PoseBack.Dispose();
    HOperatorSet.CreatePose(-hv_PX, -hv_PY, (-(hv_BoundingBox.TupleSelect(5)))-(hv_CylinderLength/2.0), 
        0, 0, 0, "Rp+T", "gba", "point", out hv_PoseBack);
    }
    hv_ObjectModel3DInitTiltedBack.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_ObjectModel3DInitTilted, hv_PoseBack, 
        out hv_ObjectModel3DInitTiltedBack);
    //
    //Move to the position of the camera in world coordinates.
    hv_CamPose.Dispose();
    HOperatorSet.GetCameraSetupParam(hv_CameraSetupModel, hv_CamIndex, "pose", out hv_CamPose);
    hv_OM3DSensor.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_ObjectModel3DInitTiltedBack, hv_CamPose, 
        out hv_OM3DSensor);
    hv_OM3DLense.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_ObjectModel3DLense, hv_CamPose, out hv_OM3DLense);
    hv_OM3DCam.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DCam = new HTuple();
    hv_OM3DCam = hv_OM3DCam.TupleConcat(hv_OM3DSensor, hv_OM3DLense);
    }
    //
    //Clean up.
    HOperatorSet.ClearObjectModel3d(hv_ObjectModel3DInit);
    HOperatorSet.ClearObjectModel3d(hv_ObjectModel3DInitTilted);
    HOperatorSet.ClearObjectModel3d(hv_ObjectModel3DInitTiltedBack);
    HOperatorSet.ClearObjectModel3d(hv_ObjectModel3DLense);

    hv_LensePose.Dispose();
    hv_CylinderLength.Dispose();
    hv_ObjectModel3DLense.Dispose();
    hv_ObjectModel3DInit.Dispose();
    hv_CamParams.Dispose();
    hv_Type.Dispose();
    hv_Tilt.Dispose();
    hv_Rot.Dispose();
    hv_HomMat3DIdentity.Dispose();
    hv_HomMat3DRotate.Dispose();
    hv_SensorToLenseRotation.Dispose();
    hv_ObjectModel3DInitTilted.Dispose();
    hv_BoundingBox.Dispose();
    hv_PX.Dispose();
    hv_PY.Dispose();
    hv_QZ.Dispose();
    hv_PoseBack.Dispose();
    hv_ObjectModel3DInitTiltedBack.Dispose();
    hv_CamPose.Dispose();
    hv_OM3DSensor.Dispose();
    hv_OM3DLense.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate 3D object models which visualize the cameras of a stereo model. 
  public void gen_camera_setup_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraSize, 
      HTuple hv_ConeLength, out HTuple hv_ObjectModel3DCamera, out HTuple hv_ObjectModel3DCone)
  {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_NumCameras = new HTuple(), hv_AutoConeLength = new HTuple();
        HTuple hv_AllCameras = new HTuple(), hv_CurrentCamera = new HTuple();
        HTuple hv_ConcatZ = new HTuple(), hv_OtherCameras = new HTuple();
        HTuple hv_Index = new HTuple(), hv_CamParam0 = new HTuple();
        HTuple hv_Pose0 = new HTuple(), hv_CamParam1 = new HTuple();
        HTuple hv_Pose1 = new HTuple(), hv_PoseInvert = new HTuple();
        HTuple hv_RelPose = new HTuple(), hv_CX0 = new HTuple();
        HTuple hv_CY0 = new HTuple(), hv_CX1 = new HTuple(), hv_CY1 = new HTuple();
        HTuple hv_X = new HTuple(), hv_Y = new HTuple(), hv_Z = new HTuple();
        HTuple hv_Dist = new HTuple(), hv_Exception = new HTuple();
        HTuple hv_CameraType = new HTuple(), hv_ObjectModel3DConeTmp = new HTuple();
        HTuple hv_ObjectModel3DCameraTmp = new HTuple();
        HTuple   hv_CameraSize_COPY_INP_TMP = new HTuple(hv_CameraSize);
        HTuple   hv_ConeLength_COPY_INP_TMP = new HTuple(hv_ConeLength);

        // Initialize local and output iconic variables 
        hv_ObjectModel3DCamera = new HTuple();
        hv_ObjectModel3DCone = new HTuple();
    hv_NumCameras.Dispose();
    HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, "general", "num_cameras", 
        out hv_NumCameras);
    //
    //Consistency check:
    if ((int)(new HTuple(hv_NumCameras.TupleLess(1))) != 0)
    {
      throw new HalconException("No camera set.");
    }
    if ((int)(hv_CameraSize_COPY_INP_TMP.TupleIsNumber()) != 0)
    {
      if ((int)(new HTuple(hv_CameraSize_COPY_INP_TMP.TupleLessEqual(0.0))) != 0)
      {
        throw new HalconException("Invalid value for CameraSize. CameraSize must be positive or 'auto'.");
      }
    }
    else if ((int)(new HTuple(hv_CameraSize_COPY_INP_TMP.TupleNotEqual("auto"))) != 0)
    {
      throw new HalconException("Invalid value for CameraSize. CameraSize must be positive or 'auto'.");
    }
    if ((int)(hv_ConeLength_COPY_INP_TMP.TupleIsNumber()) != 0)
    {
      if ((int)(new HTuple(hv_ConeLength_COPY_INP_TMP.TupleLessEqual(0.0))) != 0)
      {
        throw new HalconException("Invalid value for ConeLength. ConeLength must be positive or 'auto'.");
      }
    }
    else if ((int)(new HTuple(hv_ConeLength_COPY_INP_TMP.TupleNotEqual("auto"))) != 0)
    {
      throw new HalconException("Invalid value for ConeLength. ConeLength must be positive or 'auto'.");
    }
    //
    hv_AutoConeLength.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_AutoConeLength = new HTuple(hv_ConeLength_COPY_INP_TMP.TupleEqual(
        "auto"));
    }
    //
    hv_ObjectModel3DCamera.Dispose();
    hv_ObjectModel3DCamera = new HTuple();
    hv_ObjectModel3DCone.Dispose();
    hv_ObjectModel3DCone = new HTuple();
    hv_AllCameras.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_AllCameras = HTuple.TupleGenSequence(
        0,hv_NumCameras-1,1);
    }
    HTuple end_val26 = hv_NumCameras-1;
    HTuple step_val26 = 1;
    for (hv_CurrentCamera=0; hv_CurrentCamera.Continue(end_val26, step_val26); hv_CurrentCamera = hv_CurrentCamera.TupleAdd(step_val26))
    {
      hv_ConcatZ.Dispose();
      hv_ConcatZ = new HTuple();
      if ((int)(hv_AutoConeLength) != 0)
      {
        if ((int)(new HTuple(hv_NumCameras.TupleLess(2))) != 0)
        {
          throw new HalconException("You need at least two cameras for ConeLength == auto.");
        }
        //Intersect the line of sight of each camera with all other cameras.
        hv_OtherCameras.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OtherCameras = hv_AllCameras.TupleRemove(
            hv_AllCameras.TupleFind(hv_CurrentCamera));
        }
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_OtherCameras.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          hv_CamParam0.Dispose();
          HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_CurrentCamera, 
              "params", out hv_CamParam0);
          hv_Pose0.Dispose();
          HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_CurrentCamera, 
              "pose", out hv_Pose0);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CamParam1.Dispose();
          HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_OtherCameras.TupleSelect(
              hv_Index), "params", out hv_CamParam1);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Pose1.Dispose();
          HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_OtherCameras.TupleSelect(
              hv_Index), "pose", out hv_Pose1);
          }
          //Intersect the lines of sight of the camera pair.
          hv_PoseInvert.Dispose();
          HOperatorSet.PoseInvert(hv_Pose1, out hv_PoseInvert);
          hv_RelPose.Dispose();
          HOperatorSet.PoseCompose(hv_PoseInvert, hv_Pose0, out hv_RelPose);
          hv_CX0.Dispose();
          get_cam_par_data(hv_CamParam0, "cx", out hv_CX0);
          hv_CY0.Dispose();
          get_cam_par_data(hv_CamParam0, "cy", out hv_CY0);
          hv_CX1.Dispose();
          get_cam_par_data(hv_CamParam1, "cx", out hv_CX1);
          hv_CY1.Dispose();
          get_cam_par_data(hv_CamParam1, "cy", out hv_CY1);
          try
          {
            hv_X.Dispose();hv_Y.Dispose();hv_Z.Dispose();hv_Dist.Dispose();
            HOperatorSet.IntersectLinesOfSight(hv_CamParam0, hv_CamParam1, hv_RelPose, 
                hv_CY0, hv_CX0, hv_CY1, hv_CX1, out hv_X, out hv_Y, out hv_Z, out hv_Dist);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            throw new HalconException("Estimating a value for ConeLength automatically was not possible. Please use a number instead.");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ConcatZ = hv_ConcatZ.TupleConcat(
              hv_Z);
          hv_ConcatZ.Dispose();
          hv_ConcatZ = ExpTmpLocalVar_ConcatZ;
          }
          }
        }
        //Use the Z value of the determined coordinates as basis for the ConeLength.
        hv_ConeLength_COPY_INP_TMP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ConeLength_COPY_INP_TMP = (hv_ConcatZ.TupleMax()
            )*1.05;
        }
      }
      //
      //Create cone of sight 3D object models.
      //Distinguish cases with/without projection center.
      hv_CameraType.Dispose();
      HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_CurrentCamera, "type", 
          out hv_CameraType);
      if ((int)(hv_CameraType.TupleRegexpTest("telecentric")) != 0)
      {
        hv_ObjectModel3DConeTmp.Dispose();
        gen_cone_telecentric_object_model_3d(hv_CameraSetupModelID, hv_CurrentCamera, 
            hv_ConeLength_COPY_INP_TMP, out hv_ObjectModel3DConeTmp);
      }
      else
      {
        hv_ObjectModel3DConeTmp.Dispose();
        gen_cone_perspective_object_model_3d(hv_CameraSetupModelID, hv_CurrentCamera, 
            hv_ConeLength_COPY_INP_TMP, out hv_ObjectModel3DConeTmp);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ObjectModel3DCone = hv_ObjectModel3DCone.TupleConcat(
          hv_ObjectModel3DConeTmp);
      hv_ObjectModel3DCone.Dispose();
      hv_ObjectModel3DCone = ExpTmpLocalVar_ObjectModel3DCone;
      }
      }
      //
      //Create camera 3D object models.
      if ((int)(new HTuple(hv_CameraSize_COPY_INP_TMP.TupleEqual("auto"))) != 0)
      {
        //In auto mode, the camera size for all cameras
        //is defined by the first camera's cone length.
        hv_CameraSize_COPY_INP_TMP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CameraSize_COPY_INP_TMP = hv_ConeLength_COPY_INP_TMP*0.1;
        }
      }
      hv_ObjectModel3DCameraTmp.Dispose();
      gen_camera_object_model_3d_reconstruction_3d(hv_CameraSetupModelID, hv_CurrentCamera, 
          hv_CameraSize_COPY_INP_TMP, out hv_ObjectModel3DCameraTmp);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ObjectModel3DCamera = hv_ObjectModel3DCamera.TupleConcat(
          hv_ObjectModel3DCameraTmp);
      hv_ObjectModel3DCamera.Dispose();
      hv_ObjectModel3DCamera = ExpTmpLocalVar_ObjectModel3DCamera;
      }
      }
    }

    hv_CameraSize_COPY_INP_TMP.Dispose();
    hv_ConeLength_COPY_INP_TMP.Dispose();
    hv_NumCameras.Dispose();
    hv_AutoConeLength.Dispose();
    hv_AllCameras.Dispose();
    hv_CurrentCamera.Dispose();
    hv_ConcatZ.Dispose();
    hv_OtherCameras.Dispose();
    hv_Index.Dispose();
    hv_CamParam0.Dispose();
    hv_Pose0.Dispose();
    hv_CamParam1.Dispose();
    hv_Pose1.Dispose();
    hv_PoseInvert.Dispose();
    hv_RelPose.Dispose();
    hv_CX0.Dispose();
    hv_CY0.Dispose();
    hv_CX1.Dispose();
    hv_CY1.Dispose();
    hv_X.Dispose();
    hv_Y.Dispose();
    hv_Z.Dispose();
    hv_Dist.Dispose();
    hv_Exception.Dispose();
    hv_CameraType.Dispose();
    hv_ObjectModel3DConeTmp.Dispose();
    hv_ObjectModel3DCameraTmp.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate a 3D object model representing the view cone of a perspective camera. 
  public void gen_cone_perspective_object_model_3d (HTuple hv_CameraSetupModelID, 
      HTuple hv_CameraIndex, HTuple hv_ConeLength, out HTuple hv_ObjectModel3D)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CamPose = new HTuple(), hv_HomMat3D = new HTuple();
    HTuple hv_CamParam = new HTuple(), hv_PX = new HTuple();
    HTuple hv_PY = new HTuple(), hv_PZ = new HTuple(), hv_QX = new HTuple();
    HTuple hv_QY = new HTuple(), hv_QZ = new HTuple(), hv_QXT = new HTuple();
    HTuple hv_QYT = new HTuple(), hv_QZT = new HTuple(), hv_QX1 = new HTuple();
    HTuple hv_QY1 = new HTuple(), hv_QZ1 = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Faces = new HTuple();

    HTupleVector hvec_Points = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_ObjectModel3D = new HTuple();
    hv_CamPose.Dispose();
    HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "pose", 
        out hv_CamPose);
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_CamPose, out hv_HomMat3D);
    hv_CamParam.Dispose();
    HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "params", 
        out hv_CamParam);
    //
    //Get the lines of sight of the four corner points of the image.
    //Scale them to the given length and transform into world coordinates.
    hvec_Points.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points = dh.Take((
        dh.Add(new HTupleVector(1)).Insert(0,dh.Add(new HTupleVector(new HTuple())))));
    }
    //First corner.
    hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX.Dispose();hv_QY.Dispose();hv_QZ.Dispose();
    HOperatorSet.GetLineOfSight(0, 0, hv_CamParam, out hv_PX, out hv_PY, out hv_PZ, 
        out hv_QX, out hv_QY, out hv_QZ);
    hv_QXT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
    }
    hv_QYT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
    }
    hv_QZT.Dispose();
    hv_QZT = new HTuple(hv_ConeLength);
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[0] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    //Second corner.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX.Dispose();hv_QY.Dispose();hv_QZ.Dispose();
    HOperatorSet.GetLineOfSight((hv_CamParam.TupleSelect((new HTuple(hv_CamParam.TupleLength()
        ))-1))-1, 0, hv_CamParam, out hv_PX, out hv_PY, out hv_PZ, out hv_QX, out hv_QY, 
        out hv_QZ);
    }
    hv_QXT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
    }
    hv_QYT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
    }
    hv_QZT.Dispose();
    hv_QZT = new HTuple(hv_ConeLength);
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[1] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    //Third corner.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX.Dispose();hv_QY.Dispose();hv_QZ.Dispose();
    HOperatorSet.GetLineOfSight((hv_CamParam.TupleSelect((new HTuple(hv_CamParam.TupleLength()
        ))-1))-1, (hv_CamParam.TupleSelect((new HTuple(hv_CamParam.TupleLength()))-2))-1, 
        hv_CamParam, out hv_PX, out hv_PY, out hv_PZ, out hv_QX, out hv_QY, out hv_QZ);
    }
    hv_QXT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
    }
    hv_QYT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
    }
    hv_QZT.Dispose();
    hv_QZT = new HTuple(hv_ConeLength);
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[2] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    //Fourth corner.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX.Dispose();hv_QY.Dispose();hv_QZ.Dispose();
    HOperatorSet.GetLineOfSight(0, (hv_CamParam.TupleSelect((new HTuple(hv_CamParam.TupleLength()
        ))-2))-1, hv_CamParam, out hv_PX, out hv_PY, out hv_PZ, out hv_QX, out hv_QY, 
        out hv_QZ);
    }
    hv_QXT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
    }
    hv_QYT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
    }
    hv_QZT.Dispose();
    hv_QZT = new HTuple(hv_ConeLength);
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[3] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    //
    //Get camera center.
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, 0, 0, 0, out hv_QX1, out hv_QY1, 
        out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[4] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    //
    //Sort the points by coordinate direction.
    hv_PX.Dispose();
    hv_PX = new HTuple();
    hv_PY.Dispose();
    hv_PY = new HTuple();
    hv_PZ.Dispose();
    hv_PZ = new HTuple();
    for (hv_Index=0; (int)hv_Index<=4; hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PX = hv_PX.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(0));
      hv_PX.Dispose();
      hv_PX = ExpTmpLocalVar_PX;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PY = hv_PY.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(1));
      hv_PY.Dispose();
      hv_PY = ExpTmpLocalVar_PY;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PZ = hv_PZ.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(2));
      hv_PZ.Dispose();
      hv_PZ = ExpTmpLocalVar_PZ;
      }
      }
    }
    hv_ObjectModel3D.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(hv_PX, hv_PY, hv_PZ, out hv_ObjectModel3D);
    //
    //Set the sides of the cone.
    hv_Faces.Dispose();
    hv_Faces = new HTuple();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((new HTuple(4)).TupleConcat(0)).TupleConcat(1));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((new HTuple(4)).TupleConcat(1)).TupleConcat(2));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((new HTuple(4)).TupleConcat(2)).TupleConcat(3));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((new HTuple(4)).TupleConcat(3)).TupleConcat(0));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    HOperatorSet.SetObjectModel3dAttribMod(hv_ObjectModel3D, "triangles", new HTuple(), 
        hv_Faces);

    hv_CamPose.Dispose();
    hv_HomMat3D.Dispose();
    hv_CamParam.Dispose();
    hv_PX.Dispose();
    hv_PY.Dispose();
    hv_PZ.Dispose();
    hv_QX.Dispose();
    hv_QY.Dispose();
    hv_QZ.Dispose();
    hv_QXT.Dispose();
    hv_QYT.Dispose();
    hv_QZT.Dispose();
    hv_QX1.Dispose();
    hv_QY1.Dispose();
    hv_QZ1.Dispose();
    hv_Index.Dispose();
    hv_Faces.Dispose();
    hvec_Points.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate a 3D object model representing the view cone of a telecentric camera. 
  public void gen_cone_telecentric_object_model_3d (HTuple hv_CameraSetupModelID, 
      HTuple hv_CameraIndex, HTuple hv_ConeLength, out HTuple hv_ObjectModel3D)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CamPose = new HTuple(), hv_HomMat3D = new HTuple();
    HTuple hv_CamParam = new HTuple(), hv_PX = new HTuple();
    HTuple hv_PY = new HTuple(), hv_PZ = new HTuple(), hv_QX = new HTuple();
    HTuple hv_QY = new HTuple(), hv_QZ = new HTuple(), hv_QX1 = new HTuple();
    HTuple hv_QY1 = new HTuple(), hv_QZ1 = new HTuple(), hv_QZT = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Faces = new HTuple();

    HTupleVector hvec_Points = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_ObjectModel3D = new HTuple();
    hv_CamPose.Dispose();
    HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "pose", 
        out hv_CamPose);
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_CamPose, out hv_HomMat3D);
    hv_CamParam.Dispose();
    HOperatorSet.GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "params", 
        out hv_CamParam);
    //
    //Get the lines of sight of the four corner points of the image.
    //Scale them to the given length and transform into world coordinates.
    hvec_Points.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points = dh.Take((
        dh.Add(new HTupleVector(1)).Insert(0,dh.Add(new HTupleVector(new HTuple())))));
    }
    //First corner.
    hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX.Dispose();hv_QY.Dispose();hv_QZ.Dispose();
    HOperatorSet.GetLineOfSight(0, 0, hv_CamParam, out hv_PX, out hv_PY, out hv_PZ, 
        out hv_QX, out hv_QY, out hv_QZ);
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[0] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    hv_QZT.Dispose();
    hv_QZT = new HTuple(hv_ConeLength);
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[1] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    //Second corner.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX.Dispose();hv_QY.Dispose();hv_QZ.Dispose();
    HOperatorSet.GetLineOfSight((hv_CamParam.TupleSelect((new HTuple(hv_CamParam.TupleLength()
        ))-1))-1, 0, hv_CamParam, out hv_PX, out hv_PY, out hv_PZ, out hv_QX, out hv_QY, 
        out hv_QZ);
    }
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[2] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    hv_QZT.Dispose();
    hv_QZT = new HTuple(hv_ConeLength);
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[3] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    //Third corner.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX.Dispose();hv_QY.Dispose();hv_QZ.Dispose();
    HOperatorSet.GetLineOfSight((hv_CamParam.TupleSelect((new HTuple(hv_CamParam.TupleLength()
        ))-1))-1, (hv_CamParam.TupleSelect((new HTuple(hv_CamParam.TupleLength()))-2))-1, 
        hv_CamParam, out hv_PX, out hv_PY, out hv_PZ, out hv_QX, out hv_QY, out hv_QZ);
    }
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[4] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    hv_QZT.Dispose();
    hv_QZT = new HTuple(hv_ConeLength);
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[5] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    //Fourth corner.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();hv_QX.Dispose();hv_QY.Dispose();hv_QZ.Dispose();
    HOperatorSet.GetLineOfSight(0, (hv_CamParam.TupleSelect((new HTuple(hv_CamParam.TupleLength()
        ))-2))-1, hv_CamParam, out hv_PX, out hv_PY, out hv_PZ, out hv_QX, out hv_QY, 
        out hv_QZ);
    }
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[6] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    hv_QZT.Dispose();
    hv_QZT = new HTuple(hv_ConeLength);
    hv_QX1.Dispose();hv_QY1.Dispose();hv_QZ1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, out hv_QX1, 
        out hv_QY1, out hv_QZ1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[7] = dh.Add(new HTupleVector(((hv_QX1.TupleConcat(
        hv_QY1))).TupleConcat(hv_QZ1)));
    }
    //
    //Sort the points by coordinate direction.
    hv_PX.Dispose();
    hv_PX = new HTuple();
    hv_PY.Dispose();
    hv_PY = new HTuple();
    hv_PZ.Dispose();
    hv_PZ = new HTuple();
    for (hv_Index=0; (int)hv_Index<=7; hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PX = hv_PX.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(0));
      hv_PX.Dispose();
      hv_PX = ExpTmpLocalVar_PX;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PY = hv_PY.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(1));
      hv_PY.Dispose();
      hv_PY = ExpTmpLocalVar_PY;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PZ = hv_PZ.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(2));
      hv_PZ.Dispose();
      hv_PZ = ExpTmpLocalVar_PZ;
      }
      }
    }
    hv_ObjectModel3D.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(hv_PX, hv_PY, hv_PZ, out hv_ObjectModel3D);
    //
    //Set the sides of the cone.
    hv_Faces.Dispose();
    hv_Faces = new HTuple();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(0)).TupleConcat(1)).TupleConcat(3)).TupleConcat(
        2));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(2)).TupleConcat(3)).TupleConcat(5)).TupleConcat(
        4));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(4)).TupleConcat(5)).TupleConcat(7)).TupleConcat(
        6));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(6)).TupleConcat(7)).TupleConcat(1)).TupleConcat(
        0));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    HOperatorSet.SetObjectModel3dAttribMod(hv_ObjectModel3D, "polygons", new HTuple(), 
        hv_Faces);

    hv_CamPose.Dispose();
    hv_HomMat3D.Dispose();
    hv_CamParam.Dispose();
    hv_PX.Dispose();
    hv_PY.Dispose();
    hv_PZ.Dispose();
    hv_QX.Dispose();
    hv_QY.Dispose();
    hv_QZ.Dispose();
    hv_QX1.Dispose();
    hv_QY1.Dispose();
    hv_QZ1.Dispose();
    hv_QZT.Dispose();
    hv_Index.Dispose();
    hv_Faces.Dispose();
    hvec_Points.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Visualize and return the confusion matrix for the given labels.  
  public void gen_confusion_matrix (HTuple hv_GroundTruthLabels, HTuple hv_PredictedClasses, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle, out HTuple hv_ConfusionMatrix)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DisplayMatrix = new HTuple(), hv_ReturnMatrix = new HTuple();
    HTuple hv_DisplayColor = new HTuple(), hv_DisplayColumnWidth = new HTuple();
    HTuple hv_GenParamIndex = new HTuple(), hv_CalculateRelativeMatrix = new HTuple();
    HTuple hv_Classes = new HTuple(), hv_NumClasses = new HTuple();
    HTuple hv_AbsoluteMatrixID = new HTuple(), hv_RelativeMatrixID = new HTuple();
    HTuple hv_ColumnMatrix = new HTuple(), hv_Class = new HTuple();
    HTuple hv_ThisLabel = new HTuple(), hv_NumClassGroundTruth = new HTuple();
    HTuple hv_RowMatrix = new HTuple(), hv_PredictedClass = new HTuple();
    HTuple hv_ThisPredictedClass = new HTuple(), hv_NumMatches = new HTuple();
    HTuple hv_RelativeError = new HTuple(), hv_StringWidths = new HTuple();
    HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
    HTuple hv_MaxStringWidth = new HTuple(), hv_RowStart = new HTuple();
    HTuple hv_RowDistance = new HTuple(), hv_RowEnd = new HTuple();
    HTuple hv_ColumnStart = new HTuple(), hv_ColumnOffset = new HTuple();
    HTuple hv_ColumnEnd = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_WidthLimit = new HTuple();
    HTuple hv_HeightLimit = new HTuple(), hv_TextRow = new HTuple();
    HTuple hv_TextColumn = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Text = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_AbsoluteTransposedMatrixID = new HTuple(), hv_MatrixText = new HTuple();
    HTuple hv_MatrixMaxID = new HTuple(), hv_MaxValue = new HTuple();
    HTuple hv_StringConversion = new HTuple(), hv_RelativeTransposedMatrixID = new HTuple();
    HTuple hv_TextColor = new HTuple(), hv_RelativeValues = new HTuple();
    HTuple hv_Thresholds = new HTuple(), hv_Colors = new HTuple();
    HTuple hv_Greater = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_DiagonalIndex = new HTuple(), hv_Value = new HTuple();
    // Initialize local and output iconic variables 
    hv_ConfusionMatrix = new HTuple();
    //This procedure computes a confusion matrix.
    //Therefore, it compares the classes
    //assigned in GroundTruthLabels and PredictedClasses.
    //The resulting confusion matrix can be
    //visualized, returned, or both.
    //In each case, the output can be changed
    //via generic parameters using GenParamName and GenParamValue.
    //For the visualization, the graphics window
    //must be specified with WindowHandle.
    //
    if ((int)(new HTuple((new HTuple(hv_GroundTruthLabels.TupleLength())).TupleNotEqual(
        new HTuple(hv_PredictedClasses.TupleLength())))) != 0)
    {
      throw new HalconException("Number of ground truth labels and predicted classes must be equal.");
    }
    //
    //Set generic parameter defaults.
    hv_DisplayMatrix.Dispose();
    hv_DisplayMatrix = "absolute";
    hv_ReturnMatrix.Dispose();
    hv_ReturnMatrix = "absolute";
    hv_DisplayColor.Dispose();
    hv_DisplayColor = "true";
    hv_DisplayColumnWidth.Dispose();
    hv_DisplayColumnWidth = "minimal";
    //
    //Parse generic parameters.
    for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
        ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
    {
      if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "display_matrix"))) != 0)
      {
        //Set 'display_matrix'.
        hv_DisplayMatrix.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DisplayMatrix = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "return_matrix"))) != 0)
      {
        //Set 'return_matrix'.
        hv_ReturnMatrix.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ReturnMatrix = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "display_color"))) != 0)
      {
        //Set 'display_color'.
        hv_DisplayColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DisplayColor = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "display_column_width"))) != 0)
      {
        //Set 'display_column_width'.
        hv_DisplayColumnWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DisplayColumnWidth = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else
      {
        throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
            hv_GenParamIndex)))+"'");
      }
    }
    //
    if ((int)((new HTuple((new HTuple(hv_DisplayMatrix.TupleEqual("relative"))).TupleOr(
        new HTuple(hv_ReturnMatrix.TupleEqual("relative"))))).TupleOr(new HTuple(hv_DisplayColor.TupleEqual(
        "true")))) != 0)
    {
      hv_CalculateRelativeMatrix.Dispose();
      hv_CalculateRelativeMatrix = 1;
    }
    else
    {
      hv_CalculateRelativeMatrix.Dispose();
      hv_CalculateRelativeMatrix = 0;
    }
    //
    //Calculate the confusion matrix with absolute values
    //and the confusion matrix with relative errors.
    //We start with an empty matrix
    //and add the number of matching labels.
    hv_Classes.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Classes = ((hv_GroundTruthLabels.TupleSort()
        )).TupleUniq();
    }
    hv_NumClasses.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumClasses = new HTuple(hv_Classes.TupleLength()
        );
    }
    hv_AbsoluteMatrixID.Dispose();
    HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_AbsoluteMatrixID);
    if ((int)(hv_CalculateRelativeMatrix) != 0)
    {
      hv_RelativeMatrixID.Dispose();
      HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_RelativeMatrixID);
    }
    HTuple end_val55 = hv_NumClasses-1;
    HTuple step_val55 = 1;
    for (hv_ColumnMatrix=0; hv_ColumnMatrix.Continue(end_val55, step_val55); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val55))
    {
      hv_Class.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Class = hv_Classes.TupleSelect(
          hv_ColumnMatrix);
      }
      hv_ThisLabel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ThisLabel = hv_GroundTruthLabels.TupleEqualElem(
          hv_Class);
      }
      if ((int)(hv_CalculateRelativeMatrix) != 0)
      {
        //Obtain the number of ground truth labels per class.
        hv_NumClassGroundTruth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumClassGroundTruth = hv_ThisLabel.TupleSum()
            ;
        }
      }
      HTuple end_val62 = hv_NumClasses-1;
      HTuple step_val62 = 1;
      for (hv_RowMatrix=0; hv_RowMatrix.Continue(end_val62, step_val62); hv_RowMatrix = hv_RowMatrix.TupleAdd(step_val62))
      {
        //Select classes for this row/column.
        hv_PredictedClass.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PredictedClass = hv_Classes.TupleSelect(
            hv_RowMatrix);
        }
        //Check whether the input data
        //corresponds to these classes.
        hv_ThisPredictedClass.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ThisPredictedClass = hv_PredictedClasses.TupleEqualElem(
            hv_PredictedClass);
        }
        //Count the number of elements where the predicted class
        //matches the ground truth label.
        hv_NumMatches.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumMatches = ((((hv_ThisLabel+hv_ThisPredictedClass)).TupleEqualElem(
            2))).TupleSum();
        }
        //Set value in matrix.
        HOperatorSet.SetValueMatrix(hv_AbsoluteMatrixID, hv_RowMatrix, hv_ColumnMatrix, 
            hv_NumMatches);
        if ((int)(hv_CalculateRelativeMatrix) != 0)
        {
          if ((int)(new HTuple(hv_NumClassGroundTruth.TupleGreater(0))) != 0)
          {
            hv_RelativeError.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_RelativeError = (hv_NumMatches.TupleReal()
                )/hv_NumClassGroundTruth;
            }
          }
          else
          {
            hv_RelativeError.Dispose();
            hv_RelativeError = 0;
          }
          HOperatorSet.SetValueMatrix(hv_RelativeMatrixID, hv_RowMatrix, hv_ColumnMatrix, 
              hv_RelativeError);
        }
      }
    }
    //
    //Return the result.
    if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("absolute"))) != 0)
    {
      hv_ConfusionMatrix.Dispose();
      HOperatorSet.CopyMatrix(hv_AbsoluteMatrixID, out hv_ConfusionMatrix);
    }
    else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("relative"))) != 0)
    {
      hv_ConfusionMatrix.Dispose();
      HOperatorSet.CopyMatrix(hv_RelativeMatrixID, out hv_ConfusionMatrix);
    }
    else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("none"))) != 0)
    {
      //No matrix is returned.
    }
    else
    {
      throw new HalconException("Unsupported mode for 'return_matrix'");
    }
    //
    //Display the matrix.
    if ((int)(new HTuple(hv_DisplayMatrix.TupleNotEqual("none"))) != 0)
    {
      //
      //Find maximal string width and set display position parameters.
      hv_StringWidths.Dispose();
      hv_StringWidths = new HTuple();
      //Get the string width of each class.
      for (hv_StringIndex=0; (int)hv_StringIndex<=(int)((new HTuple(hv_Classes.TupleLength()
          ))-1); hv_StringIndex = (int)hv_StringIndex + 1)
      {
        hv_String.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_String = hv_Classes.TupleSelect(
            hv_StringIndex);
        }
        hv_Ascent.Dispose();hv_Descent.Dispose();hv_StringWidth.Dispose();hv_StringHeight.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent, 
            out hv_Descent, out hv_StringWidth, out hv_StringHeight);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_StringWidths = hv_StringWidths.TupleConcat(
            hv_StringWidth);
        hv_StringWidths.Dispose();
        hv_StringWidths = ExpTmpLocalVar_StringWidths;
        }
        }
      }
      //The columns should have a minimum width for 4 characters.
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_StringWidth.Dispose();hv_StringHeight.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent, 
          out hv_StringWidth, out hv_StringHeight);
      hv_MaxStringWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxStringWidth = ((hv_StringWidths.TupleMax()
          )).TupleMax2(hv_StringWidth);
      }
      //Get the maximum string width
      //and resize the window accordingly.
      hv_RowStart.Dispose();
      hv_RowStart = 80;
      hv_RowDistance.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RowDistance = hv_StringHeight+10;
      }
      hv_RowEnd.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RowEnd = hv_StringHeight*7;
      }
      hv_ColumnStart.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColumnStart = 50+hv_MaxStringWidth;
      }
      hv_ColumnOffset.Dispose();
      hv_ColumnOffset = 20;
      hv_ColumnEnd.Dispose();
      hv_ColumnEnd = new HTuple(hv_ColumnOffset);
      //
      //Adapt the window size to fit the confusion matrix.
      if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
      {
        //Every column of the confusion matrix is as narrow as possible
        //based to the respective string widths.
        hv_Width.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Width = (((hv_StringWidths.TupleSum()
            )+(hv_ColumnOffset*hv_NumClasses))+hv_ColumnStart)+hv_ColumnEnd;
        }
      }
      else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
      {
        //Every column of the confusion matrix should have the same width.
        //based on the maximum string width.
        hv_Width.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Width = (((hv_MaxStringWidth+hv_ColumnOffset)*hv_NumClasses)+hv_ColumnStart)+hv_ColumnEnd;
        }
      }
      else
      {
        throw new HalconException("");
      }
      hv_Height.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Height = ((hv_RowDistance*hv_NumClasses)+hv_RowStart)+hv_RowEnd;
      }
      HDevWindowStack.SetActive(hv_WindowHandle);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
      }
      //
      //Set reasonable limits for graphics window (adapt if necessary).
      hv_WidthLimit.Dispose();
      hv_WidthLimit = new HTuple();
      hv_WidthLimit[0] = 450;
      hv_WidthLimit[1] = 1920;
      hv_HeightLimit.Dispose();
      hv_HeightLimit = new HTuple();
      hv_HeightLimit[0] = 250;
      hv_HeightLimit[1] = 1080;
      if ((int)((new HTuple(hv_Width.TupleGreater(hv_WidthLimit.TupleSelect(1)))).TupleOr(
          new HTuple(hv_Height.TupleGreater(hv_HeightLimit.TupleSelect(1))))) != 0)
      {
        throw new HalconException("Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.");
      }
      dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
      //
      //Get display coordinates.
      //Get row coordinates for display.
      hv_TextRow.Dispose();
      hv_TextRow = new HTuple();
      HTuple end_val145 = hv_NumClasses-1;
      HTuple step_val145 = 1;
      for (hv_ColumnMatrix=0; hv_ColumnMatrix.Continue(end_val145, step_val145); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val145))
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
            HTuple.TupleGenSequence(0,(hv_NumClasses-1)*hv_RowDistance,hv_RowDistance));
        hv_TextRow.Dispose();
        hv_TextRow = ExpTmpLocalVar_TextRow;
        }
        }
      }
      //Get column coordinates for display.
      hv_TextColumn.Dispose();
      hv_TextColumn = new HTuple();
      HTuple end_val150 = hv_NumClasses-1;
      HTuple step_val150 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val150, step_val150); hv_Index = hv_Index.TupleAdd(step_val150))
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
            HTuple.TupleGenConst(hv_NumClasses,hv_ColumnStart));
        hv_TextColumn.Dispose();
        hv_TextColumn = ExpTmpLocalVar_TextColumn;
        }
        }
        if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ColumnStart = (hv_ColumnStart+(hv_StringWidths.TupleSelect(
              hv_Index)))+hv_ColumnOffset;
          hv_ColumnStart.Dispose();
          hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
          }
          }
        }
        else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ColumnStart = (hv_ColumnStart+hv_MaxStringWidth)+hv_ColumnOffset;
          hv_ColumnStart.Dispose();
          hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
          }
          }
        }
      }
      //Display the confusion matrix with a margin from the top.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TextRow = hv_TextRow+hv_RowStart;
      hv_TextRow.Dispose();
      hv_TextRow = ExpTmpLocalVar_TextRow;
      }
      }
      //Display axis titles.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Ground truth labels", 
            "window", "top", "right", "white", "box", "false");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Predicted classes", "window", 
            "bottom", "left", "white", "box", "false");
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Classes.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        hv_Text.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Text = hv_Classes.TupleSelect(
            hv_Index);
        }
        //Display predicted class names.
        hv_Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row = hv_TextRow.TupleSelect(
            hv_Index);
        }
        hv_Column.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column = ((hv_TextColumn.TupleSelect(
            0))-hv_MaxStringWidth)-hv_ColumnOffset;
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", hv_Row, 
              hv_Column, "light gray", "box", "false");
        }
        //Display ground truth label names.
        hv_Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row = (hv_TextRow.TupleSelect(
            0))-hv_RowDistance;
        }
        hv_Column.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column = hv_TextColumn.TupleSelect(
            hv_Index*hv_NumClasses);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", hv_Row, 
              hv_Column, "light gray", "box", "false");
        }
      }
      //
      //Get the confusion matrix values for display.
      if ((int)(new HTuple(hv_DisplayMatrix.TupleEqual("absolute"))) != 0)
      {
        //Displayed matrix corresponds to the transposed returned matrix.
        hv_AbsoluteTransposedMatrixID.Dispose();
        HOperatorSet.TransposeMatrix(hv_AbsoluteMatrixID, out hv_AbsoluteTransposedMatrixID);
        hv_MatrixText.Dispose();
        HOperatorSet.GetFullMatrix(hv_AbsoluteTransposedMatrixID, out hv_MatrixText);
        HOperatorSet.ClearMatrix(hv_AbsoluteTransposedMatrixID);
        //Align the numbers right.
        hv_MatrixMaxID.Dispose();
        HOperatorSet.MaxMatrix(hv_AbsoluteMatrixID, "full", out hv_MatrixMaxID);
        hv_MaxValue.Dispose();
        HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
        HOperatorSet.ClearMatrix(hv_MatrixMaxID);
        hv_StringConversion.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_StringConversion = (((((hv_MaxValue.TupleLog10()
            )).TupleCeil())).TupleInt())+".0f";
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
            hv_StringConversion);
        hv_MatrixText.Dispose();
        hv_MatrixText = ExpTmpLocalVar_MatrixText;
        }
        }
      }
      else
      {
        //Displayed matrix corresponds to the transposed returned matrix.
        hv_RelativeTransposedMatrixID.Dispose();
        HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
        hv_MatrixText.Dispose();
        HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_MatrixText);
        HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
            ".2f");
        hv_MatrixText.Dispose();
        hv_MatrixText = ExpTmpLocalVar_MatrixText;
        }
        }
      }
      //Set color for displayed confusion matrix.
      if ((int)(new HTuple(hv_DisplayColor.TupleEqual("true"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TextColor.Dispose();
        HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "#666666", 
            out hv_TextColor);
        }
        //Use the relative values to adapt the color of the text.
        hv_RelativeTransposedMatrixID.Dispose();
        HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
        hv_RelativeValues.Dispose();
        HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_RelativeValues);
        HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
        //Set the colors and respective thresholds for the off-diagonal values.
        hv_Thresholds.Dispose();
        hv_Thresholds = new HTuple();
        hv_Thresholds[0] = 0.0;
        hv_Thresholds[1] = 0.05;
        hv_Thresholds[2] = 0.1;
        hv_Thresholds[3] = 0.2;
        hv_Colors.Dispose();
        hv_Colors = new HTuple();
        hv_Colors[0] = "#8C4D4D";
        hv_Colors[1] = "#B33333";
        hv_Colors[2] = "#D91A1A";
        hv_Colors[3] = "#FF0000";
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Thresholds.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Greater.Dispose();
          HOperatorSet.TupleGreaterElem(hv_RelativeValues, hv_Thresholds.TupleSelect(
              hv_Index), out hv_Greater);
          }
          hv_Indices.Dispose();
          HOperatorSet.TupleFind(hv_Greater, 1, out hv_Indices);
          if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.TupleReplace(hv_TextColor, hv_Indices, hv_Colors.TupleSelect(
                hv_Index), out ExpTmpOutVar_0);
            hv_TextColor.Dispose();
            hv_TextColor = ExpTmpOutVar_0;
            }
          }
          else
          {
            break;
          }
        }
        //Set the colors and respective thresholds for the diagonal values.
        hv_Thresholds.Dispose();
        hv_Thresholds = new HTuple();
        hv_Thresholds[0] = -0.01;
        hv_Thresholds[1] = 0.60;
        hv_Thresholds[2] = 0.80;
        hv_Thresholds[3] = 0.90;
        hv_Thresholds[4] = 0.95;
        hv_Thresholds[5] = 0.98;
        hv_Colors.Dispose();
        hv_Colors = new HTuple();
        hv_Colors[0] = "#666666";
        hv_Colors[1] = "#508650";
        hv_Colors[2] = "#419C41";
        hv_Colors[3] = "#2BBD2B";
        hv_Colors[4] = "#15DE15";
        hv_Colors[5] = "#00FF00";
        HTuple end_val216 = hv_NumClasses-1;
        HTuple step_val216 = 1;
        for (hv_DiagonalIndex=0; hv_DiagonalIndex.Continue(end_val216, step_val216); hv_DiagonalIndex = hv_DiagonalIndex.TupleAdd(step_val216))
        {
          hv_Value.Dispose();
          HOperatorSet.GetValueMatrix(hv_RelativeMatrixID, hv_DiagonalIndex, hv_DiagonalIndex, 
              out hv_Value);
          for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Thresholds.TupleLength()
              ))-1); hv_Index = (int)hv_Index + 1)
          {
            if ((int)(new HTuple(hv_Value.TupleGreater(hv_Thresholds.TupleSelect(
                hv_Index)))) != 0)
            {
              if (hv_TextColor == null)
                hv_TextColor = new HTuple();
              hv_TextColor[hv_DiagonalIndex*(hv_NumClasses+1)] = hv_Colors.TupleSelect(
                  hv_Index);
            }
            else
            {
              break;
            }
          }
        }
      }
      else
      {
        //Default value for the text color.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TextColor.Dispose();
        HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "white", 
            out hv_TextColor);
        }
      }
      //
      //Display confusion matrix.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText, "window", 
            hv_TextRow, hv_TextColumn, hv_TextColor, "box", "false");
      }
      //
      //Clean up.
      if ((int)(hv_CalculateRelativeMatrix) != 0)
      {
        HOperatorSet.ClearMatrix(hv_RelativeMatrixID);
      }
      HOperatorSet.ClearMatrix(hv_AbsoluteMatrixID);
    }

    hv_DisplayMatrix.Dispose();
    hv_ReturnMatrix.Dispose();
    hv_DisplayColor.Dispose();
    hv_DisplayColumnWidth.Dispose();
    hv_GenParamIndex.Dispose();
    hv_CalculateRelativeMatrix.Dispose();
    hv_Classes.Dispose();
    hv_NumClasses.Dispose();
    hv_AbsoluteMatrixID.Dispose();
    hv_RelativeMatrixID.Dispose();
    hv_ColumnMatrix.Dispose();
    hv_Class.Dispose();
    hv_ThisLabel.Dispose();
    hv_NumClassGroundTruth.Dispose();
    hv_RowMatrix.Dispose();
    hv_PredictedClass.Dispose();
    hv_ThisPredictedClass.Dispose();
    hv_NumMatches.Dispose();
    hv_RelativeError.Dispose();
    hv_StringWidths.Dispose();
    hv_StringIndex.Dispose();
    hv_String.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_StringWidth.Dispose();
    hv_StringHeight.Dispose();
    hv_MaxStringWidth.Dispose();
    hv_RowStart.Dispose();
    hv_RowDistance.Dispose();
    hv_RowEnd.Dispose();
    hv_ColumnStart.Dispose();
    hv_ColumnOffset.Dispose();
    hv_ColumnEnd.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_WidthLimit.Dispose();
    hv_HeightLimit.Dispose();
    hv_TextRow.Dispose();
    hv_TextColumn.Dispose();
    hv_Index.Dispose();
    hv_Text.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_AbsoluteTransposedMatrixID.Dispose();
    hv_MatrixText.Dispose();
    hv_MatrixMaxID.Dispose();
    hv_MaxValue.Dispose();
    hv_StringConversion.Dispose();
    hv_RelativeTransposedMatrixID.Dispose();
    hv_TextColor.Dispose();
    hv_RelativeValues.Dispose();
    hv_Thresholds.Dispose();
    hv_Colors.Dispose();
    hv_Greater.Dispose();
    hv_Indices.Dispose();
    hv_DiagonalIndex.Dispose();
    hv_Value.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate 3D object models for the camera, robot's tool and plane. 
  public void gen_current_setup_moving_cam_object_model_3d (HTuple hv_CameraSize, 
      HTuple hv_ToolInBasePose, HTuple hv_HandEyeCalibData, HTuple hv_OM3DToolOrigin, 
      HTuple hv_OM3DBase, out HTuple hv_OM3DCamera, out HTuple hv_OM3DTool, out HTuple hv_OM3DPlane)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ToolInCamPose = new HTuple(), hv_CamParam = new HTuple();
    HTuple hv_PlaneInBasePose0 = new HTuple(), hv_BaseInToolPose = new HTuple();
    HTuple hv_PlaneInToolPose = new HTuple(), hv_PlaneInCamPose = new HTuple();
    HTuple hv_CX = new HTuple(), hv_CY = new HTuple(), hv_OptAxisPlaneX = new HTuple();
    HTuple hv_OptAxisPlaneY = new HTuple(), hv_HomMat3D = new HTuple();
    HTuple hv_OptAxisCamX = new HTuple(), hv_OptAxisCamY = new HTuple();
    HTuple hv_OptAxisCamZ = new HTuple(), hv_ConeLength = new HTuple();
    HTuple hv_FactorBorder = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DCamera = new HTuple();
    hv_OM3DTool = new HTuple();
    hv_OM3DPlane = new HTuple();
    //This procedure visualizes the camera, tool, and plane in their
    //current positions.
    //
    hv_ToolInCamPose.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "ToolInCamPose", out hv_ToolInCamPose);
    hv_CamParam.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "CamParam", out hv_CamParam);
    hv_PlaneInBasePose0.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "PlaneInBasePose0", out hv_PlaneInBasePose0);
    //
    if ((int)(new HTuple(hv_CameraSize.TupleLessEqual(0))) != 0)
    {
      throw new HalconException("CameraSize should be > 0");
    }
    //
    //Visualize current camera and tool position.
    //
    //Get the intersection of the optical axis of the camera and the plane
    hv_BaseInToolPose.Dispose();
    HOperatorSet.PoseInvert(hv_ToolInBasePose, out hv_BaseInToolPose);
    hv_PlaneInToolPose.Dispose();
    HOperatorSet.PoseCompose(hv_BaseInToolPose, hv_PlaneInBasePose0, out hv_PlaneInToolPose);
    hv_PlaneInCamPose.Dispose();
    HOperatorSet.PoseCompose(hv_ToolInCamPose, hv_PlaneInToolPose, out hv_PlaneInCamPose);
    hv_CX.Dispose();
    get_cam_par_data(hv_CamParam, "cx", out hv_CX);
    hv_CY.Dispose();
    get_cam_par_data(hv_CamParam, "cy", out hv_CY);
    hv_OptAxisPlaneX.Dispose();hv_OptAxisPlaneY.Dispose();
    HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_PlaneInCamPose, hv_CY, hv_CX, 
        "m", out hv_OptAxisPlaneX, out hv_OptAxisPlaneY);
    //Transform to camera coordinates
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_PlaneInCamPose, out hv_HomMat3D);
    hv_OptAxisCamX.Dispose();hv_OptAxisCamY.Dispose();hv_OptAxisCamZ.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_OptAxisPlaneX, hv_OptAxisPlaneY, 
        0, out hv_OptAxisCamX, out hv_OptAxisCamY, out hv_OptAxisCamZ);
    hv_ConeLength.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ConeLength = hv_OptAxisCamZ*1.1;
    }
    //If the optical axis does not intersect the plane, we still want to visualize the camera.
    if ((int)(new HTuple(hv_ConeLength.TupleLessEqual(0.0))) != 0)
    {
      hv_ConeLength.Dispose();
      hv_ConeLength = new HTuple(hv_CameraSize);
    }
    hv_OM3DCamera.Dispose();hv_OM3DTool.Dispose();
    gen_camera_and_tool_moving_cam_object_model_3d(hv_ToolInCamPose, hv_ToolInBasePose, 
        hv_CameraSize, hv_ConeLength, hv_OM3DToolOrigin, hv_CamParam, out hv_OM3DCamera, 
        out hv_OM3DTool);
    //
    //Create 3D object model of plane.
    hv_FactorBorder.Dispose();
    hv_FactorBorder = 1.5;
    hv_OM3DPlane.Dispose();
    gen_ground_plane_object_model_3d(hv_OM3DTool, hv_OM3DCamera, hv_OM3DBase, hv_FactorBorder, 
        hv_PlaneInBasePose0, out hv_OM3DPlane);

    hv_ToolInCamPose.Dispose();
    hv_CamParam.Dispose();
    hv_PlaneInBasePose0.Dispose();
    hv_BaseInToolPose.Dispose();
    hv_PlaneInToolPose.Dispose();
    hv_PlaneInCamPose.Dispose();
    hv_CX.Dispose();
    hv_CY.Dispose();
    hv_OptAxisPlaneX.Dispose();
    hv_OptAxisPlaneY.Dispose();
    hv_HomMat3D.Dispose();
    hv_OptAxisCamX.Dispose();
    hv_OptAxisCamY.Dispose();
    hv_OptAxisCamZ.Dispose();
    hv_ConeLength.Dispose();
    hv_FactorBorder.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate 3D object models for the camera, the plane, the robot's base and the robot's tool in a stationary camera setup. 
  public void gen_current_setup_stationary_cam_object_model_3d (HTuple hv_ArrowThickness, 
      HTuple hv_ArrowLength, HTuple hv_CameraSize, HTuple hv_HandEyeCalibData, out HTuple hv_OM3DCamera, 
      out HTuple hv_OM3DPlane, out HTuple hv_OM3DBase, out HTuple hv_OM3DToolOrigin)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CamParam = new HTuple(), hv_PlaneInCamPose0 = new HTuple();
    HTuple hv_BaseInCamPose = new HTuple(), hv_CX = new HTuple();
    HTuple hv_CY = new HTuple(), hv_OptAxisPlaneX = new HTuple();
    HTuple hv_OptAxisPlaneY = new HTuple(), hv_HomMat3D = new HTuple();
    HTuple hv_OptAxisCamX = new HTuple(), hv_OptAxisCamY = new HTuple();
    HTuple hv_OptAxisCamZ = new HTuple(), hv_ConeLength = new HTuple();
    HTuple hv_IdentityPose = new HTuple(), hv_CameraSetupModelID = new HTuple();
    HTuple hv_OM3DCameraOrigin = new HTuple(), hv_OM3DConeOrig = new HTuple();
    HTuple hv_CamInBasePose = new HTuple(), hv_FactorBorder = new HTuple();
    HTuple hv_PlaneInBasePose = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DCamera = new HTuple();
    hv_OM3DPlane = new HTuple();
    hv_OM3DBase = new HTuple();
    hv_OM3DToolOrigin = new HTuple();
    //This procedure generates the 3D object models of the camera and its
    //cone, the plane, the robot's base and the robot's tool at its
    //initial position.
    //
    hv_CamParam.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "CamParam", out hv_CamParam);
    hv_PlaneInCamPose0.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "PlaneInCamPose0", out hv_PlaneInCamPose0);
    hv_BaseInCamPose.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "BaseInCamPose", out hv_BaseInCamPose);
    //
    //Visualize base and tool in the origin.
    hv_OM3DToolOrigin.Dispose();hv_OM3DBase.Dispose();
    gen_robot_tool_and_base_object_model_3d(hv_ArrowThickness, hv_ArrowLength, out hv_OM3DToolOrigin, 
        out hv_OM3DBase);
    //Visualize camera.
    hv_CX.Dispose();
    get_cam_par_data(hv_CamParam, "cx", out hv_CX);
    hv_CY.Dispose();
    get_cam_par_data(hv_CamParam, "cy", out hv_CY);
    hv_OptAxisPlaneX.Dispose();hv_OptAxisPlaneY.Dispose();
    HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_PlaneInCamPose0, hv_CY, 
        hv_CX, "m", out hv_OptAxisPlaneX, out hv_OptAxisPlaneY);
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_PlaneInCamPose0, out hv_HomMat3D);
    hv_OptAxisCamX.Dispose();hv_OptAxisCamY.Dispose();hv_OptAxisCamZ.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_OptAxisPlaneX, hv_OptAxisPlaneY, 
        0, out hv_OptAxisCamX, out hv_OptAxisCamY, out hv_OptAxisCamZ);
    hv_ConeLength.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ConeLength = hv_OptAxisCamZ*1.1;
    }
    //If the optical axis does not intersect the plane, we still want to visualize the camera.
    if ((int)(new HTuple(hv_ConeLength.TupleLessEqual(0.0))) != 0)
    {
      hv_ConeLength.Dispose();
      hv_ConeLength = new HTuple(hv_CameraSize);
    }
    hv_IdentityPose.Dispose();
    HOperatorSet.CreatePose(0, 0, 0, 0, 0, 0, "Rp+T", "gba", "point", out hv_IdentityPose);
    hv_CameraSetupModelID.Dispose();
    HOperatorSet.CreateCameraSetupModel(1, out hv_CameraSetupModelID);
    HOperatorSet.SetCameraSetupCamParam(hv_CameraSetupModelID, 0, new HTuple(), hv_CamParam, 
        hv_IdentityPose);
    hv_OM3DCameraOrigin.Dispose();hv_OM3DConeOrig.Dispose();
    gen_camera_setup_object_model_3d(hv_CameraSetupModelID, hv_CameraSize, hv_ConeLength, 
        out hv_OM3DCameraOrigin, out hv_OM3DConeOrig);
    HOperatorSet.ClearCameraSetupModel(hv_CameraSetupModelID);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_OM3DCameraOrigin = hv_OM3DCameraOrigin.TupleConcat(
        hv_OM3DConeOrig);
    hv_OM3DCameraOrigin.Dispose();
    hv_OM3DCameraOrigin = ExpTmpLocalVar_OM3DCameraOrigin;
    }
    }
    hv_CamInBasePose.Dispose();
    HOperatorSet.PoseInvert(hv_BaseInCamPose, out hv_CamInBasePose);
    hv_OM3DCamera.Dispose();
    HOperatorSet.RigidTransObjectModel3d(hv_OM3DCameraOrigin, hv_CamInBasePose, out hv_OM3DCamera);
    HOperatorSet.ClearObjectModel3d(hv_OM3DCameraOrigin);
    //
    //Create 3D object model of plane.
    hv_FactorBorder.Dispose();
    hv_FactorBorder = 1.5;
    hv_PlaneInBasePose.Dispose();
    HOperatorSet.PoseCompose(hv_CamInBasePose, hv_PlaneInCamPose0, out hv_PlaneInBasePose);
    hv_OM3DPlane.Dispose();
    gen_ground_plane_object_model_3d(hv_OM3DToolOrigin, hv_OM3DCamera, hv_OM3DBase, 
        hv_FactorBorder, hv_PlaneInBasePose, out hv_OM3DPlane);

    hv_CamParam.Dispose();
    hv_PlaneInCamPose0.Dispose();
    hv_BaseInCamPose.Dispose();
    hv_CX.Dispose();
    hv_CY.Dispose();
    hv_OptAxisPlaneX.Dispose();
    hv_OptAxisPlaneY.Dispose();
    hv_HomMat3D.Dispose();
    hv_OptAxisCamX.Dispose();
    hv_OptAxisCamY.Dispose();
    hv_OptAxisCamZ.Dispose();
    hv_ConeLength.Dispose();
    hv_IdentityPose.Dispose();
    hv_CameraSetupModelID.Dispose();
    hv_OM3DCameraOrigin.Dispose();
    hv_OM3DConeOrig.Dispose();
    hv_CamInBasePose.Dispose();
    hv_FactorBorder.Dispose();
    hv_PlaneInBasePose.Dispose();

    return;

  }

  // Chapter: Deep Learning / Classification
  // Short Description: Do not use this procedure, use dev_display_dl_classifier_heatmap.  
  public void gen_dl_classifier_heatmap (HObject ho_Image, out HObject ho_HeatmapRegions, 
      HTuple hv_DLClassifierHandle, HTuple hv_GenParamName, HTuple hv_GenParamValue, 
      HTuple hv_WindowHandle)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_HeatmapRegions);
    //The procedure gen_dl_classifier_heatmap has been revised and renamed.
    //From now on the heatmap functionality is available in the procedure
    //dev_display_dl_classifier_heatmap.
    //This procedure now displays a text to guide the user to the correct procedure.
    //
    hv_Text.Dispose();
    hv_Text = new HTuple();
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[new HTuple(hv_Text.TupleLength())] = "ERROR: This procedure (gen_dl_classifier_heatmap) ";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[new HTuple(hv_Text.TupleLength())] = "has been revised and renamed.";
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[new HTuple(hv_Text.TupleLength())] = "Please use the procedure dev_display_dl_classifier_heatmap";
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "center", 
          "center", (new HTuple("red")).TupleConcat("red"), new HTuple(), new HTuple());
    }

    hv_Text.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: The procedure returns DLSample dicts for given sample indices of a DLDataset. 
  public void gen_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple hv_RestrictKeysDLSample, 
      HTuple hv_GenParam, out HTuple hv_DLSampleBatch)
  {



    // Local iconic variables 

    HObject ho_ImageRaw=null, ho_ImageSegmentation=null;

    // Local control variables 

    HTuple hv_ImageDir = new HTuple(), hv_DLSamples = new HTuple();
    HTuple hv_MinIndex = new HTuple(), hv_MaxIndex = new HTuple();
    HTuple hv_IgnoreMissing = new HTuple(), hv_GenParamName = new HTuple();
    HTuple hv_IndexGenParam = new HTuple(), hv_DLSamplesProc = new HTuple();
    HTuple hv_ImageIndex = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_ImageID = new HTuple(), hv_ImageName = new HTuple();
    HTuple hv_FileName = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_BboxExists = new HTuple(), hv_BboxLabels = new HTuple();
    HTuple hv_BboxKeyList = new HTuple(), hv_IndexParam = new HTuple();
    HTuple hv_BboxCoord = new HTuple(), hv_ExceptionBbox = new HTuple();
    HTuple hv_SegKeyExists = new HTuple(), hv_SegmentationDir = new HTuple();
    HTuple hv_SegmentationName = new HTuple(), hv_ExceptionSegmentation = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageRaw);
    HOperatorSet.GenEmptyObj(out ho_ImageSegmentation);
    hv_DLSampleBatch = new HTuple();
    //This procedure creates DLSampleBatch, a tuple of DLSample dictionaries, with
    //the image data for each DLDataset sample, that was selected through SampleIndices.
    //The keys to be transferred can be restricted using RestrictKeysDLSample,
    //which is switched off ('off') by default.
    //The procedure returns all generated DLSample dictionaries in the tuple
    //DLSampleBatch.
    //Setting the GenParam 'ignore_missing_labels' controls whether an error is thrown,
    //if no ground truth annotation information is available for a given image.
    //
    //Get the image directory.
    hv_ImageDir.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "image_dir", out hv_ImageDir);
    //
    //Get the samples from the DLDataset.
    hv_DLSamples.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
    //
    //Check the input values.
    //
    //Check that the given indices are valid.
    hv_MinIndex.Dispose();
    HOperatorSet.TupleMin(hv_SampleIndices, out hv_MinIndex);
    hv_MaxIndex.Dispose();
    HOperatorSet.TupleMax(hv_SampleIndices, out hv_MaxIndex);
    if ((int)((new HTuple(hv_MinIndex.TupleLess(0))).TupleOr(new HTuple(hv_MaxIndex.TupleGreater(
        (new HTuple(hv_DLSamples.TupleLength()))-1)))) != 0)
    {
      throw new HalconException("The given SampleIndices are not within the range of available samples in DLDataset.");
    }
    //
    //Check if the given method is valid.
    if ((int)(new HTuple((new HTuple(hv_RestrictKeysDLSample.TupleLength())).TupleEqual(
        1))) != 0)
    {
      if ((int)(new HTuple((new HTuple((new HTuple(((((new HTuple("detection")).TupleConcat(
          "segmentation")).TupleConcat("image_only")).TupleConcat("off")).TupleFind(
          hv_RestrictKeysDLSample))).TupleMax())).TupleEqual(-1))) != 0)
      {
        throw new HalconException("Unknown RestrictKeysDLSample : "+hv_RestrictKeysDLSample);
      }
    }
    else
    {
      throw new HalconException("RestrictKeysDLSample must be specified by one string.");
    }
    //
    //Generic Parameters.
    //Set default values.
    //For missing labels an error is thrown.
    if ((int)(new HTuple(hv_RestrictKeysDLSample.TupleEqual("off"))) != 0)
    {
      hv_IgnoreMissing.Dispose();
      hv_IgnoreMissing = 1;
    }
    else
    {
      hv_IgnoreMissing.Dispose();
      hv_IgnoreMissing = 0;
    }
    //
    //Transfer generic parameters.
    if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_GenParamName.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamName);
      for (hv_IndexGenParam=0; (int)hv_IndexGenParam<=(int)((new HTuple(hv_GenParamName.TupleLength()
          ))-1); hv_IndexGenParam = (int)hv_IndexGenParam + 1)
      {
        if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_IndexGenParam))).TupleEqual(
            "ignore_missing_labels"))) != 0)
        {
          hv_IgnoreMissing.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "ignore_missing_labels", out hv_IgnoreMissing);
          if ((int)((new HTuple((new HTuple(hv_IgnoreMissing.TupleEqual(1))).TupleOr(
              new HTuple(hv_IgnoreMissing.TupleEqual(0))))).TupleNot()) != 0)
          {
            throw new HalconException("The GenParam ignore_missing_labels must be true or false.");
          }
        }
        else
        {
          throw new HalconException("Unknown GenParam key : "+(hv_GenParamName.TupleSelect(
              hv_IndexGenParam)));
        }
      }
    }

    //
    //Get the samples to be processed
    hv_DLSamplesProc.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DLSamplesProc = hv_DLSamples.TupleSelect(
        hv_SampleIndices);
    }
    //
    //Initialize the tuple for collection the DLSample dictionaries.
    hv_DLSampleBatch.Dispose();
    hv_DLSampleBatch = new HTuple();
    //
    //Loop over all selected samples and create a DLSample dictionary
    //for each dictionary in the DLDataset samples.
    for (hv_ImageIndex=0; (int)hv_ImageIndex<=(int)((new HTuple(hv_SampleIndices.TupleLength()
        ))-1); hv_ImageIndex = (int)hv_ImageIndex + 1)
    {
      //
      //Create the DLSample dictionary
      hv_DLSample.Dispose();
      HOperatorSet.CreateDict(out hv_DLSample);
      //
      //Set the image key.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageID.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), "image_id", 
          out hv_ImageID);
      }
      HOperatorSet.SetDictTuple(hv_DLSample, "image_id", hv_ImageID);
      //
      //Read image.
      //The relative file path of the image is specified in image_name.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageName.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), "image_file_name", 
          out hv_ImageName);
      }
      //
      hv_FileName.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FileName = (hv_ImageDir+"/")+hv_ImageName;
      }
      try
      {
        ho_ImageRaw.Dispose();
        HOperatorSet.ReadImage(out ho_ImageRaw, hv_FileName);
        //Insert image into dictionary.
        HOperatorSet.SetDictObject(ho_ImageRaw, hv_DLSample, "image");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        throw new HalconException((((("Error for reading/setting image "+hv_FileName)+" with ID ")+hv_ImageID)+" : Error code ")+(hv_Exception.TupleSelect(
            0)));
      }
      //
      //Read specific data.
      //
      if ((int)(new HTuple(hv_RestrictKeysDLSample.TupleNotEqual("image_only"))) != 0)
      {
        //
        //Transfer detection relevant data.
        if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("detection")).TupleConcat(
            "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
            -1))) != 0)
        {
          //Check the existence of the required key.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BboxExists.Dispose();
          HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
              "key_exists", "bbox_label_id", out hv_BboxExists);
          }
          if ((int)(hv_BboxExists) != 0)
          {
            //Transfer the bounding box labels.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BboxLabels.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                "bbox_label_id", out hv_BboxLabels);
            }
            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_BboxLabels);
            //Transfer the bounding box coordinates.
            hv_BboxKeyList.Dispose();
            hv_BboxKeyList = new HTuple();
            hv_BboxKeyList[0] = "bbox_col1";
            hv_BboxKeyList[1] = "bbox_row1";
            hv_BboxKeyList[2] = "bbox_col2";
            hv_BboxKeyList[3] = "bbox_row2";
            for (hv_IndexParam=0; (int)hv_IndexParam<=(int)((new HTuple(hv_BboxKeyList.TupleLength()
                ))-1); hv_IndexParam = (int)hv_IndexParam + 1)
            {
              try
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_BboxCoord.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                    hv_BboxKeyList.TupleSelect(hv_IndexParam), out hv_BboxCoord);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_DLSample, hv_BboxKeyList.TupleSelect(
                    hv_IndexParam), hv_BboxCoord);
                }
              }
              // catch (ExceptionBbox) 
              catch (HalconException HDevExpDefaultException1)
              {
                HDevExpDefaultException1.ToHTuple(out hv_ExceptionBbox);
                throw new HalconException((((("For image_id "+hv_ImageID)+new HTuple(", an error has occurred when transferring the key "))+(hv_BboxKeyList.TupleSelect(
                    hv_IndexParam)))+" : Error code ")+(hv_ExceptionBbox.TupleSelect(
                    0)));
              }
            }
          }
          else if ((int)(hv_IgnoreMissing.TupleNot()) != 0)
          {
            throw new HalconException(("For image_id "+hv_ImageID)+" there is no bbox_label_id key. Missing labels can be ignored with the GenParam ignore_missing_labels.");
          }
        }
        //
        //Transfer segmentation relevant data.
        if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("segmentation")).TupleConcat(
            "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
            -1))) != 0)
        {
          //Check the existence of the required keys.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SegKeyExists.Dispose();
          HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
              "key_exists", "segmentation_file_name", out hv_SegKeyExists);
          }
          if ((int)(hv_SegKeyExists) != 0)
          {
            //Get the ground truth segmentation directory.
            hv_SegmentationDir.Dispose();
            HOperatorSet.GetDictTuple(hv_DLDataset, "segmentation_dir", out hv_SegmentationDir);
            //Get the image file name.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_SegmentationName.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                "segmentation_file_name", out hv_SegmentationName);
            }
            //Read the ground truth segmentation image.
            try
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_ImageSegmentation.Dispose();
              HOperatorSet.ReadImage(out ho_ImageSegmentation, (hv_SegmentationDir+"/")+hv_SegmentationName);
              }
            }
            // catch (ExceptionSegmentation) 
            catch (HalconException HDevExpDefaultException1)
            {
              HDevExpDefaultException1.ToHTuple(out hv_ExceptionSegmentation);
              throw new HalconException((("Error for reading segmentation file of image_id "+hv_ImageID)+" : Error code ")+(hv_ExceptionSegmentation.TupleSelect(
                  0)));
            }
            //Insert image into DLSample dictionary.
            HOperatorSet.SetDictObject(ho_ImageSegmentation, hv_DLSample, "segmentation_image");
          }
          else if ((int)(hv_IgnoreMissing.TupleNot()) != 0)
          {
            throw new HalconException(("For image_id "+hv_ImageID)+" there is no segmentation_file_name key. Missing labels can be ignored with the GenParam ignore_missing_labels.");
          }
        }
      }
      //
      //Collect all data dictionaries of all processed indices.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DLSampleBatch = hv_DLSampleBatch.TupleConcat(
          hv_DLSample);
      hv_DLSampleBatch.Dispose();
      hv_DLSampleBatch = ExpTmpLocalVar_DLSampleBatch;
      }
      }
    }
    ho_ImageRaw.Dispose();
    ho_ImageSegmentation.Dispose();

    hv_ImageDir.Dispose();
    hv_DLSamples.Dispose();
    hv_MinIndex.Dispose();
    hv_MaxIndex.Dispose();
    hv_IgnoreMissing.Dispose();
    hv_GenParamName.Dispose();
    hv_IndexGenParam.Dispose();
    hv_DLSamplesProc.Dispose();
    hv_ImageIndex.Dispose();
    hv_DLSample.Dispose();
    hv_ImageID.Dispose();
    hv_ImageName.Dispose();
    hv_FileName.Dispose();
    hv_Exception.Dispose();
    hv_BboxExists.Dispose();
    hv_BboxLabels.Dispose();
    hv_BboxKeyList.Dispose();
    hv_IndexParam.Dispose();
    hv_BboxCoord.Dispose();
    hv_ExceptionBbox.Dispose();
    hv_SegKeyExists.Dispose();
    hv_SegmentationDir.Dispose();
    hv_SegmentationName.Dispose();
    hv_ExceptionSegmentation.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Store the given images in a tuple of dictionaries DLSamples. 
  public void gen_dl_samples_from_images (HObject ho_Images, out HTuple hv_DLSampleBatch)
  {



    // Local iconic variables 

    HObject ho_Image=null;

    // Local control variables 

    HTuple hv_NumImages = new HTuple(), hv_ImageIndex = new HTuple();
    HTuple hv_DLSample = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    hv_DLSampleBatch = new HTuple();
    //
    //This procedure creates DLSampleBatch, a tuple
    //containing a dictionary DLSample
    //for every image given in Images.
    //
    //Initialize output tuple.
    hv_NumImages.Dispose();
    HOperatorSet.CountObj(ho_Images, out hv_NumImages);
    hv_DLSampleBatch.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DLSampleBatch = HTuple.TupleGenConst(
        hv_NumImages,-1);
    }
    //
    //Loop through all given images.
    HTuple end_val10 = hv_NumImages-1;
    HTuple step_val10 = 1;
    for (hv_ImageIndex=0; hv_ImageIndex.Continue(end_val10, step_val10); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val10))
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_Image.Dispose();
      HOperatorSet.SelectObj(ho_Images, out ho_Image, hv_ImageIndex+1);
      }
      //Create DLSample from image.
      hv_DLSample.Dispose();
      HOperatorSet.CreateDict(out hv_DLSample);
      HOperatorSet.SetDictObject(ho_Image, hv_DLSample, "image");
      //
      //Collect the DLSamples.
      if (hv_DLSampleBatch == null)
        hv_DLSampleBatch = new HTuple();
      hv_DLSampleBatch[hv_ImageIndex] = hv_DLSample;
    }
    ho_Image.Dispose();

    hv_NumImages.Dispose();
    hv_ImageIndex.Dispose();
    hv_DLSample.Dispose();

    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Generates weight images for the training dataset. 
  public void gen_dl_segmentation_weight_images (HTuple hv_DLDataset, HTuple hv_DLPreprocessParam, 
      HTuple hv_ClassWeights, HTuple hv_GenParam)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_SegmentationImage=null, ho_WeightImage=null;
    HObject ho_IgnoreRegion=null, ho_IgnoreRegionTmp=null, ho_ClassRegion=null;

    // Local control variables 

    HTuple hv_KeyExists = new HTuple(), hv_ClassIDs = new HTuple();
    HTuple hv_OverwriteFiles = new HTuple(), hv_GenParamKeys = new HTuple();
    HTuple hv_GenParamIndex = new HTuple(), hv_IgnoreClassIDs = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_DLSamples = new HTuple();
    HTuple hv_SampleIndices = new HTuple(), hv_InitNewImage = new HTuple();
    HTuple hv_SampleIndex = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_WeightImageExists = new HTuple(), hv_SampleImageID = new HTuple();
    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_IgnoreIndex = new HTuple(), hv_IgnoreClassID = new HTuple();
    HTuple hv_ClassIndex = new HTuple(), hv_ClassID = new HTuple();
    HTuple hv_Weight = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationImage);
    HOperatorSet.GenEmptyObj(out ho_WeightImage);
    HOperatorSet.GenEmptyObj(out ho_IgnoreRegion);
    HOperatorSet.GenEmptyObj(out ho_IgnoreRegionTmp);
    HOperatorSet.GenEmptyObj(out ho_ClassRegion);
    //
    //This procedure generates for each training sample in DLDataset a weight image,
    //that is used as input to the loss in a segmentation model.
    //The dictionary DLDataset needs a key 'dlsample_dir', assigning a directory
    //in which for every sample a dictionary DLSample has to exist.
    //The procedure reads for each training sample the dictionary DLSample,
    //generates a weight image according to the specified ClassWeights
    //and overwrites the DLSample with the updated sample including the weight image.
    //
    //Check input data.
    hv_KeyExists.Dispose();
    HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", ((new HTuple("dlsample_dir")).TupleConcat(
        "samples")).TupleConcat("class_ids"), out hv_KeyExists);
    if ((int)(((hv_KeyExists.TupleSelect(0))).TupleNot()) != 0)
    {
      throw new HalconException("DLDataset needs a key-value pair for 'dlsample_dir'");
    }
    if ((int)(((hv_KeyExists.TupleSelect(1))).TupleNot()) != 0)
    {
      throw new HalconException("DLDataset needs a key-value pair for 'samples'");
    }
    if ((int)(((hv_KeyExists.TupleSelect(2))).TupleNot()) != 0)
    {
      throw new HalconException("DLDataset needs a key-value pair for 'class_ids'");
    }
    //
    hv_ClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
    if ((int)(new HTuple(hv_ClassWeights.TupleEqual(new HTuple()))) != 0)
    {
      throw new HalconException("ClassWeights is empty");
    }
    else if ((int)((new HTuple((new HTuple(hv_ClassWeights.TupleLength())).TupleNotEqual(
        new HTuple(hv_ClassIDs.TupleLength())))).TupleAnd(new HTuple((new HTuple(hv_ClassWeights.TupleLength()
        )).TupleNotEqual(1)))) != 0)
    {
      throw new HalconException("ClassWeights must be either a single value or of the same length as the DLDataset ClassIDs.");
    }
    //
    if ((int)(new HTuple(((((hv_ClassWeights.TupleLessElem(0))).TupleFind(1))).TupleGreater(
        -1))) != 0)
    {
      throw new HalconException("ClassWeights must be greater or equal zero.");
    }
    else if ((int)((new HTuple((new HTuple(hv_ClassWeights.TupleLength())).TupleEqual(
        1))).TupleAnd(new HTuple(hv_ClassWeights.TupleLessEqual(0)))) != 0)
    {
      throw new HalconException(new HTuple("If only a single weight is given as ClassWeights, this must be greater than zero."));
    }
    //
    //Check the validity of the preprocessing parameters.
    check_dl_preprocess_param(hv_DLPreprocessParam);
    //
    //Set defaults.
    hv_OverwriteFiles.Dispose();
    hv_OverwriteFiles = 0;
    //
    //Overwrite defaults specified in GenParam.
    if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_GenParamKeys.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamKeys);
      for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamKeys.TupleLength()
          ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
      {
        if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "overwrite_files"))) != 0)
        {
          //Set parameter for overwriting files.
          hv_OverwriteFiles.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "overwrite_files", out hv_OverwriteFiles);
          if ((int)((new HTuple(hv_OverwriteFiles.TupleNotEqual(0))).TupleAnd(new HTuple(hv_OverwriteFiles.TupleNotEqual(
              1)))) != 0)
          {
            throw new HalconException("'overwrite_files' must be either true or false");
          }
        }
        else
        {
          throw new HalconException(("Unknown parameter: '"+(hv_GenParamKeys.TupleSelect(
              hv_GenParamIndex)))+"'");
        }
      }
    }
    //
    //Get the IDs of the classes to be ignored.
    try
    {
      hv_IgnoreClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_IgnoreClassIDs.Dispose();
      hv_IgnoreClassIDs = new HTuple();
    }
    //
    //Get the samples from the dataset.
    hv_DLSamples.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
    //
    //Get the indices of the samples belonging to the defined split.
    hv_SampleIndices.Dispose();
    find_dl_samples(hv_DLSamples, "split", "train", "or", out hv_SampleIndices);
    //
    //Get system info on init_new_image.
    hv_InitNewImage.Dispose();
    HOperatorSet.GetSystem("init_new_image", out hv_InitNewImage);
    //
    //Loop over training samples.
    for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_SampleIndices.TupleLength()
        ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
    {
      //
      //Read the DLSample.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLSample.Dispose();
      read_dl_samples(hv_DLDataset, hv_SampleIndices.TupleSelect(hv_SampleIndex), 
          out hv_DLSample);
      }
      //
      //Check if there is already a weight image in the DLSample.
      hv_WeightImageExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "weight_image", out hv_WeightImageExists);
      if ((int)(hv_WeightImageExists.TupleAnd(hv_OverwriteFiles.TupleNot())) != 0)
      {
        hv_SampleImageID.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_SampleImageID);
        throw new HalconException(("The DLSample with image_id "+hv_SampleImageID)+" already contains a weight image. Force overwriting using the parameter 'overwrite_files' to true.");
      }
      //
      //Get the segmentation image.
      ho_SegmentationImage.Dispose();
      HOperatorSet.GetDictObject(out ho_SegmentationImage, hv_DLSample, "segmentation_image");
      //
      //Generate the weight image.
      //
      //Initialize the weight image with 0.
      hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
      HOperatorSet.GetImageSize(ho_SegmentationImage, out hv_ImageWidth, out hv_ImageHeight);
      ho_WeightImage.Dispose();
      HOperatorSet.GenImageConst(out ho_WeightImage, "real", hv_ImageWidth, hv_ImageHeight);
      //Clear image.
      if ((int)(new HTuple(hv_InitNewImage.TupleEqual("false"))) != 0)
      {
        HOperatorSet.OverpaintRegion(ho_WeightImage, ho_WeightImage, 0, "fill");
      }
      //
      if ((int)(new HTuple((new HTuple(hv_ClassWeights.TupleLength())).TupleEqual(
          1))) != 0)
      {
        //Constant class weight.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.OverpaintRegion(ho_WeightImage, ho_WeightImage, hv_ClassWeights.TupleSelect(
            0), "fill");
        }
        //
        if ((int)(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
            0))) != 0)
        {
          //Set ignore region to 0.
          ho_IgnoreRegion.Dispose();
          HOperatorSet.GenEmptyRegion(out ho_IgnoreRegion);
          for (hv_IgnoreIndex=0; (int)hv_IgnoreIndex<=(int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
              ))-1); hv_IgnoreIndex = (int)hv_IgnoreIndex + 1)
          {
            hv_IgnoreClassID.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_IgnoreClassID = hv_IgnoreClassIDs.TupleSelect(
                hv_IgnoreIndex);
            }
            ho_IgnoreRegionTmp.Dispose();
            HOperatorSet.Threshold(ho_SegmentationImage, out ho_IgnoreRegionTmp, 
                hv_IgnoreClassID, hv_IgnoreClassID);
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.Union2(ho_IgnoreRegion, ho_IgnoreRegionTmp, out ExpTmpOutVar_0
                );
            ho_IgnoreRegion.Dispose();
            ho_IgnoreRegion = ExpTmpOutVar_0;
            }
          }
          HOperatorSet.OverpaintRegion(ho_WeightImage, ho_IgnoreRegion, 0.0, "fill");
        }
      }
      else
      {
        //Loop over model ClassIDs.
        for (hv_ClassIndex=0; (int)hv_ClassIndex<=(int)((new HTuple(hv_ClassIDs.TupleLength()
            ))-1); hv_ClassIndex = (int)hv_ClassIndex + 1)
        {
          if ((int)((new HTuple(hv_IgnoreClassIDs.TupleEqual(new HTuple()))).TupleOr(
              new HTuple(((hv_IgnoreClassIDs.TupleFind(hv_ClassIDs.TupleSelect(hv_ClassIndex)))).TupleEqual(
              -1)))) != 0)
          {
            //Set the pixel values of the weight image according to ClassWeights.
            hv_ClassID.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ClassID = hv_ClassIDs.TupleSelect(
                hv_ClassIndex);
            }
            hv_Weight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Weight = hv_ClassWeights.TupleSelect(
                hv_ClassIndex);
            }
            ho_ClassRegion.Dispose();
            HOperatorSet.Threshold(ho_SegmentationImage, out ho_ClassRegion, hv_ClassID, 
                hv_ClassID);
            HOperatorSet.OverpaintRegion(ho_WeightImage, ho_ClassRegion, hv_Weight, 
                "fill");
          }
          else
          {
            //Ignore class has weight 0 which is already set.
          }
        }
      }
      //
      //Add the weight image to DLSample.
      HOperatorSet.SetDictObject(ho_WeightImage, hv_DLSample, "weight_image");
      //
      //Write the updated DLSample.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      write_dl_samples(hv_DLDataset, hv_SampleIndices.TupleSelect(hv_SampleIndex), 
          hv_DLSample, new HTuple(), new HTuple());
      }
    }
    //
    //On success we store the class weights for later reference in the DLDataset.
    HOperatorSet.SetDictTuple(hv_DLDataset, "class_weights", hv_ClassWeights);
    //
    ho_SegmentationImage.Dispose();
    ho_WeightImage.Dispose();
    ho_IgnoreRegion.Dispose();
    ho_IgnoreRegionTmp.Dispose();
    ho_ClassRegion.Dispose();

    hv_KeyExists.Dispose();
    hv_ClassIDs.Dispose();
    hv_OverwriteFiles.Dispose();
    hv_GenParamKeys.Dispose();
    hv_GenParamIndex.Dispose();
    hv_IgnoreClassIDs.Dispose();
    hv_Exception.Dispose();
    hv_DLSamples.Dispose();
    hv_SampleIndices.Dispose();
    hv_InitNewImage.Dispose();
    hv_SampleIndex.Dispose();
    hv_DLSample.Dispose();
    hv_WeightImageExists.Dispose();
    hv_SampleImageID.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_IgnoreIndex.Dispose();
    hv_IgnoreClassID.Dispose();
    hv_ClassIndex.Dispose();
    hv_ClassID.Dispose();
    hv_Weight.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Generate a dummy image and region that are, e.g., used to determine the lengths of the feature vectors in get_feature_lengths. 
  public void gen_dummy_objects (out HObject ho_Region, out HObject ho_Image)
  {


    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_Image);
    //
    //Create dummy objects for the feature calculation
    //(may be used to determine the lengths of the
    //vectors etc.).
    //
    ho_Image.Dispose();
    HOperatorSet.GenImageConst(out ho_Image, "byte", 3, 3);
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.Compose3(ho_Image, ho_Image, ho_Image, out ExpTmpOutVar_0);
    ho_Image.Dispose();
    ho_Image = ExpTmpOutVar_0;
    }
    ho_Region.Dispose();
    HOperatorSet.GetDomain(ho_Image, out ho_Region);


    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate the 3D object model of the plane. 
  public void gen_ground_plane_object_model_3d (HTuple hv_OM3DTool, HTuple hv_OM3DCamera, 
      HTuple hv_OM3DBase, HTuple hv_FactorBorder, HTuple hv_PlaneInBasePose, out HTuple hv_OM3DPlane)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_XBase = new HTuple(), hv_YBase = new HTuple();
    HTuple hv_ZBase = new HTuple(), hv_MinXt = new HTuple();
    HTuple hv_MinYt = new HTuple(), hv_MinZt = new HTuple();
    HTuple hv_MaxXt = new HTuple(), hv_MaxYt = new HTuple();
    HTuple hv_MaxZt = new HTuple(), hv_Min = new HTuple();
    HTuple hv_Max = new HTuple(), hv_MinT = new HTuple(), hv_MaxT = new HTuple();
    HTuple hv_BoundingBox = new HTuple(), hv_PXBB = new HTuple();
    HTuple hv_PYBB = new HTuple(), hv_PZBB = new HTuple();
    HTuple hv_BaseInPlanePose = new HTuple(), hv_HomMat3D = new HTuple();
    HTuple hv_PX = new HTuple(), hv_PY = new HTuple(), hv_PZ = new HTuple();
    HTuple hv_Qx = new HTuple(), hv_Qx1 = new HTuple(), hv_Qy = new HTuple();
    HTuple hv_Qy1 = new HTuple(), hv_XPlane = new HTuple();
    HTuple hv_YPlane = new HTuple(), hv_ZPlane = new HTuple();
    HTuple hv_HomMat3D1 = new HTuple(), hv_Qx2 = new HTuple();
    HTuple hv_Qy2 = new HTuple(), hv_Qz = new HTuple(), hv_Faces = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DPlane = new HTuple();
    //This procedure generates the 3D object model of
    //the plane on which objects are matched and grasped.
    //
    hv_XBase.Dispose();
    hv_XBase = new HTuple();
    hv_YBase.Dispose();
    hv_YBase = new HTuple();
    hv_ZBase.Dispose();
    hv_ZBase = new HTuple();
    //Extent of tool in base coordinates.
    {
    HTuple ExpTmpOutVar_0;HTuple ExpTmpOutVar_1;HTuple ExpTmpOutVar_2;
    get_extent_by_axis(hv_OM3DTool, hv_XBase, hv_YBase, hv_ZBase, out ExpTmpOutVar_0, 
        out ExpTmpOutVar_1, out ExpTmpOutVar_2);
    hv_XBase.Dispose();
    hv_XBase = ExpTmpOutVar_0;
    hv_YBase.Dispose();
    hv_YBase = ExpTmpOutVar_1;
    hv_ZBase.Dispose();
    hv_ZBase = ExpTmpOutVar_2;
    }
    //Extent of camera in base coordinates.
    {
    HTuple ExpTmpOutVar_0;HTuple ExpTmpOutVar_1;HTuple ExpTmpOutVar_2;
    get_extent_by_axis(hv_OM3DCamera, hv_XBase, hv_YBase, hv_ZBase, out ExpTmpOutVar_0, 
        out ExpTmpOutVar_1, out ExpTmpOutVar_2);
    hv_XBase.Dispose();
    hv_XBase = ExpTmpOutVar_0;
    hv_YBase.Dispose();
    hv_YBase = ExpTmpOutVar_1;
    hv_ZBase.Dispose();
    hv_ZBase = ExpTmpOutVar_2;
    }
    //Extent of base in base coordinates.
    {
    HTuple ExpTmpOutVar_0;HTuple ExpTmpOutVar_1;HTuple ExpTmpOutVar_2;
    get_extent_by_axis(hv_OM3DBase, hv_XBase, hv_YBase, hv_ZBase, out ExpTmpOutVar_0, 
        out ExpTmpOutVar_1, out ExpTmpOutVar_2);
    hv_XBase.Dispose();
    hv_XBase = ExpTmpOutVar_0;
    hv_YBase.Dispose();
    hv_YBase = ExpTmpOutVar_1;
    hv_ZBase.Dispose();
    hv_ZBase = ExpTmpOutVar_2;
    }
    //
    //Joint bounding box.
    hv_MinXt.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MinXt = hv_XBase.TupleMin()
        ;
    }
    hv_MinYt.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MinYt = hv_YBase.TupleMin()
        ;
    }
    hv_MinZt.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MinZt = hv_ZBase.TupleMin()
        ;
    }
    hv_MaxXt.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxXt = hv_XBase.TupleMax()
        ;
    }
    hv_MaxYt.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxYt = hv_YBase.TupleMax()
        ;
    }
    hv_MaxZt.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxZt = hv_ZBase.TupleMax()
        ;
    }
    hv_Min.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Min = new HTuple();
    hv_Min = hv_Min.TupleConcat(hv_MinXt, hv_MinYt, hv_MinZt);
    }
    hv_Max.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Max = new HTuple();
    hv_Max = hv_Max.TupleConcat(hv_MaxXt, hv_MaxYt, hv_MaxZt);
    }
    //
    //Joint bounding box extended by a factor of FactorBorder.
    hv_MinT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MinT = ((hv_Max*(1.0-hv_FactorBorder))/2.0)+((hv_Min*(1.0+hv_FactorBorder))/2.0);
    }
    hv_MaxT.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxT = ((hv_Max*(1.0+hv_FactorBorder))/2.0)+((hv_Min*(1.0-hv_FactorBorder))/2.0);
    }
    hv_BoundingBox.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_BoundingBox = new HTuple();
    hv_BoundingBox = hv_BoundingBox.TupleConcat(hv_MinT, hv_MaxT);
    }
    //
    //Get the eight corner points of the bounding box from the min/max representation.
    hv_PXBB.Dispose();hv_PYBB.Dispose();hv_PZBB.Dispose();
    get_bounding_box_points_from_min_max(hv_BoundingBox, out hv_PXBB, out hv_PYBB, 
        out hv_PZBB);

    //Transform to plane coordinates (z is direction of the normal of the plane).
    hv_BaseInPlanePose.Dispose();
    HOperatorSet.PoseInvert(hv_PlaneInBasePose, out hv_BaseInPlanePose);
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_BaseInPlanePose, out hv_HomMat3D);
    hv_PX.Dispose();hv_PY.Dispose();hv_PZ.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_PXBB, hv_PYBB, hv_PZBB, out hv_PX, 
        out hv_PY, out hv_PZ);
    //
    //Get outline of projection onto the plane.
    hv_Qx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Qx = hv_PX.TupleMin()
        ;
    }
    hv_Qx1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Qx1 = hv_PX.TupleMax()
        ;
    }
    hv_Qy.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Qy = hv_PY.TupleMin()
        ;
    }
    hv_Qy1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Qy1 = hv_PY.TupleMax()
        ;
    }
    hv_XPlane.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XPlane = new HTuple();
    hv_XPlane = hv_XPlane.TupleConcat(hv_Qx, hv_Qx, hv_Qx1, hv_Qx1);
    }
    hv_YPlane.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YPlane = new HTuple();
    hv_YPlane = hv_YPlane.TupleConcat(hv_Qy, hv_Qy1, hv_Qy1, hv_Qy);
    }
    hv_ZPlane.Dispose();
    HOperatorSet.TupleGenConst(4, 0, out hv_ZPlane);
    //
    //Transform back to base coordinates.
    hv_HomMat3D1.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_PlaneInBasePose, out hv_HomMat3D1);
    hv_Qx2.Dispose();hv_Qy2.Dispose();hv_Qz.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D1, hv_XPlane, hv_YPlane, hv_ZPlane, 
        out hv_Qx2, out hv_Qy2, out hv_Qz);
    //
    //Generate the visualization.
    hv_OM3DPlane.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(hv_Qx2, hv_Qy2, hv_Qz, out hv_OM3DPlane);
    hv_Faces.Dispose();
    hv_Faces = new HTuple();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Faces = hv_Faces.TupleConcat(
        ((((new HTuple(4)).TupleConcat(0)).TupleConcat(1)).TupleConcat(2)).TupleConcat(
        3));
    hv_Faces.Dispose();
    hv_Faces = ExpTmpLocalVar_Faces;
    }
    }
    HOperatorSet.SetObjectModel3dAttribMod(hv_OM3DPlane, "polygons", new HTuple(), 
        hv_Faces);
    //

    hv_XBase.Dispose();
    hv_YBase.Dispose();
    hv_ZBase.Dispose();
    hv_MinXt.Dispose();
    hv_MinYt.Dispose();
    hv_MinZt.Dispose();
    hv_MaxXt.Dispose();
    hv_MaxYt.Dispose();
    hv_MaxZt.Dispose();
    hv_Min.Dispose();
    hv_Max.Dispose();
    hv_MinT.Dispose();
    hv_MaxT.Dispose();
    hv_BoundingBox.Dispose();
    hv_PXBB.Dispose();
    hv_PYBB.Dispose();
    hv_PZBB.Dispose();
    hv_BaseInPlanePose.Dispose();
    hv_HomMat3D.Dispose();
    hv_PX.Dispose();
    hv_PY.Dispose();
    hv_PZ.Dispose();
    hv_Qx.Dispose();
    hv_Qx1.Dispose();
    hv_Qy.Dispose();
    hv_Qy1.Dispose();
    hv_XPlane.Dispose();
    hv_YPlane.Dispose();
    hv_ZPlane.Dispose();
    hv_HomMat3D1.Dispose();
    hv_Qx2.Dispose();
    hv_Qy2.Dispose();
    hv_Qz.Dispose();
    hv_Faces.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Visualize and return the confusion matrix for the given labels.  
  public void gen_interactive_confusion_matrix (HTuple hv_ImageFiles, HTuple hv_GroundTruthLabels, 
      HTuple hv_PredictedClasses, HTuple hv_GenParamName, HTuple hv_GenParamValue, 
      HTuple hv_WindowHandle, out HTuple hv_ConfusionMatrix)
  {



    // Local iconic variables 

    HObject ho_Images=null;

    // Local control variables 

    HTuple hv_DisplayMatrix = new HTuple(), hv_ReturnMatrix = new HTuple();
    HTuple hv_DisplayColor = new HTuple(), hv_DisplayColumnWidth = new HTuple();
    HTuple hv_GenParamIndex = new HTuple(), hv_CalculateRelativeMatrix = new HTuple();
    HTuple hv_Classes = new HTuple(), hv_NumClasses = new HTuple();
    HTuple hv_AbsoluteMatrixID = new HTuple(), hv_RelativeMatrixID = new HTuple();
    HTuple hv_ColumnMatrix = new HTuple(), hv_Class = new HTuple();
    HTuple hv_ThisLabel = new HTuple(), hv_NumClassGroundTruth = new HTuple();
    HTuple hv_RowMatrix = new HTuple(), hv_PredictedClass = new HTuple();
    HTuple hv_ThisPredictedClass = new HTuple(), hv_NumMatches = new HTuple();
    HTuple hv_RelativeError = new HTuple(), hv_DisplayMatrixAgain = new HTuple();
    HTuple hv_StringWidths = new HTuple(), hv_StringIndex = new HTuple();
    HTuple hv_String = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_StringWidth = new HTuple();
    HTuple hv_StringHeight = new HTuple(), hv_MaxStringWidth = new HTuple();
    HTuple hv_RowStart = new HTuple(), hv_RowDistance = new HTuple();
    HTuple hv_RowEnd = new HTuple(), hv_ColumnStart = new HTuple();
    HTuple hv_ColumnOffset = new HTuple(), hv_ColumnEnd = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    HTuple hv_WidthLimit = new HTuple(), hv_HeightLimit = new HTuple();
    HTuple hv_TextRow = new HTuple(), hv_TextColumn = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Text = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_AbsoluteTransposedMatrixID = new HTuple(), hv_MatrixText = new HTuple();
    HTuple hv_MatrixMaxID = new HTuple(), hv_MaxValue = new HTuple();
    HTuple hv_StringConversion = new HTuple(), hv_RelativeTransposedMatrixID = new HTuple();
    HTuple hv_TextColor = new HTuple(), hv_RelativeValues = new HTuple();
    HTuple hv_Thresholds = new HTuple(), hv_Colors = new HTuple();
    HTuple hv_Greater = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_DiagonalIndex = new HTuple(), hv_Value = new HTuple();
    HTuple hv_ButtonHeight = new HTuple(), hv_ButtonWidth = new HTuple();
    HTuple hv_I = new HTuple(), hv_BoxColor = new HTuple();
    HTuple hv_AbsValues = new HTuple(), hv_FoundIndices = new HTuple();
    HTuple hv_HighlightColor = new HTuple(), hv_TextWidth = new HTuple();
    HTuple hv_TextHeight = new HTuple(), hv_SelectedElement = new HTuple();
    HTuple hv_ClickedGroundTruthLabel = new HTuple(), hv_ClickedPredictedClass = new HTuple();
    HTuple   hv_GenParamName_COPY_INP_TMP = new HTuple(hv_GenParamName);
    HTuple   hv_GenParamValue_COPY_INP_TMP = new HTuple(hv_GenParamValue);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Images);
    hv_ConfusionMatrix = new HTuple();
    //This procedure computes a confusion matrix.
    //Therefore, it compares the classes
    //assigned in GroundTruthLabels and PredictedClasses.
    //The resulting confusion matrix can be
    //visualized, returned, or both.
    //In each case, the output can be changed
    //via generic parameters using GenParamName and GenParamValue.
    //For the visualization, the graphics window
    //must be specified with WindowHandle.
    //
    if ((int)(new HTuple((new HTuple(hv_GroundTruthLabels.TupleLength())).TupleNotEqual(
        new HTuple(hv_PredictedClasses.TupleLength())))) != 0)
    {
      throw new HalconException("Number of ground truth labels and predicted classes must be equal.");
    }
    //
    //Set generic parameter defaults.
    hv_DisplayMatrix.Dispose();
    hv_DisplayMatrix = "absolute";
    hv_ReturnMatrix.Dispose();
    hv_ReturnMatrix = "absolute";
    hv_DisplayColor.Dispose();
    hv_DisplayColor = "true";
    hv_DisplayColumnWidth.Dispose();
    hv_DisplayColumnWidth = "minimal";
    //
    //Parse generic parameters.
    for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName_COPY_INP_TMP.TupleLength()
        ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
    {
      if ((int)(new HTuple(((hv_GenParamName_COPY_INP_TMP.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "display_matrix"))) != 0)
      {
        //Set 'display_matrix'.
        hv_DisplayMatrix.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DisplayMatrix = hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName_COPY_INP_TMP.TupleSelect(
          hv_GenParamIndex))).TupleEqual("return_matrix"))) != 0)
      {
        //Set 'return_matrix'.
        hv_ReturnMatrix.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ReturnMatrix = hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName_COPY_INP_TMP.TupleSelect(
          hv_GenParamIndex))).TupleEqual("display_color"))) != 0)
      {
        //Set 'display_color'.
        hv_DisplayColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DisplayColor = hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName_COPY_INP_TMP.TupleSelect(
          hv_GenParamIndex))).TupleEqual("display_column_width"))) != 0)
      {
        //Set 'display_column_width'.
        hv_DisplayColumnWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DisplayColumnWidth = hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else
      {
        throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName_COPY_INP_TMP.TupleSelect(
            hv_GenParamIndex)))+"'");
      }
    }
    //
    if ((int)((new HTuple((new HTuple(hv_DisplayMatrix.TupleEqual("relative"))).TupleOr(
        new HTuple(hv_ReturnMatrix.TupleEqual("relative"))))).TupleOr(new HTuple(hv_DisplayColor.TupleEqual(
        "true")))) != 0)
    {
      hv_CalculateRelativeMatrix.Dispose();
      hv_CalculateRelativeMatrix = 1;
    }
    else
    {
      hv_CalculateRelativeMatrix.Dispose();
      hv_CalculateRelativeMatrix = 0;
    }
    //
    //Calculate the confusion matrix with absolute values
    //and the confusion matrix with relative errors.
    //We start with an empty matrix
    //and add the number of matching labels.
    hv_Classes.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Classes = ((hv_GroundTruthLabels.TupleSort()
        )).TupleUniq();
    }
    hv_NumClasses.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumClasses = new HTuple(hv_Classes.TupleLength()
        );
    }
    hv_AbsoluteMatrixID.Dispose();
    HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_AbsoluteMatrixID);
    if ((int)(hv_CalculateRelativeMatrix) != 0)
    {
      hv_RelativeMatrixID.Dispose();
      HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_RelativeMatrixID);
    }
    HTuple end_val55 = hv_NumClasses-1;
    HTuple step_val55 = 1;
    for (hv_ColumnMatrix=0; hv_ColumnMatrix.Continue(end_val55, step_val55); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val55))
    {
      hv_Class.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Class = hv_Classes.TupleSelect(
          hv_ColumnMatrix);
      }
      hv_ThisLabel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ThisLabel = hv_GroundTruthLabels.TupleEqualElem(
          hv_Class);
      }
      if ((int)(hv_CalculateRelativeMatrix) != 0)
      {
        //Obtain the number of ground truth labels per class.
        hv_NumClassGroundTruth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumClassGroundTruth = hv_ThisLabel.TupleSum()
            ;
        }
      }
      HTuple end_val62 = hv_NumClasses-1;
      HTuple step_val62 = 1;
      for (hv_RowMatrix=0; hv_RowMatrix.Continue(end_val62, step_val62); hv_RowMatrix = hv_RowMatrix.TupleAdd(step_val62))
      {
        //Select classes for this row/column.
        hv_PredictedClass.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PredictedClass = hv_Classes.TupleSelect(
            hv_RowMatrix);
        }
        //Check whether the input data
        //corresponds to these classes.
        hv_ThisPredictedClass.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ThisPredictedClass = hv_PredictedClasses.TupleEqualElem(
            hv_PredictedClass);
        }
        //Count the number of elements where the predicted class
        //matches the ground truth label.
        hv_NumMatches.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumMatches = ((((hv_ThisLabel+hv_ThisPredictedClass)).TupleEqualElem(
            2))).TupleSum();
        }
        //Set value in matrix.
        HOperatorSet.SetValueMatrix(hv_AbsoluteMatrixID, hv_RowMatrix, hv_ColumnMatrix, 
            hv_NumMatches);
        if ((int)(hv_CalculateRelativeMatrix) != 0)
        {
          if ((int)(new HTuple(hv_NumClassGroundTruth.TupleGreater(0))) != 0)
          {
            hv_RelativeError.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_RelativeError = (hv_NumMatches.TupleReal()
                )/hv_NumClassGroundTruth;
            }
          }
          else
          {
            hv_RelativeError.Dispose();
            hv_RelativeError = 0;
          }
          HOperatorSet.SetValueMatrix(hv_RelativeMatrixID, hv_RowMatrix, hv_ColumnMatrix, 
              hv_RelativeError);
        }
      }
    }
    //
    //Return the result.
    if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("absolute"))) != 0)
    {
      hv_ConfusionMatrix.Dispose();
      HOperatorSet.CopyMatrix(hv_AbsoluteMatrixID, out hv_ConfusionMatrix);
    }
    else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("relative"))) != 0)
    {
      hv_ConfusionMatrix.Dispose();
      HOperatorSet.CopyMatrix(hv_RelativeMatrixID, out hv_ConfusionMatrix);
    }
    else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("none"))) != 0)
    {
      //No matrix is returned.
    }
    else
    {
      throw new HalconException("Unsupported mode for 'return_matrix'");
    }
    //
    //Display the matrix.
    if ((int)(new HTuple(hv_DisplayMatrix.TupleNotEqual("none"))) != 0)
    {
      hv_DisplayMatrixAgain.Dispose();
      hv_DisplayMatrixAgain = 1;
      while ((int)(hv_DisplayMatrixAgain) != 0)
      {
        //
        //Find maximal string width and set display position parameters.
        hv_StringWidths.Dispose();
        hv_StringWidths = new HTuple();
        //Get the string width of each class.
        for (hv_StringIndex=0; (int)hv_StringIndex<=(int)((new HTuple(hv_Classes.TupleLength()
            ))-1); hv_StringIndex = (int)hv_StringIndex + 1)
        {
          hv_String.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_String = hv_Classes.TupleSelect(
              hv_StringIndex);
          }
          hv_Ascent.Dispose();hv_Descent.Dispose();hv_StringWidth.Dispose();hv_StringHeight.Dispose();
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent, 
              out hv_Descent, out hv_StringWidth, out hv_StringHeight);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_StringWidths = hv_StringWidths.TupleConcat(
              hv_StringWidth);
          hv_StringWidths.Dispose();
          hv_StringWidths = ExpTmpLocalVar_StringWidths;
          }
          }
        }
        //The columns should have a minimum width for 4 characters.
        hv_Ascent.Dispose();hv_Descent.Dispose();hv_StringWidth.Dispose();hv_StringHeight.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent, 
            out hv_StringWidth, out hv_StringHeight);
        hv_MaxStringWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxStringWidth = ((hv_StringWidths.TupleMax()
            )).TupleMax2(hv_StringWidth);
        }
        //Get the maximum string width
        //and resize the window accordingly.
        hv_RowStart.Dispose();
        hv_RowStart = 80;
        hv_RowDistance.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RowDistance = hv_StringHeight+10;
        }
        hv_RowEnd.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RowEnd = hv_StringHeight*7;
        }
        hv_ColumnStart.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ColumnStart = 50+hv_MaxStringWidth;
        }
        hv_ColumnOffset.Dispose();
        hv_ColumnOffset = 20;
        hv_ColumnEnd.Dispose();
        hv_ColumnEnd = new HTuple(hv_ColumnOffset);
        //
        //Adapt the window size to fit the confusion matrix.
        if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
        {
          //Every column of the confusion matrix is as narrow as possible
          //based to the respective string widths.
          hv_WindowWidth.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowWidth = (((hv_StringWidths.TupleSum()
              )+(hv_ColumnOffset*hv_NumClasses))+hv_ColumnStart)+hv_ColumnEnd;
          }
        }
        else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
        {
          //Every column of the confusion matrix should have the same width.
          //based on the maximum string width.
          hv_WindowWidth.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowWidth = (((hv_MaxStringWidth+hv_ColumnOffset)*hv_NumClasses)+hv_ColumnStart)+hv_ColumnEnd;
          }
        }
        else
        {
          throw new HalconException("");
        }
        hv_WindowHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowHeight = ((hv_RowDistance*hv_NumClasses)+hv_RowStart)+hv_RowEnd;
        }
        HDevWindowStack.SetActive(hv_WindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        //
        //Set reasonable limits for graphics window (adapt if necessary).
        hv_WidthLimit.Dispose();
        hv_WidthLimit = new HTuple();
        hv_WidthLimit[0] = 450;
        hv_WidthLimit[1] = 1920;
        hv_HeightLimit.Dispose();
        hv_HeightLimit = new HTuple();
        hv_HeightLimit[0] = 250;
        hv_HeightLimit[1] = 1080;
        if ((int)((new HTuple(hv_WindowWidth.TupleGreater(hv_WidthLimit.TupleSelect(
            1)))).TupleOr(new HTuple(hv_WindowHeight.TupleGreater(hv_HeightLimit.TupleSelect(
            1))))) != 0)
        {
          throw new HalconException("Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.");
        }
        dev_resize_window_fit_size(0, 0, hv_WindowWidth, hv_WindowHeight, hv_WidthLimit, 
            hv_HeightLimit);
        //
        //Get display coordinates.
        //Get row coordinates for display.
        hv_TextRow.Dispose();
        hv_TextRow = new HTuple();
        HTuple end_val147 = hv_NumClasses-1;
        HTuple step_val147 = 1;
        for (hv_ColumnMatrix=0; hv_ColumnMatrix.Continue(end_val147, step_val147); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val147))
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
              HTuple.TupleGenSequence(0,(hv_NumClasses-1)*hv_RowDistance,hv_RowDistance));
          hv_TextRow.Dispose();
          hv_TextRow = ExpTmpLocalVar_TextRow;
          }
          }
        }
        //Get column coordinates for display.
        hv_TextColumn.Dispose();
        hv_TextColumn = new HTuple();
        HTuple end_val152 = hv_NumClasses-1;
        HTuple step_val152 = 1;
        for (hv_Index=0; hv_Index.Continue(end_val152, step_val152); hv_Index = hv_Index.TupleAdd(step_val152))
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
              HTuple.TupleGenConst(hv_NumClasses,hv_ColumnStart));
          hv_TextColumn.Dispose();
          hv_TextColumn = ExpTmpLocalVar_TextColumn;
          }
          }
          if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ColumnStart = (hv_ColumnStart+(hv_StringWidths.TupleSelect(
                hv_Index)))+hv_ColumnOffset;
            hv_ColumnStart.Dispose();
            hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
            }
            }
          }
          else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual(
              "equal"))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ColumnStart = (hv_ColumnStart+hv_MaxStringWidth)+hv_ColumnOffset;
            hv_ColumnStart.Dispose();
            hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
            }
            }
          }
        }
        //Display the confusion matrix with a margin from the top.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TextRow = hv_TextRow+hv_RowStart;
        hv_TextRow.Dispose();
        hv_TextRow = ExpTmpLocalVar_TextRow;
        }
        }
        //Display axis titles.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), "Ground truth labels", 
              "window", "top", "right", "white", "box", "false");
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), "Predicted classes", 
              "window", "bottom", "left", "white", "box", "false");
        }
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Classes.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = hv_Classes.TupleSelect(
              hv_Index);
          }
          //Display predicted class names.
          hv_Row.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Row = hv_TextRow.TupleSelect(
              hv_Index);
          }
          hv_Column.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Column = ((hv_TextColumn.TupleSelect(
              0))-hv_MaxStringWidth)-hv_ColumnOffset;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                hv_Row, hv_Column, "light gray", "box", "false");
          }
          //Display ground truth label names.
          hv_Row.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Row = (hv_TextRow.TupleSelect(
              0))-(hv_RowDistance*1.1);
          }
          hv_Column.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Column = hv_TextColumn.TupleSelect(
              hv_Index*hv_NumClasses);
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                hv_Row, hv_Column, "light gray", "box", "false");
          }
        }
        //
        //Get the confusion matrix values for display.
        if ((int)(new HTuple(hv_DisplayMatrix.TupleEqual("absolute"))) != 0)
        {
          //Displayed matrix corresponds to the transposed returned matrix.
          hv_AbsoluteTransposedMatrixID.Dispose();
          HOperatorSet.TransposeMatrix(hv_AbsoluteMatrixID, out hv_AbsoluteTransposedMatrixID);
          hv_MatrixText.Dispose();
          HOperatorSet.GetFullMatrix(hv_AbsoluteTransposedMatrixID, out hv_MatrixText);
          //Align the numbers right.
          hv_MatrixMaxID.Dispose();
          HOperatorSet.MaxMatrix(hv_AbsoluteMatrixID, "full", out hv_MatrixMaxID);
          hv_MaxValue.Dispose();
          HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
          HOperatorSet.ClearMatrix(hv_MatrixMaxID);
          hv_StringConversion.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_StringConversion = (((((hv_MaxValue.TupleLog10()
              )).TupleCeil())).TupleInt())+".0f";
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
              hv_StringConversion);
          hv_MatrixText.Dispose();
          hv_MatrixText = ExpTmpLocalVar_MatrixText;
          }
          }
        }
        else
        {
          //Displayed matrix corresponds to the transposed returned matrix.
          hv_RelativeTransposedMatrixID.Dispose();
          HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
          hv_MatrixText.Dispose();
          HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_MatrixText);
          HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
              ".2f");
          hv_MatrixText.Dispose();
          hv_MatrixText = ExpTmpLocalVar_MatrixText;
          }
          }
        }
        //Set color for displayed confusion matrix.
        if ((int)(new HTuple(hv_DisplayColor.TupleEqual("true"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextColor.Dispose();
          HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "#666666", 
              out hv_TextColor);
          }
          //Use the relative values to adapt the color of the text.
          hv_RelativeTransposedMatrixID.Dispose();
          HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
          hv_RelativeValues.Dispose();
          HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_RelativeValues);
          HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
          //Set the colors and respective thresholds for the off-diagonal values.
          hv_Thresholds.Dispose();
          hv_Thresholds = new HTuple();
          hv_Thresholds[0] = 0.0;
          hv_Thresholds[1] = 0.05;
          hv_Thresholds[2] = 0.1;
          hv_Thresholds[3] = 0.2;
          hv_Colors.Dispose();
          hv_Colors = new HTuple();
          hv_Colors[0] = "#8C4D4D";
          hv_Colors[1] = "#B33333";
          hv_Colors[2] = "#D91A1A";
          hv_Colors[3] = "#FF0000";
          for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Thresholds.TupleLength()
              ))-1); hv_Index = (int)hv_Index + 1)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Greater.Dispose();
            HOperatorSet.TupleGreaterElem(hv_RelativeValues, hv_Thresholds.TupleSelect(
                hv_Index), out hv_Greater);
            }
            hv_Indices.Dispose();
            HOperatorSet.TupleFind(hv_Greater, 1, out hv_Indices);
            if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HTuple ExpTmpOutVar_0;
              HOperatorSet.TupleReplace(hv_TextColor, hv_Indices, hv_Colors.TupleSelect(
                  hv_Index), out ExpTmpOutVar_0);
              hv_TextColor.Dispose();
              hv_TextColor = ExpTmpOutVar_0;
              }
            }
            else
            {
              break;
            }
          }
          //Set the colors and respective thresholds for the diagonal values.
          hv_Thresholds.Dispose();
          hv_Thresholds = new HTuple();
          hv_Thresholds[0] = -0.01;
          hv_Thresholds[1] = 0.60;
          hv_Thresholds[2] = 0.80;
          hv_Thresholds[3] = 0.90;
          hv_Thresholds[4] = 0.95;
          hv_Thresholds[5] = 0.98;
          hv_Colors.Dispose();
          hv_Colors = new HTuple();
          hv_Colors[0] = "#666666";
          hv_Colors[1] = "#508650";
          hv_Colors[2] = "#419C41";
          hv_Colors[3] = "#2BBD2B";
          hv_Colors[4] = "#15DE15";
          hv_Colors[5] = "#00FF00";
          HTuple end_val217 = hv_NumClasses-1;
          HTuple step_val217 = 1;
          for (hv_DiagonalIndex=0; hv_DiagonalIndex.Continue(end_val217, step_val217); hv_DiagonalIndex = hv_DiagonalIndex.TupleAdd(step_val217))
          {
            hv_Value.Dispose();
            HOperatorSet.GetValueMatrix(hv_RelativeMatrixID, hv_DiagonalIndex, hv_DiagonalIndex, 
                out hv_Value);
            for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Thresholds.TupleLength()
                ))-1); hv_Index = (int)hv_Index + 1)
            {
              if ((int)(new HTuple(hv_Value.TupleGreater(hv_Thresholds.TupleSelect(
                  hv_Index)))) != 0)
              {
                if (hv_TextColor == null)
                  hv_TextColor = new HTuple();
                hv_TextColor[hv_DiagonalIndex*(hv_NumClasses+1)] = hv_Colors.TupleSelect(
                    hv_Index);
              }
              else
              {
                break;
              }
            }
          }
        }
        else
        {
          //Default value for the text color.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextColor.Dispose();
          HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "white", 
              out hv_TextColor);
          }
        }
        //
        //Prepare display of buttons.
        hv_ButtonHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ButtonHeight = HTuple.TupleGenConst(
            new HTuple(hv_TextRow.TupleLength()),hv_RowDistance*0.8);
        }
        hv_ButtonWidth.Dispose();
        hv_ButtonWidth = new HTuple();
        HTuple end_val235 = hv_NumClasses-1;
        HTuple step_val235 = 1;
        for (hv_I=0; hv_I.Continue(end_val235, step_val235); hv_I = hv_I.TupleAdd(step_val235))
        {
          if (hv_ButtonWidth == null)
            hv_ButtonWidth = new HTuple();
          hv_ButtonWidth[HTuple.TupleGenSequence(hv_I*hv_NumClasses,((hv_I*hv_NumClasses)+hv_NumClasses)-1,1)] = (hv_StringWidths.TupleSelect(
              hv_I%hv_NumClasses))+hv_ColumnOffset;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ButtonWidth = HTuple.TupleGenConst(
            new HTuple(hv_ButtonWidth.TupleLength()),(hv_ButtonWidth.TupleMin())*0.9);
        hv_ButtonWidth.Dispose();
        hv_ButtonWidth = ExpTmpLocalVar_ButtonWidth;
        }
        }
        hv_BoxColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BoxColor = HTuple.TupleGenConst(
            new HTuple(hv_ButtonWidth.TupleLength()),"#333333");
        }
        //Do not display colored box
        //when no images can be shown.
        hv_AbsoluteTransposedMatrixID.Dispose();
        HOperatorSet.TransposeMatrix(hv_AbsoluteMatrixID, out hv_AbsoluteTransposedMatrixID);
        hv_AbsValues.Dispose();
        HOperatorSet.GetFullMatrix(hv_AbsoluteTransposedMatrixID, out hv_AbsValues);
        hv_FoundIndices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FoundIndices = ((hv_AbsValues.TupleEqualElem(
            0.0))).TupleFind(1);
        }
        if ((int)(new HTuple(hv_FoundIndices.TupleNotEqual(-1))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BoxColor = hv_BoxColor.TupleReplace(
              hv_FoundIndices,"black");
          hv_BoxColor.Dispose();
          hv_BoxColor = ExpTmpLocalVar_BoxColor;
          }
          }
        }
        hv_HighlightColor.Dispose();
        hv_HighlightColor = "#fce9d4";
        //Add continue button.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleConcat(
            "Continue");
        hv_MatrixText.Dispose();
        hv_MatrixText = ExpTmpLocalVar_MatrixText;
        }
        }
        hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandle, "Continue", out hv_Ascent, 
            out hv_Descent, out hv_TextWidth, out hv_TextHeight);
        hv_Row.Dispose();hv_Column.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
        HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, 
            out hv_WindowWidth, out hv_WindowHeight);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
            (hv_WindowHeight-hv_TextHeight)-20);
        hv_TextRow.Dispose();
        hv_TextRow = ExpTmpLocalVar_TextRow;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
            (hv_WindowWidth-hv_TextWidth)-40);
        hv_TextColumn.Dispose();
        hv_TextColumn = ExpTmpLocalVar_TextColumn;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ButtonHeight = hv_ButtonHeight.TupleConcat(
            hv_TextHeight*1.5);
        hv_ButtonHeight.Dispose();
        hv_ButtonHeight = ExpTmpLocalVar_ButtonHeight;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ButtonWidth = hv_ButtonWidth.TupleConcat(
            hv_TextWidth*1.2);
        hv_ButtonWidth.Dispose();
        hv_ButtonWidth = ExpTmpLocalVar_ButtonWidth;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TextColor = hv_TextColor.TupleConcat(
            "black");
        hv_TextColor.Dispose();
        hv_TextColor = ExpTmpLocalVar_TextColor;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BoxColor = hv_BoxColor.TupleConcat(
            "#f28d26");
        hv_BoxColor.Dispose();
        hv_BoxColor = ExpTmpLocalVar_BoxColor;
        }
        }
        //
        //Display confusion matrix.
        hv_SelectedElement.Dispose();
        dev_disp_button(hv_MatrixText, hv_TextRow, hv_TextColumn, hv_ButtonWidth, 
            hv_ButtonHeight, hv_TextColor, hv_BoxColor, hv_HighlightColor, hv_WindowHandle, 
            out hv_SelectedElement);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        //
        if ((int)(new HTuple(hv_SelectedElement.TupleNotEqual((new HTuple(hv_Classes.TupleLength()
            ))*(new HTuple(hv_Classes.TupleLength()))))) != 0)
        {
          //
          //Display images as selected with confusion matrix.
          hv_ClickedGroundTruthLabel.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClickedGroundTruthLabel = hv_Classes.TupleSelect(
              hv_SelectedElement/(new HTuple(hv_Classes.TupleLength())));
          }
          hv_ClickedPredictedClass.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClickedPredictedClass = hv_Classes.TupleSelect(
              hv_SelectedElement%(new HTuple(hv_Classes.TupleLength())));
          }
          //
          //Check if 0 images are to be displayed.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Value.Dispose();
          HOperatorSet.GetValueMatrix(hv_AbsoluteMatrixID, hv_SelectedElement%(new HTuple(hv_Classes.TupleLength()
              )), hv_SelectedElement/(new HTuple(hv_Classes.TupleLength())), out hv_Value);
          }
          if ((int)(new HTuple(hv_Value.TupleNotEqual(0.0))) != 0)
          {
            hv_GenParamName_COPY_INP_TMP.Dispose();
            hv_GenParamName_COPY_INP_TMP = new HTuple();
            hv_GenParamName_COPY_INP_TMP[0] = "global_selection";
            hv_GenParamName_COPY_INP_TMP[1] = "label_selection";
            hv_GenParamName_COPY_INP_TMP[2] = "predicted_class_selection";
            hv_GenParamName_COPY_INP_TMP[3] = "display_buttons";
            hv_GenParamValue_COPY_INP_TMP.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_GenParamValue_COPY_INP_TMP = new HTuple();
            hv_GenParamValue_COPY_INP_TMP[0] = "all";
            hv_GenParamValue_COPY_INP_TMP = hv_GenParamValue_COPY_INP_TMP.TupleConcat(hv_ClickedGroundTruthLabel, hv_ClickedPredictedClass);
            hv_GenParamValue_COPY_INP_TMP = hv_GenParamValue_COPY_INP_TMP.TupleConcat("true");
            }
            ho_Images.Dispose();
            get_dl_classifier_image_results(out ho_Images, hv_ImageFiles, hv_GroundTruthLabels, 
                hv_PredictedClasses, hv_GenParamName_COPY_INP_TMP, hv_GenParamValue_COPY_INP_TMP, 
                hv_WindowHandle);
          }
          else
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "Please select an element where images are available.", 
                  "window", "center", "center", "black", new HTuple(), new HTuple());
            }
            HOperatorSet.WaitSeconds(3);
          }
        }
        else
        {
          //Exit the display loop.
          hv_DisplayMatrixAgain.Dispose();
          hv_DisplayMatrixAgain = 0;
        }
      }
      //
      //Clean up.
      if ((int)(hv_CalculateRelativeMatrix) != 0)
      {
        HOperatorSet.ClearMatrix(hv_RelativeMatrixID);
      }
      HOperatorSet.ClearMatrix(hv_AbsoluteMatrixID);
    }
    ho_Images.Dispose();

    hv_GenParamName_COPY_INP_TMP.Dispose();
    hv_GenParamValue_COPY_INP_TMP.Dispose();
    hv_DisplayMatrix.Dispose();
    hv_ReturnMatrix.Dispose();
    hv_DisplayColor.Dispose();
    hv_DisplayColumnWidth.Dispose();
    hv_GenParamIndex.Dispose();
    hv_CalculateRelativeMatrix.Dispose();
    hv_Classes.Dispose();
    hv_NumClasses.Dispose();
    hv_AbsoluteMatrixID.Dispose();
    hv_RelativeMatrixID.Dispose();
    hv_ColumnMatrix.Dispose();
    hv_Class.Dispose();
    hv_ThisLabel.Dispose();
    hv_NumClassGroundTruth.Dispose();
    hv_RowMatrix.Dispose();
    hv_PredictedClass.Dispose();
    hv_ThisPredictedClass.Dispose();
    hv_NumMatches.Dispose();
    hv_RelativeError.Dispose();
    hv_DisplayMatrixAgain.Dispose();
    hv_StringWidths.Dispose();
    hv_StringIndex.Dispose();
    hv_String.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_StringWidth.Dispose();
    hv_StringHeight.Dispose();
    hv_MaxStringWidth.Dispose();
    hv_RowStart.Dispose();
    hv_RowDistance.Dispose();
    hv_RowEnd.Dispose();
    hv_ColumnStart.Dispose();
    hv_ColumnOffset.Dispose();
    hv_ColumnEnd.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();
    hv_WidthLimit.Dispose();
    hv_HeightLimit.Dispose();
    hv_TextRow.Dispose();
    hv_TextColumn.Dispose();
    hv_Index.Dispose();
    hv_Text.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_AbsoluteTransposedMatrixID.Dispose();
    hv_MatrixText.Dispose();
    hv_MatrixMaxID.Dispose();
    hv_MaxValue.Dispose();
    hv_StringConversion.Dispose();
    hv_RelativeTransposedMatrixID.Dispose();
    hv_TextColor.Dispose();
    hv_RelativeValues.Dispose();
    hv_Thresholds.Dispose();
    hv_Colors.Dispose();
    hv_Greater.Dispose();
    hv_Indices.Dispose();
    hv_DiagonalIndex.Dispose();
    hv_Value.Dispose();
    hv_ButtonHeight.Dispose();
    hv_ButtonWidth.Dispose();
    hv_I.Dispose();
    hv_BoxColor.Dispose();
    hv_AbsValues.Dispose();
    hv_FoundIndices.Dispose();
    hv_HighlightColor.Dispose();
    hv_TextWidth.Dispose();
    hv_TextHeight.Dispose();
    hv_SelectedElement.Dispose();
    hv_ClickedGroundTruthLabel.Dispose();
    hv_ClickedPredictedClass.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate a 3D object of the matched model, in the case of rectification. 
  public void gen_matching_object_model_3d (HTuple hv_ModelID, HTuple hv_ObjectHeight, 
      HTuple hv_Poses, HTuple hv_HandEyeCalibData, HTuple hv_RectificationData, out HTuple hv_OM3DModel)
  {



    // Local iconic variables 

    HObject ho_ModelContours, ho_ObjectSelected=null;

    // Local control variables 

    HTuple hv_CamParam = new HTuple(), hv_MatchingPlaneInCamPose = new HTuple();
    HTuple hv_RectifyImage = new HTuple(), hv_ScaleRectification = new HTuple();
    HTuple hv_Number = new HTuple(), hv_ModelRows = new HTuple();
    HTuple hv_ModelCols = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
    HTuple hv_PX = new HTuple(), hv_PY = new HTuple(), hv_PXPlane = new HTuple();
    HTuple hv_PYPlane = new HTuple(), hv_PXPlaneOrig = new HTuple();
    HTuple hv_PYPlaneOrig = new HTuple(), hv_PZ1 = new HTuple();
    HTuple hv_PZ2 = new HTuple(), hv_PlanePartRectToModelPose = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_Qx = new HTuple();
    HTuple hv_Qy = new HTuple(), hv_Qz = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ModelContours);
    HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
    hv_OM3DModel = new HTuple();
    //This procedure generates a 3D model from a shape model for
    //visualization for a known (rectified) matching plane.
    //
    //The 3D model consists of the model-contours transformed to
    //their real world size. The origin of the 3D model coordinate system
    //lies in the origin of the input shape model with the z-axis
    //pointing towards the camera. The model contours are displayed
    //twice, at z = 0 and z = ObjectHeight.
    //
    hv_CamParam.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "CamParam", out hv_CamParam);
    hv_MatchingPlaneInCamPose.Dispose();
    read_dict_tuple(hv_Poses, "MatchingPlaneInCamPose", out hv_MatchingPlaneInCamPose);
    hv_RectifyImage.Dispose();
    read_dict_tuple(hv_RectificationData, "RectifyImage", out hv_RectifyImage);
    if ((int)((new HTuple((new HTuple(hv_RectifyImage.TupleEqual("true"))).TupleOr(
        new HTuple(hv_RectifyImage.TupleEqual("only_rectify"))))).TupleOr(new HTuple(hv_RectifyImage.TupleEqual(
        "align_and_rectify")))) != 0)
    {
      hv_ScaleRectification.Dispose();
      read_dict_tuple(hv_RectificationData, "ScaleRectification", out hv_ScaleRectification);
    }
    //
    //Get shape model contours.
    ho_ModelContours.Dispose();
    HOperatorSet.GetShapeModelContours(out ho_ModelContours, hv_ModelID, 1);
    hv_Number.Dispose();
    HOperatorSet.CountObj(ho_ModelContours, out hv_Number);
    hv_ModelRows.Dispose();
    hv_ModelRows = new HTuple();
    hv_ModelCols.Dispose();
    hv_ModelCols = new HTuple();
    HTuple end_val21 = hv_Number;
    HTuple step_val21 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val21, step_val21); hv_Index = hv_Index.TupleAdd(step_val21))
    {
      ho_ObjectSelected.Dispose();
      HOperatorSet.SelectObj(ho_ModelContours, out ho_ObjectSelected, hv_Index);
      hv_Row1.Dispose();hv_Col1.Dispose();
      HOperatorSet.GetContourXld(ho_ObjectSelected, out hv_Row1, out hv_Col1);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ModelRows = hv_ModelRows.TupleConcat(
          hv_Row1);
      hv_ModelRows.Dispose();
      hv_ModelRows = ExpTmpLocalVar_ModelRows;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ModelCols = hv_ModelCols.TupleConcat(
          hv_Col1);
      hv_ModelCols.Dispose();
      hv_ModelCols = ExpTmpLocalVar_ModelCols;
      }
      }
    }
    //Obtain real world size (col = x, row = y), centered around the shape model origin (0,0).
    if ((int)((new HTuple((new HTuple(hv_RectifyImage.TupleEqual("true"))).TupleOr(
        new HTuple(hv_RectifyImage.TupleEqual("only_rectify"))))).TupleOr(new HTuple(hv_RectifyImage.TupleEqual(
        "align_and_rectify")))) != 0)
    {
      hv_PX.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PX = hv_ModelCols*hv_ScaleRectification;
      }
      hv_PY.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PY = hv_ModelRows*hv_ScaleRectification;
      }
    }
    else
    {
      hv_PXPlane.Dispose();hv_PYPlane.Dispose();
      HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, 
          hv_ModelRows, hv_ModelCols, "m", out hv_PXPlane, out hv_PYPlane);
      hv_PXPlaneOrig.Dispose();hv_PYPlaneOrig.Dispose();
      HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, 
          0, 0, "m", out hv_PXPlaneOrig, out hv_PYPlaneOrig);
      hv_PX.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PX = hv_PXPlane-hv_PXPlaneOrig;
      }
      hv_PY.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PY = hv_PYPlane-hv_PYPlaneOrig;
      }
    }
    //Display the contours twice, once in the plane, once above.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PZ1.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_PY.TupleLength()), 0, out hv_PZ1);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PZ2.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_PY.TupleLength()), hv_ObjectHeight, 
        out hv_PZ2);
    }
    //Transform from plane to model coordinate system. The plane
    //coordinate system has previously been adapted such that its
    //z-axis points away from the camera.
    hv_PlanePartRectToModelPose.Dispose();
    HOperatorSet.CreatePose(0, 0, hv_ObjectHeight, 180, 0, 0, "Rp+T", "gba", "point", 
        out hv_PlanePartRectToModelPose);
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_PlanePartRectToModelPose, out hv_HomMat3D);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Qx.Dispose();hv_Qy.Dispose();hv_Qz.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_PX.TupleConcat(hv_PX), hv_PY.TupleConcat(
        hv_PY), hv_PZ1.TupleConcat(hv_PZ2), out hv_Qx, out hv_Qy, out hv_Qz);
    }
    hv_OM3DModel.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(hv_Qx, hv_Qy, hv_Qz, out hv_OM3DModel);
    ho_ModelContours.Dispose();
    ho_ObjectSelected.Dispose();

    hv_CamParam.Dispose();
    hv_MatchingPlaneInCamPose.Dispose();
    hv_RectifyImage.Dispose();
    hv_ScaleRectification.Dispose();
    hv_Number.Dispose();
    hv_ModelRows.Dispose();
    hv_ModelCols.Dispose();
    hv_Index.Dispose();
    hv_Row1.Dispose();
    hv_Col1.Dispose();
    hv_PX.Dispose();
    hv_PY.Dispose();
    hv_PXPlane.Dispose();
    hv_PYPlane.Dispose();
    hv_PXPlaneOrig.Dispose();
    hv_PYPlaneOrig.Dispose();
    hv_PZ1.Dispose();
    hv_PZ2.Dispose();
    hv_PlanePartRectToModelPose.Dispose();
    hv_HomMat3D.Dispose();
    hv_Qx.Dispose();
    hv_Qy.Dispose();
    hv_Qz.Dispose();

    return;
  }

  public void gen_menu_regions_ext (out HObject ho_MenuRegions, HTuple hv_TopBottom, 
      HTuple hv_WindowHandleMenu, HTuple hv_PercentageHeight, HTuple hv_NumRows, HTuple hv_NumCols)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Rectangle=null;

    // Local control variables 

    HTuple hv_PartRow1 = new HTuple(), hv_PartCol1 = new HTuple();
    HTuple hv_PartRow2 = new HTuple(), hv_PartCol2 = new HTuple();
    HTuple hv_Height = new HTuple(), hv_Width = new HTuple();
    HTuple hv_MenuHeight = new HTuple(), hv_MenuWidth = new HTuple();
    HTuple hv_ButtonHeight = new HTuple(), hv_ButtonWidth = new HTuple();
    HTuple hv_Row0 = new HTuple(), hv_Col0 = new HTuple();
    HTuple hv_r = new HTuple(), hv_c = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_MenuRegions);
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    if ((int)((new HTuple(hv_TopBottom.TupleNotEqual("top"))).TupleAnd(new HTuple(hv_TopBottom.TupleNotEqual(
        "bottom")))) != 0)
    {
      throw new HalconException("Invalid parameter: TopBottom must be \"top\" or \"bottom\"");
    }

    hv_PartRow1.Dispose();hv_PartCol1.Dispose();hv_PartRow2.Dispose();hv_PartCol2.Dispose();
    HOperatorSet.GetPart(hv_WindowHandleMenu, out hv_PartRow1, out hv_PartCol1, out hv_PartRow2, 
        out hv_PartCol2);
    hv_Height.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Height = (hv_PartRow2-hv_PartRow1)+1;
    }
    hv_Width.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Width = (hv_PartCol2-hv_PartCol1)+1;
    }
    hv_MenuHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MenuHeight = (hv_Height*hv_PercentageHeight)/100.0;
    }
    hv_MenuWidth.Dispose();
    hv_MenuWidth = new HTuple(hv_Width);
    hv_ButtonHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonHeight = hv_MenuHeight/hv_NumRows;
    }
    hv_ButtonWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonWidth = hv_MenuWidth/hv_NumCols;
    }
    if ((int)(new HTuple(hv_TopBottom.TupleEqual("top"))) != 0)
    {
      hv_Row0.Dispose();
      hv_Row0 = new HTuple(hv_PartRow1);
    }
    if ((int)(new HTuple(hv_TopBottom.TupleEqual("bottom"))) != 0)
    {
      hv_Row0.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row0 = hv_PartRow2-hv_MenuHeight;
      }
    }
    hv_Col0.Dispose();
    hv_Col0 = new HTuple(hv_PartCol1);
    HOperatorSet.SetSystem("clip_region", "false");
    ho_MenuRegions.Dispose();
    HOperatorSet.GenEmptyObj(out ho_MenuRegions);
    HTuple end_val20 = hv_NumRows-1;
    HTuple step_val20 = 1;
    for (hv_r=0; hv_r.Continue(end_val20, step_val20); hv_r = hv_r.TupleAdd(step_val20))
    {
      HTuple end_val21 = hv_NumCols-1;
      HTuple step_val21 = 1;
      for (hv_c=0; hv_c.Continue(end_val21, step_val21); hv_c = hv_c.TupleAdd(step_val21))
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Rectangle.Dispose();
        HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row0+(hv_r*hv_ButtonHeight), 
            hv_Col0+(hv_c*hv_ButtonWidth), ((hv_Row0+(hv_r*hv_ButtonHeight))+hv_ButtonHeight)-1, 
            ((hv_Col0+(hv_c*hv_ButtonWidth))+hv_ButtonWidth)-1);
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_MenuRegions, ho_Rectangle, out ExpTmpOutVar_0);
        ho_MenuRegions.Dispose();
        ho_MenuRegions = ExpTmpOutVar_0;
        }
      }
    }
    ho_Rectangle.Dispose();

    hv_PartRow1.Dispose();
    hv_PartCol1.Dispose();
    hv_PartRow2.Dispose();
    hv_PartCol2.Dispose();
    hv_Height.Dispose();
    hv_Width.Dispose();
    hv_MenuHeight.Dispose();
    hv_MenuWidth.Dispose();
    hv_ButtonHeight.Dispose();
    hv_ButtonWidth.Dispose();
    hv_Row0.Dispose();
    hv_Col0.Dispose();
    hv_r.Dispose();
    hv_c.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate base and tool 3D models of the robot. 
  public void gen_robot_tool_and_base_object_model_3d (HTuple hv_ArrowThickness, 
      HTuple hv_ArrowLength, out HTuple hv_OM3DToolOrigin, out HTuple hv_OM3DBase)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_IdentityPose = new HTuple(), hv_TransXPose = new HTuple();
    HTuple hv_OM3DToolXOrigin = new HTuple(), hv_TransYPose = new HTuple();
    HTuple hv_OM3DToolYOrigin = new HTuple(), hv_TransZPose = new HTuple();
    HTuple hv_OM3DToolZOrigin = new HTuple(), hv_FactorVisBase = new HTuple();
    HTuple hv_OM3DBasePlate = new HTuple(), hv_OM3DBaseX = new HTuple();
    HTuple hv_OM3DBaseY = new HTuple(), hv_OM3DBaseZ = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DToolOrigin = new HTuple();
    hv_OM3DBase = new HTuple();
    //This procedure creates 3D models that represent the tool and the base
    //of the robot.
    //
    if ((int)(new HTuple(hv_ArrowThickness.TupleLessEqual(0))) != 0)
    {
      throw new HalconException("ArrowThickness should be > 0");
    }
    if ((int)(new HTuple(hv_ArrowLength.TupleLessEqual(0))) != 0)
    {
      throw new HalconException("ArrowLength should be > 0");
    }
    hv_IdentityPose.Dispose();
    HOperatorSet.CreatePose(0, 0, 0, 0, 0, 0, "Rp+T", "gba", "point", out hv_IdentityPose);
    //
    //3D model for the tool.
    hv_TransXPose.Dispose();
    HOperatorSet.CreatePose(hv_ArrowLength, 0, 0, 0, 0, 0, "Rp+T", "gba", "point", 
        out hv_TransXPose);
    hv_OM3DToolXOrigin.Dispose();
    gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransXPose, 
        out hv_OM3DToolXOrigin);
    hv_TransYPose.Dispose();
    HOperatorSet.CreatePose(0, hv_ArrowLength, 0, 0, 0, 0, "Rp+T", "gba", "point", 
        out hv_TransYPose);
    hv_OM3DToolYOrigin.Dispose();
    gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransYPose, 
        out hv_OM3DToolYOrigin);
    hv_TransZPose.Dispose();
    HOperatorSet.CreatePose(0, 0, hv_ArrowLength, 0, 0, 0, "Rp+T", "gba", "point", 
        out hv_TransZPose);
    hv_OM3DToolZOrigin.Dispose();
    gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransZPose, 
        out hv_OM3DToolZOrigin);
    hv_OM3DToolOrigin.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DToolOrigin = new HTuple();
    hv_OM3DToolOrigin = hv_OM3DToolOrigin.TupleConcat(hv_OM3DToolXOrigin, hv_OM3DToolYOrigin, hv_OM3DToolZOrigin);
    }
    //
    //3D model for the base.
    hv_FactorVisBase.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_FactorVisBase = hv_ArrowThickness*10;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DBasePlate.Dispose();
    HOperatorSet.GenBoxObjectModel3d(hv_IdentityPose, hv_FactorVisBase*1.5, hv_FactorVisBase*1.5, 
        hv_FactorVisBase/12, out hv_OM3DBasePlate);
    }
    hv_TransXPose.Dispose();
    HOperatorSet.CreatePose(hv_ArrowLength, 0, 0, 0, 0, 0, "Rp+T", "gba", "point", 
        out hv_TransXPose);
    hv_OM3DBaseX.Dispose();
    gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransXPose, 
        out hv_OM3DBaseX);
    hv_TransYPose.Dispose();
    HOperatorSet.CreatePose(0, hv_ArrowLength, 0, 0, 0, 0, "Rp+T", "gba", "point", 
        out hv_TransYPose);
    hv_OM3DBaseY.Dispose();
    gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransYPose, 
        out hv_OM3DBaseY);
    hv_TransZPose.Dispose();
    HOperatorSet.CreatePose(0, 0, hv_ArrowLength, 0, 0, 0, "Rp+T", "gba", "point", 
        out hv_TransZPose);
    hv_OM3DBaseZ.Dispose();
    gen_arrow_object_model_3d(hv_ArrowThickness, hv_IdentityPose, hv_TransZPose, 
        out hv_OM3DBaseZ);
    hv_OM3DBase.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DBase = new HTuple();
    hv_OM3DBase = hv_OM3DBase.TupleConcat(hv_OM3DBaseX, hv_OM3DBaseY, hv_OM3DBaseZ, hv_OM3DBasePlate);
    }

    hv_IdentityPose.Dispose();
    hv_TransXPose.Dispose();
    hv_OM3DToolXOrigin.Dispose();
    hv_TransYPose.Dispose();
    hv_OM3DToolYOrigin.Dispose();
    hv_TransZPose.Dispose();
    hv_OM3DToolZOrigin.Dispose();
    hv_FactorVisBase.Dispose();
    hv_OM3DBasePlate.Dispose();
    hv_OM3DBaseX.Dispose();
    hv_OM3DBaseY.Dispose();
    hv_OM3DBaseZ.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  // Short Description: Generate 3D object models which visualize a sheet of light setup. 
  public void gen_sheet_of_light_object_model_3d (HTuple hv_SheetOfLightModelID, 
      HTuple hv_PlaneAndMovementSize, HTuple hv_CameraSize, HTuple hv_ConeLength, 
      out HTuple hv_OM3DLightPlane, out HTuple hv_OM3DMovement, out HTuple hv_OM3DCamera, 
      out HTuple hv_OM3DCone)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CalibrationType = new HTuple(), hv_CamParam = new HTuple();
    HTuple hv_CameraPose = new HTuple(), hv_LPPose = new HTuple();
    HTuple hv_MovementPose = new HTuple(), hv_LightPlanePoseVis = new HTuple();
    HTuple hv_XVis = new HTuple(), hv_YVis = new HTuple();
    HTuple hv_Norm = new HTuple(), hv_ArrowStart = new HTuple();
    HTuple hv_ArrowEnd = new HTuple(), hv_CameraSetupModelID = new HTuple();
    HTuple hv_CameraPoseVis = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DLightPlane = new HTuple();
    hv_OM3DMovement = new HTuple();
    hv_OM3DCamera = new HTuple();
    hv_OM3DCone = new HTuple();
    //
    hv_CalibrationType.Dispose();
    HOperatorSet.GetSheetOfLightParam(hv_SheetOfLightModelID, "calibration", out hv_CalibrationType);
    if ((int)(new HTuple(hv_CalibrationType.TupleNotEqual("xyz"))) != 0)
    {
      throw new HalconException("The 'calibration' of the sheet of light model has to be 'xyz'.");
    }
    //
    if ((int)(new HTuple(hv_PlaneAndMovementSize.TupleLessEqual(0.0))) != 0)
    {
      throw new HalconException("Invalid value for PlaneAndMovementSize. PlaneAndMovementSize must be positive.");
    }
    //
    hv_CamParam.Dispose();
    HOperatorSet.GetSheetOfLightParam(hv_SheetOfLightModelID, "camera_parameter", 
        out hv_CamParam);
    hv_CameraPose.Dispose();
    HOperatorSet.GetSheetOfLightParam(hv_SheetOfLightModelID, "camera_pose", out hv_CameraPose);
    hv_LPPose.Dispose();
    HOperatorSet.GetSheetOfLightParam(hv_SheetOfLightModelID, "lightplane_pose", 
        out hv_LPPose);
    hv_MovementPose.Dispose();
    HOperatorSet.GetSheetOfLightParam(hv_SheetOfLightModelID, "movement_pose", out hv_MovementPose);
    if ((int)((new HTuple((new HTuple((new HTuple(hv_CamParam.TupleEqual(new HTuple()))).TupleOr(
        new HTuple(hv_CameraPose.TupleEqual(new HTuple()))))).TupleOr(new HTuple(hv_LPPose.TupleEqual(
        new HTuple()))))).TupleOr(new HTuple(hv_MovementPose.TupleEqual(new HTuple())))) != 0)
    {
      throw new HalconException("The sheet of light model has to contain all calibration results.");
    }
    //
    //Create object model 3D of light plane.
    hv_LightPlanePoseVis.Dispose();
    HOperatorSet.PoseInvert(hv_LPPose, out hv_LightPlanePoseVis);
    hv_XVis.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XVis = ((
        (new HTuple(-1.0)).TupleConcat(1.0)).TupleConcat(1.0)).TupleConcat(-1.0)*hv_PlaneAndMovementSize;
    }
    hv_YVis.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YVis = ((
        (new HTuple(-1.0)).TupleConcat(-1.0)).TupleConcat(1.0)).TupleConcat(1.0)*hv_PlaneAndMovementSize;
    }
    hv_OM3DLightPlane.Dispose();
    HOperatorSet.GenPlaneObjectModel3d(hv_LightPlanePoseVis, hv_XVis, hv_YVis, out hv_OM3DLightPlane);
    //
    //Create object model 3D of movement.
    hv_Norm.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Norm = (((((hv_MovementPose.TupleSelectRange(
        0,2))*(hv_MovementPose.TupleSelectRange(0,2)))).TupleSum())).TupleSqrt();
    }
    hv_ArrowStart.Dispose();
    hv_ArrowStart = new HTuple();
    hv_ArrowStart[0] = 0.0;
    hv_ArrowStart[1] = 0.0;
    hv_ArrowStart[2] = 0.0;
    hv_ArrowEnd.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ArrowEnd = ((hv_MovementPose.TupleSelectRange(
        0,2))*hv_PlaneAndMovementSize)/hv_Norm;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DMovement.Dispose();
    gen_arrow_object_model_3d(hv_PlaneAndMovementSize/40.0, hv_ArrowStart, hv_ArrowEnd, 
        out hv_OM3DMovement);
    }
    //
    //Create object model 3D of camera.
    hv_CameraSetupModelID.Dispose();
    HOperatorSet.CreateCameraSetupModel(1, out hv_CameraSetupModelID);
    hv_CameraPoseVis.Dispose();
    HOperatorSet.PoseInvert(hv_CameraPose, out hv_CameraPoseVis);
    HOperatorSet.SetCameraSetupCamParam(hv_CameraSetupModelID, 0, new HTuple(), hv_CamParam, 
        hv_CameraPoseVis);
    hv_OM3DCamera.Dispose();hv_OM3DCone.Dispose();
    gen_camera_setup_object_model_3d(hv_CameraSetupModelID, hv_CameraSize, hv_ConeLength, 
        out hv_OM3DCamera, out hv_OM3DCone);
    HOperatorSet.ClearCameraSetupModel(hv_CameraSetupModelID);

    hv_CalibrationType.Dispose();
    hv_CamParam.Dispose();
    hv_CameraPose.Dispose();
    hv_LPPose.Dispose();
    hv_MovementPose.Dispose();
    hv_LightPlanePoseVis.Dispose();
    hv_XVis.Dispose();
    hv_YVis.Dispose();
    hv_Norm.Dispose();
    hv_ArrowStart.Dispose();
    hv_ArrowEnd.Dispose();
    hv_CameraSetupModelID.Dispose();
    hv_CameraPoseVis.Dispose();

    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  public void gen_tiled_segmentation_image (out HObject ho_TiledImageRow, HTuple hv_DLSamples, 
      HTuple hv_SpacingCol, HTuple hv_Width, HTuple hv_Height)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_GTImages, ho_GTImage=null;

    // Local control variables 

    HTuple hv_Crop = new HTuple(), hv_OffsetRow = new HTuple();
    HTuple hv_NumSamples = new HTuple(), hv_Index = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_TiledImageRow);
    HOperatorSet.GenEmptyObj(out ho_GTImages);
    HOperatorSet.GenEmptyObj(out ho_GTImage);
    //
    //This procedure tiles the segmentation images of given samples in a row.
    //
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Crop.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), -1, out hv_Crop);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OffsetRow.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), 0, out hv_OffsetRow);
    }
    hv_NumSamples.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumSamples = new HTuple(hv_DLSamples.TupleLength()
        );
    }
    ho_GTImages.Dispose();
    HOperatorSet.GenEmptyObj(out ho_GTImages);
    HTuple end_val7 = hv_NumSamples-1;
    HTuple step_val7 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val7, step_val7); hv_Index = hv_Index.TupleAdd(step_val7))
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_GTImage.Dispose();
      HOperatorSet.GetDictObject(out ho_GTImage, hv_DLSamples.TupleSelect(hv_Index), 
          "segmentation_image");
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_GTImages, ho_GTImage, out ExpTmpOutVar_0);
      ho_GTImages.Dispose();
      ho_GTImages = ExpTmpOutVar_0;
      }
    }
    //
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_TiledImageRow.Dispose();
    HOperatorSet.TileImagesOffset(ho_GTImages, out ho_TiledImageRow, hv_OffsetRow, 
        (((new HTuple(0)).TupleConcat(((hv_Width+hv_SpacingCol)).TupleCumul()))).TupleSelectRange(
        0,(new HTuple(hv_Width.TupleLength()))-1), hv_Crop, hv_Crop, hv_Crop, hv_Crop, 
        (((((hv_Width+hv_SpacingCol)).TupleCumul())).TupleSelect((new HTuple(hv_Width.TupleLength()
        ))-1))-hv_SpacingCol, hv_Height.TupleMax());
    }
    ho_GTImages.Dispose();
    ho_GTImage.Dispose();

    hv_Crop.Dispose();
    hv_OffsetRow.Dispose();
    hv_NumSamples.Dispose();
    hv_Index.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Creation
  public void gen_tool_to_touching_point_object_model_3d (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePosesTouchingPoint, 
      HTuple hv_RobotTouchingPointInToolCoordinates, out HTuple hv_OM3DToolTouchingPoint)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OM3DToolOrigin = new HTuple(), hv_OM3DToolTouchingPointTmp = new HTuple();
    HTuple hv_Index = new HTuple(), hv_OM3DRigidTrans = new HTuple();
    HTuple hv_OM3DBase = new HTuple();
    // Initialize local and output iconic variables 
    hv_OM3DToolTouchingPoint = new HTuple();
    //
    hv_OM3DToolOrigin.Dispose();hv_OM3DBase.Dispose();
    gen_robot_tool_and_base_object_model_3d(0.0025, 0.05, out hv_OM3DToolOrigin, 
        out hv_OM3DBase);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DToolTouchingPoint.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints((new HTuple(0)).TupleConcat(hv_RobotTouchingPointInToolCoordinates.TupleSelect(
        0)), (new HTuple(0)).TupleConcat(hv_RobotTouchingPointInToolCoordinates.TupleSelect(
        1)), (new HTuple(0)).TupleConcat(hv_RobotTouchingPointInToolCoordinates.TupleSelect(
        2)), out hv_OM3DToolTouchingPoint);
    }
    HOperatorSet.SetObjectModel3dAttribMod(hv_OM3DToolTouchingPoint, "lines", new HTuple(), 
        ((new HTuple(2)).TupleConcat(0)).TupleConcat(1));
    hv_OM3DToolTouchingPointTmp.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DToolTouchingPointTmp = new HTuple();
    hv_OM3DToolTouchingPointTmp = hv_OM3DToolTouchingPointTmp.TupleConcat(hv_OM3DToolOrigin, hv_OM3DToolTouchingPoint);
    }
    //
    hv_OM3DToolTouchingPoint.Dispose();
    hv_OM3DToolTouchingPoint = new HTuple();
    HTuple end_val7 = new HTuple(hvec_ToolInBasePosesTouchingPoint.Length)-1;
    HTuple step_val7 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val7, step_val7); hv_Index = hv_Index.TupleAdd(step_val7))
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_OM3DRigidTrans.Dispose();
      HOperatorSet.RigidTransObjectModel3d(hv_OM3DToolTouchingPointTmp, hvec_ToolInBasePosesTouchingPoint[hv_Index].T, 
          out hv_OM3DRigidTrans);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_OM3DToolTouchingPoint = hv_OM3DToolTouchingPoint.TupleConcat(
          hv_OM3DRigidTrans);
      hv_OM3DToolTouchingPoint.Dispose();
      hv_OM3DToolTouchingPoint = ExpTmpLocalVar_OM3DToolTouchingPoint;
      }
      }
    }

    hv_OM3DToolOrigin.Dispose();
    hv_OM3DToolTouchingPointTmp.Dispose();
    hv_Index.Dispose();
    hv_OM3DRigidTrans.Dispose();
    hv_OM3DBase.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Features
  public void get_bounding_box_points_from_min_max (HTuple hv_BoundingBox, out HTuple hv_PX, 
      out HTuple hv_PY, out HTuple hv_PZ)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Index = new HTuple();

    HTupleVector hvec_Points = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_PX = new HTuple();
    hv_PY = new HTuple();
    hv_PZ = new HTuple();
    hvec_Points.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points = dh.Take((
        dh.Add(new HTupleVector(1)).Insert(0,dh.Add(new HTupleVector(new HTuple())))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[0] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        0))).TupleConcat(hv_BoundingBox.TupleSelect(1)))).TupleConcat(hv_BoundingBox.TupleSelect(
        2))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[1] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        3))).TupleConcat(hv_BoundingBox.TupleSelect(1)))).TupleConcat(hv_BoundingBox.TupleSelect(
        2))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[2] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        3))).TupleConcat(hv_BoundingBox.TupleSelect(4)))).TupleConcat(hv_BoundingBox.TupleSelect(
        2))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[3] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        0))).TupleConcat(hv_BoundingBox.TupleSelect(4)))).TupleConcat(hv_BoundingBox.TupleSelect(
        2))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[4] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        0))).TupleConcat(hv_BoundingBox.TupleSelect(1)))).TupleConcat(hv_BoundingBox.TupleSelect(
        5))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[5] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        3))).TupleConcat(hv_BoundingBox.TupleSelect(1)))).TupleConcat(hv_BoundingBox.TupleSelect(
        5))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[6] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        3))).TupleConcat(hv_BoundingBox.TupleSelect(4)))).TupleConcat(hv_BoundingBox.TupleSelect(
        5))));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_Points[7] = dh.Add(new HTupleVector(((((hv_BoundingBox.TupleSelect(
        0))).TupleConcat(hv_BoundingBox.TupleSelect(4)))).TupleConcat(hv_BoundingBox.TupleSelect(
        5))));
    }
    hv_PX.Dispose();
    hv_PX = new HTuple();
    hv_PY.Dispose();
    hv_PY = new HTuple();
    hv_PZ.Dispose();
    hv_PZ = new HTuple();
    for (hv_Index=0; (int)hv_Index<=7; hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PX = hv_PX.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(0));
      hv_PX.Dispose();
      hv_PX = ExpTmpLocalVar_PX;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PY = hv_PY.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(1));
      hv_PY.Dispose();
      hv_PY = ExpTmpLocalVar_PY;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PZ = hv_PZ.TupleConcat(
          (hvec_Points[hv_Index].T).TupleSelect(2));
      hv_PZ.Dispose();
      hv_PZ = ExpTmpLocalVar_PZ;
      }
      }
    }

    hv_Index.Dispose();
    hvec_Points.Dispose();

    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Get the value of a specified camera parameter from the camera parameter tuple. 
  public void get_cam_par_data (HTuple hv_CameraParam, HTuple hv_ParamName, out HTuple hv_ParamValue)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CameraType = new HTuple(), hv_CameraParamNames = new HTuple();
    HTuple hv_Index = new HTuple(), hv_ParamNameInd = new HTuple();
    HTuple hv_I = new HTuple();
    // Initialize local and output iconic variables 
    hv_ParamValue = new HTuple();
    //get_cam_par_data returns in ParamValue the value of the
    //parameter that is given in ParamName from the tuple of
    //camera parameters that is given in CameraParam.
    //
    //Get the parameter names that correspond to the
    //elements in the input camera parameter tuple.
    hv_CameraType.Dispose();hv_CameraParamNames.Dispose();
    get_cam_par_names(hv_CameraParam, out hv_CameraType, out hv_CameraParamNames);
    //
    //Find the index of the requested camera data and return
    //the corresponding value.
    hv_ParamValue.Dispose();
    hv_ParamValue = new HTuple();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ParamName.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_ParamNameInd.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ParamNameInd = hv_ParamName.TupleSelect(
          hv_Index);
      }
      if ((int)(new HTuple(hv_ParamNameInd.TupleEqual("camera_type"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ParamValue = hv_ParamValue.TupleConcat(
            hv_CameraType);
        hv_ParamValue.Dispose();
        hv_ParamValue = ExpTmpLocalVar_ParamValue;
        }
        }
        continue;
      }
      hv_I.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_I = hv_CameraParamNames.TupleFind(
          hv_ParamNameInd);
      }
      if ((int)(new HTuple(hv_I.TupleNotEqual(-1))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ParamValue = hv_ParamValue.TupleConcat(
            hv_CameraParam.TupleSelect(hv_I));
        hv_ParamValue.Dispose();
        hv_ParamValue = ExpTmpLocalVar_ParamValue;
        }
        }
      }
      else
      {
        throw new HalconException("Unknown camera parameter "+hv_ParamNameInd);
      }
    }

    hv_CameraType.Dispose();
    hv_CameraParamNames.Dispose();
    hv_Index.Dispose();
    hv_ParamNameInd.Dispose();
    hv_I.Dispose();

    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Get the names of the parameters in a camera parameter tuple. 
  public void get_cam_par_names (HTuple hv_CameraParam, out HTuple hv_CameraType, 
      out HTuple hv_ParamNames)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CameraParamAreaScanDivision = new HTuple();
    HTuple hv_CameraParamAreaScanPolynomial = new HTuple();
    HTuple hv_CameraParamAreaScanTelecentricDivision = new HTuple();
    HTuple hv_CameraParamAreaScanTelecentricPolynomial = new HTuple();
    HTuple hv_CameraParamAreaScanTiltDivision = new HTuple();
    HTuple hv_CameraParamAreaScanTiltPolynomial = new HTuple();
    HTuple hv_CameraParamAreaScanImageSideTelecentricTiltDivision = new HTuple();
    HTuple hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial = new HTuple();
    HTuple hv_CameraParamAreaScanBilateralTelecentricTiltDivision = new HTuple();
    HTuple hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial = new HTuple();
    HTuple hv_CameraParamAreaScanObjectSideTelecentricTiltDivision = new HTuple();
    HTuple hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial = new HTuple();
    HTuple hv_CameraParamAreaScanHypercentricDivision = new HTuple();
    HTuple hv_CameraParamAreaScanHypercentricPolynomial = new HTuple();
    HTuple hv_CameraParamLinesScan = new HTuple(), hv_CameraParamAreaScanTiltDivisionLegacy = new HTuple();
    HTuple hv_CameraParamAreaScanTiltPolynomialLegacy = new HTuple();
    HTuple hv_CameraParamAreaScanTelecentricDivisionLegacy = new HTuple();
    HTuple hv_CameraParamAreaScanTelecentricPolynomialLegacy = new HTuple();
    HTuple hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy = new HTuple();
    HTuple hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy = new HTuple();
    // Initialize local and output iconic variables 
    hv_CameraType = new HTuple();
    hv_ParamNames = new HTuple();
    //get_cam_par_names returns for each element in the camera
    //parameter tuple that is passed in CameraParam the name
    //of the respective camera parameter. The parameter names
    //are returned in ParamNames. Additionally, the camera
    //type is returned in CameraType. Alternatively, instead of
    //the camera parameters, the camera type can be passed in
    //CameraParam in form of one of the following strings:
    //  - 'area_scan_division'
    //  - 'area_scan_polynomial'
    //  - 'area_scan_tilt_division'
    //  - 'area_scan_tilt_polynomial'
    //  - 'area_scan_telecentric_division'
    //  - 'area_scan_telecentric_polynomial'
    //  - 'area_scan_tilt_bilateral_telecentric_division'
    //  - 'area_scan_tilt_bilateral_telecentric_polynomial'
    //  - 'area_scan_tilt_object_side_telecentric_division'
    //  - 'area_scan_tilt_object_side_telecentric_polynomial'
    //  - 'area_scan_hypercentric_division'
    //  - 'area_scan_hypercentric_polynomial'
    //  - 'line_scan'
    //
    hv_CameraParamAreaScanDivision.Dispose();
    hv_CameraParamAreaScanDivision = new HTuple();
    hv_CameraParamAreaScanDivision[0] = "focus";
    hv_CameraParamAreaScanDivision[1] = "kappa";
    hv_CameraParamAreaScanDivision[2] = "sx";
    hv_CameraParamAreaScanDivision[3] = "sy";
    hv_CameraParamAreaScanDivision[4] = "cx";
    hv_CameraParamAreaScanDivision[5] = "cy";
    hv_CameraParamAreaScanDivision[6] = "image_width";
    hv_CameraParamAreaScanDivision[7] = "image_height";
    hv_CameraParamAreaScanPolynomial.Dispose();
    hv_CameraParamAreaScanPolynomial = new HTuple();
    hv_CameraParamAreaScanPolynomial[0] = "focus";
    hv_CameraParamAreaScanPolynomial[1] = "k1";
    hv_CameraParamAreaScanPolynomial[2] = "k2";
    hv_CameraParamAreaScanPolynomial[3] = "k3";
    hv_CameraParamAreaScanPolynomial[4] = "p1";
    hv_CameraParamAreaScanPolynomial[5] = "p2";
    hv_CameraParamAreaScanPolynomial[6] = "sx";
    hv_CameraParamAreaScanPolynomial[7] = "sy";
    hv_CameraParamAreaScanPolynomial[8] = "cx";
    hv_CameraParamAreaScanPolynomial[9] = "cy";
    hv_CameraParamAreaScanPolynomial[10] = "image_width";
    hv_CameraParamAreaScanPolynomial[11] = "image_height";
    hv_CameraParamAreaScanTelecentricDivision.Dispose();
    hv_CameraParamAreaScanTelecentricDivision = new HTuple();
    hv_CameraParamAreaScanTelecentricDivision[0] = "magnification";
    hv_CameraParamAreaScanTelecentricDivision[1] = "kappa";
    hv_CameraParamAreaScanTelecentricDivision[2] = "sx";
    hv_CameraParamAreaScanTelecentricDivision[3] = "sy";
    hv_CameraParamAreaScanTelecentricDivision[4] = "cx";
    hv_CameraParamAreaScanTelecentricDivision[5] = "cy";
    hv_CameraParamAreaScanTelecentricDivision[6] = "image_width";
    hv_CameraParamAreaScanTelecentricDivision[7] = "image_height";
    hv_CameraParamAreaScanTelecentricPolynomial.Dispose();
    hv_CameraParamAreaScanTelecentricPolynomial = new HTuple();
    hv_CameraParamAreaScanTelecentricPolynomial[0] = "magnification";
    hv_CameraParamAreaScanTelecentricPolynomial[1] = "k1";
    hv_CameraParamAreaScanTelecentricPolynomial[2] = "k2";
    hv_CameraParamAreaScanTelecentricPolynomial[3] = "k3";
    hv_CameraParamAreaScanTelecentricPolynomial[4] = "p1";
    hv_CameraParamAreaScanTelecentricPolynomial[5] = "p2";
    hv_CameraParamAreaScanTelecentricPolynomial[6] = "sx";
    hv_CameraParamAreaScanTelecentricPolynomial[7] = "sy";
    hv_CameraParamAreaScanTelecentricPolynomial[8] = "cx";
    hv_CameraParamAreaScanTelecentricPolynomial[9] = "cy";
    hv_CameraParamAreaScanTelecentricPolynomial[10] = "image_width";
    hv_CameraParamAreaScanTelecentricPolynomial[11] = "image_height";
    hv_CameraParamAreaScanTiltDivision.Dispose();
    hv_CameraParamAreaScanTiltDivision = new HTuple();
    hv_CameraParamAreaScanTiltDivision[0] = "focus";
    hv_CameraParamAreaScanTiltDivision[1] = "kappa";
    hv_CameraParamAreaScanTiltDivision[2] = "image_plane_dist";
    hv_CameraParamAreaScanTiltDivision[3] = "tilt";
    hv_CameraParamAreaScanTiltDivision[4] = "rot";
    hv_CameraParamAreaScanTiltDivision[5] = "sx";
    hv_CameraParamAreaScanTiltDivision[6] = "sy";
    hv_CameraParamAreaScanTiltDivision[7] = "cx";
    hv_CameraParamAreaScanTiltDivision[8] = "cy";
    hv_CameraParamAreaScanTiltDivision[9] = "image_width";
    hv_CameraParamAreaScanTiltDivision[10] = "image_height";
    hv_CameraParamAreaScanTiltPolynomial.Dispose();
    hv_CameraParamAreaScanTiltPolynomial = new HTuple();
    hv_CameraParamAreaScanTiltPolynomial[0] = "focus";
    hv_CameraParamAreaScanTiltPolynomial[1] = "k1";
    hv_CameraParamAreaScanTiltPolynomial[2] = "k2";
    hv_CameraParamAreaScanTiltPolynomial[3] = "k3";
    hv_CameraParamAreaScanTiltPolynomial[4] = "p1";
    hv_CameraParamAreaScanTiltPolynomial[5] = "p2";
    hv_CameraParamAreaScanTiltPolynomial[6] = "image_plane_dist";
    hv_CameraParamAreaScanTiltPolynomial[7] = "tilt";
    hv_CameraParamAreaScanTiltPolynomial[8] = "rot";
    hv_CameraParamAreaScanTiltPolynomial[9] = "sx";
    hv_CameraParamAreaScanTiltPolynomial[10] = "sy";
    hv_CameraParamAreaScanTiltPolynomial[11] = "cx";
    hv_CameraParamAreaScanTiltPolynomial[12] = "cy";
    hv_CameraParamAreaScanTiltPolynomial[13] = "image_width";
    hv_CameraParamAreaScanTiltPolynomial[14] = "image_height";
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision.Dispose();
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision = new HTuple();
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision[0] = "focus";
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision[1] = "kappa";
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision[2] = "tilt";
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision[3] = "rot";
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision[4] = "sx";
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision[5] = "sy";
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision[6] = "cx";
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision[7] = "cy";
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision[8] = "image_width";
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision[9] = "image_height";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial.Dispose();
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial = new HTuple();
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[0] = "focus";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[1] = "k1";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[2] = "k2";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[3] = "k3";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[4] = "p1";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[5] = "p2";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[6] = "tilt";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[7] = "rot";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[8] = "sx";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[9] = "sy";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[10] = "cx";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[11] = "cy";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[12] = "image_width";
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial[13] = "image_height";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision.Dispose();
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision = new HTuple();
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision[0] = "magnification";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision[1] = "kappa";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision[2] = "tilt";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision[3] = "rot";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision[4] = "sx";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision[5] = "sy";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision[6] = "cx";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision[7] = "cy";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision[8] = "image_width";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision[9] = "image_height";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial.Dispose();
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial = new HTuple();
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[0] = "magnification";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[1] = "k1";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[2] = "k2";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[3] = "k3";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[4] = "p1";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[5] = "p2";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[6] = "tilt";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[7] = "rot";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[8] = "sx";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[9] = "sy";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[10] = "cx";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[11] = "cy";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[12] = "image_width";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial[13] = "image_height";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision.Dispose();
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision = new HTuple();
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[0] = "magnification";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[1] = "kappa";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[2] = "image_plane_dist";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[3] = "tilt";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[4] = "rot";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[5] = "sx";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[6] = "sy";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[7] = "cx";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[8] = "cy";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[9] = "image_width";
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision[10] = "image_height";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial.Dispose();
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial = new HTuple();
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[0] = "magnification";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[1] = "k1";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[2] = "k2";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[3] = "k3";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[4] = "p1";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[5] = "p2";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[6] = "image_plane_dist";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[7] = "tilt";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[8] = "rot";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[9] = "sx";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[10] = "sy";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[11] = "cx";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[12] = "cy";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[13] = "image_width";
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial[14] = "image_height";
    hv_CameraParamAreaScanHypercentricDivision.Dispose();
    hv_CameraParamAreaScanHypercentricDivision = new HTuple();
    hv_CameraParamAreaScanHypercentricDivision[0] = "focus";
    hv_CameraParamAreaScanHypercentricDivision[1] = "kappa";
    hv_CameraParamAreaScanHypercentricDivision[2] = "sx";
    hv_CameraParamAreaScanHypercentricDivision[3] = "sy";
    hv_CameraParamAreaScanHypercentricDivision[4] = "cx";
    hv_CameraParamAreaScanHypercentricDivision[5] = "cy";
    hv_CameraParamAreaScanHypercentricDivision[6] = "image_width";
    hv_CameraParamAreaScanHypercentricDivision[7] = "image_height";
    hv_CameraParamAreaScanHypercentricPolynomial.Dispose();
    hv_CameraParamAreaScanHypercentricPolynomial = new HTuple();
    hv_CameraParamAreaScanHypercentricPolynomial[0] = "focus";
    hv_CameraParamAreaScanHypercentricPolynomial[1] = "k1";
    hv_CameraParamAreaScanHypercentricPolynomial[2] = "k2";
    hv_CameraParamAreaScanHypercentricPolynomial[3] = "k3";
    hv_CameraParamAreaScanHypercentricPolynomial[4] = "p1";
    hv_CameraParamAreaScanHypercentricPolynomial[5] = "p2";
    hv_CameraParamAreaScanHypercentricPolynomial[6] = "sx";
    hv_CameraParamAreaScanHypercentricPolynomial[7] = "sy";
    hv_CameraParamAreaScanHypercentricPolynomial[8] = "cx";
    hv_CameraParamAreaScanHypercentricPolynomial[9] = "cy";
    hv_CameraParamAreaScanHypercentricPolynomial[10] = "image_width";
    hv_CameraParamAreaScanHypercentricPolynomial[11] = "image_height";
    hv_CameraParamLinesScan.Dispose();
    hv_CameraParamLinesScan = new HTuple();
    hv_CameraParamLinesScan[0] = "focus";
    hv_CameraParamLinesScan[1] = "kappa";
    hv_CameraParamLinesScan[2] = "sx";
    hv_CameraParamLinesScan[3] = "sy";
    hv_CameraParamLinesScan[4] = "cx";
    hv_CameraParamLinesScan[5] = "cy";
    hv_CameraParamLinesScan[6] = "image_width";
    hv_CameraParamLinesScan[7] = "image_height";
    hv_CameraParamLinesScan[8] = "vx";
    hv_CameraParamLinesScan[9] = "vy";
    hv_CameraParamLinesScan[10] = "vz";
    //Legacy parameter names
    hv_CameraParamAreaScanTiltDivisionLegacy.Dispose();
    hv_CameraParamAreaScanTiltDivisionLegacy = new HTuple();
    hv_CameraParamAreaScanTiltDivisionLegacy[0] = "focus";
    hv_CameraParamAreaScanTiltDivisionLegacy[1] = "kappa";
    hv_CameraParamAreaScanTiltDivisionLegacy[2] = "tilt";
    hv_CameraParamAreaScanTiltDivisionLegacy[3] = "rot";
    hv_CameraParamAreaScanTiltDivisionLegacy[4] = "sx";
    hv_CameraParamAreaScanTiltDivisionLegacy[5] = "sy";
    hv_CameraParamAreaScanTiltDivisionLegacy[6] = "cx";
    hv_CameraParamAreaScanTiltDivisionLegacy[7] = "cy";
    hv_CameraParamAreaScanTiltDivisionLegacy[8] = "image_width";
    hv_CameraParamAreaScanTiltDivisionLegacy[9] = "image_height";
    hv_CameraParamAreaScanTiltPolynomialLegacy.Dispose();
    hv_CameraParamAreaScanTiltPolynomialLegacy = new HTuple();
    hv_CameraParamAreaScanTiltPolynomialLegacy[0] = "focus";
    hv_CameraParamAreaScanTiltPolynomialLegacy[1] = "k1";
    hv_CameraParamAreaScanTiltPolynomialLegacy[2] = "k2";
    hv_CameraParamAreaScanTiltPolynomialLegacy[3] = "k3";
    hv_CameraParamAreaScanTiltPolynomialLegacy[4] = "p1";
    hv_CameraParamAreaScanTiltPolynomialLegacy[5] = "p2";
    hv_CameraParamAreaScanTiltPolynomialLegacy[6] = "tilt";
    hv_CameraParamAreaScanTiltPolynomialLegacy[7] = "rot";
    hv_CameraParamAreaScanTiltPolynomialLegacy[8] = "sx";
    hv_CameraParamAreaScanTiltPolynomialLegacy[9] = "sy";
    hv_CameraParamAreaScanTiltPolynomialLegacy[10] = "cx";
    hv_CameraParamAreaScanTiltPolynomialLegacy[11] = "cy";
    hv_CameraParamAreaScanTiltPolynomialLegacy[12] = "image_width";
    hv_CameraParamAreaScanTiltPolynomialLegacy[13] = "image_height";
    hv_CameraParamAreaScanTelecentricDivisionLegacy.Dispose();
    hv_CameraParamAreaScanTelecentricDivisionLegacy = new HTuple();
    hv_CameraParamAreaScanTelecentricDivisionLegacy[0] = "focus";
    hv_CameraParamAreaScanTelecentricDivisionLegacy[1] = "kappa";
    hv_CameraParamAreaScanTelecentricDivisionLegacy[2] = "sx";
    hv_CameraParamAreaScanTelecentricDivisionLegacy[3] = "sy";
    hv_CameraParamAreaScanTelecentricDivisionLegacy[4] = "cx";
    hv_CameraParamAreaScanTelecentricDivisionLegacy[5] = "cy";
    hv_CameraParamAreaScanTelecentricDivisionLegacy[6] = "image_width";
    hv_CameraParamAreaScanTelecentricDivisionLegacy[7] = "image_height";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy.Dispose();
    hv_CameraParamAreaScanTelecentricPolynomialLegacy = new HTuple();
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[0] = "focus";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[1] = "k1";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[2] = "k2";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[3] = "k3";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[4] = "p1";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[5] = "p2";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[6] = "sx";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[7] = "sy";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[8] = "cx";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[9] = "cy";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[10] = "image_width";
    hv_CameraParamAreaScanTelecentricPolynomialLegacy[11] = "image_height";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy.Dispose();
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy = new HTuple();
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[0] = "focus";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[1] = "kappa";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[2] = "tilt";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[3] = "rot";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[4] = "sx";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[5] = "sy";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[6] = "cx";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[7] = "cy";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[8] = "image_width";
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy[9] = "image_height";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy.Dispose();
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy = new HTuple();
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[0] = "focus";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[1] = "k1";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[2] = "k2";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[3] = "k3";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[4] = "p1";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[5] = "p2";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[6] = "tilt";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[7] = "rot";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[8] = "sx";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[9] = "sy";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[10] = "cx";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[11] = "cy";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[12] = "image_width";
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy[13] = "image_height";
    //
    //If the camera type is passed in CameraParam
    if ((int)((new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleEqual(1))).TupleAnd(
        ((hv_CameraParam.TupleSelect(0))).TupleIsString())) != 0)
    {
      hv_CameraType.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CameraType = hv_CameraParam.TupleSelect(
          0);
      }
      if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_division"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_polynomial"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_telecentric_division"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanTelecentricDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_telecentric_polynomial"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanTelecentricPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_division"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanTiltDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_polynomial"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanTiltPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_image_side_telecentric_division"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanImageSideTelecentricTiltDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_image_side_telecentric_polynomial"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_bilateral_telecentric_division"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanBilateralTelecentricTiltDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_bilateral_telecentric_polynomial"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_object_side_telecentric_division"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanObjectSideTelecentricTiltDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_object_side_telecentric_polynomial"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_hypercentric_division"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanHypercentricDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_hypercentric_polynomial"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanHypercentricPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("line_scan"))) != 0)
      {
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamLinesScan);
        }
      }
      else
      {
        throw new HalconException(("Unknown camera type '"+hv_CameraType)+"' passed in CameraParam.");
      }

      hv_CameraParamAreaScanDivision.Dispose();
      hv_CameraParamAreaScanPolynomial.Dispose();
      hv_CameraParamAreaScanTelecentricDivision.Dispose();
      hv_CameraParamAreaScanTelecentricPolynomial.Dispose();
      hv_CameraParamAreaScanTiltDivision.Dispose();
      hv_CameraParamAreaScanTiltPolynomial.Dispose();
      hv_CameraParamAreaScanImageSideTelecentricTiltDivision.Dispose();
      hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial.Dispose();
      hv_CameraParamAreaScanBilateralTelecentricTiltDivision.Dispose();
      hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial.Dispose();
      hv_CameraParamAreaScanObjectSideTelecentricTiltDivision.Dispose();
      hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial.Dispose();
      hv_CameraParamAreaScanHypercentricDivision.Dispose();
      hv_CameraParamAreaScanHypercentricPolynomial.Dispose();
      hv_CameraParamLinesScan.Dispose();
      hv_CameraParamAreaScanTiltDivisionLegacy.Dispose();
      hv_CameraParamAreaScanTiltPolynomialLegacy.Dispose();
      hv_CameraParamAreaScanTelecentricDivisionLegacy.Dispose();
      hv_CameraParamAreaScanTelecentricPolynomialLegacy.Dispose();
      hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy.Dispose();
      hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy.Dispose();

      return;
    }
    //
    //If the camera parameters are passed in CameraParam
    if ((int)(((((hv_CameraParam.TupleSelect(0))).TupleIsString())).TupleNot()) != 0)
    {
      //Format of camera parameters for HALCON 12 and earlier
      switch ((new HTuple(hv_CameraParam.TupleLength()
          )).I)
      {
        //
        //Area Scan
      case 8:
        //CameraType: 'area_scan_division' or 'area_scan_telecentric_division'
        if ((int)(new HTuple(((hv_CameraParam.TupleSelect(0))).TupleNotEqual(0.0))) != 0)
        {
          hv_ParamNames.Dispose();
          hv_ParamNames = new HTuple(hv_CameraParamAreaScanDivision);
          hv_CameraType.Dispose();
          hv_CameraType = "area_scan_division";
        }
        else
        {
          hv_ParamNames.Dispose();
          hv_ParamNames = new HTuple(hv_CameraParamAreaScanTelecentricDivisionLegacy);
          hv_CameraType.Dispose();
          hv_CameraType = "area_scan_telecentric_division";
        }
        break;
      case 10:
        //CameraType: 'area_scan_tilt_division' or 'area_scan_telecentric_tilt_division'
        if ((int)(new HTuple(((hv_CameraParam.TupleSelect(0))).TupleNotEqual(0.0))) != 0)
        {
          hv_ParamNames.Dispose();
          hv_ParamNames = new HTuple(hv_CameraParamAreaScanTiltDivisionLegacy);
          hv_CameraType.Dispose();
          hv_CameraType = "area_scan_tilt_division";
        }
        else
        {
          hv_ParamNames.Dispose();
          hv_ParamNames = new HTuple(hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy);
          hv_CameraType.Dispose();
          hv_CameraType = "area_scan_tilt_bilateral_telecentric_division";
        }
        break;
      case 12:
        //CameraType: 'area_scan_polynomial' or 'area_scan_telecentric_polynomial'
        if ((int)(new HTuple(((hv_CameraParam.TupleSelect(0))).TupleNotEqual(0.0))) != 0)
        {
          hv_ParamNames.Dispose();
          hv_ParamNames = new HTuple(hv_CameraParamAreaScanPolynomial);
          hv_CameraType.Dispose();
          hv_CameraType = "area_scan_polynomial";
        }
        else
        {
          hv_ParamNames.Dispose();
          hv_ParamNames = new HTuple(hv_CameraParamAreaScanTelecentricPolynomialLegacy);
          hv_CameraType.Dispose();
          hv_CameraType = "area_scan_telecentric_polynomial";
        }
        break;
      case 14:
        //CameraType: 'area_scan_tilt_polynomial' or 'area_scan_telecentric_tilt_polynomial'
        if ((int)(new HTuple(((hv_CameraParam.TupleSelect(0))).TupleNotEqual(0.0))) != 0)
        {
          hv_ParamNames.Dispose();
          hv_ParamNames = new HTuple(hv_CameraParamAreaScanTiltPolynomialLegacy);
          hv_CameraType.Dispose();
          hv_CameraType = "area_scan_tilt_polynomial";
        }
        else
        {
          hv_ParamNames.Dispose();
          hv_ParamNames = new HTuple(hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy);
          hv_CameraType.Dispose();
          hv_CameraType = "area_scan_tilt_bilateral_telecentric_polynomial";
        }
        break;
        //
        //Line Scan
      case 11:
        //CameraType: 'line_scan'
        hv_ParamNames.Dispose();
        hv_ParamNames = new HTuple(hv_CameraParamLinesScan);
        hv_CameraType.Dispose();
        hv_CameraType = "line_scan";
        break;
      default:
        throw new HalconException("Wrong number of values in CameraParam.");
        break;
      }
    }
    else
    {
      //Format of camera parameters since HALCON 13
      hv_CameraType.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CameraType = hv_CameraParam.TupleSelect(
          0);
      }
      if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_division"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            9))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_polynomial"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            13))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_telecentric_division"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            9))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanTelecentricDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_telecentric_polynomial"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            13))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanTelecentricPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_division"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            12))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanTiltDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_polynomial"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            16))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanTiltPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_image_side_telecentric_division"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            11))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanImageSideTelecentricTiltDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_image_side_telecentric_polynomial"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            15))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_bilateral_telecentric_division"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            11))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanBilateralTelecentricTiltDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_bilateral_telecentric_polynomial"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            15))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_object_side_telecentric_division"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            12))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanObjectSideTelecentricTiltDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_tilt_object_side_telecentric_polynomial"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            16))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_hypercentric_division"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            9))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanHypercentricDivision);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("area_scan_hypercentric_polynomial"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            13))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamAreaScanHypercentricPolynomial);
        }
      }
      else if ((int)(new HTuple(hv_CameraType.TupleEqual("line_scan"))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_CameraParam.TupleLength())).TupleNotEqual(
            12))) != 0)
        {
          throw new HalconException("Wrong number of values in CameraParam.");
        }
        hv_ParamNames.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNames = new HTuple();
        hv_ParamNames[0] = "camera_type";
        hv_ParamNames = hv_ParamNames.TupleConcat(hv_CameraParamLinesScan);
        }
      }
      else
      {
        throw new HalconException("Unknown camera type in CameraParam.");
      }
    }

    hv_CameraParamAreaScanDivision.Dispose();
    hv_CameraParamAreaScanPolynomial.Dispose();
    hv_CameraParamAreaScanTelecentricDivision.Dispose();
    hv_CameraParamAreaScanTelecentricPolynomial.Dispose();
    hv_CameraParamAreaScanTiltDivision.Dispose();
    hv_CameraParamAreaScanTiltPolynomial.Dispose();
    hv_CameraParamAreaScanImageSideTelecentricTiltDivision.Dispose();
    hv_CameraParamAreaScanImageSideTelecentricTiltPolynomial.Dispose();
    hv_CameraParamAreaScanBilateralTelecentricTiltDivision.Dispose();
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomial.Dispose();
    hv_CameraParamAreaScanObjectSideTelecentricTiltDivision.Dispose();
    hv_CameraParamAreaScanObjectSideTelecentricTiltPolynomial.Dispose();
    hv_CameraParamAreaScanHypercentricDivision.Dispose();
    hv_CameraParamAreaScanHypercentricPolynomial.Dispose();
    hv_CameraParamLinesScan.Dispose();
    hv_CameraParamAreaScanTiltDivisionLegacy.Dispose();
    hv_CameraParamAreaScanTiltPolynomialLegacy.Dispose();
    hv_CameraParamAreaScanTelecentricDivisionLegacy.Dispose();
    hv_CameraParamAreaScanTelecentricPolynomialLegacy.Dispose();
    hv_CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy.Dispose();
    hv_CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy.Dispose();

    return;
  }

  // Chapter: Graphics / Window
  public void get_child_window (HTuple hv_HeightImage, HTuple hv_Font, HTuple hv_FontSize, 
      HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_WindowImageRatio, out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_ParentWindowHandle = new HTuple(), hv_ChildWindowHandle = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_MetaInfo = new HTuple();
    HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowImageRatio = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    //
    //This procedure returns the next child window that
    //is used for visualization. If ReuseWindows is true
    //and WindowHandleList is suitable, the window handles
    //that are passed over are used. Else, this procedure
    //opens a new window, either next to the last ones, or
    //in a new row.
    //
    //First, check if the requested window is already available.
    hv_OpenNewWindow.Dispose();
    hv_OpenNewWindow = 0;
    try
    {
      hv_WindowHandles.Dispose();
      HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
      hv_ParentWindowHandle.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ParentWindowHandle = hv_WindowHandles.TupleSelect(
          0);
      }
      hv_ChildWindowHandle.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ChildWindowHandle = hv_WindowHandles.TupleSelect(
          1);
      }
      //Check if window handle is valid.
      try
      {
        HOperatorSet.FlushBuffer(hv_ChildWindowHandle);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException2)
      {
        HDevExpDefaultException2.ToHTuple(out hv_Exception);
        //Since there is something wrong with the current window, create a new one.
        hv_OpenNewWindow.Dispose();
        hv_OpenNewWindow = 1;
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_OpenNewWindow.Dispose();
      hv_OpenNewWindow = 1;
    }
    //
    //Get next child window.
    if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
    {
      //
      //If possible, reuse existing window handles.
      HDevWindowStack.SetActive(hv_ChildWindowHandle);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
      }
      set_display_font(hv_ChildWindowHandle, hv_FontSize, hv_Font, "true", "false");
      //
      hv_MetaInfo.Dispose();
      HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
      //
      //Get previous window coordinates.
      hv_WindowRow.Dispose();hv_WindowColumn.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
      HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow, out hv_WindowColumn, 
          out hv_WindowWidth, out hv_WindowHeight);
      hv_WindowImageRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowImageRatio = hv_WindowHeight/(hv_HeightImage*1.0);
      }
      //
      try
      {
        //
        //Get WindowImageRatio from parent window.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowImageRatio.Dispose();
        HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio", 
            out hv_WindowImageRatio);
        }
        //
        //Get previous window coordinates.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PrevWindowCoordinatesOut.Dispose();
        HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_child_window_coordinates", 
            out hv_PrevWindowCoordinatesOut);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //
        //Set WindowImageRatio from parent window.
        hv_WindowRow.Dispose();hv_WindowColumn.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
        HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow, out hv_WindowColumn, 
            out hv_WindowWidth, out hv_WindowHeight);
        hv_WindowImageRatio.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowImageRatio = hv_WindowHeight/(hv_HeightImage*1.0);
        }
        //
        //Set previous window coordinates.
        if (hv_PrevWindowCoordinatesOut == null)
          hv_PrevWindowCoordinatesOut = new HTuple();
        hv_PrevWindowCoordinatesOut[0] = hv_WindowRow;
        if (hv_PrevWindowCoordinatesOut == null)
          hv_PrevWindowCoordinatesOut = new HTuple();
        hv_PrevWindowCoordinatesOut[1] = hv_WindowColumn;
        if (hv_PrevWindowCoordinatesOut == null)
          hv_PrevWindowCoordinatesOut = new HTuple();
        hv_PrevWindowCoordinatesOut[2] = hv_WindowWidth;
        if (hv_PrevWindowCoordinatesOut == null)
          hv_PrevWindowCoordinatesOut = new HTuple();
        hv_PrevWindowCoordinatesOut[3] = hv_WindowHeight;
      }
    }
    else
    {
      //Open a new child window.
      hv_ChildWindowHandle.Dispose();hv_PrevWindowCoordinatesOut.Dispose();
      open_child_window(hv_ParentWindowHandle, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
          hv_WindowHandleDict, hv_WindowHandleKey, out hv_ChildWindowHandle, out hv_PrevWindowCoordinatesOut);
      HOperatorSet.SetWindowParam(hv_ChildWindowHandle, "flush", "false");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_ParentWindowHandle.TupleConcat(
          hv_ChildWindowHandle));
      }
    }

    hv_OpenNewWindow.Dispose();
    hv_WindowHandles.Dispose();
    hv_ParentWindowHandle.Dispose();
    hv_ChildWindowHandle.Dispose();
    hv_Exception.Dispose();
    hv_MetaInfo.Dispose();
    hv_WindowRow.Dispose();
    hv_WindowColumn.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();

    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  public void get_confidence_image (out HObject ho_ImageConfidence, HTuple hv_ResultKeys, 
      HTuple hv_DLResult)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
    //
    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidence"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_ImageConfidence.Dispose();
      HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidence");
    }
    else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidences"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_ImageConfidence.Dispose();
      HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidences");
    }
    else
    {
      throw new HalconException("Confidence image could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Describe and calculate user-defined features to be used in conjunction with the calculate_feature_set procedure library. 
  public void get_custom_features (HObject ho_Region, HObject ho_Image, HTuple hv_CurrentName, 
      HTuple hv_Mode, out HTuple hv_Output)
  {




    // Local iconic variables 

    HObject ho_RegionSelected=null, ho_Contours=null;
    HObject ho_ContoursSelected=null, ho_ContoursSplit=null;

    // Local control variables 

    HTuple hv_TmpResults = new HTuple(), hv_Name = new HTuple();
    HTuple hv_Groups = new HTuple(), hv_Feature = new HTuple();
    HTuple hv_NumRegions = new HTuple(), hv_I = new HTuple();
    HTuple hv_NumContours = new HTuple(), hv_NumLines = new HTuple();
    HTuple hv_J = new HTuple(), hv_NumSplit = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_RegionSelected);
    HOperatorSet.GenEmptyObj(out ho_Contours);
    HOperatorSet.GenEmptyObj(out ho_ContoursSelected);
    HOperatorSet.GenEmptyObj(out ho_ContoursSplit);
    hv_Output = new HTuple();
    //
    //This procedure can be used to extend the functionality
    //of the calculate_feature_set procedure library by
    //user-defined features.
    //
    //Instructions:
    //
    //1. Find the template block at the beginning the procedure
    //(marked by comments) and duplicate it.
    //
    //2. In the copy edit the two marked areas as follows:
    //
    //2.1. Feature name and groups:
    //Assign a unique identifier for your feature to the variable "Name".
    //Then, assign the groups that you want your feature to belong to
    //to the variable "Groups".
    //
    //2.2. Feature calculation:
    //Enter the code that calculates your feature and
    //assign the result to the variable "Feature".
    //
    //3. Test
    //Use the "test_feature" procedure to check,
    //if the feature is calculated correctly.
    //If the procedure throws an exception,
    //maybe the order of the feature vector is wrong
    //(See note below).
    //
    //4. Integration
    //- Save your modified procedure get_custom_features.hdvp
    //  to a location of your choice.
    //  (We recommend not to overwrite the template.)
    //- Make sure, that your version of get_custom_procedures
    //  is included in the procedure directories of HDevelop.
    //  (Choose Procedures -> Manage Procedures -> Directories -> Add from the HDevelop menu bar.)
    //
    //Note:
    //The current implementation supports region arrays as input.
    //In that case, multi-dimensional feature vectors are simply concatenated.
    //Example: The feature 'center' has two dimensions [Row,Column].
    //If an array of three regions is passed, the correct order of the "Feature" variable is
    //[Row1, Column1, Row2, Column2, Row3, Column3].
    //
    hv_TmpResults.Dispose();
    hv_TmpResults = new HTuple();
    //************************************************
    //************************************************
    //**** Copy the following template block     *****
    //**** and edit the two marked code sections *****
    //**** to add user-defined features          *****
    //************************************************
    //************************************************
    //
    //***************************************
    //*********** TEMPLATE BLOCK ************
    //***************************************
    //
    //********************************************************************
    //** Section 1:
    //** Enter unique feature name and groups to which it belongs here ***
    hv_Name.Dispose();
    hv_Name = "custom_feature_numlines";
    hv_Groups.Dispose();
    hv_Groups = "custom";
    //** Enter unique feature name and groups above this line ************
    //********************************************************************
    if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
    {
      //******************************************************
      //** Section 2:
      //** Enter code to calculate feature here **************
      hv_Feature.Dispose();
      hv_Feature = new HTuple();
      hv_NumRegions.Dispose();
      HOperatorSet.CountObj(ho_Region, out hv_NumRegions);
      HTuple end_val69 = hv_NumRegions;
      HTuple step_val69 = 1;
      for (hv_I=1; hv_I.Continue(end_val69, step_val69); hv_I = hv_I.TupleAdd(step_val69))
      {
        ho_RegionSelected.Dispose();
        HOperatorSet.SelectObj(ho_Region, out ho_RegionSelected, hv_I);
        ho_Contours.Dispose();
        HOperatorSet.GenContourRegionXld(ho_RegionSelected, out ho_Contours, "border");
        hv_NumContours.Dispose();
        HOperatorSet.CountObj(ho_Contours, out hv_NumContours);
        hv_NumLines.Dispose();
        hv_NumLines = 0;
        HTuple end_val74 = hv_NumContours;
        HTuple step_val74 = 1;
        for (hv_J=1; hv_J.Continue(end_val74, step_val74); hv_J = hv_J.TupleAdd(step_val74))
        {
          ho_ContoursSelected.Dispose();
          HOperatorSet.SelectObj(ho_Contours, out ho_ContoursSelected, hv_J);
          ho_ContoursSplit.Dispose();
          HOperatorSet.SegmentContoursXld(ho_ContoursSelected, out ho_ContoursSplit, 
              "lines", 5, 2, 1);
          hv_NumSplit.Dispose();
          HOperatorSet.CountObj(ho_ContoursSplit, out hv_NumSplit);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_NumLines = hv_NumLines+hv_NumSplit;
          hv_NumLines.Dispose();
          hv_NumLines = ExpTmpLocalVar_NumLines;
          }
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Feature = hv_Feature.TupleConcat(
            hv_NumLines);
        hv_Feature.Dispose();
        hv_Feature = ExpTmpLocalVar_Feature;
        }
        }
      }
      //** Enter code to calculate feature above this line ***
      //******************************************************
      {
      HTuple ExpTmpOutVar_0;
      append_length_or_values(hv_Mode, hv_Feature, hv_TmpResults, out ExpTmpOutVar_0);
      hv_TmpResults.Dispose();
      hv_TmpResults = ExpTmpOutVar_0;
      }
    }
    {
    HTuple ExpTmpOutVar_0;
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_TmpResults, 
        out ExpTmpOutVar_0);
    hv_TmpResults.Dispose();
    hv_TmpResults = ExpTmpOutVar_0;
    }
    //
    //************************************
    //****** END OF TEMPLATE BLOCK *******
    //************************************
    //
    hv_Output.Dispose();
    hv_Output = new HTuple(hv_TmpResults);
    ho_RegionSelected.Dispose();
    ho_Contours.Dispose();
    ho_ContoursSelected.Dispose();
    ho_ContoursSplit.Dispose();

    hv_TmpResults.Dispose();
    hv_Name.Dispose();
    hv_Groups.Dispose();
    hv_Feature.Dispose();
    hv_NumRegions.Dispose();
    hv_I.Dispose();
    hv_NumContours.Dispose();
    hv_NumLines.Dispose();
    hv_J.Dispose();
    hv_NumSplit.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Generates NumColors distinct colors 
  public void get_distinct_colors (HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor, 
      HTuple hv_EndColor, out HTuple hv_Colors)
  {



      // Local iconic variables 

      HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
      HObject ho_ImageR, ho_ImageG, ho_ImageB;

      // Local control variables 

      HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
      HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
      HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
      HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
      HTuple hv_Blue = new HTuple();
      HTuple   hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
      HTuple   hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_HLSImageH);
      HOperatorSet.GenEmptyObj(out ho_HLSImageL);
      HOperatorSet.GenEmptyObj(out ho_HLSImageS);
      HOperatorSet.GenEmptyObj(out ho_ImageR);
      HOperatorSet.GenEmptyObj(out ho_ImageG);
      HOperatorSet.GenEmptyObj(out ho_ImageB);
      hv_Colors = new HTuple();
    //
    //We get distinct color-values first in HLS color-space.
    //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
    //
    //Parameter checks.
    //NumColors.
    if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
    {
      throw new HalconException("NumColors should be at least 1");
    }
    if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
    {
      throw new HalconException("NumColors should be of type int");
    }
    if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(1))) != 0)
    {
      throw new HalconException("NumColors should have length 1");
    }
    //Random.
    if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
        1)))) != 0)
    {
      hv_IsString.Dispose();
      HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
      if ((int)(hv_IsString) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
            "true"))).TupleOr("false");
        hv_Random_COPY_INP_TMP.Dispose();
        hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
        }
        }
      }
      else
      {
        throw new HalconException("Random should be either true or false");
      }
    }
    //StartColor.
    if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("StartColor should have length 1");
    }
    if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
        255)))) != 0)
    {
      throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
    }
    if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
    {
      throw new HalconException("StartColor should be of type int");
    }
    //EndColor.
    if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("EndColor should have length 1");
    }
    if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
        255)))) != 0)
    {
      throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
    }
    if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
    {
      throw new HalconException("EndColor should be of type int");
    }
    //
    //Color generation.
    if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP+255;
      hv_EndColor_COPY_INP_TMP.Dispose();
      hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
      }
      }
    }
    if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
    {
      hv_Hue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Hue = (hv_StartColor+(((((hv_EndColor_COPY_INP_TMP-hv_StartColor)*((HTuple.TupleGenSequence(
          0,hv_NumColors-1,1)).TupleReal()))/(((hv_NumColors-1)).TupleReal()))).TupleInt()
          ))%255;
      }
    }
    else
    {
      hv_Hue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Hue = ((hv_StartColor.TupleConcat(
          hv_EndColor_COPY_INP_TMP))).TupleMean();
      }
    }
    if ((int)(hv_Random_COPY_INP_TMP) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
          (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
      hv_Hue.Dispose();
      hv_Hue = ExpTmpLocalVar_Hue;
      }
      }
      hv_Lightness.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Lightness = ((((5.0+HTuple.TupleRand(
          hv_NumColors))*255.0)/10.0)).TupleInt();
      }
      hv_Saturation.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Saturation = ((((9.0+HTuple.TupleRand(
          hv_NumColors))*255.0)/10.0)).TupleInt();
      }
    }
    else
    {
      hv_Lightness.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Lightness = ((HTuple.TupleGenConst(
          hv_NumColors,0.55)*255.0)).TupleInt();
      }
      hv_Saturation.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Saturation = ((HTuple.TupleGenConst(
          hv_NumColors,0.95)*255.0)).TupleInt();
      }
    }
    //
    //Write colors to a 3-channel image in order to transform easier.
    ho_HLSImageH.Dispose();
    HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
    ho_HLSImageL.Dispose();
    HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
    ho_HLSImageS.Dispose();
    HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
    hv_Rows.Dispose();hv_Columns.Dispose();
    HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
    HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
    HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
    HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
    //
    //Convert from HLS to RGB.
    ho_ImageR.Dispose();ho_ImageG.Dispose();ho_ImageB.Dispose();
    HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR, 
        out ho_ImageG, out ho_ImageB, "hls");
    //
    //Get RGB-values and transform to Hex.
    hv_Red.Dispose();
    HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
    hv_Green.Dispose();
    HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
    hv_Blue.Dispose();
    HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
    hv_Colors.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Colors = (("#"+(hv_Red.TupleString(
        "02x")))+(hv_Green.TupleString("02x")))+(hv_Blue.TupleString("02x"));
    }
    ho_HLSImageH.Dispose();
    ho_HLSImageL.Dispose();
    ho_HLSImageS.Dispose();
    ho_ImageR.Dispose();
    ho_ImageG.Dispose();
    ho_ImageB.Dispose();

    hv_EndColor_COPY_INP_TMP.Dispose();
    hv_Random_COPY_INP_TMP.Dispose();
    hv_IsString.Dispose();
    hv_Hue.Dispose();
    hv_Lightness.Dispose();
    hv_Saturation.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_Red.Dispose();
    hv_Green.Dispose();
    hv_Blue.Dispose();

    return;

  }

  // Chapter: Deep Learning / Model
  // Short Description: Generates certain colors for different ClassNames 
  public void get_dl_class_colors (HTuple hv_ClassNames, out HTuple hv_Colors)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_ColorsRainbow = new HTuple();
    HTuple hv_ClassNamesGood = new HTuple(), hv_IndexFind = new HTuple();
    HTuple hv_GoodIdx = new HTuple(), hv_CurrentColor = new HTuple();
    HTuple hv_GreenIdx = new HTuple();
    // Initialize local and output iconic variables 
    hv_Colors = new HTuple();
    //
    //This procedure returns for each class a certain color.
    //
    //Define distinct colors for the classes.
    hv_NumColors.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumColors = new HTuple(hv_ClassNames.TupleLength()
        );
    }
    //Get distinct colors without randomness makes neighboring colors look very similar.
    //We use a workaround to get deterministic colors where subsequent colors are distinguishable.
    hv_ColorsRainbow.Dispose();
    get_distinct_colors(hv_NumColors, 0, 0, 200, out hv_ColorsRainbow);
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.TupleInverse(hv_ColorsRainbow, out ExpTmpOutVar_0);
    hv_ColorsRainbow.Dispose();
    hv_ColorsRainbow = ExpTmpOutVar_0;
    }
    hv_Colors.Dispose();
    make_neighboring_colors_distinguishable(hv_ColorsRainbow, out hv_Colors);
    //If a class 'OK','ok', 'good' or 'GOOD' is present set this class to green.
    //Only the first occurrence found is set to a green shade.
    hv_ClassNamesGood.Dispose();
    hv_ClassNamesGood = new HTuple();
    hv_ClassNamesGood[0] = "good";
    hv_ClassNamesGood[1] = "GOOD";
    hv_ClassNamesGood[2] = "ok";
    hv_ClassNamesGood[3] = "OK";
    for (hv_IndexFind=0; (int)hv_IndexFind<=(int)((new HTuple(hv_ClassNamesGood.TupleLength()
        ))-1); hv_IndexFind = (int)hv_IndexFind + 1)
    {
      hv_GoodIdx.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_GoodIdx = hv_ClassNames.TupleFindFirst(
          hv_ClassNamesGood.TupleSelect(hv_IndexFind));
      }
      if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(new HTuple((new HTuple(hv_ClassNames.TupleLength()
          )).TupleLessEqual(8)))) != 0)
      {
        //If number of classes is <= 8, swap color with a green color.
        hv_CurrentColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentColor = hv_Colors.TupleSelect(
            hv_GoodIdx);
        }
        hv_GreenIdx.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GreenIdx = (new HTuple((new HTuple(hv_ClassNames.TupleLength()
            ))/2.0)).TupleFloor();
        }
        //Set to pure green.
        if (hv_Colors == null)
          hv_Colors = new HTuple();
        hv_Colors[hv_GoodIdx] = "#00ff00";
        //Write original color to a green entry.
        if (hv_Colors == null)
          hv_Colors = new HTuple();
        hv_Colors[hv_GreenIdx] = hv_CurrentColor;
        break;
      }
      else if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(
          new HTuple((new HTuple(hv_ClassNames.TupleLength())).TupleGreater(8)))) != 0)
      {
        //If number of classes is larger than 8, set the respective color to green.
        if (hv_Colors == null)
          hv_Colors = new HTuple();
        hv_Colors[hv_GoodIdx] = "#00ff00";
        break;
      }
    }

    hv_NumColors.Dispose();
    hv_ColorsRainbow.Dispose();
    hv_ClassNamesGood.Dispose();
    hv_IndexFind.Dispose();
    hv_GoodIdx.Dispose();
    hv_CurrentColor.Dispose();
    hv_GreenIdx.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Display and return the classified images. 
  public void get_dl_classifier_image_results (out HObject ho_Images, HTuple hv_ImageFiles, 
      HTuple hv_GroundTruthLabels, HTuple hv_PredictedClasses, HTuple hv_GenParamName, 
      HTuple hv_GenParamValue, HTuple hv_WindowHandle)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image=null;

    // Local control variables 

    HTuple hv_LabelSelection = new HTuple(), hv_PredictedClassSelection = new HTuple();
    HTuple hv_GlobalSelection = new HTuple(), hv_DisplayImages = new HTuple();
    HTuple hv_DisplayButtons = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_Mask = new HTuple(), hv_ImageIndex = new HTuple();
    HTuple hv_Label = new HTuple(), hv_PredictedClass = new HTuple();
    HTuple hv_Text = new HTuple(), hv_Color = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    HTuple hv_ButtonLabel = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_TextWidth = new HTuple();
    HTuple hv_TextHeight = new HTuple(), hv_ButtonRow = new HTuple();
    HTuple hv_ButtonColumn = new HTuple(), hv_ColorLabels = new HTuple();
    HTuple hv_HighlightColor = new HTuple(), hv_SelectedButton = new HTuple();
    HTuple   hv_GroundTruthLabels_COPY_INP_TMP = new HTuple(hv_GroundTruthLabels);
    HTuple   hv_ImageFiles_COPY_INP_TMP = new HTuple(hv_ImageFiles);
    HTuple   hv_PredictedClasses_COPY_INP_TMP = new HTuple(hv_PredictedClasses);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Images);
    HOperatorSet.GenEmptyObj(out ho_Image);
    //This procedure can be used to visualize classified
    //ImageFiles selected according to the specifications
    //given with GenParamName and GenParamValue.
    //
    //Set parameter defaults.
    hv_LabelSelection.Dispose();
    hv_LabelSelection = "all";
    hv_PredictedClassSelection.Dispose();
    hv_PredictedClassSelection = "all";
    hv_GlobalSelection.Dispose();
    hv_GlobalSelection = "erroneously_classified";
    hv_DisplayImages.Dispose();
    hv_DisplayImages = "true";
    hv_DisplayButtons.Dispose();
    hv_DisplayButtons = "false";
    //
    //Check if number of elements in
    //GenParamName and GenParamValue is equal.
    if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleNotEqual(
        new HTuple(hv_GenParamValue.TupleLength())))) != 0)
    {
      throw new HalconException("Number of generic parameter names does not match number of generic parameter values.");
    }
    //
    //Parse generic parameters.
    for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
        ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
    {
      if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "label_selection"))) != 0)
      {
        //Set 'label_selection'.
        hv_LabelSelection.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LabelSelection = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "predicted_class_selection"))) != 0)
      {
        //Set 'predicted_class_selection'.
        hv_PredictedClassSelection.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PredictedClassSelection = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "global_selection"))) != 0)
      {
        //Set 'global_selection'.
        hv_GlobalSelection.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GlobalSelection = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "display_images"))) != 0)
      {
        //Set 'display_images'.
        hv_DisplayImages.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DisplayImages = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "display_buttons"))) != 0)
      {
        //Set 'display_buttons'.
        hv_DisplayButtons.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DisplayButtons = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else
      {
        throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
            hv_GenParamIndex)))+"'");
      }
    }
    //
    //Filter data according to LabelSelection.
    if ((int)(new HTuple(hv_LabelSelection.TupleNotEqual("all"))) != 0)
    {
      hv_Mask.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Mask = hv_GroundTruthLabels_COPY_INP_TMP.TupleEqualElem(
          hv_LabelSelection);
      }
      if ((int)(new HTuple(((hv_Mask.TupleSum())).TupleEqual(0))) != 0)
      {
        throw new HalconException(("LabelSelection '"+hv_LabelSelection)+"' not found in GroundTruthLabels.");
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageFiles = hv_ImageFiles_COPY_INP_TMP.TupleSelectMask(
          hv_Mask);
      hv_ImageFiles_COPY_INP_TMP.Dispose();
      hv_ImageFiles_COPY_INP_TMP = ExpTmpLocalVar_ImageFiles;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_GroundTruthLabels = hv_GroundTruthLabels_COPY_INP_TMP.TupleSelectMask(
          hv_Mask);
      hv_GroundTruthLabels_COPY_INP_TMP.Dispose();
      hv_GroundTruthLabels_COPY_INP_TMP = ExpTmpLocalVar_GroundTruthLabels;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PredictedClasses = hv_PredictedClasses_COPY_INP_TMP.TupleSelectMask(
          hv_Mask);
      hv_PredictedClasses_COPY_INP_TMP.Dispose();
      hv_PredictedClasses_COPY_INP_TMP = ExpTmpLocalVar_PredictedClasses;
      }
      }
    }
    //
    //Filter data according to PredictedClassSelection.
    if ((int)(new HTuple(hv_PredictedClassSelection.TupleNotEqual("all"))) != 0)
    {
      hv_Mask.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Mask = hv_PredictedClasses_COPY_INP_TMP.TupleEqualElem(
          hv_PredictedClassSelection);
      }
      if ((int)(new HTuple(((hv_Mask.TupleSum())).TupleEqual(0))) != 0)
      {
        throw new HalconException(("PredictedClassSelection '"+hv_PredictedClassSelection)+"' not found in PredictedClasses.");
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageFiles = hv_ImageFiles_COPY_INP_TMP.TupleSelectMask(
          hv_Mask);
      hv_ImageFiles_COPY_INP_TMP.Dispose();
      hv_ImageFiles_COPY_INP_TMP = ExpTmpLocalVar_ImageFiles;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_GroundTruthLabels = hv_GroundTruthLabels_COPY_INP_TMP.TupleSelectMask(
          hv_Mask);
      hv_GroundTruthLabels_COPY_INP_TMP.Dispose();
      hv_GroundTruthLabels_COPY_INP_TMP = ExpTmpLocalVar_GroundTruthLabels;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PredictedClasses = hv_PredictedClasses_COPY_INP_TMP.TupleSelectMask(
          hv_Mask);
      hv_PredictedClasses_COPY_INP_TMP.Dispose();
      hv_PredictedClasses_COPY_INP_TMP = ExpTmpLocalVar_PredictedClasses;
      }
      }
    }
    //
    //Filter data according to GlobalSelection.
    if ((int)(new HTuple(hv_GlobalSelection.TupleNotEqual("all"))) != 0)
    {
      hv_Mask.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Mask = hv_GroundTruthLabels_COPY_INP_TMP.TupleEqualElem(
          hv_PredictedClasses_COPY_INP_TMP);
      }
      if ((int)(new HTuple(hv_GlobalSelection.TupleEqual("erroneously_classified"))) != 0)
      {
        //Flip the mask.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Mask = ((hv_Mask-1)).TupleAbs()
            ;
        hv_Mask.Dispose();
        hv_Mask = ExpTmpLocalVar_Mask;
        }
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageFiles = hv_ImageFiles_COPY_INP_TMP.TupleSelectMask(
          hv_Mask);
      hv_ImageFiles_COPY_INP_TMP.Dispose();
      hv_ImageFiles_COPY_INP_TMP = ExpTmpLocalVar_ImageFiles;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_GroundTruthLabels = hv_GroundTruthLabels_COPY_INP_TMP.TupleSelectMask(
          hv_Mask);
      hv_GroundTruthLabels_COPY_INP_TMP.Dispose();
      hv_GroundTruthLabels_COPY_INP_TMP = ExpTmpLocalVar_GroundTruthLabels;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_PredictedClasses = hv_PredictedClasses_COPY_INP_TMP.TupleSelectMask(
          hv_Mask);
      hv_PredictedClasses_COPY_INP_TMP.Dispose();
      hv_PredictedClasses_COPY_INP_TMP = ExpTmpLocalVar_PredictedClasses;
      }
      }
    }
    //
    if ((int)(new HTuple(hv_DisplayImages.TupleEqual("true"))) != 0)
    {
      //Loop over the images.
      ho_Images.Dispose();
      HOperatorSet.GenEmptyObj(out ho_Images);
      for (hv_ImageIndex=0; (int)hv_ImageIndex<=(int)((new HTuple(hv_ImageFiles_COPY_INP_TMP.TupleLength()
          ))-1); hv_ImageIndex = (int)hv_ImageIndex + 1)
      {
        //
        //Concatenate selected images.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Image.Dispose();
        HOperatorSet.ReadImage(out ho_Image, hv_ImageFiles_COPY_INP_TMP.TupleSelect(
            hv_ImageIndex));
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_Images, ho_Image, out ExpTmpOutVar_0);
        ho_Images.Dispose();
        ho_Images = ExpTmpOutVar_0;
        }
        //
        hv_Label.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Label = hv_GroundTruthLabels_COPY_INP_TMP.TupleSelect(
            hv_ImageIndex);
        }
        hv_PredictedClass.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PredictedClass = hv_PredictedClasses_COPY_INP_TMP.TupleSelect(
            hv_ImageIndex);
        }
        //
        hv_Text.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Text = (("Image "+(hv_ImageIndex+1))+"/")+(new HTuple(hv_ImageFiles_COPY_INP_TMP.TupleLength()
            ));
        }
        if (hv_Text == null)
          hv_Text = new HTuple();
        hv_Text[1] = "Label: "+hv_Label;
        if (hv_Text == null)
          hv_Text = new HTuple();
        hv_Text[2] = "Predicted Class: "+hv_PredictedClass;
        if ((int)(new HTuple(hv_Label.TupleEqual(hv_PredictedClass))) != 0)
        {
          hv_Color.Dispose();
          hv_Color = "forest green";
        }
        else
        {
          hv_Color.Dispose();
          hv_Color = "red";
        }
        //
        //Display the image.
        dev_resize_window_fit_image(ho_Image, 0, 0, -1, -1);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
              "left", ((new HTuple("black")).TupleConcat("black")).TupleConcat(hv_Color), 
              "box_color", "#ffffffaa");
          }
        }
        if ((int)(new HTuple(hv_DisplayButtons.TupleEqual("false"))) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
                "window", "bottom", "right", "black", "box_color", "#ffffffaa");
          }
          // stop(...); only in hdevelop
        }
        else
        {
          hv_Row.Dispose();hv_Column.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
          HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, 
              out hv_WindowWidth, out hv_WindowHeight);
          hv_ButtonLabel.Dispose();
          hv_ButtonLabel = new HTuple();
          hv_ButtonLabel[0] = "Next image";
          hv_ButtonLabel[1] = "Continue";
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_ButtonLabel.TupleSelect(
              0), out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
          }
          hv_ButtonRow.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ButtonRow = new HTuple();
          hv_ButtonRow = hv_ButtonRow.TupleConcat((hv_WindowHeight-hv_TextHeight)-20);
          hv_ButtonRow = hv_ButtonRow.TupleConcat((hv_WindowHeight-hv_TextHeight)-20);
          }
          hv_ButtonColumn.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ButtonColumn = new HTuple();
          hv_ButtonColumn[0] = 20;
          hv_ButtonColumn = hv_ButtonColumn.TupleConcat((hv_WindowWidth-hv_TextWidth)-40);
          }
          hv_ColorLabels.Dispose();
          hv_ColorLabels = "black";
          hv_Color.Dispose();
          hv_Color = new HTuple();
          hv_Color[0] = "#fce9d4";
          hv_Color[1] = "#fce9d4";
          hv_HighlightColor.Dispose();
          hv_HighlightColor = "#f28d26";
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SelectedButton.Dispose();
          dev_disp_button(hv_ButtonLabel, hv_ButtonRow, hv_ButtonColumn, hv_TextWidth*1.2, 
              hv_TextHeight*1.2, hv_ColorLabels, hv_Color, hv_HighlightColor, hv_WindowHandle, 
              out hv_SelectedButton);
          }
          if ((int)(new HTuple(hv_SelectedButton.TupleEqual(0))) != 0)
          {
            HOperatorSet.WaitSeconds(0.1);
          }
          else
          {
            ho_Image.Dispose();

            hv_GroundTruthLabels_COPY_INP_TMP.Dispose();
            hv_ImageFiles_COPY_INP_TMP.Dispose();
            hv_PredictedClasses_COPY_INP_TMP.Dispose();
            hv_LabelSelection.Dispose();
            hv_PredictedClassSelection.Dispose();
            hv_GlobalSelection.Dispose();
            hv_DisplayImages.Dispose();
            hv_DisplayButtons.Dispose();
            hv_GenParamIndex.Dispose();
            hv_Mask.Dispose();
            hv_ImageIndex.Dispose();
            hv_Label.Dispose();
            hv_PredictedClass.Dispose();
            hv_Text.Dispose();
            hv_Color.Dispose();
            hv_Row.Dispose();
            hv_Column.Dispose();
            hv_WindowWidth.Dispose();
            hv_WindowHeight.Dispose();
            hv_ButtonLabel.Dispose();
            hv_Ascent.Dispose();
            hv_Descent.Dispose();
            hv_TextWidth.Dispose();
            hv_TextHeight.Dispose();
            hv_ButtonRow.Dispose();
            hv_ButtonColumn.Dispose();
            hv_ColorLabels.Dispose();
            hv_HighlightColor.Dispose();
            hv_SelectedButton.Dispose();

            return;
          }
        }
      }
    }
    else
    {
      ho_Images.Dispose();
      HOperatorSet.ReadImage(out ho_Images, hv_ImageFiles_COPY_INP_TMP);
    }
    ho_Image.Dispose();

    hv_GroundTruthLabels_COPY_INP_TMP.Dispose();
    hv_ImageFiles_COPY_INP_TMP.Dispose();
    hv_PredictedClasses_COPY_INP_TMP.Dispose();
    hv_LabelSelection.Dispose();
    hv_PredictedClassSelection.Dispose();
    hv_GlobalSelection.Dispose();
    hv_DisplayImages.Dispose();
    hv_DisplayButtons.Dispose();
    hv_GenParamIndex.Dispose();
    hv_Mask.Dispose();
    hv_ImageIndex.Dispose();
    hv_Label.Dispose();
    hv_PredictedClass.Dispose();
    hv_Text.Dispose();
    hv_Color.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();
    hv_ButtonLabel.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_TextWidth.Dispose();
    hv_TextHeight.Dispose();
    hv_ButtonRow.Dispose();
    hv_ButtonColumn.Dispose();
    hv_ColorLabels.Dispose();
    hv_HighlightColor.Dispose();
    hv_SelectedButton.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Transformations
  public void get_extent_by_axis (HTuple hv_OM3D, HTuple hv_XExtent, HTuple hv_YExtent, 
      HTuple hv_ZExtent, out HTuple hv_XExtentOut, out HTuple hv_YExtentOut, out HTuple hv_ZExtentOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_BB = new HTuple(), hv_Index = new HTuple();
    // Initialize local and output iconic variables 
    hv_XExtentOut = new HTuple();
    hv_YExtentOut = new HTuple();
    hv_ZExtentOut = new HTuple();
    hv_XExtentOut.Dispose();
    hv_XExtentOut = new HTuple(hv_XExtent);
    hv_YExtentOut.Dispose();
    hv_YExtentOut = new HTuple(hv_YExtent);
    hv_ZExtentOut.Dispose();
    hv_ZExtentOut = new HTuple(hv_ZExtent);
    hv_BB.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_OM3D, "bounding_box1", out hv_BB);
    for (hv_Index=0; (int)hv_Index<=(int)(((new HTuple(hv_BB.TupleLength()))/6)-1); hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_XExtentOut = ((hv_XExtentOut.TupleConcat(
          hv_BB.TupleSelect(hv_Index*6)))).TupleConcat(hv_BB.TupleSelect((hv_Index*6)+3));
      hv_XExtentOut.Dispose();
      hv_XExtentOut = ExpTmpLocalVar_XExtentOut;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_YExtentOut = ((hv_YExtentOut.TupleConcat(
          hv_BB.TupleSelect((hv_Index*6)+1)))).TupleConcat(hv_BB.TupleSelect((hv_Index*6)+4));
      hv_YExtentOut.Dispose();
      hv_YExtentOut = ExpTmpLocalVar_YExtentOut;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ZExtentOut = ((hv_ZExtentOut.TupleConcat(
          hv_BB.TupleSelect((hv_Index*6)+2)))).TupleConcat(hv_BB.TupleSelect((hv_Index*6)+5));
      hv_ZExtentOut.Dispose();
      hv_ZExtentOut = ExpTmpLocalVar_ZExtentOut;
      }
      }
    }

    hv_BB.Dispose();
    hv_Index.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Returns the length of the feature vector for each feature name. 
  public void get_feature_lengths (HTuple hv_FeatureNames, out HTuple hv_Lengths)
  {



    // Local iconic variables 

    HObject ho_Region, ho_Image;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_Image);
    hv_Lengths = new HTuple();
    //
    //Calculate the lengths of the feature vectors of
    //the features in FeatureNames.
    //
    ho_Region.Dispose();ho_Image.Dispose();
    gen_dummy_objects(out ho_Region, out ho_Image);
    hv_Lengths.Dispose();
    get_features(ho_Region, ho_Image, hv_FeatureNames, "get_lengths", out hv_Lengths);
    ho_Region.Dispose();
    ho_Image.Dispose();


    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Returns a list of feature names that belong to the feature groups given in GroupNames. 
  public void get_feature_names (HTuple hv_GroupNames, out HTuple hv_Names)
  {



    // Local iconic variables 

    HObject ho_Region, ho_Image;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_Image);
    hv_Names = new HTuple();
    //
    //Return all features that belong to
    //at least one of the groups in GroupNames
    //
    ho_Region.Dispose();ho_Image.Dispose();
    gen_dummy_objects(out ho_Region, out ho_Image);
    hv_Names.Dispose();
    get_features(ho_Region, ho_Image, hv_GroupNames, "get_names", out hv_Names);
    ho_Region.Dispose();
    ho_Image.Dispose();


    return;
  }

  // Chapter: Classification / Misc
  // Short Description: This procedure contains all relevant information about the supported features. 
  public void get_features (HObject ho_Region, HObject ho_Image, HTuple hv_Namelist, 
      HTuple hv_Mode, out HTuple hv_Output)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_EmptyRegionResult = new HTuple();
    HTuple hv_AccumulatedResults = new HTuple(), hv_CustomResults = new HTuple();
    HTuple hv_NumRegions = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_I = new HTuple();
    HTuple hv_CurrentName = new HTuple(), hv_Name = new HTuple();
    HTuple hv_Groups = new HTuple(), hv_Feature = new HTuple();
    HTuple hv__ = new HTuple(), hv_ExtendedResults = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
    HTuple hv_Ra = new HTuple(), hv_Rb = new HTuple(), hv_Phi = new HTuple();
    HTuple hv_Distance = new HTuple(), hv_Sigma = new HTuple();
    HTuple hv_Roundness = new HTuple(), hv_Sides = new HTuple();
    HTuple hv_NumConnected = new HTuple(), hv_NumHoles = new HTuple();
    HTuple hv_Diameter = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Anisometry = new HTuple();
    HTuple hv_Bulkiness = new HTuple(), hv_StructureFactor = new HTuple();
    HTuple hv_Length1 = new HTuple(), hv_Length2 = new HTuple();
    HTuple hv_ContLength = new HTuple(), hv_AreaHoles = new HTuple();
    HTuple hv_Area = new HTuple(), hv_Min = new HTuple(), hv_Max = new HTuple();
    HTuple hv_Range = new HTuple(), hv_Mean = new HTuple();
    HTuple hv_Deviation = new HTuple(), hv_Entropy = new HTuple();
    HTuple hv_Anisotropy = new HTuple(), hv_Size = new HTuple();
    HTuple hv_NumBins = new HTuple(), hv_NameRegExp = new HTuple();
    HTuple hv_Names = new HTuple(), hv_NumPyramids = new HTuple();
    HTuple hv_Energy = new HTuple(), hv_Correlation = new HTuple();
    HTuple hv_Homogeneity = new HTuple(), hv_Contrast = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_Projection = new HTuple();
    HTuple hv_Start = new HTuple(), hv_Histo = new HTuple();
    HTuple hv_BinSize = new HTuple();
    // Initialize local and output iconic variables 
    hv_Output = new HTuple();
    //*********************************************************
    //Feature procedure
    //Contains the names, properties and calculation of
    //all supproted features.
    //It consists of similar blocks for each feature.
    //
    //If you like to add your own features, please use
    //the external procedure get_custom_features.hdvp
    //in the HALCON procedures/templates directory.
    //*********************************************************
    //
    //Insert location of your custom procedure here
    //
    hv_EmptyRegionResult.Dispose();
    HOperatorSet.GetSystem("empty_region_result", out hv_EmptyRegionResult);
    HOperatorSet.SetSystem("empty_region_result", "true");
    hv_AccumulatedResults.Dispose();
    hv_AccumulatedResults = new HTuple();
    hv_CustomResults.Dispose();
    hv_CustomResults = new HTuple();
    hv_NumRegions.Dispose();
    HOperatorSet.CountObj(ho_Region, out hv_NumRegions);
    hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    //
    for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Namelist.TupleLength()))-1); hv_I = (int)hv_I + 1)
    {
      hv_CurrentName.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentName = hv_Namelist.TupleSelect(
          hv_I);
      }
      //
      hv_CustomResults.Dispose();
      get_custom_features(ho_Region, ho_Image, hv_CurrentName, hv_Mode, out hv_CustomResults);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_AccumulatedResults = hv_AccumulatedResults.TupleConcat(
          hv_CustomResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = ExpTmpLocalVar_AccumulatedResults;
      }
      }
      //
      //
      //************************************
      //HALCON REGION FEATURES
      //************************************
      //
      //************************************
      //BASIC
      //************************************
      //** area ***
      hv_Name.Dispose();
      hv_Name = "area";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();hv__.Dispose();hv__.Dispose();
        HOperatorSet.AreaCenter(ho_Region, out hv_Feature, out hv__, out hv__);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** width ***
      hv_Name.Dispose();
      hv_Name = "width";
      hv_Groups.Dispose();
      hv_Groups = "region";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
        HOperatorSet.SmallestRectangle1(ho_Region, out hv_Row1, out hv_Column1, out hv_Row2, 
            out hv_Column2);
        hv_Feature.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Feature = (hv_Column2-hv_Column1)+1;
        }
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** height ***
      hv_Name.Dispose();
      hv_Name = "height";
      hv_Groups.Dispose();
      hv_Groups = "region";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
        HOperatorSet.SmallestRectangle1(ho_Region, out hv_Row1, out hv_Column1, out hv_Row2, 
            out hv_Column2);
        hv_Feature.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Feature = (hv_Row2-hv_Row1)+1;
        }
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** ra ***
      hv_Name.Dispose();
      hv_Name = "ra";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Ra.Dispose();hv_Rb.Dispose();hv_Phi.Dispose();
        HOperatorSet.EllipticAxis(ho_Region, out hv_Ra, out hv_Rb, out hv_Phi);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Ra);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** rb ***
      hv_Name.Dispose();
      hv_Name = "rb";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Ra.Dispose();hv_Rb.Dispose();hv_Phi.Dispose();
        HOperatorSet.EllipticAxis(ho_Region, out hv_Ra, out hv_Rb, out hv_Phi);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Rb);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** phi ***
      hv_Name.Dispose();
      hv_Name = "phi";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Ra.Dispose();hv_Rb.Dispose();hv_Phi.Dispose();
        HOperatorSet.EllipticAxis(ho_Region, out hv_Ra, out hv_Rb, out hv_Phi);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Phi);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** roundness ***
      hv_Name.Dispose();
      hv_Name = "roundness";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Distance.Dispose();hv_Sigma.Dispose();hv_Roundness.Dispose();hv_Sides.Dispose();
        HOperatorSet.Roundness(ho_Region, out hv_Distance, out hv_Sigma, out hv_Roundness, 
            out hv_Sides);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Roundness);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** num_sides ***
      hv_Name.Dispose();
      hv_Name = "num_sides";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Distance.Dispose();hv_Sigma.Dispose();hv_Roundness.Dispose();hv_Sides.Dispose();
        HOperatorSet.Roundness(ho_Region, out hv_Distance, out hv_Sigma, out hv_Roundness, 
            out hv_Sides);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Sides);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** num_connected ***
      hv_Name.Dispose();
      hv_Name = "num_connected";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_NumConnected.Dispose();hv_NumHoles.Dispose();
        HOperatorSet.ConnectAndHoles(ho_Region, out hv_NumConnected, out hv_NumHoles);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_NumConnected);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** num_holes ***
      hv_Name.Dispose();
      hv_Name = "num_holes";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_NumConnected.Dispose();hv_NumHoles.Dispose();
        HOperatorSet.ConnectAndHoles(ho_Region, out hv_NumConnected, out hv_NumHoles);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_NumHoles);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** area_holes ***
      hv_Name.Dispose();
      hv_Name = "area_holes";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        HOperatorSet.AreaHoles(ho_Region, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** max_diameter ***
      hv_Name.Dispose();
      hv_Name = "max_diameter";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();hv_Diameter.Dispose();
        HOperatorSet.DiameterRegion(ho_Region, out hv_Row1, out hv_Column1, out hv_Row2, 
            out hv_Column2, out hv_Diameter);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Diameter);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** orientation ***
      hv_Name.Dispose();
      hv_Name = "orientation";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        HOperatorSet.OrientationRegion(ho_Region, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //SHAPE
      //************************************
      //
      //************************************
      //** outer_radius ***
      hv_Name.Dispose();
      hv_Name = "outer_radius";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Row.Dispose();hv_Column.Dispose();hv_Feature.Dispose();
        HOperatorSet.SmallestCircle(ho_Region, out hv_Row, out hv_Column, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** inner_radius ***
      hv_Name.Dispose();
      hv_Name = "inner_radius";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Row.Dispose();hv_Column.Dispose();hv_Feature.Dispose();
        HOperatorSet.InnerCircle(ho_Region, out hv_Row, out hv_Column, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** inner_width ***
      hv_Name.Dispose();
      hv_Name = "inner_width";
      hv_Groups.Dispose();
      hv_Groups = "region";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
        HOperatorSet.InnerRectangle1(ho_Region, out hv_Row1, out hv_Column1, out hv_Row2, 
            out hv_Column2);
        hv_Feature.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Feature = (hv_Column2-hv_Column1)+1;
        }
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** inner_height ***
      hv_Name.Dispose();
      hv_Name = "inner_height";
      hv_Groups.Dispose();
      hv_Groups = "region";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
        HOperatorSet.InnerRectangle1(ho_Region, out hv_Row1, out hv_Column1, out hv_Row2, 
            out hv_Column2);
        hv_Feature.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Feature = (hv_Row2-hv_Row1)+1;
        }
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** circularity ***
      hv_Name.Dispose();
      hv_Name = "circularity";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        HOperatorSet.Circularity(ho_Region, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** compactness ***
      hv_Name.Dispose();
      hv_Name = "compactness";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        HOperatorSet.Compactness(ho_Region, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** convexity ***
      hv_Name.Dispose();
      hv_Name = "convexity";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        HOperatorSet.Convexity(ho_Region, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** rectangularity ***
      hv_Name.Dispose();
      hv_Name = "rectangularity";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        HOperatorSet.Rectangularity(ho_Region, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** anisometry ***
      hv_Name.Dispose();
      hv_Name = "anisometry";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Anisometry.Dispose();hv_Bulkiness.Dispose();hv_StructureFactor.Dispose();
        HOperatorSet.Eccentricity(ho_Region, out hv_Anisometry, out hv_Bulkiness, 
            out hv_StructureFactor);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Anisometry);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** bulkiness ***
      hv_Name.Dispose();
      hv_Name = "bulkiness";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Anisometry.Dispose();hv_Bulkiness.Dispose();hv_StructureFactor.Dispose();
        HOperatorSet.Eccentricity(ho_Region, out hv_Anisometry, out hv_Bulkiness, 
            out hv_StructureFactor);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Bulkiness);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** struct_factor ***
      hv_Name.Dispose();
      hv_Name = "struct_factor";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Anisometry.Dispose();hv_Bulkiness.Dispose();hv_StructureFactor.Dispose();
        HOperatorSet.Eccentricity(ho_Region, out hv_Anisometry, out hv_Bulkiness, 
            out hv_StructureFactor);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_StructureFactor);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** dist_mean ***
      hv_Name.Dispose();
      hv_Name = "dist_mean";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Distance.Dispose();hv_Sigma.Dispose();hv_Roundness.Dispose();hv_Sides.Dispose();
        HOperatorSet.Roundness(ho_Region, out hv_Distance, out hv_Sigma, out hv_Roundness, 
            out hv_Sides);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Distance);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** dist_deviation ***
      hv_Name.Dispose();
      hv_Name = "dist_deviation";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Distance.Dispose();hv_Sigma.Dispose();hv_Roundness.Dispose();hv_Sides.Dispose();
        HOperatorSet.Roundness(ho_Region, out hv_Distance, out hv_Sigma, out hv_Roundness, 
            out hv_Sides);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Sigma);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** euler_number ***
      hv_Name.Dispose();
      hv_Name = "euler_number";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        HOperatorSet.EulerNumber(ho_Region, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** rect2_phi ***
      hv_Name.Dispose();
      hv_Name = "rect2_phi";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Row.Dispose();hv_Column.Dispose();hv_Phi.Dispose();hv_Length1.Dispose();hv_Length2.Dispose();
        HOperatorSet.SmallestRectangle2(ho_Region, out hv_Row, out hv_Column, out hv_Phi, 
            out hv_Length1, out hv_Length2);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Phi);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** rect2_len1 ***
      hv_Name.Dispose();
      hv_Name = "rect2_len1";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Row.Dispose();hv_Column.Dispose();hv_Phi.Dispose();hv_Length1.Dispose();hv_Length2.Dispose();
        HOperatorSet.SmallestRectangle2(ho_Region, out hv_Row, out hv_Column, out hv_Phi, 
            out hv_Length1, out hv_Length2);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Length1);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** rect2_len2 ***
      hv_Name.Dispose();
      hv_Name = "rect2_len2";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Row.Dispose();hv_Column.Dispose();hv_Phi.Dispose();hv_Length1.Dispose();hv_Length2.Dispose();
        HOperatorSet.SmallestRectangle2(ho_Region, out hv_Row, out hv_Column, out hv_Phi, 
            out hv_Length1, out hv_Length2);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Length2);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** contlength ***
      hv_Name.Dispose();
      hv_Name = "contlength";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_ContLength.Dispose();
        HOperatorSet.Contlength(ho_Region, out hv_ContLength);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_ContLength);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //REGION FEATURES
      //************************************
      //MISC
      //************************************
      //** porosity ***
      hv_Name.Dispose();
      hv_Name = "porosity";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "region";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_AreaHoles.Dispose();
        HOperatorSet.AreaHoles(ho_Region, out hv_AreaHoles);
        hv_Area.Dispose();hv_Row.Dispose();hv_Column.Dispose();
        HOperatorSet.AreaCenter(ho_Region, out hv_Area, out hv_Row, out hv_Column);
        if ((int)(new HTuple(hv_Area.TupleEqual(0))) != 0)
        {
          hv_Feature.Dispose();
          hv_Feature = 0.0;
        }
        else
        {
          hv_Feature.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Feature = (hv_AreaHoles.TupleReal()
              )/(hv_Area+hv_AreaHoles);
          }
        }
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //HALCON GRAY VALUE FEATURES
      //************************************
      //BASIC
      //************************************
      //
      //** gray_area ***
      hv_Name.Dispose();
      hv_Name = "gray_area";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Area.Dispose();hv_Row.Dispose();hv_Column.Dispose();
        HOperatorSet.AreaCenterGray(ho_Region, ho_Image, out hv_Area, out hv_Row, 
            out hv_Column);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Area);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_ra ***
      hv_Name.Dispose();
      hv_Name = "gray_ra";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Ra.Dispose();hv_Rb.Dispose();hv_Phi.Dispose();
        HOperatorSet.EllipticAxisGray(ho_Region, ho_Image, out hv_Ra, out hv_Rb, 
            out hv_Phi);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Ra);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_rb ***
      hv_Name.Dispose();
      hv_Name = "gray_rb";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Ra.Dispose();hv_Rb.Dispose();hv_Phi.Dispose();
        HOperatorSet.EllipticAxisGray(ho_Region, ho_Image, out hv_Ra, out hv_Rb, 
            out hv_Phi);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Rb);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_phi ***
      hv_Name.Dispose();
      hv_Name = "gray_phi";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Ra.Dispose();hv_Rb.Dispose();hv_Phi.Dispose();
        HOperatorSet.EllipticAxisGray(ho_Region, ho_Image, out hv_Ra, out hv_Rb, 
            out hv_Phi);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Phi);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_min ***
      hv_Name.Dispose();
      hv_Name = "gray_min";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
        HOperatorSet.MinMaxGray(ho_Region, ho_Image, 0, out hv_Min, out hv_Max, out hv_Range);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Min);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_max ***
      hv_Name.Dispose();
      hv_Name = "gray_max";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
        HOperatorSet.MinMaxGray(ho_Region, ho_Image, 0, out hv_Min, out hv_Max, out hv_Range);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Max);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_range ***
      hv_Name.Dispose();
      hv_Name = "gray_range";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
        HOperatorSet.MinMaxGray(ho_Region, ho_Image, 0, out hv_Min, out hv_Max, out hv_Range);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Range);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //TEXTURE
      //************************************
      //
      //************************************
      //** gray_mean ***
      hv_Name.Dispose();
      hv_Name = "gray_mean";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "rot_invar";
      hv_Groups[3] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Mean.Dispose();hv_Deviation.Dispose();
        HOperatorSet.Intensity(ho_Region, ho_Image, out hv_Mean, out hv_Deviation);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Mean);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_deviation ***
      hv_Name.Dispose();
      hv_Name = "gray_deviation";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "rot_invar";
      hv_Groups[3] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Mean.Dispose();hv_Deviation.Dispose();
        HOperatorSet.Intensity(ho_Region, ho_Image, out hv_Mean, out hv_Deviation);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Deviation);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_plane_deviation ***
      hv_Name.Dispose();
      hv_Name = "gray_plane_deviation";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "rot_invar";
      hv_Groups[3] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        HOperatorSet.PlaneDeviation(ho_Region, ho_Image, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_anisotropy ***
      hv_Name.Dispose();
      hv_Name = "gray_anisotropy";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "rot_invar";
      hv_Groups[3] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Entropy.Dispose();hv_Anisotropy.Dispose();
        HOperatorSet.EntropyGray(ho_Region, ho_Image, out hv_Entropy, out hv_Anisotropy);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Anisotropy);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_entropy ***
      hv_Name.Dispose();
      hv_Name = "gray_entropy";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "rot_invar";
      hv_Groups[3] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Entropy.Dispose();hv_Anisotropy.Dispose();
        HOperatorSet.EntropyGray(ho_Region, ho_Image, out hv_Entropy, out hv_Anisotropy);
        hv_Feature.Dispose();
        hv_Feature = new HTuple(hv_Entropy);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_hor_proj ***
      hv_Name.Dispose();
      hv_Name = "gray_hor_proj";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Size.Dispose();
        hv_Size = 20;
        hv_Feature.Dispose();
        calc_feature_gray_proj(ho_Region, ho_Image, "hor", hv_Size, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_vert_proj ***
      hv_Name.Dispose();
      hv_Name = "gray_vert_proj";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Size.Dispose();
        hv_Size = 20;
        hv_Feature.Dispose();
        calc_feature_gray_proj(ho_Region, ho_Image, "vert", hv_Size, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_hor_proj_histo ***
      hv_Name.Dispose();
      hv_Name = "gray_hor_proj_histo";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Size.Dispose();
        hv_Size = 20;
        hv_Feature.Dispose();
        calc_feature_gray_proj(ho_Region, ho_Image, "hor_histo", hv_Size, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** gray_vert_proj_histo ***
      hv_Name.Dispose();
      hv_Name = "gray_vert_proj_histo";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Size.Dispose();
        hv_Size = 20;
        hv_Feature.Dispose();
        calc_feature_gray_proj(ho_Region, ho_Image, "vert_histo", hv_Size, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** grad_dir_histo ***
      hv_Name.Dispose();
      hv_Name = "grad_dir_histo";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_NumBins.Dispose();
        hv_NumBins = 20;
        hv_Feature.Dispose();
        calc_feature_grad_dir_histo(ho_Region, ho_Image, hv_NumBins, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** edge_density ***
      hv_Name.Dispose();
      hv_Name = "edge_density";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "rot_invar";
      hv_Groups[3] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        calc_feature_edge_density(ho_Region, ho_Image, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** edge_density_histogram ***
      hv_Name.Dispose();
      hv_Name = "edge_density_histogram";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "rot_invar";
      hv_Groups[3] = "scale_invar";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_NumBins.Dispose();
        hv_NumBins = 4;
        hv_Feature.Dispose();
        calc_feature_edge_density_histogram(ho_Region, ho_Image, hv_NumBins, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** edge_density_pyramid ***
      hv_NameRegExp.Dispose();
      hv_NameRegExp = "edge_density_pyramid_([234])";
      hv_Names.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Names = new HTuple("edge_density_pyramid_")+HTuple.TupleGenSequence(
          2,4,1);
      }
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "rot_invar";
      hv_Groups[3] = "scale_invar";
      //****************
      if ((int)(hv_CurrentName.TupleRegexpTest(hv_NameRegExp)) != 0)
      {
        //** Calculate feature ***
        hv_NumPyramids.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumPyramids = ((hv_CurrentName.TupleRegexpMatch(
            hv_NameRegExp))).TupleNumber();
        }
        hv_Feature.Dispose();
        calc_feature_pyramid(ho_Region, ho_Image, "edge_density", hv_NumPyramids, 
            out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups_pyramid(hv_Mode, hv_Groups, hv_CurrentName, hv_Names, 
          hv_NameRegExp, hv_AccumulatedResults, out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** edge_density_histogram_pyramid ***
      hv_NameRegExp.Dispose();
      hv_NameRegExp = "edge_density_histogram_pyramid_([234])";
      hv_Names.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Names = new HTuple("edge_density_histogram_pyramid_")+HTuple.TupleGenSequence(
          2,4,1);
      }
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      hv_Groups[2] = "rot_invar";
      hv_Groups[3] = "scale_invar";
      //****************
      if ((int)(hv_CurrentName.TupleRegexpTest(hv_NameRegExp)) != 0)
      {
        //** Calculate feature ***
        hv_NumPyramids.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumPyramids = ((hv_CurrentName.TupleRegexpMatch(
            hv_NameRegExp))).TupleNumber();
        }
        hv_Feature.Dispose();
        calc_feature_pyramid(ho_Region, ho_Image, "edge_density_histogram", hv_NumPyramids, 
            out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups_pyramid(hv_Mode, hv_Groups, hv_CurrentName, hv_Names, 
          hv_NameRegExp, hv_AccumulatedResults, out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //** cooc ***
      hv_Name.Dispose();
      hv_Name = "cooc";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      //****************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        hv_Feature = new HTuple();
        hv_Energy.Dispose();hv_Correlation.Dispose();hv_Homogeneity.Dispose();hv_Contrast.Dispose();
        HOperatorSet.CoocFeatureImage(ho_Region, ho_Image, 6, 0, out hv_Energy, out hv_Correlation, 
            out hv_Homogeneity, out hv_Contrast);
        if ((int)(new HTuple(hv_NumRegions.TupleGreater(0))) != 0)
        {
          hv_Index.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Index = HTuple.TupleGenSequence(
              0,(4*hv_NumRegions)-1,4);
          }
          if (hv_Feature == null)
            hv_Feature = new HTuple();
          hv_Feature[hv_Index] = hv_Energy;
          if (hv_Feature == null)
            hv_Feature = new HTuple();
          hv_Feature[1+hv_Index] = hv_Correlation;
          if (hv_Feature == null)
            hv_Feature = new HTuple();
          hv_Feature[2+hv_Index] = hv_Homogeneity;
          if (hv_Feature == null)
            hv_Feature = new HTuple();
          hv_Feature[3+hv_Index] = hv_Contrast;
        }
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** cooc_pyramid ***
      hv_NameRegExp.Dispose();
      hv_NameRegExp = "cooc_pyramid_([234])";
      hv_Names.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Names = new HTuple("cooc_pyramid_")+HTuple.TupleGenSequence(
          2,4,1);
      }
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "texture";
      //****************
      if ((int)(hv_CurrentName.TupleRegexpTest(hv_NameRegExp)) != 0)
      {
        //** Calculate feature ***
        hv_NumPyramids.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumPyramids = ((hv_CurrentName.TupleRegexpMatch(
            hv_NameRegExp))).TupleNumber();
        }
        hv_Feature.Dispose();
        calc_feature_pyramid(ho_Region, ho_Image, "cooc", hv_NumPyramids, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups_pyramid(hv_Mode, hv_Groups, hv_CurrentName, hv_Names, 
          hv_NameRegExp, hv_AccumulatedResults, out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //
      //************************************
      //
      //************************************
      //POLAR TRANSFORM FEATURES
      //************************************
      //
      //************************************
      //** polar_gray_proj ***
      hv_Name.Dispose();
      hv_Name = "polar_gray_proj";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Width.Dispose();
        hv_Width = 100;
        hv_Height.Dispose();
        hv_Height = 40;
        hv_Feature.Dispose();
        calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_gray", hv_Width, hv_Height, 
            out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** polar_grad_proj ***
      hv_Name.Dispose();
      hv_Name = "polar_grad_proj";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Width.Dispose();
        hv_Width = 100;
        hv_Height.Dispose();
        hv_Height = 40;
        hv_Feature.Dispose();
        calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_sobel_amp", hv_Width, 
            hv_Height, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** polar_grad_x_proj ***
      hv_Name.Dispose();
      hv_Name = "polar_grad_x_proj";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Width.Dispose();
        hv_Width = 100;
        hv_Height.Dispose();
        hv_Height = 40;
        hv_Feature.Dispose();
        calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_sobel_x", hv_Width, 
            hv_Height, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** polar_grad_y_proj ***
      hv_Name.Dispose();
      hv_Name = "polar_grad_y_proj";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Width.Dispose();
        hv_Width = 100;
        hv_Height.Dispose();
        hv_Height = 40;
        hv_Feature.Dispose();
        calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_sobel_y", hv_Width, 
            hv_Height, out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** polar_gray_proj_histo ***
      hv_Name.Dispose();
      hv_Name = "polar_gray_proj_histo";
      hv_Groups.Dispose();
      hv_Groups = new HTuple();
      hv_Groups[0] = "gray";
      hv_Groups[1] = "rot_invar";
      hv_Groups[2] = "scale_invar";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Width.Dispose();
        hv_Width = 100;
        hv_Height.Dispose();
        hv_Height = 40;
        hv_Projection.Dispose();
        calc_feature_polar_gray_proj(ho_Region, ho_Image, "vert_gray", hv_Width, 
            hv_Height, out hv_Projection);
        hv_NumBins.Dispose();
        hv_NumBins = 20;
        hv_Feature.Dispose();
        hv_Feature = new HTuple();
        HTuple end_val1093 = hv_NumRegions;
        HTuple step_val1093 = 1;
        for (hv_Index=1; hv_Index.Continue(end_val1093, step_val1093); hv_Index = hv_Index.TupleAdd(step_val1093))
        {
          hv_Start.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Start = (hv_Index-1)*hv_Width;
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Histo.Dispose();hv_BinSize.Dispose();
          HOperatorSet.TupleHistoRange(hv_Projection.TupleSelectRange(hv_Start,(hv_Start+hv_Width)-1), 
              0, 255, hv_NumBins, out hv_Histo, out hv_BinSize);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Feature = hv_Feature.TupleConcat(
              hv_Histo);
          hv_Feature.Dispose();
          hv_Feature = ExpTmpLocalVar_Feature;
          }
          }
        }
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //COLOR FEATURES
      //************************************
      //
      //************************************
      //** cielab_mean ***
      hv_Name.Dispose();
      hv_Name = "cielab_mean";
      hv_Groups.Dispose();
      hv_Groups = "color";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        calc_feature_color_intensity(ho_Region, ho_Image, "cielab", "mean", out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** cielab_dev ***
      hv_Name.Dispose();
      hv_Name = "cielab_dev";
      hv_Groups.Dispose();
      hv_Groups = "color";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        calc_feature_color_intensity(ho_Region, ho_Image, "cielab", "deviation", 
            out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** hls_mean ***
      hv_Name.Dispose();
      hv_Name = "hls_mean";
      hv_Groups.Dispose();
      hv_Groups = "color";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        calc_feature_color_intensity(ho_Region, ho_Image, "hls", "mean", out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** hls_dev ***
      hv_Name.Dispose();
      hv_Name = "hls_dev";
      hv_Groups.Dispose();
      hv_Groups = "color";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        calc_feature_color_intensity(ho_Region, ho_Image, "hls", "deviation", out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** rgb_mean ***
      hv_Name.Dispose();
      hv_Name = "rgb_mean";
      hv_Groups.Dispose();
      hv_Groups = "color";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        calc_feature_color_intensity(ho_Region, ho_Image, "rgb", "mean", out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      //************************************
      //
      //************************************
      //** rgb_dev ***
      hv_Name.Dispose();
      hv_Name = "rgb_dev";
      hv_Groups.Dispose();
      hv_Groups = "color";
      //*************
      if ((int)(new HTuple(hv_Name.TupleEqual(hv_CurrentName))) != 0)
      {
        //** Calculate feature ***
        hv_Feature.Dispose();
        calc_feature_color_intensity(ho_Region, ho_Image, "rgb", "deviation", out hv_Feature);
        //*************************
        hv_ExtendedResults.Dispose();
        append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, out hv_ExtendedResults);
        hv_AccumulatedResults.Dispose();
        hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
      }
      hv_ExtendedResults.Dispose();
      append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
          out hv_ExtendedResults);
      hv_AccumulatedResults.Dispose();
      hv_AccumulatedResults = new HTuple(hv_ExtendedResults);
    }
    hv_Output.Dispose();
    hv_Output = new HTuple(hv_AccumulatedResults);
    HOperatorSet.SetSystem("empty_region_result", hv_EmptyRegionResult);

    hv_EmptyRegionResult.Dispose();
    hv_AccumulatedResults.Dispose();
    hv_CustomResults.Dispose();
    hv_NumRegions.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_I.Dispose();
    hv_CurrentName.Dispose();
    hv_Name.Dispose();
    hv_Groups.Dispose();
    hv_Feature.Dispose();
    hv__.Dispose();
    hv_ExtendedResults.Dispose();
    hv_Row1.Dispose();
    hv_Column1.Dispose();
    hv_Row2.Dispose();
    hv_Column2.Dispose();
    hv_Ra.Dispose();
    hv_Rb.Dispose();
    hv_Phi.Dispose();
    hv_Distance.Dispose();
    hv_Sigma.Dispose();
    hv_Roundness.Dispose();
    hv_Sides.Dispose();
    hv_NumConnected.Dispose();
    hv_NumHoles.Dispose();
    hv_Diameter.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Anisometry.Dispose();
    hv_Bulkiness.Dispose();
    hv_StructureFactor.Dispose();
    hv_Length1.Dispose();
    hv_Length2.Dispose();
    hv_ContLength.Dispose();
    hv_AreaHoles.Dispose();
    hv_Area.Dispose();
    hv_Min.Dispose();
    hv_Max.Dispose();
    hv_Range.Dispose();
    hv_Mean.Dispose();
    hv_Deviation.Dispose();
    hv_Entropy.Dispose();
    hv_Anisotropy.Dispose();
    hv_Size.Dispose();
    hv_NumBins.Dispose();
    hv_NameRegExp.Dispose();
    hv_Names.Dispose();
    hv_NumPyramids.Dispose();
    hv_Energy.Dispose();
    hv_Correlation.Dispose();
    hv_Homogeneity.Dispose();
    hv_Contrast.Dispose();
    hv_Index.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_Projection.Dispose();
    hv_Start.Dispose();
    hv_Histo.Dispose();
    hv_BinSize.Dispose();

    return;
  }

  public void get_find_parameter (HTuple hv_GenParamNames, HTuple hv_GenParamValues, 
      HTuple hv_ParamName, HTuple hv_DefaultValue, out HTuple hv_ParamValue)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Idx = new HTuple();
    // Initialize local and output iconic variables 
    hv_ParamValue = new HTuple();
    hv_ParamValue.Dispose();
    hv_ParamValue = new HTuple(hv_DefaultValue);
    hv_Idx.Dispose();
    HOperatorSet.TupleFind(hv_GenParamNames, hv_ParamName, out hv_Idx);
    if ((int)((new HTuple(hv_Idx.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Idx.TupleNotEqual(
        new HTuple())))) != 0)
    {
      hv_ParamValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ParamValue = hv_GenParamValues.TupleSelect(
          hv_Idx);
      }
    }

    hv_Idx.Dispose();

    return;
  }

  public void get_find_surface_model_param (HTuple hv_ParamName, HTuple hv_DefaultValue, 
      HTuple hv_GenParamNames, HTuple hv_GenParamValues, HTuple hv_ConvertBoolToInt, 
      out HTuple hv_ParamValue)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ValidParamNames = new HTuple(), hv_Pos = new HTuple();
    // Initialize local and output iconic variables 
    hv_ParamValue = new HTuple();
    if ((int)(1) != 0)
    {
      //Debug Check: Is the parameter valid?
      hv_ValidParamNames.Dispose();
      HOperatorSet.GetParamInfo("find_surface_model_image", "GenParamName", "value_list", 
          out hv_ValidParamNames);
      hv_Pos.Dispose();
      HOperatorSet.TupleFind(hv_ValidParamNames, hv_ParamName, out hv_Pos);
      if ((int)((new HTuple(hv_Pos.TupleEqual(-1))).TupleOr(new HTuple(hv_Pos.TupleEqual(
          new HTuple())))) != 0)
      {
        throw new HalconException("Invalid parameter name: "+hv_ParamName);
      }
    }

    hv_Pos.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Pos = hv_GenParamNames.TupleFind(
        hv_ParamName);
    }
    if ((int)((new HTuple(hv_Pos.TupleNotEqual(new HTuple()))).TupleAnd(new HTuple(hv_Pos.TupleNotEqual(
        -1)))) != 0)
    {
      //If the parameter is set multiple times, use the last.
      hv_ParamValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ParamValue = hv_GenParamValues.TupleSelect(
          hv_Pos.TupleSelect((new HTuple(hv_Pos.TupleLength()))-1));
      }
    }
    else
    {
      hv_ParamValue.Dispose();
      hv_ParamValue = new HTuple(hv_DefaultValue);
    }

    if ((int)(hv_ConvertBoolToInt) != 0)
    {
      if ((int)(new HTuple(hv_ParamValue.TupleEqual("true"))) != 0)
      {
        hv_ParamValue.Dispose();
        hv_ParamValue = 1;
      }
      if ((int)(new HTuple(hv_ParamValue.TupleEqual("false"))) != 0)
      {
        hv_ParamValue.Dispose();
        hv_ParamValue = 0;
      }
    }


    hv_ValidParamNames.Dispose();
    hv_Pos.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Get a parameter value from GenParamValue with the name RequestedGenParamName. 
  public void get_genparam_single_value (HTuple hv_GenParamName, HTuple hv_GenParamValue, 
      HTuple hv_RequestedGenParamName, out HTuple hv_FoundGenParamValue)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Indices = new HTuple();
    // Initialize local and output iconic variables 
    hv_FoundGenParamValue = new HTuple();
    //
    //Get a parameter value from GenParamValue with the name RequestedGenParamName,
    //which is allowed to appear only once in GenParamName.
    //
    //Set a default in case no value is provided.
    hv_FoundGenParamValue.Dispose();
    hv_FoundGenParamValue = new HTuple();
    //Set user provided values, if provided.
    hv_Indices.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Indices = hv_GenParamName.TupleFind(
        hv_RequestedGenParamName);
    }
    if ((int)((new HTuple((new HTuple(hv_Indices.TupleLength())).TupleEqual(1))).TupleAnd(
        new HTuple(hv_Indices.TupleNotEqual(-1)))) != 0)
    {
      hv_FoundGenParamValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FoundGenParamValue = hv_GenParamValue.TupleSelect(
          hv_Indices);
      }
    }
    else if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
        1))) != 0)
    {
      //Throw an error if more than one value was provided for RequestedGenParamName.
      throw new HalconException(("Only a single evaluate parameter dictionary or none is allowed for '"+hv_RequestedGenParamName)+"'.");
    }

    hv_Indices.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  public void get_image (out HObject ho_Image, HTuple hv_SampleKeys, HTuple hv_DLSample)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image"))).TupleNotEqual(-1))) != 0)
    {
      ho_Image.Dispose();
      HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
    }
    else
    {
      throw new HalconException("Image could not be found in DLSample.");
    }


    return;
  }

  public void get_image_direction (HObject ho_Image, out HTuple hv_MedianDirection)
  {



    // Local iconic variables 

    HObject ho_Domain, ho_RegionTrans, ho_XWithNeighbor;

    // Local control variables 

    HTuple hv_Direction = new HTuple(), hv_Rows = new HTuple();
    HTuple hv_Columns = new HTuple(), hv_Grayval1 = new HTuple();
    HTuple hv_Grayval2 = new HTuple(), hv_Diff = new HTuple();
    HTuple hv_MedianDiff1 = new HTuple(), hv_MedianDiff2 = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Domain);
    HOperatorSet.GenEmptyObj(out ho_RegionTrans);
    HOperatorSet.GenEmptyObj(out ho_XWithNeighbor);
    hv_MedianDirection = new HTuple();
    hv_Direction.Dispose();
    hv_Direction = new HTuple();
    hv_Direction[0] = 1;
    hv_Direction[1] = 0;
    ho_Domain.Dispose();
    HOperatorSet.GetDomain(ho_Image, out ho_Domain);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_RegionTrans.Dispose();
    HOperatorSet.AffineTransRegion(ho_Domain, out ho_RegionTrans, ((((((new HTuple(1)).TupleConcat(
        0)).TupleConcat(hv_Direction.TupleSelect(1)))).TupleConcat((new HTuple(0)).TupleConcat(
        1)))).TupleConcat(hv_Direction.TupleSelect(0)), "false");
    }
    ho_XWithNeighbor.Dispose();
    HOperatorSet.Intersection(ho_Image, ho_RegionTrans, out ho_XWithNeighbor);
    hv_Rows.Dispose();hv_Columns.Dispose();
    HOperatorSet.GetRegionPoints(ho_XWithNeighbor, out hv_Rows, out hv_Columns);
    if ((int)(new HTuple((new HTuple(hv_Columns.TupleLength())).TupleGreater(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Grayval1.Dispose();
      HOperatorSet.GetGrayval(ho_Image, hv_Rows-(hv_Direction.TupleSelect(1)), hv_Columns-(hv_Direction.TupleSelect(
          0)), out hv_Grayval1);
      }
      hv_Grayval2.Dispose();
      HOperatorSet.GetGrayval(ho_Image, hv_Rows, hv_Columns, out hv_Grayval2);
      hv_Diff.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Diff = hv_Grayval2-hv_Grayval1;
      }
      hv_MedianDiff1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MedianDiff1 = hv_Diff.TupleMedian()
          ;
      }
    }
    else
    {
      hv_MedianDirection.Dispose();
      hv_MedianDirection = new HTuple();
      hv_MedianDirection[0] = 0;
      hv_MedianDirection[1] = 0;
      ho_Domain.Dispose();
      ho_RegionTrans.Dispose();
      ho_XWithNeighbor.Dispose();

      hv_Direction.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Grayval1.Dispose();
      hv_Grayval2.Dispose();
      hv_Diff.Dispose();
      hv_MedianDiff1.Dispose();
      hv_MedianDiff2.Dispose();

      return;
    }

    hv_Direction.Dispose();
    hv_Direction = new HTuple();
    hv_Direction[0] = 0;
    hv_Direction[1] = 1;
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_RegionTrans.Dispose();
    HOperatorSet.AffineTransRegion(ho_Image, out ho_RegionTrans, ((((((new HTuple(1)).TupleConcat(
        0)).TupleConcat(hv_Direction.TupleSelect(1)))).TupleConcat((new HTuple(0)).TupleConcat(
        1)))).TupleConcat(hv_Direction.TupleSelect(0)), "nearest_neighbor");
    }
    ho_XWithNeighbor.Dispose();
    HOperatorSet.Intersection(ho_Image, ho_RegionTrans, out ho_XWithNeighbor);
    hv_Rows.Dispose();hv_Columns.Dispose();
    HOperatorSet.GetRegionPoints(ho_XWithNeighbor, out hv_Rows, out hv_Columns);
    if ((int)(new HTuple((new HTuple(hv_Columns.TupleLength())).TupleGreater(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Grayval1.Dispose();
      HOperatorSet.GetGrayval(ho_Image, hv_Rows-(hv_Direction.TupleSelect(1)), hv_Columns-(hv_Direction.TupleSelect(
          0)), out hv_Grayval1);
      }
      hv_Grayval2.Dispose();
      HOperatorSet.GetGrayval(ho_Image, hv_Rows, hv_Columns, out hv_Grayval2);
      hv_Diff.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Diff = hv_Grayval2-hv_Grayval1;
      }
      hv_MedianDiff2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MedianDiff2 = hv_Diff.TupleMedian()
          ;
      }
    }
    else
    {
      hv_MedianDirection.Dispose();
      hv_MedianDirection = new HTuple();
      hv_MedianDirection[0] = 0;
      hv_MedianDirection[1] = 0;
      ho_Domain.Dispose();
      ho_RegionTrans.Dispose();
      ho_XWithNeighbor.Dispose();

      hv_Direction.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Grayval1.Dispose();
      hv_Grayval2.Dispose();
      hv_Diff.Dispose();
      hv_MedianDiff1.Dispose();
      hv_MedianDiff2.Dispose();

      return;
    }

    hv_MedianDirection.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MedianDirection = new HTuple();
    hv_MedianDirection = hv_MedianDirection.TupleConcat(hv_MedianDiff1, hv_MedianDiff2);
    }

    ho_Domain.Dispose();
    ho_RegionTrans.Dispose();
    ho_XWithNeighbor.Dispose();

    hv_Direction.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_Grayval1.Dispose();
    hv_Grayval2.Dispose();
    hv_Diff.Dispose();
    hv_MedianDiff1.Dispose();
    hv_MedianDiff2.Dispose();

    return;
  }

  public void get_mouse_info (HTuple hv_WindowHandle, HTuple hv_MessageQueue, HTuple hv_Timeout, 
      out HTuple hv_Row, out HTuple hv_Column, out HTuple hv_Button)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MessageHandle = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_H_ERR_TIMEOUT = new HTuple(), hv_MessageType = new HTuple();
    // Initialize local and output iconic variables 
    hv_Row = new HTuple();
    hv_Column = new HTuple();
    hv_Button = new HTuple();
    //Initialize as "no event"
    hv_Row.Dispose();
    hv_Row = -1;
    hv_Column.Dispose();
    hv_Column = -1;
    hv_Button.Dispose();
    hv_Button = -1;
    //
    if ((int)(new HTuple(hv_MessageQueue.TupleEqual(new HTuple()))) != 0)
    {
      hv_Row.Dispose();hv_Column.Dispose();hv_Button.Dispose();
      HOperatorSet.GetMpositionSubPix(hv_WindowHandle, out hv_Row, out hv_Column, 
          out hv_Button);
    }
    else
    {
      //Queue-based visualization
      if ((int)(new HTuple(hv_Timeout.TupleEqual(new HTuple()))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MessageHandle.Dispose();
        HOperatorSet.DequeueMessage(hv_MessageQueue.TupleSelect(0), new HTuple(), 
            new HTuple(), out hv_MessageHandle);
        }
      }
      else
      {
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MessageHandle.Dispose();
          HOperatorSet.DequeueMessage(hv_MessageQueue.TupleSelect(0), "timeout", 
              hv_Timeout, out hv_MessageHandle);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          hv_H_ERR_TIMEOUT.Dispose();
          hv_H_ERR_TIMEOUT = 9400;
          if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(hv_H_ERR_TIMEOUT))) != 0)
          {

            hv_MessageHandle.Dispose();
            hv_Exception.Dispose();
            hv_H_ERR_TIMEOUT.Dispose();
            hv_MessageType.Dispose();

            return;
          }
          else
          {
            throw new HalconException(hv_Exception);
          }
        }
      }
      hv_MessageType.Dispose();
      HOperatorSet.GetMessageTuple(hv_MessageHandle, "type", out hv_MessageType);
      if ((int)(new HTuple(hv_MessageType.TupleEqual("mouse_event"))) != 0)
      {
        hv_Row.Dispose();
        HOperatorSet.GetMessageTuple(hv_MessageHandle, "mouse_row", out hv_Row);
        hv_Column.Dispose();
        HOperatorSet.GetMessageTuple(hv_MessageHandle, "mouse_col", out hv_Column);
        hv_Button.Dispose();
        HOperatorSet.GetMessageTuple(hv_MessageHandle, "mouse_button", out hv_Button);
        HOperatorSet.ClearMessage(hv_MessageHandle);
      }
      else
      {
        HOperatorSet.ClearMessage(hv_MessageHandle);
        throw new HalconException("Unknown or unexpected message type: "+hv_MessageType);
      }
    }

    //Normalize the button
    if ((int)(new HTuple(hv_Button.TupleEqual(new HTuple()))) != 0)
    {
      hv_Button.Dispose();
      hv_Button = 0;
    }

    hv_MessageHandle.Dispose();
    hv_Exception.Dispose();
    hv_H_ERR_TIMEOUT.Dispose();
    hv_MessageType.Dispose();

    return;
  }

  // Chapter: Calibration / Hand-Eye
  // Short Description: Get the coordinates of the central mark of the closest finder pattern. 
  public void get_nearest_finder_pattern_coordinates (HObject ho_CalibPlateImage, 
      HTuple hv_RowNearFinderPattern, HTuple hv_ColumNearFinderPattern, HTuple hv_CalibObjectData, 
      out HTuple hv_RowFinderPattern, out HTuple hv_ColumnFinderPattern)
  {




    // Local iconic variables 

    HObject ho_Contours, ho_Region, ho_RegionUnion;

    // Local control variables 

    HTuple hv_CamParam = new HTuple(), hv_CalPlateDescr = new HTuple();
    HTuple hv_MarksPerRow = new HTuple(), hv_FinderRow = new HTuple();
    HTuple hv_FinderColumn = new HTuple(), hv_CalibDataID = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Index1 = new HTuple();
    HTuple hv_Pose = new HTuple(), hv_Area1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
    HTuple hv_RowTmp = new HTuple(), hv_ColTmp = new HTuple();
    HTuple hv_Diff = new HTuple(), hv_IndexFinal = new HTuple();
    HTuple hv_RowToApproach1 = new HTuple(), hv_ColToApproach1 = new HTuple();
    HTuple hv_XCal = new HTuple(), hv_YCal = new HTuple();
    HTuple hv_ZCal = new HTuple(), hv_XFP = new HTuple(), hv_YFP = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_ZFP = new HTuple();
    HTuple hv_X1 = new HTuple(), hv_Y1 = new HTuple(), hv_Z1 = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Contours);
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_RegionUnion);
    hv_RowFinderPattern = new HTuple();
    hv_ColumnFinderPattern = new HTuple();
    //
    hv_CamParam.Dispose();
    read_dict_tuple(hv_CalibObjectData, "CamParam", out hv_CamParam);
    hv_CalPlateDescr.Dispose();
    read_dict_tuple(hv_CalibObjectData, "CalPlateDescr", out hv_CalPlateDescr);
    hv_MarksPerRow.Dispose();
    read_dict_tuple(hv_CalibObjectData, "MarksPerRow", out hv_MarksPerRow);
    hv_FinderRow.Dispose();
    read_dict_tuple(hv_CalibObjectData, "FinderRow", out hv_FinderRow);
    hv_FinderColumn.Dispose();
    read_dict_tuple(hv_CalibObjectData, "FinderColumn", out hv_FinderColumn);
    //
    //Check input.
    //
    //Check image coordinates.
    if ((int)((new HTuple((new HTuple(hv_RowNearFinderPattern.TupleLength())).TupleGreater(
        1))).TupleOr(new HTuple((new HTuple(hv_ColumNearFinderPattern.TupleLength()
        )).TupleGreater(1)))) != 0)
    {
      throw new HalconException("Please specify only one image coordinate.");
    }
    //Check number of marks per row.
    if ((int)(new HTuple(hv_MarksPerRow.TupleLess(3))) != 0)
    {
      throw new HalconException("At least three marks per row are necessary for a valid finder pattern.");
    }
    //Find calibration plate.
    hv_CalibDataID.Dispose();
    HOperatorSet.CreateCalibData("calibration_object", 1, 1, out hv_CalibDataID);
    HOperatorSet.SetCalibDataCamParam(hv_CalibDataID, 0, new HTuple(), hv_CamParam);
    HOperatorSet.SetCalibDataCalibObject(hv_CalibDataID, 0, hv_CalPlateDescr);
    try
    {
      HOperatorSet.FindCalibObject(ho_CalibPlateImage, hv_CalibDataID, 0, 0, 0, new HTuple(), 
          new HTuple());
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      throw new HalconException(new HTuple("Calibration plate could not be find, please make sure that at least one finder pattern is visible."));
    }
    hv_Row.Dispose();hv_Column.Dispose();hv_Index1.Dispose();hv_Pose.Dispose();
    HOperatorSet.GetCalibDataObservPoints(hv_CalibDataID, 0, 0, 0, out hv_Row, out hv_Column, 
        out hv_Index1, out hv_Pose);
    ho_Contours.Dispose();
    HOperatorSet.GetCalibDataObservContours(out ho_Contours, hv_CalibDataID, "caltab", 
        0, 0, 0);
    //Get the finder pattern used to find the calibration plate.
    ho_Region.Dispose();
    HOperatorSet.GenRegionContourXld(ho_Contours, out ho_Region, "filled");
    ho_RegionUnion.Dispose();
    HOperatorSet.Union1(ho_Region, out ho_RegionUnion);
    hv_Area1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
    HOperatorSet.AreaCenter(ho_RegionUnion, out hv_Area1, out hv_Row2, out hv_Column2);
    hv_RowTmp.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RowTmp = ((hv_Row-hv_Row2)).TupleAbs()
        ;
    }
    hv_ColTmp.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColTmp = ((hv_Column-hv_Column2)).TupleAbs()
        ;
    }
    hv_Diff.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Diff = (((hv_RowTmp*hv_RowTmp)+(hv_ColTmp*hv_ColTmp))).TupleSqrt()
        ;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IndexFinal.Dispose();
    HOperatorSet.TupleFind(hv_Diff, hv_Diff.TupleMin(), out hv_IndexFinal);
    }
    hv_RowToApproach1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RowToApproach1 = hv_Row.TupleSelect(
        hv_IndexFinal);
    }
    hv_ColToApproach1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColToApproach1 = hv_Column.TupleSelect(
        hv_IndexFinal);
    }
    HOperatorSet.ClearCalibData(hv_CalibDataID);
    //Get remaining finder pattern.
    //
    //Get finder pattern in world coordinates.
    hv_XCal.Dispose();hv_YCal.Dispose();hv_ZCal.Dispose();
    HOperatorSet.CaltabPoints(hv_CalPlateDescr, out hv_XCal, out hv_YCal, out hv_ZCal);
    hv_XFP.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XFP = hv_XCal.TupleSelect(
        (hv_FinderRow*hv_MarksPerRow)+hv_FinderColumn);
    }
    hv_YFP.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YFP = hv_YCal.TupleSelect(
        (hv_FinderRow*hv_MarksPerRow)+hv_FinderColumn);
    }
    //Get finder pattern in camera coordinates.
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_Pose, out hv_HomMat3D);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ZFP.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_XFP.TupleLength()), 0.0, out hv_ZFP);
    }
    hv_X1.Dispose();hv_Y1.Dispose();hv_Z1.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_XFP, hv_YFP, hv_ZFP, out hv_X1, 
        out hv_Y1, out hv_Z1);
    //Project into the image.
    hv_Row.Dispose();hv_Column.Dispose();
    HOperatorSet.Project3dPoint(hv_X1, hv_Y1, hv_Z1, hv_CamParam, out hv_Row, out hv_Column);
    //
    //Get the image coordinates that are the closest ones to the passed ones.
    hv_RowTmp.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RowTmp = ((hv_Row-hv_RowNearFinderPattern)).TupleAbs()
        ;
    }
    hv_ColTmp.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColTmp = ((hv_Column-hv_ColumNearFinderPattern)).TupleAbs()
        ;
    }
    hv_Diff.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Diff = (((hv_RowTmp*hv_RowTmp)+(hv_ColTmp*hv_ColTmp))).TupleSqrt()
        ;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IndexFinal.Dispose();
    HOperatorSet.TupleFind(hv_Diff, hv_Diff.TupleMin(), out hv_IndexFinal);
    }
    //Return the image coordinates.
    hv_RowFinderPattern.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RowFinderPattern = hv_Row.TupleSelect(
        hv_IndexFinal);
    }
    hv_ColumnFinderPattern.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ColumnFinderPattern = hv_Column.TupleSelect(
        hv_IndexFinal);
    }
    ho_Contours.Dispose();
    ho_Region.Dispose();
    ho_RegionUnion.Dispose();

    hv_CamParam.Dispose();
    hv_CalPlateDescr.Dispose();
    hv_MarksPerRow.Dispose();
    hv_FinderRow.Dispose();
    hv_FinderColumn.Dispose();
    hv_CalibDataID.Dispose();
    hv_Exception.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Index1.Dispose();
    hv_Pose.Dispose();
    hv_Area1.Dispose();
    hv_Row2.Dispose();
    hv_Column2.Dispose();
    hv_RowTmp.Dispose();
    hv_ColTmp.Dispose();
    hv_Diff.Dispose();
    hv_IndexFinal.Dispose();
    hv_RowToApproach1.Dispose();
    hv_ColToApproach1.Dispose();
    hv_XCal.Dispose();
    hv_YCal.Dispose();
    hv_ZCal.Dispose();
    hv_XFP.Dispose();
    hv_YFP.Dispose();
    hv_HomMat3D.Dispose();
    hv_ZFP.Dispose();
    hv_X1.Dispose();
    hv_Y1.Dispose();
    hv_Z1.Dispose();

    return;
  }

  // Chapter: Graphics / Window
  public void get_next_window (HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc, 
      HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows, 
      HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_CurrentWindowHandle, out HTuple hv_WindowImageRatio, 
      out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_Value = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_MetaInfo = new HTuple(), hv_SetPartRow2 = new HTuple();
    HTuple hv_SetpartColumn2 = new HTuple(), hv_MarginBottom = new HTuple();
    HTuple hv_SetPartColumn2 = new HTuple(), hv__ = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    HTuple hv_WindowRow2 = new HTuple(), hv_WindowColumn2 = new HTuple();
    HTuple hv_WindowRatio = new HTuple(), hv_WindowImageRatioHeight = new HTuple();
    HTuple hv_WindowImageRatioWidth = new HTuple(), hv_ImageRow2 = new HTuple();
    HTuple hv_ImageColumn2 = new HTuple(), hv_ImageRatio = new HTuple();
    HTuple hv_ImageWindowRatio = new HTuple(), hv_ImageRow2InWindow = new HTuple();
    HTuple hv_ImageCol2InWindow = new HTuple();
    HTuple   hv_MapColorBarWidth_COPY_INP_TMP = new HTuple(hv_MapColorBarWidth);

    // Initialize local and output iconic variables 
    hv_CurrentWindowHandle = new HTuple();
    hv_WindowImageRatio = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    //
    //This procedure returns the next window that
    //is used for visualization. If ReuseWindows is true
    //and WindowHandleList is suitable, the window handles
    //that are passed over are used. Else, this procedure
    //opens a new window, either next to the last ones, or
    //in a new row.
    //
    //First, check if the requested window is already available.
    hv_OpenNewWindow.Dispose();
    hv_OpenNewWindow = 0;
    try
    {
      hv_WindowHandles.Dispose();
      HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
      hv_CurrentWindowHandle.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentWindowHandle = hv_WindowHandles.TupleSelect(
          0);
      }
      //Check if window handle is valid.
      try
      {
        hv_Value.Dispose();
        HOperatorSet.GetWindowParam(hv_CurrentWindowHandle, "flush", out hv_Value);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException2)
      {
        HDevExpDefaultException2.ToHTuple(out hv_Exception);
        //If there is something wrong with the current window, create a new one.
        hv_OpenNewWindow.Dispose();
        hv_OpenNewWindow = 1;
        HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKey);
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_OpenNewWindow.Dispose();
      hv_OpenNewWindow = 1;
    }
    //
    //Get next window.
    if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
    {
      //
      //If possible, reuse existing window handles.
      HDevWindowStack.SetActive(hv_CurrentWindowHandle);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
      }
      set_display_font(hv_CurrentWindowHandle, hv_FontSize, hv_Font, "true", "false");
      //
      hv_MetaInfo.Dispose();
      HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
      //
      try
      {
        //
        //Clear window and set part, if possible.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SetPartRow2.Dispose();
        HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_row2", 
            out hv_SetPartRow2);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SetpartColumn2.Dispose();
        HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_column2", 
            out hv_SetpartColumn2);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_SetPartRow2, 
              hv_SetpartColumn2);
        }
        //
        //Get WindowImageRatio.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowImageRatio.Dispose();
        HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio", 
            out hv_WindowImageRatio);
        }
        //
        //Get previous window coordinates.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PrevWindowCoordinatesOut.Dispose();
        HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_coordinates", 
            out hv_PrevWindowCoordinatesOut);
        }
        //
        //Get MarginBottom and MapColorBarWidth.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MarginBottom.Dispose();
        HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_margin_bottom", 
            out hv_MarginBottom);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MapColorBarWidth_COPY_INP_TMP.Dispose();
        HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_map_color_bar_with", 
            out hv_MapColorBarWidth_COPY_INP_TMP);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //
        //Some meta information is missing -> set appropriate values.
        hv_WindowImageRatio.Dispose();hv_SetPartRow2.Dispose();hv_SetPartColumn2.Dispose();hv_PrevWindowCoordinatesOut.Dispose();hv_MarginBottom.Dispose();
        get_window_meta_information(hv_CurrentWindowHandle, hv_WidthImage, hv_HeightImage, 
            hv_MapColorBarWidth_COPY_INP_TMP, 0, 0, hv_ShowBottomDesc, out hv_WindowImageRatio, 
            out hv_SetPartRow2, out hv_SetPartColumn2, out hv_PrevWindowCoordinatesOut, 
            out hv_MarginBottom);
        //
        //Set meta information about the current window handle.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio", 
            hv_WindowImageRatio);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_coordinates", 
            hv_PrevWindowCoordinatesOut);
        }
        HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
      }
      //
      //Set window part such that image is displayed undistorted.
      hv__.Dispose();hv__.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
      HOperatorSet.GetWindowExtents(hv_CurrentWindowHandle, out hv__, out hv__, out hv_WindowWidth, 
          out hv_WindowHeight);
      hv_WindowRow2.Dispose();
      hv_WindowRow2 = new HTuple(hv_WindowHeight);
      hv_WindowColumn2.Dispose();
      hv_WindowColumn2 = new HTuple(hv_WindowWidth);
      hv_WindowRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowRatio = hv_WindowColumn2/(hv_WindowRow2*1.0);
      }
      //
      hv_WindowImageRatioHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowImageRatioHeight = hv_WindowHeight/(hv_HeightImage*1.0);
      }
      hv_WindowImageRatioWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowImageRatioWidth = hv_WindowWidth/(hv_WidthImage*1.0);
      }
      //
      hv_ImageRow2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageRow2 = hv_HeightImage+(hv_MarginBottom/hv_WindowImageRatioHeight);
      }
      hv_ImageColumn2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageColumn2 = hv_WidthImage+(hv_MapColorBarWidth_COPY_INP_TMP/hv_WindowImageRatioWidth);
      }
      hv_ImageRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageRatio = hv_ImageColumn2/(hv_ImageRow2*1.0);
      }
      if ((int)(new HTuple(hv_ImageRatio.TupleGreater(hv_WindowRatio))) != 0)
      {
        //Extend image until right window border.
        hv_SetPartColumn2.Dispose();
        hv_SetPartColumn2 = new HTuple(hv_ImageColumn2);
        //
        hv_ImageWindowRatio.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageWindowRatio = hv_ImageColumn2/(hv_WindowColumn2*1.0);
        }
        hv_ImageRow2InWindow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageRow2InWindow = hv_ImageRow2/hv_ImageWindowRatio;
        }
        hv_SetPartRow2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SetPartRow2 = hv_ImageRow2+((hv_WindowRow2-hv_ImageRow2InWindow)/hv_WindowImageRatioWidth);
        }
      }
      else
      {
        //Extend image until bottom of window.
        hv_SetPartRow2.Dispose();
        hv_SetPartRow2 = new HTuple(hv_ImageRow2);
        //
        hv_ImageWindowRatio.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageWindowRatio = hv_ImageRow2/(hv_WindowRow2*1.0);
        }
        hv_ImageCol2InWindow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageCol2InWindow = hv_ImageColumn2/hv_ImageWindowRatio;
        }
        hv_SetPartColumn2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SetPartColumn2 = hv_ImageColumn2+((hv_WindowColumn2-hv_ImageCol2InWindow)/hv_WindowImageRatioHeight);
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_SetPartRow2, hv_SetPartColumn2);
      }
      //
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_row2", 
          hv_SetPartRow2);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_column2", 
          hv_SetPartColumn2);
      }
    }
    else
    {
      //Open a new window.
      hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();hv_PrevWindowCoordinatesOut.Dispose();
      open_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, hv_HeightImage, 
          hv_MapColorBarWidth_COPY_INP_TMP, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
          hv_WindowHandleDict, hv_WindowHandleKey, out hv_CurrentWindowHandle, out hv_WindowImageRatio, 
          out hv_PrevWindowCoordinatesOut);
      HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "flush", "false");
    }

    hv_MapColorBarWidth_COPY_INP_TMP.Dispose();
    hv_OpenNewWindow.Dispose();
    hv_WindowHandles.Dispose();
    hv_Value.Dispose();
    hv_Exception.Dispose();
    hv_MetaInfo.Dispose();
    hv_SetPartRow2.Dispose();
    hv_SetpartColumn2.Dispose();
    hv_MarginBottom.Dispose();
    hv_SetPartColumn2.Dispose();
    hv__.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();
    hv_WindowRow2.Dispose();
    hv_WindowColumn2.Dispose();
    hv_WindowRatio.Dispose();
    hv_WindowImageRatioHeight.Dispose();
    hv_WindowImageRatioWidth.Dispose();
    hv_ImageRow2.Dispose();
    hv_ImageColumn2.Dispose();
    hv_ImageRatio.Dispose();
    hv_ImageWindowRatio.Dispose();
    hv_ImageRow2InWindow.Dispose();
    hv_ImageCol2InWindow.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Compute the center of all given 3D object models. 
  public void get_object_models_center (HTuple hv_ObjectModel3DID, out HTuple hv_Center)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Diameters = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Diameter = new HTuple(), hv_C = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_MD = new HTuple();
    HTuple hv_Weight = new HTuple(), hv_SumW = new HTuple();
    HTuple hv_ObjectModel3DIDSelected = new HTuple(), hv_InvSum = new HTuple();
    // Initialize local and output iconic variables 
    hv_Center = new HTuple();
    //Compute the mean of all model centers (weighted by the diameter of the object models)
    hv_Diameters.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Diameters = HTuple.TupleGenConst(
        new HTuple(hv_ObjectModel3DID.TupleLength()),0.0);
    }
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ObjectModel3DID.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      try
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Diameter.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID.TupleSelect(hv_Index), 
            "diameter_axis_aligned_bounding_box", out hv_Diameter);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_C.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DID.TupleSelect(hv_Index), 
            "center", out hv_C);
        }
        if (hv_Diameters == null)
          hv_Diameters = new HTuple();
        hv_Diameters[hv_Index] = hv_Diameter;
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //Object model is empty, has no center etc. -> ignore it by leaving its diameter at zero
      }
    }

    if ((int)(new HTuple(((hv_Diameters.TupleSum())).TupleGreater(0))) != 0)
    {
      //Normalize Diameter to use it as weights for a weighted mean of the individual centers
      hv_MD.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MD = ((hv_Diameters.TupleSelectMask(
          hv_Diameters.TupleGreaterElem(0)))).TupleMean();
      }
      if ((int)(new HTuple(hv_MD.TupleGreater(1e-10))) != 0)
      {
        hv_Weight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Weight = hv_Diameters/hv_MD;
        }
      }
      else
      {
        hv_Weight.Dispose();
        hv_Weight = new HTuple(hv_Diameters);
      }
      hv_SumW.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SumW = hv_Weight.TupleSum()
          ;
      }
      if ((int)(new HTuple(hv_SumW.TupleLess(1e-10))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Weight = HTuple.TupleGenConst(
            new HTuple(hv_Weight.TupleLength()),1.0);
        hv_Weight.Dispose();
        hv_Weight = ExpTmpLocalVar_Weight;
        }
        }
        hv_SumW.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SumW = hv_Weight.TupleSum()
            ;
        }
      }
      hv_Center.Dispose();
      hv_Center = new HTuple();
      hv_Center[0] = 0;
      hv_Center[1] = 0;
      hv_Center[2] = 0;
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ObjectModel3DID.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        if ((int)(new HTuple(((hv_Diameters.TupleSelect(hv_Index))).TupleGreater(
            0))) != 0)
        {
          hv_ObjectModel3DIDSelected.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ObjectModel3DIDSelected = hv_ObjectModel3DID.TupleSelect(
              hv_Index);
          }
          hv_C.Dispose();
          HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DIDSelected, "center", 
              out hv_C);
          if (hv_Center == null)
            hv_Center = new HTuple();
          hv_Center[0] = (hv_Center.TupleSelect(0))+((hv_C.TupleSelect(0))*(hv_Weight.TupleSelect(
              hv_Index)));
          if (hv_Center == null)
            hv_Center = new HTuple();
          hv_Center[1] = (hv_Center.TupleSelect(1))+((hv_C.TupleSelect(1))*(hv_Weight.TupleSelect(
              hv_Index)));
          if (hv_Center == null)
            hv_Center = new HTuple();
          hv_Center[2] = (hv_Center.TupleSelect(2))+((hv_C.TupleSelect(2))*(hv_Weight.TupleSelect(
              hv_Index)));
        }
      }
      hv_InvSum.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_InvSum = 1.0/hv_SumW;
      }
      if (hv_Center == null)
        hv_Center = new HTuple();
      hv_Center[0] = (hv_Center.TupleSelect(0))*hv_InvSum;
      if (hv_Center == null)
        hv_Center = new HTuple();
      hv_Center[1] = (hv_Center.TupleSelect(1))*hv_InvSum;
      if (hv_Center == null)
        hv_Center = new HTuple();
      hv_Center[2] = (hv_Center.TupleSelect(2))*hv_InvSum;
    }
    else
    {
      hv_Center.Dispose();
      hv_Center = new HTuple();
    }

    hv_Diameters.Dispose();
    hv_Index.Dispose();
    hv_Diameter.Dispose();
    hv_C.Dispose();
    hv_Exception.Dispose();
    hv_MD.Dispose();
    hv_Weight.Dispose();
    hv_SumW.Dispose();
    hv_ObjectModel3DIDSelected.Dispose();
    hv_InvSum.Dispose();

    return;
  }

  // Chapter: Transformations / Misc
  // Short Description: Calculate the touching point in tool coordinates. 
  public void get_robot_touching_point_in_tool_coordinates (HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePosesTouchingPoint, 
      out HTuple hv_RobotTouchingPointInToolCoordinates)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_LHS = new HTuple(), hv_RHS = new HTuple();
    HTuple hv_HomMat3D0 = new HTuple(), hv_Mat0 = new HTuple();
    HTuple hv_MatRot0 = new HTuple(), hv_MatTrans0 = new HTuple();
    HTuple hv_Index = new HTuple(), hv_HomMat3D = new HTuple();
    HTuple hv_Mat = new HTuple(), hv_MatRot = new HTuple();
    HTuple hv_MatTrans = new HTuple(), hv_MatrixResultID = new HTuple();
    HTuple hv_DetailedErrors = new HTuple(), hv_MinDiffToIdentity = new HTuple();
    HTuple hv_MinCosAngle = new HTuple(), hv_Index1 = new HTuple();
    HTuple hv_CosAngle = new HTuple(), hv_MaxAngleBetweenRotationAxes = new HTuple();
    HTuple hv_MatrixUID = new HTuple(), hv_MatrixSID = new HTuple();
    HTuple hv_MatrixVID = new HTuple(), hv_SingularValues = new HTuple();
    HTuple hv_MinSingularValue = new HTuple();

    HTupleVector hvec_RotationAxisRelativ = new HTupleVector(1);
    HTupleVector hvec_DiffToIdentity = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_RobotTouchingPointInToolCoordinates = new HTuple();
    //To estimate the touching point with respect to the tool coordinate system, we have to
    //arrange three equations in the following form:
    //Rp + T = q,
    //where R is a is the rotation matrix that rotates a point from the tool to the base coordinate
    //system and T is a translation that translates a point from the tool to the base coordinate.
    //q is the touching point with respect to the base coordinate system
    //and p the unknown touching point with respect to the tool coordinate system.
    //
    //Approaching the same point three times while rotating the tool leads to three rotation matrices
    //R0, R1 and R2 and three translations T0, T1 and T2.
    //Solving this equation for the unknown touching point yields therefore:
    //R0*p + T0 = q, R1*p + T1 = q and R2*p + T2 = q.
    //After building two equations in the form (R1-R0)*p = T0-T1 and (R2-R0)*p = T0-T2,
    //the DLT (direct linear transformation) can be used to efficiently solve for the unknown
    //touching point p.


    //Check input.
    if ((int)(new HTuple((new HTuple(hvec_ToolInBasePosesTouchingPoint.Length)).TupleLess(
        3))) != 0)
    {
      throw new HalconException("Please specify at least three robot poses.");
    }

    //Initialize equation.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_LHS.Dispose();
    HOperatorSet.CreateMatrix((new HTuple(hvec_ToolInBasePosesTouchingPoint.Length)-1)*3, 
        3, 0, out hv_LHS);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RHS.Dispose();
    HOperatorSet.CreateMatrix((new HTuple(hvec_ToolInBasePosesTouchingPoint.Length)-1)*3, 
        1, 0, out hv_RHS);
    }
    hvec_RotationAxisRelativ.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_RotationAxisRelativ = dh.Take((
        dh.Add(new HTupleVector(1)).Insert(0,dh.Add(new HTupleVector(new HTuple())))));
    }
    hvec_DiffToIdentity.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hvec_DiffToIdentity = dh.Take((
        dh.Add(new HTupleVector(1)).Insert(0,dh.Add(new HTupleVector(new HTuple())))));
    }
    //Decompose first pose.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HomMat3D0.Dispose();
    HOperatorSet.PoseToHomMat3d(hvec_ToolInBasePosesTouchingPoint[0].T, out hv_HomMat3D0);
    }
    hv_Mat0.Dispose();
    HOperatorSet.CreateMatrix(3, 4, hv_HomMat3D0, out hv_Mat0);
    hv_MatRot0.Dispose();
    HOperatorSet.GetSubMatrix(hv_Mat0, 0, 0, 3, 3, out hv_MatRot0);
    hv_MatTrans0.Dispose();
    HOperatorSet.GetSubMatrix(hv_Mat0, 0, 3, 3, 1, out hv_MatTrans0);
    //
    HTuple end_val33 = new HTuple(hvec_ToolInBasePosesTouchingPoint.Length)-1;
    HTuple step_val33 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val33, step_val33); hv_Index = hv_Index.TupleAdd(step_val33))
    {
      //Decompose current pose.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HomMat3D.Dispose();
      HOperatorSet.PoseToHomMat3d(hvec_ToolInBasePosesTouchingPoint[hv_Index].T, 
          out hv_HomMat3D);
      }
      hv_Mat.Dispose();
      HOperatorSet.CreateMatrix(3, 4, hv_HomMat3D, out hv_Mat);
      hv_MatRot.Dispose();
      HOperatorSet.GetSubMatrix(hv_Mat, 0, 0, 3, 3, out hv_MatRot);
      hv_MatTrans.Dispose();
      HOperatorSet.GetSubMatrix(hv_Mat, 0, 3, 3, 1, out hv_MatTrans);
      //Get rotation axis relativ to first pose.
      {
      HTuple ExpTmpOutVar_0;HTuple ExpTmpOutVar_1;
      get_rotation_axis(hv_MatRot, hv_MatRot0, out ExpTmpOutVar_0, out ExpTmpOutVar_1);
      hvec_RotationAxisRelativ[hv_Index].T = ExpTmpOutVar_0;
      ExpTmpOutVar_0.Dispose();
      hvec_DiffToIdentity[hv_Index].T = ExpTmpOutVar_1;
      ExpTmpOutVar_1.Dispose();
      }
      //Fill equation.
      HOperatorSet.SubMatrixMod(hv_MatRot, hv_MatRot0);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetSubMatrix(hv_LHS, hv_MatRot, (hv_Index-1)*3, 0);
      }
      HOperatorSet.SubMatrixMod(hv_MatTrans, hv_MatTrans0);
      HOperatorSet.ScaleMatrixMod(hv_MatTrans, -1.0);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetSubMatrix(hv_RHS, hv_MatTrans, (hv_Index-1)*3, 0);
      }
      //Clear.
      HOperatorSet.ClearMatrix(hv_Mat);
      HOperatorSet.ClearMatrix(hv_MatRot);
      HOperatorSet.ClearMatrix(hv_MatTrans);
    }
    //Solve.
    hv_MatrixResultID.Dispose();
    HOperatorSet.SolveMatrix(hv_LHS, "general", 0, hv_RHS, out hv_MatrixResultID);
    hv_RobotTouchingPointInToolCoordinates.Dispose();
    HOperatorSet.GetFullMatrix(hv_MatrixResultID, out hv_RobotTouchingPointInToolCoordinates);
    //Detailed errors.
    hv_DetailedErrors.Dispose();
    hv_DetailedErrors = 0;
    if ((int)(hv_DetailedErrors) != 0)
    {
      //Check that the tool was tilted enough compared to the first pose.
      hv_MinDiffToIdentity.Dispose();
      hv_MinDiffToIdentity = 1e8;
      HTuple end_val60 = new HTuple(hvec_ToolInBasePosesTouchingPoint.Length)-1;
      HTuple step_val60 = 1;
      for (hv_Index=1; hv_Index.Continue(end_val60, step_val60); hv_Index = hv_Index.TupleAdd(step_val60))
      {
        if ((int)(new HTuple((hvec_DiffToIdentity[hv_Index].T).TupleLess(hv_MinDiffToIdentity))) != 0)
        {
          hv_MinDiffToIdentity.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MinDiffToIdentity = new HTuple(hvec_DiffToIdentity[hv_Index].T);
          }
        }
      }
      //Check that different rotation axis were used when tilted away from first pose.
      hv_MinCosAngle.Dispose();
      hv_MinCosAngle = 1.5;
      HTuple end_val67 = new HTuple(hvec_ToolInBasePosesTouchingPoint.Length)-2;
      HTuple step_val67 = 1;
      for (hv_Index=1; hv_Index.Continue(end_val67, step_val67); hv_Index = hv_Index.TupleAdd(step_val67))
      {
        HTuple end_val68 = new HTuple(hvec_ToolInBasePosesTouchingPoint.Length)-1;
        HTuple step_val68 = 1;
        for (hv_Index1=hv_Index+1; hv_Index1.Continue(end_val68, step_val68); hv_Index1 = hv_Index1.TupleAdd(step_val68))
        {
          hv_CosAngle.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CosAngle = ((((hvec_RotationAxisRelativ[hv_Index].T*hvec_RotationAxisRelativ[hv_Index1].T)).TupleSum()
              )).TupleAbs();
          }
          if ((int)(new HTuple(hv_CosAngle.TupleLess(hv_MinCosAngle))) != 0)
          {
            hv_MinCosAngle.Dispose();
            hv_MinCosAngle = new HTuple(hv_CosAngle);
          }
        }
      }
      hv_MaxAngleBetweenRotationAxes.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxAngleBetweenRotationAxes = ((hv_MinCosAngle.TupleAcos()
          )).TupleDeg();
      }
    }
    hv_MatrixUID.Dispose();hv_MatrixSID.Dispose();hv_MatrixVID.Dispose();
    HOperatorSet.SvdMatrix(hv_LHS, "full", "both", out hv_MatrixUID, out hv_MatrixSID, 
        out hv_MatrixVID);
    hv_SingularValues.Dispose();
    HOperatorSet.GetValueMatrix(hv_MatrixSID, ((new HTuple(0)).TupleConcat(1)).TupleConcat(
        2), ((new HTuple(0)).TupleConcat(1)).TupleConcat(2), out hv_SingularValues);
    hv_MinSingularValue.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MinSingularValue = ((hv_SingularValues.TupleAbs()
        )).TupleMin();
    }
    if ((int)(new HTuple(hv_MinSingularValue.TupleLess(0.15))) != 0)
    {
      //Consider the rotations of the tool from its first position to each following position.
      //Please rotate the tool enough away from the first position.
      //Furthermore, please use at least two significantly different rotation axis when rotating the tool
      //from its first position (preferably orthogonal directions?).
      //The maximum angle between the corresponding rotation axis is MaxAngleBetweenRotationAxes.
      //
      throw new HalconException("The estimated touching point might not be reliable. Try to use at least two different rotation axis and/or increase the rotations around these axis.");
    }
    //
    //Clear.
    HOperatorSet.ClearMatrix(hv_MatrixUID);
    HOperatorSet.ClearMatrix(hv_MatrixSID);
    HOperatorSet.ClearMatrix(hv_MatrixVID);
    HOperatorSet.ClearMatrix(hv_Mat0);
    HOperatorSet.ClearMatrix(hv_MatRot0);
    HOperatorSet.ClearMatrix(hv_MatTrans0);
    HOperatorSet.ClearMatrix(hv_LHS);
    HOperatorSet.ClearMatrix(hv_RHS);

    hv_LHS.Dispose();
    hv_RHS.Dispose();
    hv_HomMat3D0.Dispose();
    hv_Mat0.Dispose();
    hv_MatRot0.Dispose();
    hv_MatTrans0.Dispose();
    hv_Index.Dispose();
    hv_HomMat3D.Dispose();
    hv_Mat.Dispose();
    hv_MatRot.Dispose();
    hv_MatTrans.Dispose();
    hv_MatrixResultID.Dispose();
    hv_DetailedErrors.Dispose();
    hv_MinDiffToIdentity.Dispose();
    hv_MinCosAngle.Dispose();
    hv_Index1.Dispose();
    hv_CosAngle.Dispose();
    hv_MaxAngleBetweenRotationAxes.Dispose();
    hv_MatrixUID.Dispose();
    hv_MatrixSID.Dispose();
    hv_MatrixVID.Dispose();
    hv_SingularValues.Dispose();
    hv_MinSingularValue.Dispose();
    hvec_RotationAxisRelativ.Dispose();
    hvec_DiffToIdentity.Dispose();

    return;
  }

  // Chapter: Matrix / Arithmetic
  public void get_rotation_axis (HTuple hv_MatRot, HTuple hv_MatRot0, out HTuple hv_RotationAxis, 
      out HTuple hv_DiffToIdentity)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MatrixMultID = new HTuple(), hv_Identity = new HTuple();
    HTuple hv_MatrixSubID = new HTuple(), hv_Values = new HTuple();
    HTuple hv_MatrixUID = new HTuple(), hv_MatrixSID = new HTuple();
    HTuple hv_MatrixVID = new HTuple(), hv_SingularValues = new HTuple();
    HTuple hv_AbsSingularValues = new HTuple(), hv_Indices = new HTuple();
    // Initialize local and output iconic variables 
    hv_RotationAxis = new HTuple();
    hv_DiffToIdentity = new HTuple();
    //
    //Get (R_i)^(-1)R_0
    hv_MatrixMultID.Dispose();
    HOperatorSet.MultMatrix(hv_MatRot, hv_MatRot0, "ATB", out hv_MatrixMultID);
    //Get some measure for how far the matrix is from the identity.
    hv_Identity.Dispose();
    HOperatorSet.CreateMatrix(3, 3, "identity", out hv_Identity);
    hv_MatrixSubID.Dispose();
    HOperatorSet.SubMatrix(hv_MatrixMultID, hv_Identity, out hv_MatrixSubID);
    hv_Values.Dispose();
    HOperatorSet.GetFullMatrix(hv_MatrixSubID, out hv_Values);
    hv_DiffToIdentity.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiffToIdentity = ((hv_Values*hv_Values)).TupleSum()
        ;
    }
    //Get its rotation axis.
    hv_MatrixUID.Dispose();hv_MatrixSID.Dispose();hv_MatrixVID.Dispose();
    HOperatorSet.SvdMatrix(hv_MatrixSubID, "full", "both", out hv_MatrixUID, out hv_MatrixSID, 
        out hv_MatrixVID);
    hv_SingularValues.Dispose();
    HOperatorSet.GetValueMatrix(hv_MatrixSID, ((new HTuple(0)).TupleConcat(1)).TupleConcat(
        2), ((new HTuple(0)).TupleConcat(1)).TupleConcat(2), out hv_SingularValues);
    hv_AbsSingularValues.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_AbsSingularValues = hv_SingularValues.TupleAbs()
        ;
    }
    hv_Indices.Dispose();
    HOperatorSet.TupleSortIndex(hv_AbsSingularValues, out hv_Indices);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RotationAxis.Dispose();
    HOperatorSet.GetValueMatrix(hv_MatrixVID, ((new HTuple(0)).TupleConcat(1)).TupleConcat(
        2), ((((hv_Indices.TupleSelect(0))).TupleConcat(hv_Indices.TupleSelect(0)))).TupleConcat(
        hv_Indices.TupleSelect(0)), out hv_RotationAxis);
    }
    //Clear matrices.
    HOperatorSet.ClearMatrix(hv_MatrixMultID);
    HOperatorSet.ClearMatrix(hv_MatrixUID);
    HOperatorSet.ClearMatrix(hv_MatrixSID);
    HOperatorSet.ClearMatrix(hv_MatrixVID);
    HOperatorSet.ClearMatrix(hv_MatrixSubID);
    HOperatorSet.ClearMatrix(hv_Identity);

    hv_MatrixMultID.Dispose();
    hv_Identity.Dispose();
    hv_MatrixSubID.Dispose();
    hv_Values.Dispose();
    hv_MatrixUID.Dispose();
    hv_MatrixSID.Dispose();
    hv_MatrixVID.Dispose();
    hv_SingularValues.Dispose();
    hv_AbsSingularValues.Dispose();
    hv_Indices.Dispose();

    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  public void get_segmentation_image_ground_truth (out HObject ho_SegmentationImagGroundTruth, 
      HTuple hv_SampleKeys, HTuple hv_DLSample)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("segmentation_image"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_SegmentationImagGroundTruth.Dispose();
      HOperatorSet.GetDictObject(out ho_SegmentationImagGroundTruth, hv_DLSample, 
          "segmentation_image");
    }
    else
    {
      throw new HalconException("Ground truth segmentation image could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  public void get_segmentation_image_result (out HObject ho_SegmentationImageResult, 
      HTuple hv_ResultKeys, HTuple hv_DLResult)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
    //
    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_image"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_SegmentationImageResult.Dispose();
      HOperatorSet.GetDictObject(out ho_SegmentationImageResult, hv_DLResult, "segmentation_image");
    }
    else
    {
      throw new HalconException("Result segmentation data could not be found in DLSample.");
    }


    return;
  }

  // Chapter: 3D Reconstruction / Sheet of Light
  // Short Description: Calculate the dimensions of a sheet-of-light calibration object. 
  public void get_sheet_of_light_calib_object_dimensions (HTuple hv_Width, HTuple hv_Length, 
      HTuple hv_HeightMin, HTuple hv_HeightMax, out HTuple hv_DiameterCircle, out HTuple hv_PyramidHeight, 
      out HTuple hv_PyramidDistanceFromFront, out HTuple hv_PyramidBottomDiagonal, 
      out HTuple hv_PyramidTopDiagonal, out HTuple hv_Angle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CircleFactor = new HTuple(), hv_PyramidBottomFactor = new HTuple();
    HTuple hv_PyramidTopFactor = new HTuple(), hv_OffsetFactor = new HTuple();
    HTuple hv_MaxAngle = new HTuple(), hv_Pi = new HTuple();
    HTuple hv_Height = new HTuple(), hv_Hypotenuse = new HTuple();
    HTuple hv_CosAlpha = new HTuple(), hv_SinAlpha = new HTuple();
    HTuple hv_Dist = new HTuple(), hv_PyramidHeight1 = new HTuple();
    HTuple hv_PyramidHeight2 = new HTuple();
    // Initialize local and output iconic variables 
    hv_DiameterCircle = new HTuple();
    hv_PyramidHeight = new HTuple();
    hv_PyramidDistanceFromFront = new HTuple();
    hv_PyramidBottomDiagonal = new HTuple();
    hv_PyramidTopDiagonal = new HTuple();
    hv_Angle = new HTuple();
    //
    //Constants:
    hv_CircleFactor.Dispose();
    hv_CircleFactor = 0.075;
    hv_PyramidBottomFactor.Dispose();
    hv_PyramidBottomFactor = 0.9;
    hv_PyramidTopFactor.Dispose();
    hv_PyramidTopFactor = 0.5;
    hv_OffsetFactor.Dispose();
    hv_OffsetFactor = 0.1;
    hv_MaxAngle.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxAngle = (new HTuple(45)).TupleRad()
        ;
    }
    hv_Pi.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Pi = (new HTuple(180)).TupleRad()
        ;
    }
    //
    //Circle:
    hv_DiameterCircle.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DiameterCircle = hv_CircleFactor*hv_Width;
    }
    //
    hv_PyramidBottomDiagonal.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PyramidBottomDiagonal = hv_Width*hv_PyramidBottomFactor;
    }
    hv_PyramidTopDiagonal.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PyramidTopDiagonal = hv_PyramidBottomDiagonal*hv_PyramidTopFactor;
    }
    hv_PyramidDistanceFromFront.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PyramidDistanceFromFront = 0.1*hv_Length;
    }
    //
    //Find the height of the truncated pyramid such that
    //its highest point's Z coordinate is equal to HeightMax.
    hv_Height.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Height = hv_HeightMax-hv_HeightMin;
    }
    hv_Hypotenuse.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Hypotenuse = (((hv_Length*hv_Length)+(hv_Height*hv_Height))).TupleSqrt()
        ;
    }
    hv_CosAlpha.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CosAlpha = hv_Length/hv_Hypotenuse;
    }
    hv_SinAlpha.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SinAlpha = hv_Height/hv_Hypotenuse;
    }
    hv_Angle.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Angle = hv_CosAlpha.TupleAcos()
        ;
    }
    hv_Dist.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Dist = ((hv_OffsetFactor*hv_Length)+(0.5*hv_PyramidBottomDiagonal))+(0.5*hv_PyramidTopDiagonal);
    }
    hv_PyramidHeight1.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PyramidHeight1 = (hv_Height-(hv_Dist*hv_SinAlpha))/hv_CosAlpha;
    }
    //
    //Limit the height of the pyramid such that the angle of
    //its side planes to the ground plane is at most MaxAngle.
    hv_PyramidHeight2.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PyramidHeight2 = ((hv_MaxAngle.TupleTan()
        )*0.5)*(hv_PyramidBottomDiagonal-hv_PyramidTopDiagonal);
    }
    hv_PyramidHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PyramidHeight = hv_PyramidHeight1.TupleMin2(
        hv_PyramidHeight2);
    }

    hv_CircleFactor.Dispose();
    hv_PyramidBottomFactor.Dispose();
    hv_PyramidTopFactor.Dispose();
    hv_OffsetFactor.Dispose();
    hv_MaxAngle.Dispose();
    hv_Pi.Dispose();
    hv_Height.Dispose();
    hv_Hypotenuse.Dispose();
    hv_CosAlpha.Dispose();
    hv_SinAlpha.Dispose();
    hv_Dist.Dispose();
    hv_PyramidHeight1.Dispose();
    hv_PyramidHeight2.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Get the center of the virtual trackback that is used to move the camera. 
  public void get_trackball_center (HTuple hv_SelectedObject, HTuple hv_TrackballRadiusPixel, 
      HTuple hv_ObjectModel3D, HTuple hv_Poses, out HTuple hv_TBCenter, out HTuple hv_TBSize)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumModels = new HTuple(), hv_Diameter = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Center = new HTuple();
    HTuple hv_CurrDiameter = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_MD = new HTuple(), hv_Weight = new HTuple();
    HTuple hv_SumW = new HTuple(), hv_PoseSelected = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_TBCenterCamX = new HTuple();
    HTuple hv_TBCenterCamY = new HTuple(), hv_TBCenterCamZ = new HTuple();
    HTuple hv_InvSum = new HTuple();
    // Initialize local and output iconic variables 
    hv_TBCenter = new HTuple();
    hv_TBSize = new HTuple();
    //
    hv_NumModels.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumModels = new HTuple(hv_ObjectModel3D.TupleLength()
        );
    }
    if (hv_TBCenter == null)
      hv_TBCenter = new HTuple();
    hv_TBCenter[0] = 0;
    if (hv_TBCenter == null)
      hv_TBCenter = new HTuple();
    hv_TBCenter[1] = 0;
    if (hv_TBCenter == null)
      hv_TBCenter = new HTuple();
    hv_TBCenter[2] = 0;
    hv_Diameter.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Diameter = HTuple.TupleGenConst(
        new HTuple(hv_ObjectModel3D.TupleLength()),0.0);
    }
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ObjectModel3D.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      try
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Center.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3D.TupleSelect(hv_Index), 
            "center", out hv_Center);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrDiameter.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3D.TupleSelect(hv_Index), 
            "diameter_axis_aligned_bounding_box", out hv_CurrDiameter);
        }
        if (hv_Diameter == null)
          hv_Diameter = new HTuple();
        hv_Diameter[hv_Index] = hv_CurrDiameter;
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //3D object model is empty or otherwise malformed -> ignore
      }
    }
    //Normalize Diameter to use it as weights for a weighted mean of the individual centers
    hv_MD.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MD = hv_Diameter.TupleMean()
        ;
    }
    if ((int)(new HTuple(hv_MD.TupleGreater(1e-10))) != 0)
    {
      hv_Weight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Weight = hv_Diameter/hv_MD;
      }
    }
    else
    {
      hv_Weight.Dispose();
      hv_Weight = new HTuple(hv_Diameter);
    }
    hv_SumW.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SumW = ((hv_Weight.TupleSelectMask(
        ((hv_SelectedObject.TupleSgn())).TupleAbs()))).TupleSum();
    }
    if ((int)(new HTuple(hv_SumW.TupleLess(1e-10))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Weight = HTuple.TupleGenConst(
          new HTuple(hv_Weight.TupleLength()),1.0);
      hv_Weight.Dispose();
      hv_Weight = ExpTmpLocalVar_Weight;
      }
      }
      hv_SumW.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SumW = ((hv_Weight.TupleSelectMask(
          ((hv_SelectedObject.TupleSgn())).TupleAbs()))).TupleSum();
      }
    }
    if ((int)(new HTuple(hv_SumW.TupleLess(1e-10))) != 0)
    {
      hv_SumW.Dispose();
      hv_SumW = 1.0;
    }
    HTuple end_val30 = hv_NumModels-1;
    HTuple step_val30 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val30, step_val30); hv_Index = hv_Index.TupleAdd(step_val30))
    {
      if ((int)(((hv_SelectedObject.TupleSelect(hv_Index))).TupleAnd(new HTuple(((hv_Diameter.TupleSelect(
          hv_Index))).TupleGreater(0)))) != 0)
      {
        hv_PoseSelected.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PoseSelected = hv_Poses.TupleSelectRange(
            hv_Index*7,(hv_Index*7)+6);
        }
        hv_HomMat3D.Dispose();
        HOperatorSet.PoseToHomMat3d(hv_PoseSelected, out hv_HomMat3D);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Center.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3D.TupleSelect(hv_Index), 
            "center", out hv_Center);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TBCenterCamX.Dispose();hv_TBCenterCamY.Dispose();hv_TBCenterCamZ.Dispose();
        HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_Center.TupleSelect(0), hv_Center.TupleSelect(
            1), hv_Center.TupleSelect(2), out hv_TBCenterCamX, out hv_TBCenterCamY, 
            out hv_TBCenterCamZ);
        }
        if (hv_TBCenter == null)
          hv_TBCenter = new HTuple();
        hv_TBCenter[0] = (hv_TBCenter.TupleSelect(0))+(hv_TBCenterCamX*(hv_Weight.TupleSelect(
            hv_Index)));
        if (hv_TBCenter == null)
          hv_TBCenter = new HTuple();
        hv_TBCenter[1] = (hv_TBCenter.TupleSelect(1))+(hv_TBCenterCamY*(hv_Weight.TupleSelect(
            hv_Index)));
        if (hv_TBCenter == null)
          hv_TBCenter = new HTuple();
        hv_TBCenter[2] = (hv_TBCenter.TupleSelect(2))+(hv_TBCenterCamZ*(hv_Weight.TupleSelect(
            hv_Index)));
      }
    }
    if ((int)(new HTuple(((hv_SelectedObject.TupleMax())).TupleNotEqual(0))) != 0)
    {
      hv_InvSum.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_InvSum = 1.0/hv_SumW;
      }
      if (hv_TBCenter == null)
        hv_TBCenter = new HTuple();
      hv_TBCenter[0] = (hv_TBCenter.TupleSelect(0))*hv_InvSum;
      if (hv_TBCenter == null)
        hv_TBCenter = new HTuple();
      hv_TBCenter[1] = (hv_TBCenter.TupleSelect(1))*hv_InvSum;
      if (hv_TBCenter == null)
        hv_TBCenter = new HTuple();
      hv_TBCenter[2] = (hv_TBCenter.TupleSelect(2))*hv_InvSum;
      hv_TBSize.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TBSize = (0.5+((0.5*(hv_SelectedObject.TupleSum()
          ))/hv_NumModels))*hv_TrackballRadiusPixel;
      }
    }
    else
    {
      hv_TBCenter.Dispose();
      hv_TBCenter = new HTuple();
      hv_TBSize.Dispose();
      hv_TBSize = 0;
    }

    hv_NumModels.Dispose();
    hv_Diameter.Dispose();
    hv_Index.Dispose();
    hv_Center.Dispose();
    hv_CurrDiameter.Dispose();
    hv_Exception.Dispose();
    hv_MD.Dispose();
    hv_Weight.Dispose();
    hv_SumW.Dispose();
    hv_PoseSelected.Dispose();
    hv_HomMat3D.Dispose();
    hv_TBCenterCamX.Dispose();
    hv_TBCenterCamY.Dispose();
    hv_TBCenterCamZ.Dispose();
    hv_InvSum.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Get the center of the virtual trackback that is used to move the camera. 
  public void get_trackball_center_visualize_object_model_3d (HTuple hv_SelectedObject, 
      HTuple hv_TrackballRadiusPixel, HTuple hv_ObjectModel3D, HTuple hv_Poses, out HTuple hv_TBCenter, 
      out HTuple hv_TBSize)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumModels = new HTuple(), hv_Diameter = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Center = new HTuple();
    HTuple hv_CurrDiameter = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_MD = new HTuple(), hv_Weight = new HTuple();
    HTuple hv_SumW = new HTuple(), hv_PoseSelected = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_TBCenterCamX = new HTuple();
    HTuple hv_TBCenterCamY = new HTuple(), hv_TBCenterCamZ = new HTuple();
    HTuple hv_InvSum = new HTuple();
    // Initialize local and output iconic variables 
    hv_TBCenter = new HTuple();
    hv_TBSize = new HTuple();
    //
    hv_NumModels.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumModels = new HTuple(hv_ObjectModel3D.TupleLength()
        );
    }
    if (hv_TBCenter == null)
      hv_TBCenter = new HTuple();
    hv_TBCenter[0] = 0;
    if (hv_TBCenter == null)
      hv_TBCenter = new HTuple();
    hv_TBCenter[1] = 0;
    if (hv_TBCenter == null)
      hv_TBCenter = new HTuple();
    hv_TBCenter[2] = 0;
    hv_Diameter.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Diameter = HTuple.TupleGenConst(
        new HTuple(hv_ObjectModel3D.TupleLength()),0.0);
    }
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ObjectModel3D.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      try
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Center.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3D.TupleSelect(hv_Index), 
            "center", out hv_Center);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrDiameter.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3D.TupleSelect(hv_Index), 
            "diameter_axis_aligned_bounding_box", out hv_CurrDiameter);
        }
        if (hv_Diameter == null)
          hv_Diameter = new HTuple();
        hv_Diameter[hv_Index] = hv_CurrDiameter;
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //3D object model is empty or otherwise malformed -> ignore
      }
    }
    //Normalize Diameter to use it as weights for a weighted mean of the individual centers
    hv_MD.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MD = hv_Diameter.TupleMean()
        ;
    }
    if ((int)(new HTuple(hv_MD.TupleGreater(1e-10))) != 0)
    {
      hv_Weight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Weight = hv_Diameter/hv_MD;
      }
    }
    else
    {
      hv_Weight.Dispose();
      hv_Weight = new HTuple(hv_Diameter);
    }
    hv_SumW.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SumW = ((hv_Weight.TupleSelectMask(
        ((hv_SelectedObject.TupleSgn())).TupleAbs()))).TupleSum();
    }
    if ((int)(new HTuple(hv_SumW.TupleLess(1e-10))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Weight = HTuple.TupleGenConst(
          new HTuple(hv_Weight.TupleLength()),1.0);
      hv_Weight.Dispose();
      hv_Weight = ExpTmpLocalVar_Weight;
      }
      }
      hv_SumW.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SumW = ((hv_Weight.TupleSelectMask(
          ((hv_SelectedObject.TupleSgn())).TupleAbs()))).TupleSum();
      }
    }
    if ((int)(new HTuple(hv_SumW.TupleLess(1e-10))) != 0)
    {
      hv_SumW.Dispose();
      hv_SumW = 1.0;
    }
    HTuple end_val30 = hv_NumModels-1;
    HTuple step_val30 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val30, step_val30); hv_Index = hv_Index.TupleAdd(step_val30))
    {
      if ((int)(((hv_SelectedObject.TupleSelect(hv_Index))).TupleAnd(new HTuple(((hv_Diameter.TupleSelect(
          hv_Index))).TupleGreater(0)))) != 0)
      {
        hv_PoseSelected.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PoseSelected = hv_Poses.TupleSelectRange(
            hv_Index*7,(hv_Index*7)+6);
        }
        hv_HomMat3D.Dispose();
        HOperatorSet.PoseToHomMat3d(hv_PoseSelected, out hv_HomMat3D);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Center.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3D.TupleSelect(hv_Index), 
            "center", out hv_Center);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TBCenterCamX.Dispose();hv_TBCenterCamY.Dispose();hv_TBCenterCamZ.Dispose();
        HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_Center.TupleSelect(0), hv_Center.TupleSelect(
            1), hv_Center.TupleSelect(2), out hv_TBCenterCamX, out hv_TBCenterCamY, 
            out hv_TBCenterCamZ);
        }
        if (hv_TBCenter == null)
          hv_TBCenter = new HTuple();
        hv_TBCenter[0] = (hv_TBCenter.TupleSelect(0))+(hv_TBCenterCamX*(hv_Weight.TupleSelect(
            hv_Index)));
        if (hv_TBCenter == null)
          hv_TBCenter = new HTuple();
        hv_TBCenter[1] = (hv_TBCenter.TupleSelect(1))+(hv_TBCenterCamY*(hv_Weight.TupleSelect(
            hv_Index)));
        if (hv_TBCenter == null)
          hv_TBCenter = new HTuple();
        hv_TBCenter[2] = (hv_TBCenter.TupleSelect(2))+(hv_TBCenterCamZ*(hv_Weight.TupleSelect(
            hv_Index)));
      }
    }
    if ((int)(new HTuple(((hv_SelectedObject.TupleMax())).TupleNotEqual(0))) != 0)
    {
      hv_InvSum.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_InvSum = 1.0/hv_SumW;
      }
      if (hv_TBCenter == null)
        hv_TBCenter = new HTuple();
      hv_TBCenter[0] = (hv_TBCenter.TupleSelect(0))*hv_InvSum;
      if (hv_TBCenter == null)
        hv_TBCenter = new HTuple();
      hv_TBCenter[1] = (hv_TBCenter.TupleSelect(1))*hv_InvSum;
      if (hv_TBCenter == null)
        hv_TBCenter = new HTuple();
      hv_TBCenter[2] = (hv_TBCenter.TupleSelect(2))*hv_InvSum;
      hv_TBSize.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TBSize = (0.5+((0.5*(hv_SelectedObject.TupleSum()
          ))/hv_NumModels))*hv_TrackballRadiusPixel;
      }
    }
    else
    {
      hv_TBCenter.Dispose();
      hv_TBCenter = new HTuple();
      hv_TBSize.Dispose();
      hv_TBSize = 0;
    }

    hv_NumModels.Dispose();
    hv_Diameter.Dispose();
    hv_Index.Dispose();
    hv_Center.Dispose();
    hv_CurrDiameter.Dispose();
    hv_Exception.Dispose();
    hv_MD.Dispose();
    hv_Weight.Dispose();
    hv_SumW.Dispose();
    hv_PoseSelected.Dispose();
    hv_HomMat3D.Dispose();
    hv_TBCenterCamX.Dispose();
    hv_TBCenterCamY.Dispose();
    hv_TBCenterCamZ.Dispose();
    hv_InvSum.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface'). 
  public void get_trackball_center_fixed (HTuple hv_SelectedObject, HTuple hv_TrackballCenterRow, 
      HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel, HTuple hv_Scene3D, 
      HTuple hv_ObjectModel3DID, HTuple hv_Poses, HTuple hv_WindowHandleBuffer, HTuple hv_CamParam, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, out HTuple hv_TBCenter, out HTuple hv_TBSize)
  {



    // Local iconic variables 

    HObject ho_RegionCenter, ho_DistanceImage;
    HObject ho_Domain;

    // Local control variables 

    HTuple hv_NumModels = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_SelectPose = new HTuple();
    HTuple hv_Index1 = new HTuple(), hv_Rows = new HTuple();
    HTuple hv_Columns = new HTuple(), hv_Grayval = new HTuple();
    HTuple hv_IndicesG = new HTuple(), hv_Value = new HTuple();
    HTuple hv_Pos = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_RegionCenter);
    HOperatorSet.GenEmptyObj(out ho_DistanceImage);
    HOperatorSet.GenEmptyObj(out ho_Domain);
    hv_TBCenter = new HTuple();
    hv_TBSize = new HTuple();
    //
    //Determine the trackball center for the fixed trackball
    hv_NumModels.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumModels = new HTuple(hv_ObjectModel3DID.TupleLength()
        );
    }
    hv_Width.Dispose();
    get_cam_par_data(hv_CamParam, "image_width", out hv_Width);
    hv_Height.Dispose();
    get_cam_par_data(hv_CamParam, "image_height", out hv_Height);
    //
    //Project the selected objects
    hv_SelectPose.Dispose();
    hv_SelectPose = new HTuple();
    for (hv_Index1=0; (int)hv_Index1<=(int)((new HTuple(hv_SelectedObject.TupleLength()
        ))-1); hv_Index1 = (int)hv_Index1 + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_SelectPose = hv_SelectPose.TupleConcat(
          HTuple.TupleGenConst(7,hv_SelectedObject.TupleSelect(hv_Index1)));
      hv_SelectPose.Dispose();
      hv_SelectPose = ExpTmpLocalVar_SelectPose;
      }
      }
      if ((int)(new HTuple(((hv_SelectedObject.TupleSelect(hv_Index1))).TupleEqual(
          0))) != 0)
      {
        HOperatorSet.SetScene3dInstanceParam(hv_Scene3D, hv_Index1, "visible", "false");
      }
    }
    HOperatorSet.SetScene3dParam(hv_Scene3D, "depth_persistence", "true");
    HOperatorSet.DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
    HOperatorSet.SetScene3dParam(hv_Scene3D, "visible", "true");
    //
    //determine the depth of the object point that appears closest to the trackball
    //center
    ho_RegionCenter.Dispose();
    HOperatorSet.GenRegionPoints(out ho_RegionCenter, hv_TrackballCenterRow, hv_TrackballCenterCol);
    ho_DistanceImage.Dispose();
    HOperatorSet.DistanceTransform(ho_RegionCenter, out ho_DistanceImage, "chamfer-3-4-unnormalized", 
        "false", hv_Width, hv_Height);
    ho_Domain.Dispose();
    HOperatorSet.GetDomain(ho_DistanceImage, out ho_Domain);
    hv_Rows.Dispose();hv_Columns.Dispose();
    HOperatorSet.GetRegionPoints(ho_Domain, out hv_Rows, out hv_Columns);
    hv_Grayval.Dispose();
    HOperatorSet.GetGrayval(ho_DistanceImage, hv_Rows, hv_Columns, out hv_Grayval);
    hv_IndicesG.Dispose();
    HOperatorSet.TupleSortIndex(hv_Grayval, out hv_IndicesG);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Value.Dispose();
    HOperatorSet.GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Rows.TupleSelect(
        hv_IndicesG), hv_Columns.TupleSelect(hv_IndicesG), "depth", out hv_Value);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Pos.Dispose();
    HOperatorSet.TupleFind(hv_Value.TupleSgn(), 1, out hv_Pos);
    }
    //
    HOperatorSet.SetScene3dParam(hv_Scene3D, "depth_persistence", "false");
    //
    //
    //set TBCenter
    if ((int)(new HTuple(hv_Pos.TupleNotEqual(-1))) != 0)
    {
      //if the object is visible in the image
      hv_TBCenter.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TBCenter = new HTuple();
      hv_TBCenter[0] = 0;
      hv_TBCenter[1] = 0;
      hv_TBCenter = hv_TBCenter.TupleConcat(hv_Value.TupleSelect(
          hv_Pos.TupleSelect(0)));
      }
    }
    else
    {
      //if the object is not visible in the image, set the z coordinate to -1
      //to indicate, the the previous z value should be used instead
      hv_TBCenter.Dispose();
      hv_TBCenter = new HTuple();
      hv_TBCenter[0] = 0;
      hv_TBCenter[1] = 0;
      hv_TBCenter[2] = -1;
    }
    //
    if ((int)(new HTuple(((hv_SelectedObject.TupleMax())).TupleNotEqual(0))) != 0)
    {
      hv_TBSize.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TBSize = (0.5+((0.5*(hv_SelectedObject.TupleSum()
          ))/hv_NumModels))*hv_TrackballRadiusPixel;
      }
    }
    else
    {
      hv_TBCenter.Dispose();
      hv_TBCenter = new HTuple();
      hv_TBSize.Dispose();
      hv_TBSize = 0;
    }
    ho_RegionCenter.Dispose();
    ho_DistanceImage.Dispose();
    ho_Domain.Dispose();

    hv_NumModels.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_SelectPose.Dispose();
    hv_Index1.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_Grayval.Dispose();
    hv_IndicesG.Dispose();
    hv_Value.Dispose();
    hv_Pos.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface'). 
  public void get_trackball_center_fixed_visualize_object_model_3d (HTuple hv_SelectedObject, 
      HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel, 
      HTuple hv_Scene3D, HTuple hv_ObjectModel3DID, HTuple hv_Poses, HTuple hv_WindowHandleBuffer, 
      HTuple hv_CamParam, HTuple hv_GenParamName, HTuple hv_GenParamValue, out HTuple hv_TBCenter, 
      out HTuple hv_TBSize)
  {



    // Local iconic variables 

    HObject ho_RegionCenter, ho_DistanceImage;
    HObject ho_Domain;

    // Local control variables 

    HTuple hv_NumModels = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_SelectPose = new HTuple();
    HTuple hv_Index1 = new HTuple(), hv_Rows = new HTuple();
    HTuple hv_Columns = new HTuple(), hv_Grayval = new HTuple();
    HTuple hv_IndicesG = new HTuple(), hv_Value = new HTuple();
    HTuple hv_Pos = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_RegionCenter);
    HOperatorSet.GenEmptyObj(out ho_DistanceImage);
    HOperatorSet.GenEmptyObj(out ho_Domain);
    hv_TBCenter = new HTuple();
    hv_TBSize = new HTuple();
    //
    //Determine the trackball center for the fixed trackball
    hv_NumModels.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumModels = new HTuple(hv_ObjectModel3DID.TupleLength()
        );
    }
    hv_Width.Dispose();
    get_cam_par_data(hv_CamParam, "image_width", out hv_Width);
    hv_Height.Dispose();
    get_cam_par_data(hv_CamParam, "image_height", out hv_Height);
    //
    //Project the selected objects
    hv_SelectPose.Dispose();
    hv_SelectPose = new HTuple();
    for (hv_Index1=0; (int)hv_Index1<=(int)((new HTuple(hv_SelectedObject.TupleLength()
        ))-1); hv_Index1 = (int)hv_Index1 + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_SelectPose = hv_SelectPose.TupleConcat(
          HTuple.TupleGenConst(7,hv_SelectedObject.TupleSelect(hv_Index1)));
      hv_SelectPose.Dispose();
      hv_SelectPose = ExpTmpLocalVar_SelectPose;
      }
      }
      if ((int)(new HTuple(((hv_SelectedObject.TupleSelect(hv_Index1))).TupleEqual(
          0))) != 0)
      {
        HOperatorSet.SetScene3dInstanceParam(hv_Scene3D, hv_Index1, "visible", "false");
      }
    }
    HOperatorSet.SetScene3dParam(hv_Scene3D, "depth_persistence", "true");
    HOperatorSet.DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
    HOperatorSet.SetScene3dParam(hv_Scene3D, "visible", "true");
    //
    //determine the depth of the object point that appears closest to the trackball
    //center
    ho_RegionCenter.Dispose();
    HOperatorSet.GenRegionPoints(out ho_RegionCenter, hv_TrackballCenterRow, hv_TrackballCenterCol);
    ho_DistanceImage.Dispose();
    HOperatorSet.DistanceTransform(ho_RegionCenter, out ho_DistanceImage, "chamfer-3-4-unnormalized", 
        "false", hv_Width, hv_Height);
    ho_Domain.Dispose();
    HOperatorSet.GetDomain(ho_DistanceImage, out ho_Domain);
    hv_Rows.Dispose();hv_Columns.Dispose();
    HOperatorSet.GetRegionPoints(ho_Domain, out hv_Rows, out hv_Columns);
    hv_Grayval.Dispose();
    HOperatorSet.GetGrayval(ho_DistanceImage, hv_Rows, hv_Columns, out hv_Grayval);
    hv_IndicesG.Dispose();
    HOperatorSet.TupleSortIndex(hv_Grayval, out hv_IndicesG);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Value.Dispose();
    HOperatorSet.GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Rows.TupleSelect(
        hv_IndicesG), hv_Columns.TupleSelect(hv_IndicesG), "depth", out hv_Value);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Pos.Dispose();
    HOperatorSet.TupleFind(hv_Value.TupleSgn(), 1, out hv_Pos);
    }
    //
    HOperatorSet.SetScene3dParam(hv_Scene3D, "depth_persistence", "false");
    //
    //
    //set TBCenter
    if ((int)(new HTuple(hv_Pos.TupleNotEqual(-1))) != 0)
    {
      //if the object is visible in the image
      hv_TBCenter.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TBCenter = new HTuple();
      hv_TBCenter[0] = 0;
      hv_TBCenter[1] = 0;
      hv_TBCenter = hv_TBCenter.TupleConcat(hv_Value.TupleSelect(
          hv_Pos.TupleSelect(0)));
      }
    }
    else
    {
      //if the object is not visible in the image, set the z coordinate to -1
      //to indicate, the the previous z value should be used instead
      hv_TBCenter.Dispose();
      hv_TBCenter = new HTuple();
      hv_TBCenter[0] = 0;
      hv_TBCenter[1] = 0;
      hv_TBCenter[2] = -1;
    }
    //
    if ((int)(new HTuple(((hv_SelectedObject.TupleMax())).TupleNotEqual(0))) != 0)
    {
      hv_TBSize.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TBSize = (0.5+((0.5*(hv_SelectedObject.TupleSum()
          ))/hv_NumModels))*hv_TrackballRadiusPixel;
      }
    }
    else
    {
      hv_TBCenter.Dispose();
      hv_TBCenter = new HTuple();
      hv_TBSize.Dispose();
      hv_TBSize = 0;
    }
    ho_RegionCenter.Dispose();
    ho_DistanceImage.Dispose();
    ho_Domain.Dispose();

    hv_NumModels.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_SelectPose.Dispose();
    hv_Index1.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_Grayval.Dispose();
    hv_IndicesG.Dispose();
    hv_Value.Dispose();
    hv_Pos.Dispose();

    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  public void get_weight_image (out HObject ho_ImageWeight, HTuple hv_SampleKeys, 
      HTuple hv_DLSample)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageWeight);
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("weight_image"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_ImageWeight.Dispose();
      HOperatorSet.GetDictObject(out ho_ImageWeight, hv_DLSample, "weight_image");
    }
    else
    {
      throw new HalconException("Weight image could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Graphics / Window
  public void get_window_meta_information (HTuple hv_WindowHandle, HTuple hv_WidthImage, 
      HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_WindowRow1, HTuple hv_WindowColumn1, 
      HTuple hv_ShowBottomDesc, out HTuple hv_WindowImageRatio, out HTuple hv_SetPartRow2, 
      out HTuple hv_SetPartColumn2, out HTuple hv_PrevWindowCoordinatesOut, out HTuple hv_MarginBottom)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv__ = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple(), hv_Row1 = new HTuple();
    HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
    HTuple hv_Column2 = new HTuple(), hv_WindowImageRatioHeight = new HTuple();
    HTuple hv_WindowImageRatioWidth = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowImageRatio = new HTuple();
    hv_SetPartRow2 = new HTuple();
    hv_SetPartColumn2 = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    hv_MarginBottom = new HTuple();
    //
    //This procedure returns meta information to display images correctly
    //
    //Calculate MarginBottom.
    if ((int)(hv_ShowBottomDesc) != 0)
    {
      hv_Ascent.Dispose();hv_Descent.Dispose();hv__.Dispose();hv__.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, "test_string", out hv_Ascent, 
          out hv_Descent, out hv__, out hv__);
      hv_MarginBottom.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MarginBottom = ((2*12)+hv_Ascent)+hv_Descent;
      }
    }
    else
    {
      hv_MarginBottom.Dispose();
      hv_MarginBottom = 0;
    }
    //Adapt window size (+ MarginBottom + MapColorBarWidth).
    hv__.Dispose();hv__.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_WindowWidth, 
        out hv_WindowHeight);
    hv_WindowImageRatio.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowImageRatio = hv_WindowHeight/(hv_HeightImage*1.0);
    }
    //
    //Set part for the image to be displayed later.
    hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
    HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1, out hv_Column1, out hv_Row2, 
        out hv_Column2);
    hv_WindowImageRatioHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowImageRatioHeight = hv_WindowHeight/(hv_HeightImage*1.0);
    }
    hv_WindowImageRatioWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowImageRatioWidth = hv_WindowWidth/(hv_WidthImage*1.0);
    }
    hv_SetPartRow2.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SetPartRow2 = hv_Row2+(hv_MarginBottom/hv_WindowImageRatioHeight);
    }
    hv_SetPartColumn2.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SetPartColumn2 = hv_Column2+(hv_MapColorBarWidth/hv_WindowImageRatioWidth);
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_SetPartRow2, hv_SetPartColumn2);
    }
    //
    //Return the coordinates of the new window.
    hv_PrevWindowCoordinatesOut.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PrevWindowCoordinatesOut = new HTuple();
    hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow1, hv_WindowColumn1, hv_WindowWidth, hv_WindowHeight);
    }
    //

    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv__.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();
    hv_Row1.Dispose();
    hv_Column1.Dispose();
    hv_Row2.Dispose();
    hv_Column2.Dispose();
    hv_WindowImageRatioHeight.Dispose();
    hv_WindowImageRatioWidth.Dispose();

    return;
  }

  // Chapter: File / Misc
  public void images_exist (HTuple hv_ImageList)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OS = new HTuple(), hv_Separator = new HTuple();
    HTuple hv_HalconImages = new HTuple(), hv_Index = new HTuple();
    HTuple hv_ImageExists = new HTuple(), hv_DirIndex = new HTuple();
    // Initialize local and output iconic variables 
    //
    //Get HalconImages directories.
    hv_OS.Dispose();
    HOperatorSet.GetSystem("operating_system", out hv_OS);
    if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
    {
      hv_Separator.Dispose();
      hv_Separator = ";";
    }
    else
    {
      hv_Separator.Dispose();
      hv_Separator = ":";
    }
    hv_HalconImages.Dispose();
    HOperatorSet.GetSystem("image_dir", out hv_HalconImages);
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.TupleSplit(hv_HalconImages, hv_Separator, out ExpTmpOutVar_0);
    hv_HalconImages.Dispose();
    hv_HalconImages = ExpTmpOutVar_0;
    }
    //
    //Loop over images and segmentations.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ImageList.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageExists.Dispose();
      HOperatorSet.FileExists(hv_ImageList.TupleSelect(hv_Index), out hv_ImageExists);
      }
      if ((int)(hv_ImageExists.TupleNot()) != 0)
      {
        //Check in HalconImages directories.
        for (hv_DirIndex=0; (int)hv_DirIndex<=(int)((new HTuple(hv_HalconImages.TupleLength()
            ))-1); hv_DirIndex = (int)hv_DirIndex + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImageExists.Dispose();
          HOperatorSet.FileExists(((hv_HalconImages.TupleSelect(hv_DirIndex))+"/")+(hv_ImageList.TupleSelect(
              hv_Index)), out hv_ImageExists);
          }
          if ((int)(hv_ImageExists) != 0)
          {
            break;
          }
        }
        if ((int)(hv_ImageExists.TupleNot()) != 0)
        {
          throw new HalconException(("Image "+(hv_ImageList.TupleSelect(
              hv_Index)))+" does not exist");
        }
      }
    }

    hv_OS.Dispose();
    hv_Separator.Dispose();
    hv_HalconImages.Dispose();
    hv_Index.Dispose();
    hv_ImageExists.Dispose();
    hv_DirIndex.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Initialize the dictionary RunningMeasures for the evaluation. 
  public void init_running_evaluation_measures (HTuple hv_EvalParams, out HTuple hv_RunningMeasures)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Valid = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_NumClasses = new HTuple(), hv_EvalInstances = new HTuple();
    HTuple hv_Measures = new HTuple(), hv_ClassIDs = new HTuple();
    HTuple hv_AllocationBlockLength = new HTuple(), hv_IoUThreshs = new HTuple();
    HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRanges = new HTuple();
    HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
    HTuple hv_MaxAreas = new HTuple(), hv_DetailedEvaluation = new HTuple();
    HTuple hv_MaxNumIdx = new HTuple(), hv_MaxNum = new HTuple();
    HTuple hv_CurrentRunningMeasure = new HTuple(), hv_AreaIdx = new HTuple();
    HTuple hv_AreaRunningMeasure = new HTuple(), hv_I = new HTuple();
    HTuple hv_IoURunningMeasure = new HTuple(), hv_ClsIdx = new HTuple();
    HTuple hv_ClassRunningMeasures = new HTuple(), hv_Confidence = new HTuple();
    HTuple hv_IgnoreClassIDs = new HTuple(), hv_CalcConfMatrix = new HTuple();
    HTuple hv_MatrixSize = new HTuple(), hv_PixelConfusionMatrix = new HTuple();
    HTuple hv_MaxId = new HTuple(), hv_ClsIDToClsIdx = new HTuple();
    HTuple hv_TP = new HTuple(), hv_FP = new HTuple(), hv_FN = new HTuple();
    // Initialize local and output iconic variables 
    hv_RunningMeasures = new HTuple();
    //
    //This procedure initializes the dictionary RunningMeasures for evaluation.
    //It uses the evaluation parameters to initialize the running measures accordingly.
    //
    //The structure of RunningMeasures depends on the entry 'evaluate_instances' in the dictionary EvalParams.
    //
    //The dictionary RunningMeasures can be updated based on the per-batch/per-image evaluation results.
    //
    hv_RunningMeasures.Dispose();
    HOperatorSet.CreateDict(out hv_RunningMeasures);
    //Check that the necessary evaluation parameters exist.
    hv_Valid.Dispose();hv_Exception.Dispose();
    validate_evaluation_param(hv_EvalParams, out hv_Valid, out hv_Exception);
    if ((int)(hv_Valid.TupleNot()) != 0)
    {
      throw new HalconException(new HTuple("Invalid EvalParams, ")+hv_Exception);
    }
    //
    //Get general evaluation parameters.
    hv_NumClasses.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
    hv_EvalInstances.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "evaluate_instances", out hv_EvalInstances);
    hv_Measures.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
    hv_ClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
    //
    if ((int)(hv_EvalInstances) != 0)
    {
      //RunningMeasures contains:
      //For each maximal number of regions (MaxNumDetections):
      // - For each area range (AreaRanges):
      //   -- confidence    - confidence (score) of each result.
      //   -- num_gt        - Total number of ground truth instances per class.
      //   -- num_pred      - Total number of predictions per class.
      //   -- num_gt_ignore - Number of ignored ground truth instances per class.
      //   -- for each IoU-threshold:
      //      --- For each class:
      //          ---- IsTP     - TP/FP assignment of result.
      //          ---- Ignore   - Ignore/Not-Ignore assignment of result.
      //For confidence, IsTP and Ignore, we always allocate in arrays of -1 in blocks of AllocationBlockLength,
      //if the block is filled, we allocate the next block. Otherwise we always have to
      //concatenate the array which is rather slow. The actual length of the array is written
      //to NumPred.
      hv_AllocationBlockLength.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
      hv_IoUThreshs.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThreshs);
      hv_MaxNumDetections.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
      hv_AreaRanges.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
      //AreaRanges is a dictionary containing 'name', 'min_area', 'max_area'.
      hv_AreaNames.Dispose();
      HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
      hv_MinAreas.Dispose();
      HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
      hv_MaxAreas.Dispose();
      HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
      //Check if this should be a detailed evaluation.
      hv_DetailedEvaluation.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
      //Set a result-dictionary for each maximal number of detections and IoU-threshold.
      for (hv_MaxNumIdx=0; (int)hv_MaxNumIdx<=(int)((new HTuple(hv_MaxNumDetections.TupleLength()
          ))-1); hv_MaxNumIdx = (int)hv_MaxNumIdx + 1)
      {
        hv_MaxNum.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxNum = hv_MaxNumDetections.TupleSelect(
            hv_MaxNumIdx);
        }
        hv_CurrentRunningMeasure.Dispose();
        HOperatorSet.CreateDict(out hv_CurrentRunningMeasure);
        for (hv_AreaIdx=0; (int)hv_AreaIdx<=(int)((new HTuple(hv_AreaNames.TupleLength()
            ))-1); hv_AreaIdx = (int)hv_AreaIdx + 1)
        {
          hv_AreaRunningMeasure.Dispose();
          HOperatorSet.CreateDict(out hv_AreaRunningMeasure);
          for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_IoUThreshs.TupleLength()))-1); hv_I = (int)hv_I + 1)
          {
            hv_IoURunningMeasure.Dispose();
            HOperatorSet.CreateDict(out hv_IoURunningMeasure);
            HTuple end_val55 = hv_NumClasses-1;
            HTuple step_val55 = 1;
            for (hv_ClsIdx=0; hv_ClsIdx.Continue(end_val55, step_val55); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val55))
            {
              hv_ClassRunningMeasures.Dispose();
              HOperatorSet.CreateDict(out hv_ClassRunningMeasures);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_tp", HTuple.TupleGenConst(
                  hv_AllocationBlockLength,-1));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "ignore", HTuple.TupleGenConst(
                  hv_AllocationBlockLength,-1));
              }
              if ((int)(hv_DetailedEvaluation) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_class", 
                    HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_background", 
                    HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_localization", 
                    HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_duplicate", 
                    HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_multiple", 
                    HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_negatives", 
                    HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_positives", 
                    HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                }
                HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_negatives", 
                    0);
                HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_positives", 
                    0);
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "class_"+(hv_ClassIDs.TupleSelect(
                  hv_ClsIdx)), hv_ClassRunningMeasures);
              }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "iou_"+(((""+(hv_IoUThreshs.TupleSelect(
                hv_I)))).TupleRegexpReplace("\\.","")), hv_IoURunningMeasure);
            }
          }
          hv_Confidence.Dispose();
          HOperatorSet.CreateDict(out hv_Confidence);
          HTuple end_val75 = hv_NumClasses-1;
          HTuple step_val75 = 1;
          for (hv_ClsIdx=0; hv_ClsIdx.Continue(end_val75, step_val75); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val75))
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_Confidence, "class_"+(hv_ClassIDs.TupleSelect(
                hv_ClsIdx)), HTuple.TupleGenConst(hv_AllocationBlockLength,-1.0));
            }
          }
          HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "confidence", hv_Confidence);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt", HTuple.TupleGenConst(
              hv_NumClasses,0));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_pred", HTuple.TupleGenConst(
              hv_NumClasses,0));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt_ignore", HTuple.TupleGenConst(
              hv_NumClasses,0));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_CurrentRunningMeasure, "area_"+(hv_AreaNames.TupleSelect(
              hv_AreaIdx)), hv_AreaRunningMeasure);
          }
        }
        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
        {
          hv_MaxNum.Dispose();
          hv_MaxNum = "all";
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_RunningMeasures, "max_num_detections_"+hv_MaxNum, 
            hv_CurrentRunningMeasure);
        }
      }
    }
    else
    {
      //RunningMeasures contains:
      //if confusion matrix in Measures (slower but more information).
      // - confusion matrix per pixel.
      //else:
      // - TP/FP/FN (pixel numbers per class).
      //
      //Incorporate ignore class IDs.
      hv_IgnoreClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
      //
      //Check if we need to compute/update the confusion matrix.
      hv_CalcConfMatrix.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CalcConfMatrix = (new HTuple(((hv_Measures.TupleFind(
          "pixel_confusion_matrix"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
          "all"))).TupleGreater(-1)));
      }
      if ((int)(hv_CalcConfMatrix) != 0)
      {
        //Define the size of the confusion matrix.
        hv_MatrixSize.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MatrixSize = hv_NumClasses+(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
            )).TupleGreater(0)));
        }
        hv_PixelConfusionMatrix.Dispose();
        HOperatorSet.CreateMatrix(hv_MatrixSize, hv_MatrixSize, 0, out hv_PixelConfusionMatrix);
        HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", hv_PixelConfusionMatrix);
        //
        //If the class IDs are not running indices from 0 to NumClasses we
        //define a mapping from class IDs to class indices.
        if ((int)((new HTuple(hv_ClassIDs.TupleNotEqual(HTuple.TupleGenSequence(0,
            (new HTuple(hv_ClassIDs.TupleLength()))-1,1)))).TupleOr(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
            )).TupleGreater(0)))) != 0)
        {
          //Get the max ID that can occur.
          hv_MaxId.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MaxId = (hv_ClassIDs.TupleMax()
              )+(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
              0)));
          }
          //Define the basic mapping.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClsIDToClsIdx.Dispose();
          HOperatorSet.TupleGenConst(hv_MaxId+1, -1, out hv_ClsIDToClsIdx);
          }
          if (hv_ClsIDToClsIdx == null)
            hv_ClsIDToClsIdx = new HTuple();
          hv_ClsIDToClsIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0,(new HTuple(hv_ClassIDs.TupleLength()
              ))-1,1);
          //Map ignore IDs to the next higher one.
          if (hv_ClsIDToClsIdx == null)
            hv_ClsIDToClsIdx = new HTuple();
          hv_ClsIDToClsIdx[hv_IgnoreClassIDs] = (hv_ClsIDToClsIdx.TupleMax())+1;
          //Set the mapping to the evaluation parameters.
          HOperatorSet.SetDictTuple(hv_EvalParams, "class_id_mapping", hv_ClsIDToClsIdx);
        }
      }
      else
      {
        hv_TP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TP = HTuple.TupleGenConst(
            hv_NumClasses,0);
        }
        hv_FP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FP = HTuple.TupleGenConst(
            hv_NumClasses,0);
        }
        hv_FN.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FN = HTuple.TupleGenConst(
            hv_NumClasses,0);
        }
        HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
      }
    }


    hv_Valid.Dispose();
    hv_Exception.Dispose();
    hv_NumClasses.Dispose();
    hv_EvalInstances.Dispose();
    hv_Measures.Dispose();
    hv_ClassIDs.Dispose();
    hv_AllocationBlockLength.Dispose();
    hv_IoUThreshs.Dispose();
    hv_MaxNumDetections.Dispose();
    hv_AreaRanges.Dispose();
    hv_AreaNames.Dispose();
    hv_MinAreas.Dispose();
    hv_MaxAreas.Dispose();
    hv_DetailedEvaluation.Dispose();
    hv_MaxNumIdx.Dispose();
    hv_MaxNum.Dispose();
    hv_CurrentRunningMeasure.Dispose();
    hv_AreaIdx.Dispose();
    hv_AreaRunningMeasure.Dispose();
    hv_I.Dispose();
    hv_IoURunningMeasure.Dispose();
    hv_ClsIdx.Dispose();
    hv_ClassRunningMeasures.Dispose();
    hv_Confidence.Dispose();
    hv_IgnoreClassIDs.Dispose();
    hv_CalcConfMatrix.Dispose();
    hv_MatrixSize.Dispose();
    hv_PixelConfusionMatrix.Dispose();
    hv_MaxId.Dispose();
    hv_ClsIDToClsIdx.Dispose();
    hv_TP.Dispose();
    hv_FP.Dispose();
    hv_FN.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Initialize change strategies data. 
  public void init_train_dl_model_change_strategies (HTuple hv_TrainParam, out HTuple hv_ChangeStrategyData)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ChangeStrategies = new HTuple();
    HTuple hv_Enabled = new HTuple(), hv_Index = new HTuple();
    HTuple hv_ChangeStrategy = new HTuple(), hv_ModelParam = new HTuple();
    HTuple hv_Epochs = new HTuple(), hv_Values = new HTuple();
    HTuple hv_Initial = new HTuple(), hv_Indices = new HTuple();
    // Initialize local and output iconic variables 
    hv_ChangeStrategyData = new HTuple();
    //
    //Initialize a dictionary with the change strategies data.
    hv_ChangeStrategyData.Dispose();
    HOperatorSet.CreateDict(out hv_ChangeStrategyData);
    hv_ChangeStrategies.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainParam, "change_strategies", out hv_ChangeStrategies);
    hv_Enabled.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Enabled = new HTuple((new HTuple(hv_ChangeStrategies.TupleLength()
        )).TupleGreater(0));
    }
    HOperatorSet.SetDictTuple(hv_ChangeStrategyData, "enabled", hv_Enabled);
    if ((int)(hv_Enabled.TupleNot()) != 0)
    {

      hv_ChangeStrategies.Dispose();
      hv_Enabled.Dispose();
      hv_Index.Dispose();
      hv_ChangeStrategy.Dispose();
      hv_ModelParam.Dispose();
      hv_Epochs.Dispose();
      hv_Values.Dispose();
      hv_Initial.Dispose();
      hv_Indices.Dispose();

      return;
    }

    //Sort all epochs in all change strategies
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ChangeStrategies.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_ChangeStrategy.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ChangeStrategy = hv_ChangeStrategies.TupleSelect(
          hv_Index);
      }
      hv_ModelParam.Dispose();
      HOperatorSet.GetDictTuple(hv_ChangeStrategy, "model_param", out hv_ModelParam);
      hv_Epochs.Dispose();
      HOperatorSet.GetDictTuple(hv_ChangeStrategy, "epochs", out hv_Epochs);
      hv_Values.Dispose();
      HOperatorSet.GetDictTuple(hv_ChangeStrategy, "values", out hv_Values);
      hv_Initial.Dispose();
      HOperatorSet.GetDictTuple(hv_ChangeStrategy, "initial_value", out hv_Initial);
      //Check that the length are equal.
      if ((int)(new HTuple((new HTuple(hv_Epochs.TupleLength())).TupleNotEqual(new HTuple(hv_Values.TupleLength()
          )))) != 0)
      {
        throw new HalconException("ChangeStrategy parameter error: 'epochs' and 'values' need to have same length.");
      }
      //We need sorted arrays for faster access.
      hv_Indices.Dispose();
      HOperatorSet.TupleSortIndex(hv_Epochs, out hv_Indices);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_ChangeStrategy, "epochs", hv_Epochs.TupleSelect(
          hv_Indices));
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_ChangeStrategy, "values", hv_Values.TupleSelect(
          hv_Indices));
      }
    }
    HOperatorSet.SetDictTuple(hv_ChangeStrategyData, "strategies", hv_ChangeStrategies);

    hv_ChangeStrategies.Dispose();
    hv_Enabled.Dispose();
    hv_Index.Dispose();
    hv_ChangeStrategy.Dispose();
    hv_ModelParam.Dispose();
    hv_Epochs.Dispose();
    hv_Values.Dispose();
    hv_Initial.Dispose();
    hv_Indices.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Initializes the dictionary setting the serialization strategies. 
  public void init_train_dl_model_serialization_strategies (HTuple hv_TrainParam, 
      out HTuple hv_SerializationData)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_SerializationStrategies = new HTuple();
    HTuple hv_RawData = new HTuple(), hv_Types = new HTuple();
    HTuple hv_SerializeFinal = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Strategy = new HTuple(), hv_Type = new HTuple();
    HTuple hv_Data = new HTuple(), hv_Epochs = new HTuple();
    // Initialize local and output iconic variables 
    hv_SerializationData = new HTuple();
    //
    //This procedure initializes the dictionary setting the serialization strategies.
    //
    //Initialize each serialization strategy.
    hv_SerializationStrategies.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainParam, "serialization_strategies", out hv_SerializationStrategies);
    hv_SerializationData.Dispose();
    HOperatorSet.CreateDict(out hv_SerializationData);
    HOperatorSet.SetDictTuple(hv_SerializationData, "strategies", hv_SerializationStrategies);
    hv_RawData.Dispose();
    hv_RawData = new HTuple();
    hv_Types.Dispose();
    hv_Types = new HTuple();
    hv_SerializeFinal.Dispose();
    hv_SerializeFinal = 0;
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_SerializationStrategies.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_Strategy.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Strategy = hv_SerializationStrategies.TupleSelect(
          hv_Index);
      }
      hv_Type.Dispose();
      HOperatorSet.GetDictTuple(hv_Strategy, "type", out hv_Type);
      hv_Data.Dispose();
      HOperatorSet.CreateDict(out hv_Data);
      if ((int)(new HTuple(hv_Type.TupleEqual("best"))) != 0)
      {
        HOperatorSet.SetDictTuple(hv_Data, "best_value", -1);
      }
      else if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
      {
        hv_Epochs.Dispose();
        HOperatorSet.GetDictTuple(hv_Strategy, "epochs", out hv_Epochs);
        //Store sorted values in order to search faster during updates.
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleSort(hv_Epochs, out ExpTmpOutVar_0);
        hv_Epochs.Dispose();
        hv_Epochs = ExpTmpOutVar_0;
        }
        HOperatorSet.SetDictTuple(hv_Data, "epochs", hv_Epochs);
        HOperatorSet.SetDictTuple(hv_Data, "last_epoch_index", -1);
      }
      else if ((int)(new HTuple(hv_Type.TupleEqual("final"))) != 0)
      {
        HOperatorSet.SetDictTuple(hv_Data, "serialize_final", 1);
      }
      else
      {
        throw new HalconException(("Unknown serialization strategy type: '"+hv_Type)+"'");
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Types = hv_Types.TupleConcat(
          hv_Type);
      hv_Types.Dispose();
      hv_Types = ExpTmpLocalVar_Types;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_RawData = hv_RawData.TupleConcat(
          hv_Data);
      hv_RawData.Dispose();
      hv_RawData = ExpTmpLocalVar_RawData;
      }
      }
    }
    HOperatorSet.SetDictTuple(hv_SerializationData, "raw_data", hv_RawData);
    HOperatorSet.SetDictTuple(hv_SerializationData, "types", hv_Types);


    hv_SerializationStrategies.Dispose();
    hv_RawData.Dispose();
    hv_Types.Dispose();
    hv_SerializeFinal.Dispose();
    hv_Index.Dispose();
    hv_Strategy.Dispose();
    hv_Type.Dispose();
    hv_Data.Dispose();
    hv_Epochs.Dispose();

    return;
  }

  public void inspect_normal_direction (HObject ho_MenuRegions, HTuple hv_WindowHandle1, 
      HTuple hv_WindowHandle2, HTuple hv_WindowHandleMenu, HTuple hv_SurfaceModelID, 
      HTuple hv_ObjectModel3DScene, HTuple hv_RelSamplingDistance, HTuple hv_KeyPointFraction, 
      HTuple hv_MinScore, HTuple hv_GenParamNames, HTuple hv_GenParamValues, HTuple hv_SurfaceMatchingResultID, 
      HTuple hv_MenuText, HTuple hv_CurrentCase, HTuple hv_CasesDone, HTuple hv_FontSize, 
      out HTuple hv_CreateNames, out HTuple hv_CreateValues, out HTuple hv_FindNames, 
      out HTuple hv_FindValues)
  {


    using (HDevThreadContext context = new HDevThreadContext())
    {
    // +++ Threading variables 
    HDevThread devThread;


    // Local iconic variables 

    // Local control variables 

    HTuple hv_Instructions = new HTuple(), hv_SampledScene = new HTuple();
    HTuple hv_SampledModel = new HTuple(), hv_VC_P_Model = new HTuple();
    HTuple hv_VC_P_Scene = new HTuple(), hv_NXYZOrig = new HTuple();
    HTuple hv_MessageQueues1 = new HTuple(), hv_Buttons = new HTuple();
    HTuple hv_ShowNormals1 = new HTuple(), hv_MessageQueues2 = new HTuple();
    HTuple hv_ShowNormals2 = new HTuple(), hv_PreviousState1 = new HTuple();
    HTuple hv_PreviousState2 = new HTuple(), hv_DidFinish1 = new HTuple();
    HTuple hv_DidFinish2 = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_WindowHandleBufferMenu = new HTuple();
    HTuple hv_SceneFast = new HTuple(), hv_SceneMLS = new HTuple();
    HTuple hv_NormalsInverted = new HTuple(), hv_ModelNormalsToggled = new HTuple();
    HTuple hv_NormalCompMode = new HTuple(), hv_SceneHasNormals = new HTuple();
    HTuple hv_FastMethod = new HTuple(), hv_Message = new HTuple();
    HTuple hv_MessageChanged = new HTuple(), hv_ButtonPressed = new HTuple();
    HTuple hv_Poses = new HTuple(), hv_NXYZ = new HTuple();
    HTuple hv_MessageHandle = new HTuple(), hv_Pose = new HTuple();
    HTuple hv_Score = new HTuple(), hv_Row1 = new HTuple();
    HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
    HTuple hv_Column2 = new HTuple(), hv_TIT = new HTuple();

    HTupleVector hvec_TI = new HTupleVector(1);
    HTuple   hv_SurfaceMatchingResultID_COPY_INP_TMP = new HTuple(hv_SurfaceMatchingResultID);

    // Initialize local and output iconic variables 
    hv_CreateNames = new HTuple();
    hv_CreateValues = new HTuple();
    hv_FindNames = new HTuple();
    hv_FindValues = new HTuple();
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[0] = "Rotate: Left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[1] = "Zoom:   Shift + left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[2] = "Move:   Ctrl  + left button";
    //
    hv_SampledScene.Dispose();
    HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID_COPY_INP_TMP, 
        "sampled_scene", new HTuple(), out hv_SampledScene);
    hv_SampledModel.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModelID, "sampled_model", out hv_SampledModel);
    //
    //Visualization of the model's normals
    hv_VC_P_Model.Dispose();
    estimate_visualization_pose(hv_SampledModel, hv_WindowHandle1, out hv_VC_P_Model);
    //
    //Visualization of the scene's normals
    hv_VC_P_Scene.Dispose();
    estimate_visualization_pose(hv_SampledScene, hv_WindowHandle2, out hv_VC_P_Scene);
    //
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NXYZOrig.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_SampledModel, new HTuple("point_normal_")+(
        (new HTuple("x")).TupleConcat("y")).TupleConcat("z"), out hv_NXYZOrig);
    }
    //
    hv_MessageQueues1.Dispose();
    create_visualization_message_queues(out hv_MessageQueues1);
    hv_Buttons.Dispose();
    hv_Buttons = new HTuple();
    hv_Buttons[0] = "Continue";
    hv_Buttons[1] = "right";
    hv_Buttons[2] = "bottom";
    hv_Buttons[3] = -1;
    hv_Buttons[4] = -1;
    hv_Buttons[5] = "Invert Normals";
    hv_Buttons[6] = "left";
    hv_Buttons[7] = "bottom";
    hv_Buttons[8] = -1;
    hv_Buttons[9] = -1;
    hv_Buttons[10] = "Hide Normals";
    hv_Buttons[11] = "center";
    hv_Buttons[12] = "bottom";
    hv_Buttons[13] = -1;
    hv_Buttons[14] = -1;
    hv_ShowNormals1.Dispose();
    hv_ShowNormals1 = 1;
    devThread = new HDevThread(context,
      (HDevThread.ProcCallback) delegate(HDevThread devThreadCB)
    {
      try
      {
        // Input parameters
        HTuple        cbhv_WindowHandle = devThreadCB.GetInputCtrlParamTuple(0);
        HTuple        cbhv_ObjectModel3D = devThreadCB.GetInputCtrlParamTuple(1);
        HTuple        cbhv_CamParam = devThreadCB.GetInputCtrlParamTuple(2);
        HTuple        cbhv_PoseIn = devThreadCB.GetInputCtrlParamTuple(3);
        HTuple        cbhv_GenParamName = devThreadCB.GetInputCtrlParamTuple(4);
        HTuple        cbhv_GenParamValue = devThreadCB.GetInputCtrlParamTuple(5);
        HTuple        cbhv_Title = devThreadCB.GetInputCtrlParamTuple(6);
        HTuple        cbhv_Label = devThreadCB.GetInputCtrlParamTuple(7);
        HTuple        cbhv_Information = devThreadCB.GetInputCtrlParamTuple(8);
        HTuple        cbhv_MessageQueue = devThreadCB.GetInputCtrlParamTuple(9);
        HTuple        cbhv_Buttons = devThreadCB.GetInputCtrlParamTuple(10);
        HTuple        cbhv_Type = devThreadCB.GetInputCtrlParamTuple(11);
        HTuple        cbhv_Message = devThreadCB.GetInputCtrlParamTuple(12);
        HTuple        cbhv_DispViewPoint = devThreadCB.GetInputCtrlParamTuple(13);
        HTuple        cbhv_ViewPoint = devThreadCB.GetInputCtrlParamTuple(14);

        // Call visualize_object_model_3d_ext
        visualize_object_model_3d_ext(cbhv_WindowHandle, cbhv_ObjectModel3D, cbhv_CamParam, 
                cbhv_PoseIn, cbhv_GenParamName, cbhv_GenParamValue, cbhv_Title, cbhv_Label, 
                cbhv_Information, cbhv_MessageQueue, cbhv_Buttons, cbhv_Type, cbhv_Message, 
                cbhv_DispViewPoint, cbhv_ViewPoint);

        // Reduce reference counter of thread object
        devThreadCB.Exit();
        devThreadCB.Dispose();

      }
      catch (HalconException exc)
      {
        // No exceptions may be raised from stub in parallel case,
        // so we need to store this information prior to cleanup
        bool is_direct_call = devThreadCB.IsDirectCall();
        // Attempt to clean up in error case, too
        devThreadCB.Exit();
        devThreadCB.Dispose();
        // Propagate exception if called directly
        if (is_direct_call)
          throw exc;
      }
    },15,0);
    // Set thread procedure call arguments 
    devThread.SetInputCtrlParamTuple(0,hv_WindowHandle1);
    devThread.SetInputCtrlParamTuple(1,hv_SampledModel);
    devThread.SetInputCtrlParamTuple(2,new HTuple());
    devThread.SetInputCtrlParamTuple(3,hv_VC_P_Model);
    devThread.SetInputCtrlParamTuple(4,((
        (new HTuple("color_0")).TupleConcat("normal_color_0")).TupleConcat("disp_normals")).TupleConcat(
        "disp_pose"));
    devThread.SetInputCtrlParamTuple(5,(((new HTuple("cyan")).TupleConcat(
        "gray")).TupleConcat("true")).TupleConcat("true"));
    devThread.SetInputCtrlParamTuple(6,"Model");
    devThread.SetInputCtrlParamTuple(7,new HTuple());
    devThread.SetInputCtrlParamTuple(8,hv_Instructions);
    devThread.SetInputCtrlParamTuple(9,hv_MessageQueues1);
    devThread.SetInputCtrlParamTuple(10,hv_Buttons);
    devThread.SetInputCtrlParamTuple(11,new HTuple());
    devThread.SetInputCtrlParamTuple(12,new HTuple());
    devThread.SetInputCtrlParamTuple(13,"false");
    devThread.SetInputCtrlParamTuple(14,new HTuple());

    // Start proc line in thread
    {
    HTuple TmpThreadId;
    devThread.ParStart(out TmpThreadId);
    hvec_TI[0].T = TmpThreadId;
    }


    hv_MessageQueues2.Dispose();
    create_visualization_message_queues(out hv_MessageQueues2);
    hv_Buttons.Dispose();
    hv_Buttons = new HTuple();
    hv_Buttons[0] = "Hide Normals";
    hv_Buttons[1] = "right";
    hv_Buttons[2] = "bottom";
    hv_Buttons[3] = -1;
    hv_Buttons[4] = -1;
    hv_Buttons[5] = "Normals: fast";
    hv_Buttons[6] = "left";
    hv_Buttons[7] = "bottom";
    hv_Buttons[8] = -1;
    hv_Buttons[9] = -1;
    hv_Buttons[10] = "Normals: mls";
    hv_Buttons[11] = "center";
    hv_Buttons[12] = "bottom";
    hv_Buttons[13] = -1;
    hv_Buttons[14] = -1;
    hv_ShowNormals2.Dispose();
    hv_ShowNormals2 = 1;
    devThread = new HDevThread(context,
      (HDevThread.ProcCallback) delegate(HDevThread devThreadCB)
    {
      try
      {
        // Input parameters
        HTuple        cbhv_WindowHandle = devThreadCB.GetInputCtrlParamTuple(0);
        HTuple        cbhv_ObjectModel3D = devThreadCB.GetInputCtrlParamTuple(1);
        HTuple        cbhv_CamParam = devThreadCB.GetInputCtrlParamTuple(2);
        HTuple        cbhv_PoseIn = devThreadCB.GetInputCtrlParamTuple(3);
        HTuple        cbhv_GenParamName = devThreadCB.GetInputCtrlParamTuple(4);
        HTuple        cbhv_GenParamValue = devThreadCB.GetInputCtrlParamTuple(5);
        HTuple        cbhv_Title = devThreadCB.GetInputCtrlParamTuple(6);
        HTuple        cbhv_Label = devThreadCB.GetInputCtrlParamTuple(7);
        HTuple        cbhv_Information = devThreadCB.GetInputCtrlParamTuple(8);
        HTuple        cbhv_MessageQueue = devThreadCB.GetInputCtrlParamTuple(9);
        HTuple        cbhv_Buttons = devThreadCB.GetInputCtrlParamTuple(10);
        HTuple        cbhv_Type = devThreadCB.GetInputCtrlParamTuple(11);
        HTuple        cbhv_Message = devThreadCB.GetInputCtrlParamTuple(12);
        HTuple        cbhv_DispViewPoint = devThreadCB.GetInputCtrlParamTuple(13);
        HTuple        cbhv_ViewPoint = devThreadCB.GetInputCtrlParamTuple(14);

        // Call visualize_object_model_3d_ext
        visualize_object_model_3d_ext(cbhv_WindowHandle, cbhv_ObjectModel3D, cbhv_CamParam, 
                cbhv_PoseIn, cbhv_GenParamName, cbhv_GenParamValue, cbhv_Title, cbhv_Label, 
                cbhv_Information, cbhv_MessageQueue, cbhv_Buttons, cbhv_Type, cbhv_Message, 
                cbhv_DispViewPoint, cbhv_ViewPoint);

        // Reduce reference counter of thread object
        devThreadCB.Exit();
        devThreadCB.Dispose();

      }
      catch (HalconException exc)
      {
        // No exceptions may be raised from stub in parallel case,
        // so we need to store this information prior to cleanup
        bool is_direct_call = devThreadCB.IsDirectCall();
        // Attempt to clean up in error case, too
        devThreadCB.Exit();
        devThreadCB.Dispose();
        // Propagate exception if called directly
        if (is_direct_call)
          throw exc;
      }
    },15,0);
    // Set thread procedure call arguments 
    devThread.SetInputCtrlParamTuple(0,hv_WindowHandle2);
    devThread.SetInputCtrlParamTuple(1,hv_SampledScene);
    devThread.SetInputCtrlParamTuple(2,new HTuple());
    devThread.SetInputCtrlParamTuple(3,hv_VC_P_Scene);
    devThread.SetInputCtrlParamTuple(4,((
        (new HTuple("color_0")).TupleConcat("normal_color_0")).TupleConcat("disp_normals")).TupleConcat(
        "disp_pose"));
    devThread.SetInputCtrlParamTuple(5,(((new HTuple("cyan")).TupleConcat(
        "gray")).TupleConcat("true")).TupleConcat("true"));
    devThread.SetInputCtrlParamTuple(6,"Scene");
    devThread.SetInputCtrlParamTuple(7,new HTuple());
    devThread.SetInputCtrlParamTuple(8,hv_Instructions);
    devThread.SetInputCtrlParamTuple(9,hv_MessageQueues2);
    devThread.SetInputCtrlParamTuple(10,hv_Buttons);
    devThread.SetInputCtrlParamTuple(11,new HTuple());
    devThread.SetInputCtrlParamTuple(12,new HTuple());
    devThread.SetInputCtrlParamTuple(13,"false");
    devThread.SetInputCtrlParamTuple(14,new HTuple());

    // Start proc line in thread
    {
    HTuple TmpThreadId;
    devThread.ParStart(out TmpThreadId);
    hvec_TI[1].T = TmpThreadId;
    }

    hv_PreviousState1.Dispose();
    hv_PreviousState1 = new HTuple();
    hv_PreviousState2.Dispose();
    hv_PreviousState2 = new HTuple();
    hv_DidFinish1.Dispose();
    hv_DidFinish1 = 0;
    hv_DidFinish2.Dispose();
    hv_DidFinish2 = 0;
    //
    //Open a second (invisible) buffer window to avoid flickering
    hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandleMenu, out hv_Row, out hv_Column, 
        out hv_Width, out hv_Height);
    hv_WindowHandleBufferMenu.Dispose();
    HOperatorSet.OpenWindow(0, 0, hv_Width, hv_Height, 0, "buffer", "", out hv_WindowHandleBufferMenu);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetPart(hv_WindowHandleBufferMenu, 0, 0, hv_Height-1, hv_Width-1);
    }
    set_display_font(hv_WindowHandleBufferMenu, hv_FontSize, "mono", "true", "false");
    //
    //Cached normals
    hv_SceneFast.Dispose();
    hv_SceneFast = new HTuple();
    hv_SceneMLS.Dispose();
    hv_SceneMLS = new HTuple();
    hv_NormalsInverted.Dispose();
    HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID_COPY_INP_TMP, 
        "model_invert_normals", new HTuple(), out hv_NormalsInverted);
    if ((int)(new HTuple(hv_NormalsInverted.TupleEqual("true"))) != 0)
    {
      hv_ModelNormalsToggled.Dispose();
      hv_ModelNormalsToggled = 1;
    }
    else
    {
      hv_ModelNormalsToggled.Dispose();
      hv_ModelNormalsToggled = 0;
    }
    hv_NormalCompMode.Dispose();
    get_find_parameter(hv_GenParamNames, hv_GenParamValues, "scene_normal_computation", 
        "fast", out hv_NormalCompMode);
    hv_SceneHasNormals.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "has_point_normals", 
        out hv_SceneHasNormals);
    if ((int)(new HTuple(hv_SceneHasNormals.TupleEqual("true"))) != 0)
    {
      hv_FastMethod.Dispose();
      hv_FastMethod = new HTuple("(default, using existing scene normals)");
    }
    else
    {
      hv_FastMethod.Dispose();
      hv_FastMethod = new HTuple("(default, using XYZ-mapping)");
    }
    hv_CreateNames.Dispose();
    hv_CreateNames = new HTuple();
    hv_CreateValues.Dispose();
    hv_CreateValues = new HTuple();
    hv_FindNames.Dispose();
    hv_FindNames = new HTuple();
    hv_FindValues.Dispose();
    hv_FindValues = new HTuple();
    //
    if (hv_Message == null)
      hv_Message = new HTuple();
    hv_Message[0] = new HTuple("Check visually, if the normals of the model point approximately in the same direction as the normals of the scene by moving the model and the scene accordingly");
    if ((int)(hv_ModelNormalsToggled.TupleNot()) != 0)
    {
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[1] = "Model normals are not inverted (default)";
    }
    else
    {
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[1] = "Model normals are inverted";
    }
    if ((int)(new HTuple(hv_NormalCompMode.TupleEqual("fast"))) != 0)
    {
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[2] = "Scene normals are computed based on the fast method "+hv_FastMethod;
    }
    else if ((int)(new HTuple(hv_NormalCompMode.TupleEqual("mls"))) != 0)
    {
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[2] = "Scene normals are computed based on the mls method";
    }
    else
    {
      if (hv_Message == null)
        hv_Message = new HTuple();
      hv_Message[2] = "Scene normals are computed based on an unknown method";
    }
    hv_MessageChanged.Dispose();
    hv_MessageChanged = 1;
    //
    do
    {
      //Process first visualization window
      hv_DidFinish1.Dispose();
      {
      HTuple ExpTmpOutVar_0;hv_ButtonPressed.Dispose();hv_Poses.Dispose();
      process_visualize_events_generic(hv_WindowHandle1, hv_MessageQueues1, hv_PreviousState1, 
          out hv_DidFinish1, out ExpTmpOutVar_0, out hv_ButtonPressed, out hv_Poses);
      hv_PreviousState1.Dispose();
      hv_PreviousState1 = ExpTmpOutVar_0;
      }

      if ((int)((new HTuple(hv_ButtonPressed.TupleEqual(0))).TupleOr(hv_DidFinish1)) != 0)
      {
        //Exit-button
        break;
      }
      else if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(1))) != 0)
      {
        //Invert Normals
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NXYZ.Dispose();
        HOperatorSet.GetObjectModel3dParams(hv_SampledModel, new HTuple("point_normal_")+(
            (new HTuple("x")).TupleConcat("y")).TupleConcat("z"), out hv_NXYZ);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetObjectModel3dAttribMod(hv_SampledModel, new HTuple("point_normal_")+(
            (new HTuple("x")).TupleConcat("y")).TupleConcat("z"), new HTuple(), -hv_NXYZ);
        }
        //Redraw to show the flipped normals
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "force_redraw");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues1.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ModelNormalsToggled = hv_ModelNormalsToggled.TupleNot()
            ;
        hv_ModelNormalsToggled.Dispose();
        hv_ModelNormalsToggled = ExpTmpLocalVar_ModelNormalsToggled;
        }
        }
        //Update parameter display
        if ((int)(hv_ModelNormalsToggled.TupleNot()) != 0)
        {
          if (hv_Message == null)
            hv_Message = new HTuple();
          hv_Message[1] = "Model normals are not inverted (default)";
          hv_CreateNames.Dispose();
          hv_CreateNames = new HTuple();
          hv_CreateValues.Dispose();
          hv_CreateValues = new HTuple();
        }
        else
        {
          if (hv_Message == null)
            hv_Message = new HTuple();
          hv_Message[1] = "Model normals are inverted";
          hv_CreateNames.Dispose();
          hv_CreateNames = "model_invert_normals";
          hv_CreateValues.Dispose();
          hv_CreateValues = "true";
        }
        hv_MessageChanged.Dispose();
        hv_MessageChanged = 1;
      }
      else if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(2))) != 0)
      {
        //Toggle normals
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ShowNormals1 = hv_ShowNormals1.TupleNot()
            ;
        hv_ShowNormals1.Dispose();
        hv_ShowNormals1 = ExpTmpLocalVar_ShowNormals1;
        }
        }
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "toggle_param");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "param", "disp_normals");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues1.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "change_button_text");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "index", 2);
        if ((int)(hv_ShowNormals1) != 0)
        {
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "text", "Hide Normals");
        }
        else
        {
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "text", "Show Normals");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues1.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
      }

      //Process second visualization window
      hv_DidFinish2.Dispose();
      {
      HTuple ExpTmpOutVar_0;hv_ButtonPressed.Dispose();hv_Pose.Dispose();
      process_visualize_events_generic(hv_WindowHandle2, hv_MessageQueues2, hv_PreviousState2, 
          out hv_DidFinish2, out ExpTmpOutVar_0, out hv_ButtonPressed, out hv_Pose);
      hv_PreviousState2.Dispose();
      hv_PreviousState2 = ExpTmpOutVar_0;
      }

      if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ShowNormals2 = hv_ShowNormals2.TupleNot()
            ;
        hv_ShowNormals2.Dispose();
        hv_ShowNormals2 = ExpTmpLocalVar_ShowNormals2;
        }
        }
        //Toggle normals
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "toggle_param");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "param", "disp_normals");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "change_button_text");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "index", 0);
        if ((int)(hv_ShowNormals2) != 0)
        {
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "text", "Hide Normals");
        }
        else
        {
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "text", "Show Normals");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
      }
      else if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(1))) != 0)
      {
        //FAST
        //Use very fast find parameters, since we are only interested in the sampled scene
        if ((int)(new HTuple(hv_SceneFast.TupleEqual(new HTuple()))) != 0)
        {
          hv_Pose.Dispose();hv_Score.Dispose();hv_SurfaceMatchingResultID_COPY_INP_TMP.Dispose();
          HOperatorSet.FindSurfaceModel(hv_SurfaceModelID, hv_ObjectModel3DScene, 
              hv_RelSamplingDistance, 0.00001, 0, "true", ((new HTuple("dense_pose_refinement")).TupleConcat(
              "sparse_pose_refinement")).TupleConcat("scene_normal_computation"), 
              ((new HTuple("false")).TupleConcat("false")).TupleConcat("fast"), out hv_Pose, 
              out hv_Score, out hv_SurfaceMatchingResultID_COPY_INP_TMP);
          hv_SceneFast.Dispose();
          HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID_COPY_INP_TMP, 
              "sampled_scene", 0, out hv_SceneFast);
        }
        //Send the new 3D object model to the visualization thread
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "replace_object_model");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "index", 0);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "model", hv_SceneFast);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        if (hv_Message == null)
          hv_Message = new HTuple();
        hv_Message[2] = "Scene normals are computed based on the fast method "+hv_FastMethod;
        hv_MessageChanged.Dispose();
        hv_MessageChanged = 1;
        hv_FindNames.Dispose();
        hv_FindNames = new HTuple();
        hv_FindValues.Dispose();
        hv_FindValues = new HTuple();
      }
      else if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(2))) != 0)
      {
        //MLS
        if ((int)(new HTuple(hv_SceneMLS.TupleEqual(new HTuple()))) != 0)
        {
          //Use very fast find parameters, since we are only interested in the sampled scene
          hv_Pose.Dispose();hv_Score.Dispose();hv_SurfaceMatchingResultID_COPY_INP_TMP.Dispose();
          HOperatorSet.FindSurfaceModel(hv_SurfaceModelID, hv_ObjectModel3DScene, 
              hv_RelSamplingDistance, 0.00001, 0, "true", ((new HTuple("dense_pose_refinement")).TupleConcat(
              "sparse_pose_refinement")).TupleConcat("scene_normal_computation"), 
              ((new HTuple("false")).TupleConcat("false")).TupleConcat("mls"), out hv_Pose, 
              out hv_Score, out hv_SurfaceMatchingResultID_COPY_INP_TMP);
          hv_SceneMLS.Dispose();
          HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID_COPY_INP_TMP, 
              "sampled_scene", 0, out hv_SceneMLS);
        }
        //Send the new 3D object model to the visualization thread
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "replace_object_model");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "index", 0);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "model", hv_SceneMLS);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        if (hv_Message == null)
          hv_Message = new HTuple();
        hv_Message[2] = "Scene normals are computed based on the mls method";
        hv_MessageChanged.Dispose();
        hv_MessageChanged = 1;
        hv_FindNames.Dispose();
        hv_FindNames = "scene_normal_computation";
        hv_FindValues.Dispose();
        hv_FindValues = "mls";
      }

      //Update the menu window
      if ((int)(hv_MessageChanged) != 0)
      {
        HOperatorSet.ClearWindow(hv_WindowHandleBufferMenu);
        HOperatorSet.SetColor(hv_WindowHandleBufferMenu, "black");
        disp_menu_ext(ho_MenuRegions, hv_WindowHandleBufferMenu, hv_MenuText, hv_CasesDone, 
            hv_CurrentCase);
        //
        hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
        HOperatorSet.SmallestRectangle1(ho_MenuRegions, out hv_Row1, out hv_Column1, 
            out hv_Row2, out hv_Column2);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetTposition(hv_WindowHandleBufferMenu, (hv_Row2.TupleMax())+6, 
            1);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandleBufferMenu, "instruction", hv_Message.TupleSelect(
            0));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandleBufferMenu, "info", hv_Message.TupleSelect(1));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_note(hv_WindowHandleBufferMenu, "none", hv_Message.TupleSelect(2));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.CopyRectangle(hv_WindowHandleBufferMenu, hv_WindowHandleMenu, 
            0, 0, hv_Height-1, (hv_Width*2)-1, 0, 0);
        }
        hv_MessageChanged.Dispose();
        hv_MessageChanged = 0;
      }
    }
    while ((int)(hv_DidFinish1.TupleOr(hv_DidFinish2)) == 0);
    //
    //Send termination message to all subthreads
    hv_MessageHandle.Dispose();
    HOperatorSet.CreateMessage(out hv_MessageHandle);
    HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "exit");
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.EnqueueMessage(hv_MessageQueues1.TupleSelect(1), hv_MessageHandle, 
        new HTuple(), new HTuple());
    }
    hv_MessageHandle.Dispose();
    HOperatorSet.CreateMessage(out hv_MessageHandle);
    HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "exit");
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
        new HTuple(), new HTuple());
    }
    //
    hv_TIT = hvec_TI.ConvertVectorToTuple();
    HDevThread.ParJoin(hv_TIT);
    //

    hv_SurfaceMatchingResultID_COPY_INP_TMP.Dispose();
    hv_Instructions.Dispose();
    hv_SampledScene.Dispose();
    hv_SampledModel.Dispose();
    hv_VC_P_Model.Dispose();
    hv_VC_P_Scene.Dispose();
    hv_NXYZOrig.Dispose();
    hv_MessageQueues1.Dispose();
    hv_Buttons.Dispose();
    hv_ShowNormals1.Dispose();
    hv_MessageQueues2.Dispose();
    hv_ShowNormals2.Dispose();
    hv_PreviousState1.Dispose();
    hv_PreviousState2.Dispose();
    hv_DidFinish1.Dispose();
    hv_DidFinish2.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_WindowHandleBufferMenu.Dispose();
    hv_SceneFast.Dispose();
    hv_SceneMLS.Dispose();
    hv_NormalsInverted.Dispose();
    hv_ModelNormalsToggled.Dispose();
    hv_NormalCompMode.Dispose();
    hv_SceneHasNormals.Dispose();
    hv_FastMethod.Dispose();
    hv_Message.Dispose();
    hv_MessageChanged.Dispose();
    hv_ButtonPressed.Dispose();
    hv_Poses.Dispose();
    hv_NXYZ.Dispose();
    hv_MessageHandle.Dispose();
    hv_Pose.Dispose();
    hv_Score.Dispose();
    hv_Row1.Dispose();
    hv_Column1.Dispose();
    hv_Row2.Dispose();
    hv_Column2.Dispose();
    hv_TIT.Dispose();
    hvec_TI.Dispose();

    return;
    }
  }

  public void inspect_scene_edge_directions (HTuple hv_WindowHandle1, HTuple hv_WindowHandle2, 
      HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3DScene, HTuple hv_SurfaceMatchingResultID, 
      HTuple hv_MaxGapIn, HTuple hv_MinAmplitudeIn, HTuple hv_ViewpointIn, out HTuple hv_Viewpoint)
  {

    using (HDevThreadContext context = new HDevThreadContext())
    {
    // +++ Threading variables 
    HDevThread devThread;


    // Local iconic variables 

    // Local control variables 

    HTuple hv_Diameter = new HTuple(), hv_DefaultAmplitude = new HTuple();
    HTuple hv_MinAmplitude = new HTuple(), hv_MaxAmplitude = new HTuple();
    HTuple hv_DefaultMaxGap = new HTuple(), hv_MappingSize = new HTuple();
    HTuple hv_MinMaxGap = new HTuple(), hv_MaxMaxGap = new HTuple();
    HTuple hv_CenterScene = new HTuple(), hv_DiameterScene = new HTuple();
    HTuple hv_DiameterModel = new HTuple(), hv_ViewpointStr = new HTuple();
    HTuple hv_Direction = new HTuple(), hv_Length = new HTuple();
    HTuple hv_LengthRel = new HTuple(), hv_ViewpointViz = new HTuple();
    HTuple hv_ObjectModel3DSceneSampled = new HTuple(), hv_ObjectModel3DEdges = new HTuple();
    HTuple hv_EdgeDirs = new HTuple(), hv_ObjectModel3DEdgeDirs = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_CenterSceneGravity = new HTuple();
    HTuple hv_OM3DCamera = new HTuple(), hv_OM3DLineSphereToScene = new HTuple();
    HTuple hv_DirectionLength = new HTuple(), hv_ViewpointAsPoseIn = new HTuple();
    HTuple hv_DirNorm = new HTuple(), hv_Axis = new HTuple();
    HTuple hv_AxisNorm = new HTuple(), hv_OrthogonalDirection = new HTuple();
    HTuple hv_RotationAxis = new HTuple(), hv_DirectionProjected = new HTuple();
    HTuple hv_AngleToX = new HTuple(), hv_HomMat3DIdentity = new HTuple();
    HTuple hv_HomMat3DRotate = new HTuple(), hv_Instructions = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_CameraParam = new HTuple(), hv_Buttons = new HTuple();
    HTuple hv_MessageQueues1 = new HTuple(), hv_PreviousState1 = new HTuple();
    HTuple hv_DidFinish1 = new HTuple(), hv_VizCenter = new HTuple();
    HTuple hv_HomMat3DIdentity1 = new HTuple(), hv_PoseIn = new HTuple();
    HTuple hv_VizposeIn = new HTuple(), hv_ShowViewDir = new HTuple();
    HTuple hv_ShowEdgeDir = new HTuple(), hv_MessageQueues2 = new HTuple();
    HTuple hv_PreviousState2 = new HTuple(), hv_ButtonPressed = new HTuple();
    HTuple hv_Pose = new HTuple(), hv_MessageHandle = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_HomMat3DInvert = new HTuple();
    HTuple hv_Qx = new HTuple(), hv_Qy = new HTuple(), hv_Qz = new HTuple();
    HTuple hv_DidFinish2 = new HTuple(), hv_Poses = new HTuple();
    HTuple hv_TIT = new HTuple();

    HTupleVector hvec_TI = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_Viewpoint = new HTuple();
    //Initial, Minimum and Maximum parameter values
    hv_Diameter.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModelID, "diameter", out hv_Diameter);
    hv_DefaultAmplitude.Dispose();
    hv_DefaultAmplitude = new HTuple(hv_MinAmplitudeIn);
    hv_MinAmplitude.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MinAmplitude = 0.0001*hv_Diameter;
    }
    hv_MaxAmplitude.Dispose();
    hv_MaxAmplitude = new HTuple(hv_Diameter);
    hv_DefaultMaxGap.Dispose();
    hv_DefaultMaxGap = new HTuple(hv_MaxGapIn);
    //
    hv_MappingSize.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "mapping_size", out hv_MappingSize);
    hv_MinMaxGap.Dispose();
    hv_MinMaxGap = 0;
    hv_MaxMaxGap.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxMaxGap = hv_MappingSize.TupleMax()
        ;
    }
    //
    hv_CenterScene.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "center", out hv_CenterScene);
    hv_DiameterScene.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "diameter", out hv_DiameterScene);
    //
    hv_DiameterModel.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModelID, "diameter", out hv_DiameterModel);
    hv_Viewpoint.Dispose();
    hv_Viewpoint = new HTuple(hv_ViewpointIn);
    hv_ViewpointStr.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ViewpointStr = ((((hv_Viewpoint.TupleSelect(
        0))+" ")+(hv_Viewpoint.TupleSelect(1)))+" ")+(hv_Viewpoint.TupleSelect(2));
    }
    //With this method, the viewpoint would be very far away in view 2, leading to not-so-nice
    //visualization. Adapt the distance to be always <= SceneDiameter.
    hv_Direction.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Direction = hv_Viewpoint-hv_CenterScene;
    }
    hv_Length.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Length = ((((hv_Direction*hv_Direction)).TupleSum()
        )).TupleSqrt();
    }
    hv_LengthRel.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_LengthRel = hv_Length/hv_DiameterScene;
    }
    if ((int)(new HTuple(hv_LengthRel.TupleGreater(1))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Direction = hv_Direction/hv_LengthRel;
      hv_Direction.Dispose();
      hv_Direction = ExpTmpLocalVar_Direction;
      }
      }
    }
    hv_ViewpointViz.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ViewpointViz = hv_CenterScene+hv_Direction;
    }
    //
    try
    {
      hv_ObjectModel3DSceneSampled.Dispose();
      HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", 
          0, out hv_ObjectModel3DSceneSampled);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ObjectModel3DEdges.Dispose();
      HOperatorSet.EdgesObjectModel3d(hv_ObjectModel3DScene, hv_DefaultAmplitude, 
          (new HTuple("max_gap")).TupleConcat("viewpoint"), hv_DefaultMaxGap.TupleConcat(
          hv_ViewpointStr), out hv_ObjectModel3DEdges);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.SampleObjectModel3d(hv_ObjectModel3DEdges, "fast_compute_normals", 
          hv_DiameterModel*0.02, new HTuple(), new HTuple(), out ExpTmpOutVar_0);
      hv_ObjectModel3DEdges.Dispose();
      hv_ObjectModel3DEdges = ExpTmpOutVar_0;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EdgeDirs.Dispose();
      HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DEdges, new HTuple("edge_dir_")+(
          (new HTuple("x")).TupleConcat("y")).TupleConcat("z"), out hv_EdgeDirs);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ObjectModel3DEdgeDirs.Dispose();
      HOperatorSet.SetObjectModel3dAttrib(hv_ObjectModel3DEdges, new HTuple("point_normal_")+(
          (new HTuple("x")).TupleConcat("y")).TupleConcat("z"), new HTuple(), hv_EdgeDirs, 
          out hv_ObjectModel3DEdgeDirs);
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      //Unable to extract edges -> create a dummy 3D object model instead
      hv_ObjectModel3DEdges.Dispose();
      HOperatorSet.GenEmptyObjectModel3d(out hv_ObjectModel3DEdges);
      hv_ObjectModel3DEdgeDirs.Dispose();
      HOperatorSet.GenEmptyObjectModel3d(out hv_ObjectModel3DEdgeDirs);
    }
    //
    //We only define a viewpoint, not a full camera. "Fake" a camera that looks towards the center of
    //gravity of the scene. Do not point it towards the center of the bounding box, since that is rather
    //unstable (a single outlier point would distort it).
    hv_CenterSceneGravity.Dispose();
    HOperatorSet.MomentsObjectModel3d(hv_ObjectModel3DScene, "mean_points", out hv_CenterSceneGravity);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DCamera.Dispose();
    gen_camera_facing_scene(hv_ViewpointViz, hv_CenterSceneGravity, hv_DiameterModel*2, 
        out hv_OM3DCamera);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_OM3DLineSphereToScene.Dispose();
    HOperatorSet.GenObjectModel3dFromPoints(((hv_ViewpointViz.TupleSelect(0))).TupleConcat(
        hv_CenterScene.TupleSelect(0)), ((hv_ViewpointViz.TupleSelect(1))).TupleConcat(
        hv_CenterScene.TupleSelect(1)), ((hv_ViewpointViz.TupleSelect(2))).TupleConcat(
        hv_CenterScene.TupleSelect(2)), out hv_OM3DLineSphereToScene);
    }
    HOperatorSet.SetObjectModel3dAttribMod(hv_OM3DLineSphereToScene, "lines", new HTuple(), 
        ((new HTuple(2)).TupleConcat(0)).TupleConcat(1));
    //
    //Convert input viewpoint into initial pose
    hv_Direction.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Direction = hv_Viewpoint-hv_CenterScene;
    }
    hv_DirectionLength.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DirectionLength = ((((hv_Direction*hv_Direction)).TupleSum()
        )).TupleSqrt();
    }
    if ((int)(new HTuple(hv_DirectionLength.TupleLess(1e-1*hv_DiameterModel))) != 0)
    {
      hv_ViewpointAsPoseIn.Dispose();
      hv_ViewpointAsPoseIn = new HTuple();
      hv_ViewpointAsPoseIn[0] = 0;
      hv_ViewpointAsPoseIn[1] = 0;
      hv_ViewpointAsPoseIn[2] = 0;
      hv_ViewpointAsPoseIn[3] = 0;
      hv_ViewpointAsPoseIn[4] = 0;
      hv_ViewpointAsPoseIn[5] = 0;
      hv_ViewpointAsPoseIn[6] = 0;
    }
    else
    {
      //Create a rotation such that the camera faces the center of gravity of the scene
      hv_DirNorm.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DirNorm = hv_Direction/hv_DirectionLength;
      }
      if ((int)(new HTuple(((((hv_DirNorm*((new HTuple(0)).TupleConcat(0)).TupleConcat(
          -1))).TupleSum())).TupleGreater(-0.99999))) != 0)
      {
        //Angle between the vectors is > 0.25X
        hv_Axis.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Axis = hv_DirNorm+(
            (new HTuple(0)).TupleConcat(0)).TupleConcat(-1);
        }
        hv_AxisNorm.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AxisNorm = hv_Axis/(((((hv_Axis*hv_Axis)).TupleSum()
            )).TupleSqrt());
        }
        hv_OrthogonalDirection.Dispose();
        tuple_vector_cross_product(hv_DirNorm, ((new HTuple(0)).TupleConcat(0)).TupleConcat(
            1), out hv_OrthogonalDirection);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_OrthogonalDirection = hv_OrthogonalDirection/(((((hv_OrthogonalDirection*hv_OrthogonalDirection)).TupleSum()
            )).TupleSqrt());
        hv_OrthogonalDirection.Dispose();
        hv_OrthogonalDirection = ExpTmpLocalVar_OrthogonalDirection;
        }
        }
      }
      else
      {
        hv_Axis.Dispose();
        hv_Axis = new HTuple();
        hv_Axis[0] = 0;
        hv_Axis[1] = 1;
        hv_Axis[2] = 0;
        hv_OrthogonalDirection.Dispose();
        hv_OrthogonalDirection = new HTuple();
        hv_OrthogonalDirection[0] = 1;
        hv_OrthogonalDirection[1] = 0;
        hv_OrthogonalDirection[2] = 0;
      }
      hv_RotationAxis.Dispose();
      tuple_vector_cross_product(((new HTuple(0)).TupleConcat(0)).TupleConcat(1), 
          hv_OrthogonalDirection, out hv_RotationAxis);
      hv_DirectionProjected.Dispose();
      tuple_vector_cross_product(((new HTuple(0)).TupleConcat(0)).TupleConcat(1), 
          hv_RotationAxis, out hv_DirectionProjected);
      hv_AngleToX.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_AngleToX = ((hv_DirectionProjected.TupleSelect(
          0))).TupleAtan2(hv_DirectionProjected.TupleSelect(1));
      }
      hv_HomMat3DIdentity.Dispose();
      HOperatorSet.HomMat3dIdentity(out hv_HomMat3DIdentity);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HomMat3DRotate.Dispose();
      HOperatorSet.HomMat3dRotateLocal(hv_HomMat3DIdentity, (new HTuple(180)).TupleRad()
          , hv_Axis, out hv_HomMat3DRotate);
      }
      hv_ViewpointAsPoseIn.Dispose();
      HOperatorSet.HomMat3dToPose(hv_HomMat3DRotate, out hv_ViewpointAsPoseIn);
    }
    if (hv_ViewpointAsPoseIn == null)
      hv_ViewpointAsPoseIn = new HTuple();
    hv_ViewpointAsPoseIn[HTuple.TupleGenSequence(0,2,1)] = hv_Viewpoint;
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.PoseInvert(hv_ViewpointAsPoseIn, out ExpTmpOutVar_0);
    hv_ViewpointAsPoseIn.Dispose();
    hv_ViewpointAsPoseIn = ExpTmpOutVar_0;
    }
    //
    //Start the first 3D visualization window
    //In this window, one can set the viewpoint position
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[0] = "Rotate: Left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[1] = "Zoom:   Shift + left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[2] = "Move:   Ctrl  + left button";
    //
    hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle1, out hv_Row, out hv_Column, out hv_Width, 
        out hv_Height);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CameraParam.Dispose();
    gen_cam_par_area_scan_division(0.005, 0, 5.2e-06, 5.2e-06, (hv_Width*0.5)+0.5, 
        (hv_Height*0.5)+0.5, hv_Width, hv_Height, out hv_CameraParam);
    }
    hv_Buttons.Dispose();
    hv_Buttons = new HTuple();
    hv_Buttons[0] = "Continue";
    hv_Buttons[1] = "right";
    hv_Buttons[2] = "bottom";
    hv_Buttons[3] = -1;
    hv_Buttons[4] = -1;
    hv_Buttons[5] = "Reset";
    hv_Buttons[6] = "left";
    hv_Buttons[7] = "bottom";
    hv_Buttons[8] = -1;
    hv_Buttons[9] = -1;
    hv_MessageQueues1.Dispose();
    create_visualization_message_queues(out hv_MessageQueues1);
    devThread = new HDevThread(context,
      (HDevThread.ProcCallback) delegate(HDevThread devThreadCB)
    {
      try
      {
        // Input parameters
        HTuple        cbhv_WindowHandle = devThreadCB.GetInputCtrlParamTuple(0);
        HTuple        cbhv_ObjectModel3D = devThreadCB.GetInputCtrlParamTuple(1);
        HTuple        cbhv_CamParam = devThreadCB.GetInputCtrlParamTuple(2);
        HTuple        cbhv_PoseIn = devThreadCB.GetInputCtrlParamTuple(3);
        HTuple        cbhv_GenParamName = devThreadCB.GetInputCtrlParamTuple(4);
        HTuple        cbhv_GenParamValue = devThreadCB.GetInputCtrlParamTuple(5);
        HTuple        cbhv_Title = devThreadCB.GetInputCtrlParamTuple(6);
        HTuple        cbhv_Label = devThreadCB.GetInputCtrlParamTuple(7);
        HTuple        cbhv_Information = devThreadCB.GetInputCtrlParamTuple(8);
        HTuple        cbhv_MessageQueue = devThreadCB.GetInputCtrlParamTuple(9);
        HTuple        cbhv_Buttons = devThreadCB.GetInputCtrlParamTuple(10);
        HTuple        cbhv_Type = devThreadCB.GetInputCtrlParamTuple(11);
        HTuple        cbhv_Message = devThreadCB.GetInputCtrlParamTuple(12);
        HTuple        cbhv_DispViewPoint = devThreadCB.GetInputCtrlParamTuple(13);
        HTuple        cbhv_ViewPoint = devThreadCB.GetInputCtrlParamTuple(14);

        // Call visualize_object_model_3d_ext
        visualize_object_model_3d_ext(cbhv_WindowHandle, cbhv_ObjectModel3D, cbhv_CamParam, 
                cbhv_PoseIn, cbhv_GenParamName, cbhv_GenParamValue, cbhv_Title, cbhv_Label, 
                cbhv_Information, cbhv_MessageQueue, cbhv_Buttons, cbhv_Type, cbhv_Message, 
                cbhv_DispViewPoint, cbhv_ViewPoint);

        // Reduce reference counter of thread object
        devThreadCB.Exit();
        devThreadCB.Dispose();

      }
      catch (HalconException exc)
      {
        // No exceptions may be raised from stub in parallel case,
        // so we need to store this information prior to cleanup
        bool is_direct_call = devThreadCB.IsDirectCall();
        // Attempt to clean up in error case, too
        devThreadCB.Exit();
        devThreadCB.Dispose();
        // Propagate exception if called directly
        if (is_direct_call)
          throw exc;
      }
    },15,0);
    // Set thread procedure call arguments 
    devThread.SetInputCtrlParamTuple(0,hv_WindowHandle1);
    devThread.SetInputCtrlParamTuple(1,hv_ObjectModel3DSceneSampled.TupleConcat(
        hv_ObjectModel3DEdges));
    devThread.SetInputCtrlParamTuple(2,hv_CameraParam);
    devThread.SetInputCtrlParamTuple(3,hv_ViewpointAsPoseIn);
    devThread.SetInputCtrlParamTuple(4,(
        (new HTuple("color_0")).TupleConcat("color_1")).TupleConcat("disp_pose"));
    devThread.SetInputCtrlParamTuple(5,(
        (new HTuple("gray")).TupleConcat("red")).TupleConcat("true"));
    devThread.SetInputCtrlParamTuple(6,"Define Viewpoint");
    devThread.SetInputCtrlParamTuple(7,new HTuple());
    devThread.SetInputCtrlParamTuple(8,hv_Instructions);
    devThread.SetInputCtrlParamTuple(9,hv_MessageQueues1);
    devThread.SetInputCtrlParamTuple(10,hv_Buttons);
    devThread.SetInputCtrlParamTuple(11,new HTuple());
    devThread.SetInputCtrlParamTuple(12,new HTuple());
    devThread.SetInputCtrlParamTuple(13,"false");
    devThread.SetInputCtrlParamTuple(14,new HTuple());

    // Start proc line in thread
    {
    HTuple TmpThreadId;
    devThread.ParStart(out TmpThreadId);
    hvec_TI[0].T = TmpThreadId;
    }

    hv_PreviousState1.Dispose();
    hv_PreviousState1 = new HTuple();
    hv_DidFinish1.Dispose();
    hv_DidFinish1 = 0;
    //
    //Start the second 3D visualization window
    //Here, the edge directions are visualized
    //Find a viewpoint such that we see the scene and the camera "from the side".
    //This makes it easier to see what is going on.
    //To keep the scene upright, we first rotate around the x-axis, then around the
    //(original) z-axis.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_VizCenter.Dispose();
    get_object_models_center(hv_ObjectModel3DSceneSampled.TupleConcat(hv_OM3DCamera), 
        out hv_VizCenter);
    }
    hv_HomMat3DIdentity1.Dispose();
    HOperatorSet.HomMat3dIdentity(out hv_HomMat3DIdentity1);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_HomMat3DRotate.Dispose();
    HOperatorSet.HomMat3dRotate(hv_HomMat3DIdentity1, (new HTuple(-90)).TupleRad()
        , ((new HTuple(1)).TupleConcat(0)).TupleConcat(0), hv_VizCenter.TupleSelect(
        0), hv_VizCenter.TupleSelect(1), hv_VizCenter.TupleSelect(2), out hv_HomMat3DRotate);
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.HomMat3dRotateLocal(hv_HomMat3DRotate, hv_AngleToX, ((new HTuple(0)).TupleConcat(
        0)).TupleConcat(1), out ExpTmpOutVar_0);
    hv_HomMat3DRotate.Dispose();
    hv_HomMat3DRotate = ExpTmpOutVar_0;
    }
    hv_PoseIn.Dispose();
    HOperatorSet.HomMat3dToPose(hv_HomMat3DRotate, out hv_PoseIn);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_VizposeIn.Dispose();
    determine_optimum_pose_distance(hv_ObjectModel3DSceneSampled.TupleConcat(hv_OM3DCamera), 
        hv_CameraParam, 0.5, hv_PoseIn, out hv_VizposeIn);
    }
    //
    hv_Buttons.Dispose();
    hv_Buttons = new HTuple();
    hv_Buttons[0] = "Hide Viewing Direction";
    hv_Buttons[1] = "left";
    hv_Buttons[2] = "bottom";
    hv_Buttons[3] = -1;
    hv_Buttons[4] = -1;
    hv_Buttons[5] = "Hide Edge Direction";
    hv_Buttons[6] = "right";
    hv_Buttons[7] = "bottom";
    hv_Buttons[8] = -1;
    hv_Buttons[9] = -1;
    hv_ShowViewDir.Dispose();
    hv_ShowViewDir = 1;
    hv_ShowEdgeDir.Dispose();
    hv_ShowEdgeDir = 1;
    hv_MessageQueues2.Dispose();
    create_visualization_message_queues(out hv_MessageQueues2);
    devThread = new HDevThread(context,
      (HDevThread.ProcCallback) delegate(HDevThread devThreadCB)
    {
      try
      {
        // Input parameters
        HTuple        cbhv_WindowHandle = devThreadCB.GetInputCtrlParamTuple(0);
        HTuple        cbhv_ObjectModel3D = devThreadCB.GetInputCtrlParamTuple(1);
        HTuple        cbhv_CamParam = devThreadCB.GetInputCtrlParamTuple(2);
        HTuple        cbhv_PoseIn = devThreadCB.GetInputCtrlParamTuple(3);
        HTuple        cbhv_GenParamName = devThreadCB.GetInputCtrlParamTuple(4);
        HTuple        cbhv_GenParamValue = devThreadCB.GetInputCtrlParamTuple(5);
        HTuple        cbhv_Title = devThreadCB.GetInputCtrlParamTuple(6);
        HTuple        cbhv_Label = devThreadCB.GetInputCtrlParamTuple(7);
        HTuple        cbhv_Information = devThreadCB.GetInputCtrlParamTuple(8);
        HTuple        cbhv_MessageQueue = devThreadCB.GetInputCtrlParamTuple(9);
        HTuple        cbhv_Buttons = devThreadCB.GetInputCtrlParamTuple(10);
        HTuple        cbhv_Type = devThreadCB.GetInputCtrlParamTuple(11);
        HTuple        cbhv_Message = devThreadCB.GetInputCtrlParamTuple(12);
        HTuple        cbhv_DispViewPoint = devThreadCB.GetInputCtrlParamTuple(13);
        HTuple        cbhv_ViewPoint = devThreadCB.GetInputCtrlParamTuple(14);

        // Call visualize_object_model_3d_ext
        visualize_object_model_3d_ext(cbhv_WindowHandle, cbhv_ObjectModel3D, cbhv_CamParam, 
                cbhv_PoseIn, cbhv_GenParamName, cbhv_GenParamValue, cbhv_Title, cbhv_Label, 
                cbhv_Information, cbhv_MessageQueue, cbhv_Buttons, cbhv_Type, cbhv_Message, 
                cbhv_DispViewPoint, cbhv_ViewPoint);

        // Reduce reference counter of thread object
        devThreadCB.Exit();
        devThreadCB.Dispose();

      }
      catch (HalconException exc)
      {
        // No exceptions may be raised from stub in parallel case,
        // so we need to store this information prior to cleanup
        bool is_direct_call = devThreadCB.IsDirectCall();
        // Attempt to clean up in error case, too
        devThreadCB.Exit();
        devThreadCB.Dispose();
        // Propagate exception if called directly
        if (is_direct_call)
          throw exc;
      }
    },15,0);
    // Set thread procedure call arguments 
    devThread.SetInputCtrlParamTuple(0,hv_WindowHandle2);
    devThread.SetInputCtrlParamTuple(1,((((((hv_ObjectModel3DSceneSampled.TupleConcat(
        hv_ObjectModel3DEdges))).TupleConcat(hv_ObjectModel3DEdgeDirs))).TupleConcat(
        hv_OM3DCamera))).TupleConcat(hv_OM3DLineSphereToScene));
    devThread.SetInputCtrlParamTuple(2,hv_CameraParam);
    devThread.SetInputCtrlParamTuple(3,hv_VizposeIn);
    devThread.SetInputCtrlParamTuple(4,((((((
        (new HTuple("color_0")).TupleConcat("color_1")).TupleConcat("color_2")).TupleConcat(
        "color_3")).TupleConcat("color_4")).TupleConcat("disp_pose")).TupleConcat(
        "disp_normals_1")).TupleConcat("disp_normals_2"));
    devThread.SetInputCtrlParamTuple(5,((((((
        (new HTuple("gray")).TupleConcat("green")).TupleConcat("red")).TupleConcat(
        "gray")).TupleConcat("white")).TupleConcat("true")).TupleConcat("true")).TupleConcat(
        "true"));
    devThread.SetInputCtrlParamTuple(6,"Inspect Edges");
    devThread.SetInputCtrlParamTuple(7,(((
        (new HTuple("")).TupleConcat("")).TupleConcat("")).TupleConcat("Viewpoint")).TupleConcat(
        ""));
    devThread.SetInputCtrlParamTuple(8,new HTuple());
    devThread.SetInputCtrlParamTuple(9,hv_MessageQueues2);
    devThread.SetInputCtrlParamTuple(10,hv_Buttons);
    devThread.SetInputCtrlParamTuple(11,new HTuple());
    devThread.SetInputCtrlParamTuple(12,new HTuple());
    devThread.SetInputCtrlParamTuple(13,"false");
    devThread.SetInputCtrlParamTuple(14,new HTuple());

    // Start proc line in thread
    {
    HTuple TmpThreadId;
    devThread.ParStart(out TmpThreadId);
    hvec_TI[1].T = TmpThreadId;
    }

    hv_PreviousState2.Dispose();
    hv_PreviousState2 = new HTuple();
    //
    while ((int)(hv_DidFinish1.TupleNot()) != 0)
    {
      hv_DidFinish1.Dispose();
      {
      HTuple ExpTmpOutVar_0;hv_ButtonPressed.Dispose();hv_Pose.Dispose();
      process_visualize_events_generic(hv_WindowHandle1, hv_MessageQueues1, hv_PreviousState1, 
          out hv_DidFinish1, out ExpTmpOutVar_0, out hv_ButtonPressed, out hv_Pose);
      hv_PreviousState1.Dispose();
      hv_PreviousState1 = ExpTmpOutVar_0;
      }
      if ((int)((new HTuple(hv_ButtonPressed.TupleEqual(0))).TupleOr(hv_DidFinish1)) != 0)
      {
        //Exit button pressed
        break;
      }
      else if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(1))) != 0)
      {
        //Reset button pressed
        hv_Viewpoint.Dispose();
        hv_Viewpoint = new HTuple();
        hv_Viewpoint[0] = 0;
        hv_Viewpoint[1] = 0;
        hv_Viewpoint[2] = 0;
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "set_pose");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "poses", hv_ViewpointAsPoseIn);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues1.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        //Also update the second view below
        hv_Pose.Dispose();
        hv_Pose = new HTuple(hv_ViewpointAsPoseIn);
      }
      if ((int)(new HTuple(hv_Pose.TupleNotEqual(new HTuple()))) != 0)
      {
        //The pose of view 1 was updated
        //-> Update the viewpoint in view 2
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HomMat3D.Dispose();
        HOperatorSet.PoseToHomMat3d(hv_Pose.TupleSelectRange(0,6), out hv_HomMat3D);
        }
        hv_HomMat3DInvert.Dispose();
        HOperatorSet.HomMat3dInvert(hv_HomMat3D, out hv_HomMat3DInvert);
        hv_Qx.Dispose();hv_Qy.Dispose();hv_Qz.Dispose();
        HOperatorSet.AffineTransPoint3d(hv_HomMat3DInvert, 0, 0, 0, out hv_Qx, out hv_Qy, 
            out hv_Qz);
        hv_Viewpoint.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Viewpoint = new HTuple();
        hv_Viewpoint = hv_Viewpoint.TupleConcat(hv_Qx, hv_Qy, hv_Qz);
        }
        hv_ViewpointStr.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ViewpointStr = ((((hv_Viewpoint.TupleSelect(
            0))+" ")+(hv_Viewpoint.TupleSelect(1)))+" ")+(hv_Viewpoint.TupleSelect(
            2));
        }
        //With this method, the viewpoint would be very far away in view 2, leading to not-so-nice
        //visualization. Adapt the distance to be always <= SceneDiameter.
        hv_Direction.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Direction = hv_Viewpoint-hv_CenterScene;
        }
        hv_Length.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Length = ((((hv_Direction*hv_Direction)).TupleSum()
            )).TupleSqrt();
        }
        hv_LengthRel.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LengthRel = hv_Length/hv_DiameterScene;
        }
        if ((int)(new HTuple(hv_LengthRel.TupleGreater(1))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Direction = hv_Direction/hv_LengthRel;
          hv_Direction.Dispose();
          hv_Direction = ExpTmpLocalVar_Direction;
          }
          }
        }
        hv_ViewpointViz.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ViewpointViz = hv_CenterScene+hv_Direction;
        }
        //
        //Update title of left visualization window
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "change_title");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "title", (new HTuple("Define Viewpoint")).TupleConcat(
            ((((("Current Viewpoint: ["+(hv_Viewpoint.TupleSelect(0)))+new HTuple(","))+(hv_Viewpoint.TupleSelect(
            1)))+new HTuple(","))+(hv_Viewpoint.TupleSelect(2)))+"]"));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues1.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        //
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OM3DCamera.Dispose();
        gen_camera_facing_scene(hv_ViewpointViz, hv_CenterSceneGravity, hv_DiameterModel*2, 
            out hv_OM3DCamera);
        }

        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OM3DLineSphereToScene.Dispose();
        HOperatorSet.GenObjectModel3dFromPoints(((hv_ViewpointViz.TupleSelect(0))).TupleConcat(
            hv_CenterScene.TupleSelect(0)), ((hv_ViewpointViz.TupleSelect(1))).TupleConcat(
            hv_CenterScene.TupleSelect(1)), ((hv_ViewpointViz.TupleSelect(2))).TupleConcat(
            hv_CenterScene.TupleSelect(2)), out hv_OM3DLineSphereToScene);
        }
        HOperatorSet.SetObjectModel3dAttribMod(hv_OM3DLineSphereToScene, "lines", 
            new HTuple(), ((new HTuple(2)).TupleConcat(0)).TupleConcat(1));
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ObjectModel3DEdges.Dispose();
          HOperatorSet.EdgesObjectModel3d(hv_ObjectModel3DScene, hv_DefaultAmplitude, 
              (new HTuple("max_gap")).TupleConcat("viewpoint"), hv_DefaultMaxGap.TupleConcat(
              hv_ViewpointStr), out hv_ObjectModel3DEdges);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.SampleObjectModel3d(hv_ObjectModel3DEdges, "fast_compute_normals", 
              hv_DiameterModel*0.02, new HTuple(), new HTuple(), out ExpTmpOutVar_0);
          hv_ObjectModel3DEdges.Dispose();
          hv_ObjectModel3DEdges = ExpTmpOutVar_0;
          }
          //
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_EdgeDirs.Dispose();
          HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DEdges, new HTuple("edge_dir_")+(
              (new HTuple("x")).TupleConcat("y")).TupleConcat("z"), out hv_EdgeDirs);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ObjectModel3DEdgeDirs.Dispose();
          HOperatorSet.SetObjectModel3dAttrib(hv_ObjectModel3DEdges, new HTuple("point_normal_")+(
              (new HTuple("x")).TupleConcat("y")).TupleConcat("z"), new HTuple(), 
              hv_EdgeDirs, out hv_ObjectModel3DEdgeDirs);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          //Unable to extract edges -> create a dummy 3D object model instead
          hv_ObjectModel3DEdges.Dispose();
          HOperatorSet.GenEmptyObjectModel3d(out hv_ObjectModel3DEdges);
          hv_ObjectModel3DEdgeDirs.Dispose();
          HOperatorSet.GenEmptyObjectModel3d(out hv_ObjectModel3DEdgeDirs);
        }
        //
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "replace_object_model");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "index", (((new HTuple(1)).TupleConcat(
            2)).TupleConcat(3)).TupleConcat(4));
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "model", ((((hv_ObjectModel3DEdges.TupleConcat(
            hv_ObjectModel3DEdgeDirs))).TupleConcat(hv_OM3DCamera))).TupleConcat(
            hv_OM3DLineSphereToScene));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
      }

      hv_DidFinish2.Dispose();
      {
      HTuple ExpTmpOutVar_0;hv_ButtonPressed.Dispose();hv_Poses.Dispose();
      process_visualize_events_generic(hv_WindowHandle2, hv_MessageQueues2, hv_PreviousState2, 
          out hv_DidFinish2, out ExpTmpOutVar_0, out hv_ButtonPressed, out hv_Poses);
      hv_PreviousState2.Dispose();
      hv_PreviousState2 = ExpTmpOutVar_0;
      }
      if ((int)(hv_DidFinish2) != 0)
      {
        break;
      }
      if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ShowViewDir = hv_ShowViewDir.TupleNot()
            ;
        hv_ShowViewDir.Dispose();
        hv_ShowViewDir = ExpTmpLocalVar_ShowViewDir;
        }
        }
        //Toggle viewing direction
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "toggle_param");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "param", "disp_normals_1");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "change_button_text");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "index", 0);
        if ((int)(hv_ShowViewDir) != 0)
        {
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "text", "Hide Viewing Direction");
        }
        else
        {
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "text", "Show Viewing Direction");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
      }
      else if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(1))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ShowEdgeDir = hv_ShowEdgeDir.TupleNot()
            ;
        hv_ShowEdgeDir.Dispose();
        hv_ShowEdgeDir = ExpTmpLocalVar_ShowEdgeDir;
        }
        }
        //Toggle viewing direction
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "toggle_param");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "param", "disp_normals_2");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "change_button_text");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "index", 1);
        if ((int)(hv_ShowEdgeDir) != 0)
        {
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "text", "Hide Edge Direction");
        }
        else
        {
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "text", "Show Edge Direction");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
      }
    }

    hv_MessageHandle.Dispose();
    HOperatorSet.CreateMessage(out hv_MessageHandle);
    HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "exit");
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.EnqueueMessage(hv_MessageQueues1.TupleSelect(1), hv_MessageHandle, 
        new HTuple(), new HTuple());
    }
    hv_MessageHandle.Dispose();
    HOperatorSet.CreateMessage(out hv_MessageHandle);
    HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "exit");
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
        new HTuple(), new HTuple());
    }
    //
    hv_TIT = hvec_TI.ConvertVectorToTuple();
    HDevThread.ParJoin(hv_TIT);


    hv_Diameter.Dispose();
    hv_DefaultAmplitude.Dispose();
    hv_MinAmplitude.Dispose();
    hv_MaxAmplitude.Dispose();
    hv_DefaultMaxGap.Dispose();
    hv_MappingSize.Dispose();
    hv_MinMaxGap.Dispose();
    hv_MaxMaxGap.Dispose();
    hv_CenterScene.Dispose();
    hv_DiameterScene.Dispose();
    hv_DiameterModel.Dispose();
    hv_ViewpointStr.Dispose();
    hv_Direction.Dispose();
    hv_Length.Dispose();
    hv_LengthRel.Dispose();
    hv_ViewpointViz.Dispose();
    hv_ObjectModel3DSceneSampled.Dispose();
    hv_ObjectModel3DEdges.Dispose();
    hv_EdgeDirs.Dispose();
    hv_ObjectModel3DEdgeDirs.Dispose();
    hv_Exception.Dispose();
    hv_CenterSceneGravity.Dispose();
    hv_OM3DCamera.Dispose();
    hv_OM3DLineSphereToScene.Dispose();
    hv_DirectionLength.Dispose();
    hv_ViewpointAsPoseIn.Dispose();
    hv_DirNorm.Dispose();
    hv_Axis.Dispose();
    hv_AxisNorm.Dispose();
    hv_OrthogonalDirection.Dispose();
    hv_RotationAxis.Dispose();
    hv_DirectionProjected.Dispose();
    hv_AngleToX.Dispose();
    hv_HomMat3DIdentity.Dispose();
    hv_HomMat3DRotate.Dispose();
    hv_Instructions.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_CameraParam.Dispose();
    hv_Buttons.Dispose();
    hv_MessageQueues1.Dispose();
    hv_PreviousState1.Dispose();
    hv_DidFinish1.Dispose();
    hv_VizCenter.Dispose();
    hv_HomMat3DIdentity1.Dispose();
    hv_PoseIn.Dispose();
    hv_VizposeIn.Dispose();
    hv_ShowViewDir.Dispose();
    hv_ShowEdgeDir.Dispose();
    hv_MessageQueues2.Dispose();
    hv_PreviousState2.Dispose();
    hv_ButtonPressed.Dispose();
    hv_Pose.Dispose();
    hv_MessageHandle.Dispose();
    hv_HomMat3D.Dispose();
    hv_HomMat3DInvert.Dispose();
    hv_Qx.Dispose();
    hv_Qy.Dispose();
    hv_Qz.Dispose();
    hv_DidFinish2.Dispose();
    hv_Poses.Dispose();
    hv_TIT.Dispose();
    hvec_TI.Dispose();

    return;
    }
  }

  public void inspect_scene_edge_parameters (HTuple hv_WindowHandle1, HTuple hv_WindowHandle2, 
      HTuple hv_SurfaceModelID, HTuple hv_ObjectModel3DScene, HTuple hv_SurfaceMatchingResultID, 
      HTuple hv_MaxGapIn, HTuple hv_MinAmplitudeAbsIn, HTuple hv_ViewpointIn, out HTuple hv_MaxGap, 
      out HTuple hv_MinAmplitudeAbs)
  {

    using (HDevThreadContext context = new HDevThreadContext())
    {
    // +++ Threading variables 
    HDevThread devThread;


    // Local iconic variables 

    // Local control variables 

    HTuple hv_Diameter = new HTuple(), hv_DefaultAmplitude = new HTuple();
    HTuple hv_MinAmplitude = new HTuple(), hv_MaxAmplitude = new HTuple();
    HTuple hv_DefaultMaxGap = new HTuple(), hv_MappingSize = new HTuple();
    HTuple hv_MinMaxGap = new HTuple(), hv_MaxMaxGap = new HTuple();
    HTuple hv_ViewpointStr = new HTuple(), hv_ObjectModel3DSceneSampled = new HTuple();
    HTuple hv_ObjectModel3DEdges = new HTuple(), hv_Instructions = new HTuple();
    HTuple hv_Buttons = new HTuple(), hv_MessageQueues1 = new HTuple();
    HTuple hv_PreviousState1 = new HTuple(), hv_DidFinish1 = new HTuple();
    HTuple hv_MessageQueues2 = new HTuple(), hv_MinAmplitudeRel = new HTuple();
    HTuple hv_XXScene = new HTuple(), hv_YYScene = new HTuple();
    HTuple hv_ZZScene = new HTuple(), hv_PreviousState2 = new HTuple();
    HTuple hv_ButtonPressed = new HTuple(), hv_Poses = new HTuple();
    HTuple hv_DidFinish2 = new HTuple(), hv_MessageHandle = new HTuple();
    HTuple hv_TIT = new HTuple();

    HTupleVector hvec_TI = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_MaxGap = new HTuple();
    hv_MinAmplitudeAbs = new HTuple();
    //Initial, Minimum and Maximum parameter values
    hv_Diameter.Dispose();
    HOperatorSet.GetSurfaceModelParam(hv_SurfaceModelID, "diameter", out hv_Diameter);
    hv_DefaultAmplitude.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DefaultAmplitude = hv_MinAmplitudeAbsIn/hv_Diameter;
    }
    hv_MinAmplitude.Dispose();
    hv_MinAmplitude = 0.0001;
    hv_MaxAmplitude.Dispose();
    hv_MaxAmplitude = 1;
    hv_DefaultMaxGap.Dispose();
    hv_DefaultMaxGap = new HTuple(hv_MaxGapIn);
    hv_MappingSize.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "mapping_size", out hv_MappingSize);
    hv_MinMaxGap.Dispose();
    hv_MinMaxGap = 0;
    hv_MaxMaxGap.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxMaxGap = hv_MappingSize.TupleMax()
        ;
    }
    hv_ViewpointStr.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ViewpointStr = ((hv_ViewpointIn+" ")).TupleSum()
        ;
    }
    //
    hv_ObjectModel3DSceneSampled.Dispose();
    HOperatorSet.GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", 
        0, out hv_ObjectModel3DSceneSampled);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ObjectModel3DEdges.Dispose();
    HOperatorSet.EdgesObjectModel3d(hv_ObjectModel3DScene, hv_DefaultAmplitude*hv_Diameter, 
        (new HTuple("max_gap")).TupleConcat("viewpoint"), hv_DefaultMaxGap.TupleConcat(
        hv_ViewpointStr), out hv_ObjectModel3DEdges);
    }
    //
    //Start the 3D visualization window
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[0] = "Rotate: Left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[1] = "Zoom:   Shift + left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[2] = "Move:   Ctrl  + left button";
    //
    hv_Buttons.Dispose();
    hv_Buttons = new HTuple();
    hv_Buttons[0] = "Continue";
    hv_Buttons[1] = "right";
    hv_Buttons[2] = "bottom";
    hv_Buttons[3] = -1;
    hv_Buttons[4] = -1;
    hv_MessageQueues1.Dispose();
    create_visualization_message_queues(out hv_MessageQueues1);
    devThread = new HDevThread(context,
      (HDevThread.ProcCallback) delegate(HDevThread devThreadCB)
    {
      try
      {
        // Input parameters
        HTuple        cbhv_WindowHandle = devThreadCB.GetInputCtrlParamTuple(0);
        HTuple        cbhv_ObjectModel3D = devThreadCB.GetInputCtrlParamTuple(1);
        HTuple        cbhv_CamParam = devThreadCB.GetInputCtrlParamTuple(2);
        HTuple        cbhv_PoseIn = devThreadCB.GetInputCtrlParamTuple(3);
        HTuple        cbhv_GenParamName = devThreadCB.GetInputCtrlParamTuple(4);
        HTuple        cbhv_GenParamValue = devThreadCB.GetInputCtrlParamTuple(5);
        HTuple        cbhv_Title = devThreadCB.GetInputCtrlParamTuple(6);
        HTuple        cbhv_Label = devThreadCB.GetInputCtrlParamTuple(7);
        HTuple        cbhv_Information = devThreadCB.GetInputCtrlParamTuple(8);
        HTuple        cbhv_MessageQueue = devThreadCB.GetInputCtrlParamTuple(9);
        HTuple        cbhv_Buttons = devThreadCB.GetInputCtrlParamTuple(10);
        HTuple        cbhv_Type = devThreadCB.GetInputCtrlParamTuple(11);
        HTuple        cbhv_Message = devThreadCB.GetInputCtrlParamTuple(12);
        HTuple        cbhv_DispViewPoint = devThreadCB.GetInputCtrlParamTuple(13);
        HTuple        cbhv_ViewPoint = devThreadCB.GetInputCtrlParamTuple(14);

        // Call visualize_object_model_3d_ext
        visualize_object_model_3d_ext(cbhv_WindowHandle, cbhv_ObjectModel3D, cbhv_CamParam, 
                cbhv_PoseIn, cbhv_GenParamName, cbhv_GenParamValue, cbhv_Title, cbhv_Label, 
                cbhv_Information, cbhv_MessageQueue, cbhv_Buttons, cbhv_Type, cbhv_Message, 
                cbhv_DispViewPoint, cbhv_ViewPoint);

        // Reduce reference counter of thread object
        devThreadCB.Exit();
        devThreadCB.Dispose();

      }
      catch (HalconException exc)
      {
        // No exceptions may be raised from stub in parallel case,
        // so we need to store this information prior to cleanup
        bool is_direct_call = devThreadCB.IsDirectCall();
        // Attempt to clean up in error case, too
        devThreadCB.Exit();
        devThreadCB.Dispose();
        // Propagate exception if called directly
        if (is_direct_call)
          throw exc;
      }
    },15,0);
    // Set thread procedure call arguments 
    devThread.SetInputCtrlParamTuple(0,hv_WindowHandle1);
    devThread.SetInputCtrlParamTuple(1,hv_ObjectModel3DSceneSampled.TupleConcat(
        hv_ObjectModel3DEdges));
    devThread.SetInputCtrlParamTuple(2,new HTuple());
    devThread.SetInputCtrlParamTuple(3,new HTuple());
    devThread.SetInputCtrlParamTuple(4,(
        (new HTuple("color_0")).TupleConcat("color_1")).TupleConcat("disp_pose"));
    devThread.SetInputCtrlParamTuple(5,(
        (new HTuple("gray")).TupleConcat("red")).TupleConcat("true"));
    devThread.SetInputCtrlParamTuple(6,"Inspection");
    devThread.SetInputCtrlParamTuple(7,new HTuple());
    devThread.SetInputCtrlParamTuple(8,hv_Instructions);
    devThread.SetInputCtrlParamTuple(9,hv_MessageQueues1);
    devThread.SetInputCtrlParamTuple(10,hv_Buttons);
    devThread.SetInputCtrlParamTuple(11,new HTuple());
    devThread.SetInputCtrlParamTuple(12,new HTuple());
    devThread.SetInputCtrlParamTuple(13,"false");
    devThread.SetInputCtrlParamTuple(14,new HTuple());

    // Start proc line in thread
    {
    HTuple TmpThreadId;
    devThread.ParStart(out TmpThreadId);
    hvec_TI[0].T = TmpThreadId;
    }

    //
    hv_PreviousState1.Dispose();
    hv_PreviousState1 = new HTuple();
    hv_DidFinish1.Dispose();
    hv_DidFinish1 = 0;
    //
    //Start the 2D Slider window
    hv_MessageQueues2.Dispose();
    create_visualization_message_queues(out hv_MessageQueues2);
    devThread = new HDevThread(context,
      (HDevThread.ProcCallback) delegate(HDevThread devThreadCB)
    {
      try
      {
        // Input parameters
        HTuple        cbhv_WindowHandle = devThreadCB.GetInputCtrlParamTuple(0);
        HTuple        cbhv_ObjectModel3D = devThreadCB.GetInputCtrlParamTuple(1);
        HTuple        cbhv_MessageQueues = devThreadCB.GetInputCtrlParamTuple(2);
        HTuple        cbhv_MessageQueueOut = devThreadCB.GetInputCtrlParamTuple(3);
        HTuple        cbhv_ModelDiameter = devThreadCB.GetInputCtrlParamTuple(4);
        HTuple        cbhv_AmplitudeRange = devThreadCB.GetInputCtrlParamTuple(5);
        HTuple        cbhv_MaxGapRange = devThreadCB.GetInputCtrlParamTuple(6);
        HTuple        cbhv_Viewpoint = devThreadCB.GetInputCtrlParamTuple(7);

        // Output parameters
        HTuple        cbhv_MinAmplitude;
        HTuple        cbhv_MaxGap;

        // Call set_edge_parameter_sliders
        set_edge_parameter_sliders(cbhv_WindowHandle, cbhv_ObjectModel3D, cbhv_MessageQueues, 
                cbhv_MessageQueueOut, cbhv_ModelDiameter, cbhv_AmplitudeRange, cbhv_MaxGapRange, 
                cbhv_Viewpoint, out cbhv_MinAmplitude, out cbhv_MaxGap);

        // Store output parameters in thread object
        devThreadCB.StoreOutputCtrlParamTuple(0,cbhv_MinAmplitude);
        devThreadCB.StoreOutputCtrlParamTuple(1,cbhv_MaxGap);

        // Reduce reference counter of thread object
        devThreadCB.Exit();
        devThreadCB.Dispose();

      }
      catch (HalconException exc)
      {
        // No exceptions may be raised from stub in parallel case,
        // so we need to store this information prior to cleanup
        bool is_direct_call = devThreadCB.IsDirectCall();
        // Attempt to clean up in error case, too
        devThreadCB.Exit();
        devThreadCB.Dispose();
        // Propagate exception if called directly
        if (is_direct_call)
          throw exc;
      }
    },8,2);
    // Set thread procedure call arguments 
    devThread.SetInputCtrlParamTuple(0,hv_WindowHandle2);
    devThread.SetInputCtrlParamTuple(1,hv_ObjectModel3DScene);
    devThread.SetInputCtrlParamTuple(2,hv_MessageQueues2);
    devThread.SetInputCtrlParamTuple(3,hv_MessageQueues1);
    devThread.SetInputCtrlParamTuple(4,hv_Diameter);
    devThread.SetInputCtrlParamTuple(5,((hv_MinAmplitude.TupleConcat(
        hv_MaxAmplitude))).TupleConcat(hv_DefaultAmplitude));
    devThread.SetInputCtrlParamTuple(6,((hv_MinMaxGap.TupleConcat(
        hv_MaxMaxGap))).TupleConcat(hv_DefaultMaxGap));
    devThread.SetInputCtrlParamTuple(7,hv_ViewpointIn);
    if (hv_MinAmplitudeRel == null)
      hv_MinAmplitudeRel = new HTuple();
    devThread.BindOutputCtrlParamTuple(0,false,hv_MinAmplitudeRel);
    if (hv_MaxGap == null)
      hv_MaxGap = new HTuple();
    devThread.BindOutputCtrlParamTuple(1,false,hv_MaxGap);

    // Start proc line in thread
    {
    HTuple TmpThreadId;
    devThread.ParStart(out TmpThreadId);
    hvec_TI[1].T = TmpThreadId;
    }

    //
    hv_XXScene.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_x", out hv_XXScene);
    hv_YYScene.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_y", out hv_YYScene);
    hv_ZZScene.Dispose();
    HOperatorSet.GetObjectModel3dParams(hv_ObjectModel3DScene, "point_coord_z", out hv_ZZScene);
    //
    hv_PreviousState2.Dispose();
    hv_PreviousState2 = new HTuple();
    //
    while ((int)(hv_DidFinish1.TupleNot()) != 0)
    {
      hv_DidFinish1.Dispose();
      {
      HTuple ExpTmpOutVar_0;hv_ButtonPressed.Dispose();hv_Poses.Dispose();
      process_visualize_events_generic(hv_WindowHandle1, hv_MessageQueues1, hv_PreviousState1, 
          out hv_DidFinish1, out ExpTmpOutVar_0, out hv_ButtonPressed, out hv_Poses);
      hv_PreviousState1.Dispose();
      hv_PreviousState1 = ExpTmpOutVar_0;
      }

      if ((int)((new HTuple(hv_ButtonPressed.TupleEqual(0))).TupleOr(hv_DidFinish1)) != 0)
      {
        //Exit button pressed
        break;
      }

      {
      HTuple ExpTmpOutVar_0;hv_DidFinish2.Dispose();
      process_slider_events(hv_WindowHandle2, hv_MessageQueues2, hv_PreviousState2, 
          out ExpTmpOutVar_0, out hv_DidFinish2);
      hv_PreviousState2.Dispose();
      hv_PreviousState2 = ExpTmpOutVar_0;
      }
      if ((int)(hv_DidFinish2) != 0)
      {
        //Window closed
        break;
      }
    }

    hv_MessageHandle.Dispose();
    HOperatorSet.CreateMessage(out hv_MessageHandle);
    HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "exit");
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.EnqueueMessage(hv_MessageQueues1.TupleSelect(1), hv_MessageHandle, 
        new HTuple(), new HTuple());
    }
    hv_MessageHandle.Dispose();
    HOperatorSet.CreateMessage(out hv_MessageHandle);
    HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "exit");
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.EnqueueMessage(hv_MessageQueues2.TupleSelect(1), hv_MessageHandle, 
        new HTuple(), new HTuple());
    }
    //
    hv_TIT = hvec_TI.ConvertVectorToTuple();
    HDevThread.ParJoin(hv_TIT);
    //
    //Convert from relative to absolute
    hv_MinAmplitudeAbs.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MinAmplitudeAbs = hv_MinAmplitudeRel*hv_Diameter;
    }
    //

    hv_Diameter.Dispose();
    hv_DefaultAmplitude.Dispose();
    hv_MinAmplitude.Dispose();
    hv_MaxAmplitude.Dispose();
    hv_DefaultMaxGap.Dispose();
    hv_MappingSize.Dispose();
    hv_MinMaxGap.Dispose();
    hv_MaxMaxGap.Dispose();
    hv_ViewpointStr.Dispose();
    hv_ObjectModel3DSceneSampled.Dispose();
    hv_ObjectModel3DEdges.Dispose();
    hv_Instructions.Dispose();
    hv_Buttons.Dispose();
    hv_MessageQueues1.Dispose();
    hv_PreviousState1.Dispose();
    hv_DidFinish1.Dispose();
    hv_MessageQueues2.Dispose();
    hv_MinAmplitudeRel.Dispose();
    hv_XXScene.Dispose();
    hv_YYScene.Dispose();
    hv_ZZScene.Dispose();
    hv_PreviousState2.Dispose();
    hv_ButtonPressed.Dispose();
    hv_Poses.Dispose();
    hv_DidFinish2.Dispose();
    hv_MessageHandle.Dispose();
    hv_TIT.Dispose();
    hvec_TI.Dispose();

    return;
    }
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Generate image list and corresponding segmentation image list. 
  public void list_image_and_segmentation_files (HTuple hv_ImageDir, HTuple hv_SegmentationDir, 
      HTuple hv_ImageListIn, HTuple hv_GenParam, out HTuple hv_ImageListOut, out HTuple hv_SegmentationListOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ImageSubDirs = new HTuple(), hv_SegmentationSubDirs = new HTuple();
    HTuple hv_FileNameImageOnly = new HTuple(), hv_FileNameSegOnly = new HTuple();
    HTuple hv_IgnoreUnmatched = new HTuple(), hv_Keys = new HTuple();
    HTuple hv_KeyIndex = new HTuple(), hv_IsString = new HTuple();
    HTuple hv_ImageDirs = new HTuple(), hv_ImageBaseNames = new HTuple();
    HTuple hv_ImageExtensions = new HTuple(), hv_ImageDirectories = new HTuple();
    HTuple hv_CommonBasePathImage = new HTuple(), hv_ImageDirectoriesRel = new HTuple();
    HTuple hv_ImageMatches = new HTuple(), hv_MatchIndices = new HTuple();
    HTuple hv_ImageBaseNamesToMatch = new HTuple(), hv_SegmentationDirs = new HTuple();
    HTuple hv_SegBaseNames = new HTuple(), hv_SegExtensions = new HTuple();
    HTuple hv_SegDirectories = new HTuple(), hv_CommonBasePathSeg = new HTuple();
    HTuple hv_SegDirectoriesRel = new HTuple(), hv_SegMatches = new HTuple();
    HTuple hv_SegImageMatchIndices = new HTuple(), hv_ImageMatchIndices = new HTuple();
    HTuple hv_ImageIndex = new HTuple(), hv_Match = new HTuple();
    HTuple hv_SegImageMatchIndex = new HTuple(), hv_ImagePath = new HTuple();
    // Initialize local and output iconic variables 
    hv_ImageListOut = new HTuple();
    hv_SegmentationListOut = new HTuple();
    //
    //This procedure generates lists of images and corresponding segmentation images,
    //whereby the first one can also be handed over through ImageListIn.
    //The lists are generated by listing the images in the given directory:
    // - ImageDir specifies the base directory for the images,
    // - SegmentationDir specifies the base directory for the annotated segmentations.
    //The file base names of images and segmentation images must be unique
    //in the sense that for each image exactly one segmentation is matched based on their file names.
    //With the parameters specified in GenParam, the lists can be limited to specific file names.
    //
    //Set defaults.
    hv_ImageSubDirs.Dispose();
    hv_ImageSubDirs = new HTuple();
    hv_SegmentationSubDirs.Dispose();
    hv_SegmentationSubDirs = new HTuple();
    hv_FileNameImageOnly.Dispose();
    hv_FileNameImageOnly = "";
    hv_FileNameSegOnly.Dispose();
    hv_FileNameSegOnly = "";
    hv_IgnoreUnmatched.Dispose();
    hv_IgnoreUnmatched = 0;
    //
    //Overwrite defaults.
    if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_Keys.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_Keys);
      for (hv_KeyIndex=0; (int)hv_KeyIndex<=(int)((new HTuple(hv_Keys.TupleLength()
          ))-1); hv_KeyIndex = (int)hv_KeyIndex + 1)
      {
        if ((int)(new HTuple(((hv_Keys.TupleSelect(hv_KeyIndex))).TupleEqual("image_sub_dirs"))) != 0)
        {
          hv_ImageSubDirs.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "image_sub_dirs", out hv_ImageSubDirs);
        }
        else if ((int)(new HTuple(((hv_Keys.TupleSelect(hv_KeyIndex))).TupleEqual(
            "segmentation_sub_dirs"))) != 0)
        {
          hv_SegmentationSubDirs.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "segmentation_sub_dirs", out hv_SegmentationSubDirs);
        }
        else if ((int)(new HTuple(((hv_Keys.TupleSelect(hv_KeyIndex))).TupleEqual(
            "file_name_image_only"))) != 0)
        {
          hv_FileNameImageOnly.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "file_name_image_only", out hv_FileNameImageOnly);
        }
        else if ((int)(new HTuple(((hv_Keys.TupleSelect(hv_KeyIndex))).TupleEqual(
            "file_name_segmentation_only"))) != 0)
        {
          hv_FileNameSegOnly.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "file_name_segmentation_only", out hv_FileNameSegOnly);
        }
        else if ((int)(new HTuple(((hv_Keys.TupleSelect(hv_KeyIndex))).TupleEqual(
            "ignore_unmatched_images"))) != 0)
        {
          hv_IgnoreUnmatched.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "ignore_unmatched_images", out hv_IgnoreUnmatched);
        }
        else
        {
          throw new HalconException(("Unknown generic parameter name : '"+(hv_Keys.TupleSelect(
              hv_KeyIndex)))+"'");
        }
      }
    }
    //
    //Check generic parameters.
    if ((int)(new HTuple(hv_ImageSubDirs.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_IsString.Dispose();
      HOperatorSet.TupleIsString(hv_ImageSubDirs, out hv_IsString);
      if ((int)(new HTuple(((hv_IsString.TupleMin())).TupleEqual(0))) != 0)
      {
        throw new HalconException("'image_sub_dirs' must be a tuple of strings");
      }
    }
    if ((int)(new HTuple(hv_SegmentationSubDirs.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_IsString.Dispose();
      HOperatorSet.TupleIsString(hv_SegmentationSubDirs, out hv_IsString);
      if ((int)(new HTuple(((hv_IsString.TupleMin())).TupleEqual(0))) != 0)
      {
        throw new HalconException("'segmentation_sub_dirs' must be a tuple of strings");
      }
    }
    if ((int)(new HTuple(hv_FileNameImageOnly.TupleNotEqual(""))) != 0)
    {
      if ((int)(new HTuple((new HTuple(hv_FileNameImageOnly.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("'file_name_image_only' must be a single string");
      }
      else if ((int)(((hv_FileNameImageOnly.TupleIsString())).TupleNot()) != 0)
      {
        throw new HalconException("'file_name_image_only' must be a string");
      }
    }
    if ((int)(new HTuple(hv_FileNameSegOnly.TupleNotEqual(""))) != 0)
    {
      if ((int)(new HTuple((new HTuple(hv_FileNameSegOnly.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("'file_name_segmentation_only' must be a single string");
      }
      else if ((int)(((hv_FileNameSegOnly.TupleIsString())).TupleNot()) != 0)
      {
        throw new HalconException("'file_name_segmentation_only' must be a string");
      }
    }
    if ((int)((new HTuple(hv_IgnoreUnmatched.TupleNotEqual(0))).TupleAnd(new HTuple(hv_IgnoreUnmatched.TupleNotEqual(
        1)))) != 0)
    {
      throw new HalconException("Unsupported value for 'ignore_unmatched_images' : "+hv_IgnoreUnmatched);
    }
    //
    //* Prepare image list.
    //
    //Get all image directories.
    if ((int)(new HTuple(hv_ImageSubDirs.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_ImageDirs.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageDirs = (hv_ImageDir+"/")+hv_ImageSubDirs;
      }
    }
    else
    {
      hv_ImageDirs.Dispose();
      hv_ImageDirs = new HTuple(hv_ImageDir);
    }
    //
    if ((int)(new HTuple(hv_ImageListIn.TupleEqual(new HTuple()))) != 0)
    {
      //List all image files.
      hv_ImageBaseNames.Dispose();hv_ImageExtensions.Dispose();hv_ImageDirectories.Dispose();
      prepare_image_lists(hv_ImageDirs, out hv_ImageBaseNames, out hv_ImageExtensions, 
          out hv_ImageDirectories);
    }
    else
    {
      hv_ImageBaseNames.Dispose();hv_ImageExtensions.Dispose();hv_ImageDirectories.Dispose();
      parse_filename(hv_ImageListIn, out hv_ImageBaseNames, out hv_ImageExtensions, 
          out hv_ImageDirectories);
    }
    //
    if ((int)(new HTuple((new HTuple(hv_ImageBaseNames.TupleLength())).TupleEqual(
        0))) != 0)
    {
      throw new HalconException("No images found");
    }
    //
    //Get file paths of images relative to ImageDir.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CommonBasePathImage.Dispose();
    HOperatorSet.TupleRegexpMatch(hv_ImageDirectories.TupleSelect(0), ".*"+hv_ImageDir, 
        out hv_CommonBasePathImage);
    }
    hv_ImageDirectoriesRel.Dispose();
    HOperatorSet.TupleRegexpReplace(hv_ImageDirectories, hv_CommonBasePathImage, 
        "", out hv_ImageDirectoriesRel);
    //
    if ((int)(new HTuple(hv_FileNameImageOnly.TupleNotEqual(""))) != 0)
    {
      //Select only the images which include the specified string.
      hv_ImageMatches.Dispose();
      HOperatorSet.TupleRegexpMatch(hv_ImageBaseNames, hv_FileNameImageOnly, out hv_ImageMatches);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MatchIndices.Dispose();
      HOperatorSet.TupleFind(hv_ImageMatches.TupleNotEqualElem(""), 1, out hv_MatchIndices);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageBaseNames = hv_ImageBaseNames.TupleSelect(
          hv_MatchIndices);
      hv_ImageBaseNames.Dispose();
      hv_ImageBaseNames = ExpTmpLocalVar_ImageBaseNames;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageExtensions = hv_ImageExtensions.TupleSelect(
          hv_MatchIndices);
      hv_ImageExtensions.Dispose();
      hv_ImageExtensions = ExpTmpLocalVar_ImageExtensions;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageDirectories = hv_ImageDirectories.TupleSelect(
          hv_MatchIndices);
      hv_ImageDirectories.Dispose();
      hv_ImageDirectories = ExpTmpLocalVar_ImageDirectories;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageDirectoriesRel = hv_ImageDirectoriesRel.TupleSelect(
          hv_MatchIndices);
      hv_ImageDirectoriesRel.Dispose();
      hv_ImageDirectoriesRel = ExpTmpLocalVar_ImageDirectoriesRel;
      }
      }
      //Remove the prefix or suffix of the image file name which is not included in segmentation file name.
      hv_ImageBaseNamesToMatch.Dispose();
      HOperatorSet.TupleRegexpReplace(hv_ImageBaseNames, hv_FileNameImageOnly, "", 
          out hv_ImageBaseNamesToMatch);
    }
    else
    {
      hv_ImageBaseNamesToMatch.Dispose();
      hv_ImageBaseNamesToMatch = new HTuple(hv_ImageBaseNames);
    }
    //
    //
    //* Prepare segmentation image list.
    //
    //Get all segmentation directories.
    if ((int)(new HTuple(hv_SegmentationSubDirs.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_SegmentationDirs.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SegmentationDirs = (hv_SegmentationDir+"/")+hv_SegmentationSubDirs;
      }
    }
    else
    {
      hv_SegmentationDirs.Dispose();
      hv_SegmentationDirs = new HTuple(hv_SegmentationDir);
    }
    //
    //List all segmentation files.
    hv_SegBaseNames.Dispose();hv_SegExtensions.Dispose();hv_SegDirectories.Dispose();
    prepare_image_lists(hv_SegmentationDirs, out hv_SegBaseNames, out hv_SegExtensions, 
        out hv_SegDirectories);
    //
    if ((int)(new HTuple((new HTuple(hv_SegBaseNames.TupleLength())).TupleEqual(0))) != 0)
    {
      throw new HalconException("No segmentation images found");
    }
    //
    //Get file paths of segmentation images relative to SegmentationDir.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CommonBasePathSeg.Dispose();
    HOperatorSet.TupleRegexpMatch(hv_SegDirectories.TupleSelect(0), ".*"+hv_SegmentationDir, 
        out hv_CommonBasePathSeg);
    }
    hv_SegDirectoriesRel.Dispose();
    HOperatorSet.TupleRegexpReplace(hv_SegDirectories, hv_CommonBasePathSeg, "", 
        out hv_SegDirectoriesRel);
    //
    if ((int)(new HTuple(hv_FileNameSegOnly.TupleNotEqual(""))) != 0)
    {
      //Select only the segmentations which include the specified string.
      hv_SegMatches.Dispose();
      HOperatorSet.TupleRegexpMatch(hv_SegBaseNames, hv_FileNameSegOnly, out hv_SegMatches);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MatchIndices.Dispose();
      HOperatorSet.TupleFind(hv_SegMatches.TupleNotEqualElem(""), 1, out hv_MatchIndices);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_SegBaseNames = hv_SegBaseNames.TupleSelect(
          hv_MatchIndices);
      hv_SegBaseNames.Dispose();
      hv_SegBaseNames = ExpTmpLocalVar_SegBaseNames;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_SegExtensions = hv_SegExtensions.TupleSelect(
          hv_MatchIndices);
      hv_SegExtensions.Dispose();
      hv_SegExtensions = ExpTmpLocalVar_SegExtensions;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_SegDirectories = hv_SegDirectories.TupleSelect(
          hv_MatchIndices);
      hv_SegDirectories.Dispose();
      hv_SegDirectories = ExpTmpLocalVar_SegDirectories;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_SegDirectoriesRel = hv_SegDirectoriesRel.TupleSelect(
          hv_MatchIndices);
      hv_SegDirectoriesRel.Dispose();
      hv_SegDirectoriesRel = ExpTmpLocalVar_SegDirectoriesRel;
      }
      }
    }
    //
    //
    //* Match image and segmentation lists.
    //
    //Match a segmentation file to each image file by file name.
    hv_SegImageMatchIndices.Dispose();
    hv_SegImageMatchIndices = new HTuple();
    hv_ImageMatchIndices.Dispose();
    hv_ImageMatchIndices = new HTuple();
    for (hv_ImageIndex=0; (int)hv_ImageIndex<=(int)((new HTuple(hv_ImageBaseNames.TupleLength()
        ))-1); hv_ImageIndex = (int)hv_ImageIndex + 1)
    {
      //Find the match based on file names.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Match.Dispose();
      HOperatorSet.TupleRegexpMatch(hv_SegBaseNames, hv_ImageBaseNamesToMatch.TupleSelect(
          hv_ImageIndex), out hv_Match);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SegImageMatchIndex.Dispose();
      HOperatorSet.TupleFind(hv_Match.TupleNotEqualElem(""), 1, out hv_SegImageMatchIndex);
      }
      if ((int)((new HTuple(hv_SegImageMatchIndex.TupleGreater(-1))).TupleAnd(new HTuple((new HTuple(hv_SegImageMatchIndex.TupleLength()
          )).TupleEqual(1)))) != 0)
      {
        //Exactly one match was found.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_SegImageMatchIndices = hv_SegImageMatchIndices.TupleConcat(
            hv_SegImageMatchIndex);
        hv_SegImageMatchIndices.Dispose();
        hv_SegImageMatchIndices = ExpTmpLocalVar_SegImageMatchIndices;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ImageMatchIndices = hv_ImageMatchIndices.TupleConcat(
            hv_ImageIndex);
        hv_ImageMatchIndices.Dispose();
        hv_ImageMatchIndices = ExpTmpLocalVar_ImageMatchIndices;
        }
        }
      }
      else if ((int)(new HTuple((new HTuple(hv_SegImageMatchIndex.TupleLength()
          )).TupleGreater(1))) != 0)
      {
        //There should be only one segmentation image matching each image.
        hv_ImagePath.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImagePath = (((hv_ImageDirectoriesRel.TupleSelect(
            hv_ImageIndex))+(hv_ImageBaseNames.TupleSelect(hv_ImageIndex)))+".")+(hv_ImageExtensions.TupleSelect(
            hv_ImageIndex));
        }
        throw new HalconException("Multiple matching segmentation images for image "+hv_ImagePath);
      }
    }
    //
    //
    //* Final checks.
    //
    //Check if each match is unique.
    if ((int)(new HTuple(((((hv_SegImageMatchIndices.TupleSort())).TupleUniq())).TupleNotEqual(
        hv_SegImageMatchIndices.TupleSort()))) != 0)
    {
      throw new HalconException("A single segmentation image has matched with multiple images");
    }
    if ((int)(hv_IgnoreUnmatched.TupleNot()) != 0)
    {
      //Check if every image matched with a segmentation image.
      if ((int)(new HTuple((new HTuple(hv_ImageMatchIndices.TupleLength())).TupleNotEqual(
          new HTuple(hv_ImageBaseNames.TupleLength())))) != 0)
      {
        throw new HalconException("Not every image in ImageDir has a corresponding segmentation image in SegmentationDir");
      }
    }
    //
    //Create final image list.
    hv_ImageListOut.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ImageListOut = ((hv_ImageDirectoriesRel+hv_ImageBaseNames)+".")+hv_ImageExtensions;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_ImageListOut = hv_ImageListOut.TupleSelect(
        hv_ImageMatchIndices);
    hv_ImageListOut.Dispose();
    hv_ImageListOut = ExpTmpLocalVar_ImageListOut;
    }
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.TupleRegexpReplace(hv_ImageListOut, "^/", "", out ExpTmpOutVar_0);
    hv_ImageListOut.Dispose();
    hv_ImageListOut = ExpTmpOutVar_0;
    }
    //
    //Create final segmentation list.
    hv_SegmentationListOut.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SegmentationListOut = ((hv_SegDirectoriesRel+hv_SegBaseNames)+".")+hv_SegExtensions;
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_SegmentationListOut = hv_SegmentationListOut.TupleSelect(
        hv_SegImageMatchIndices);
    hv_SegmentationListOut.Dispose();
    hv_SegmentationListOut = ExpTmpLocalVar_SegmentationListOut;
    }
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.TupleRegexpReplace(hv_SegmentationListOut, "^/", "", out ExpTmpOutVar_0);
    hv_SegmentationListOut.Dispose();
    hv_SegmentationListOut = ExpTmpOutVar_0;
    }
    //

    hv_ImageSubDirs.Dispose();
    hv_SegmentationSubDirs.Dispose();
    hv_FileNameImageOnly.Dispose();
    hv_FileNameSegOnly.Dispose();
    hv_IgnoreUnmatched.Dispose();
    hv_Keys.Dispose();
    hv_KeyIndex.Dispose();
    hv_IsString.Dispose();
    hv_ImageDirs.Dispose();
    hv_ImageBaseNames.Dispose();
    hv_ImageExtensions.Dispose();
    hv_ImageDirectories.Dispose();
    hv_CommonBasePathImage.Dispose();
    hv_ImageDirectoriesRel.Dispose();
    hv_ImageMatches.Dispose();
    hv_MatchIndices.Dispose();
    hv_ImageBaseNamesToMatch.Dispose();
    hv_SegmentationDirs.Dispose();
    hv_SegBaseNames.Dispose();
    hv_SegExtensions.Dispose();
    hv_SegDirectories.Dispose();
    hv_CommonBasePathSeg.Dispose();
    hv_SegDirectoriesRel.Dispose();
    hv_SegMatches.Dispose();
    hv_SegImageMatchIndices.Dispose();
    hv_ImageMatchIndices.Dispose();
    hv_ImageIndex.Dispose();
    hv_Match.Dispose();
    hv_SegImageMatchIndex.Dispose();
    hv_ImagePath.Dispose();

    return;
  }

  // Chapter: File / Misc
  // Short Description: Get all image files under the given path 
  public void list_image_files (HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, 
      out HTuple hv_ImageFiles)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ImageDirectoryIndex = new HTuple();
    HTuple hv_ImageFilesTmp = new HTuple(), hv_CurrentImageDirectory = new HTuple();
    HTuple hv_HalconImages = new HTuple(), hv_OS = new HTuple();
    HTuple hv_Directories = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Length = new HTuple(), hv_NetworkDrive = new HTuple();
    HTuple hv_Substring = new HTuple(), hv_FileExists = new HTuple();
    HTuple hv_AllFiles = new HTuple(), hv_i = new HTuple();
    HTuple hv_Selection = new HTuple();
    HTuple   hv_Extensions_COPY_INP_TMP = new HTuple(hv_Extensions);

    // Initialize local and output iconic variables 
    hv_ImageFiles = new HTuple();
    //This procedure returns all files in a given directory
    //with one of the suffixes specified in Extensions.
    //
    //Input parameters:
    //ImageDirectory: Directory or a tuple of directories with images.
    //   If a directory is not found locally, the respective directory
    //   is searched under %HALCONIMAGES%/ImageDirectory.
    //   See the Installation Guide for further information
    //   in case %HALCONIMAGES% is not set.
    //Extensions: A string tuple containing the extensions to be found
    //   e.g. ['png','tif',jpg'] or others
    //If Extensions is set to 'default' or the empty string '',
    //   all image suffixes supported by HALCON are used.
    //Options: as in the operator list_files, except that the 'files'
    //   option is always used. Note that the 'directories' option
    //   has no effect but increases runtime, because only files are
    //   returned.
    //
    //Output parameter:
    //ImageFiles: A tuple of all found image file names
    //
    if ((int)((new HTuple((new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
        new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(""))))).TupleOr(new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(
        "default")))) != 0)
    {
      hv_Extensions_COPY_INP_TMP.Dispose();
      hv_Extensions_COPY_INP_TMP = new HTuple();
      hv_Extensions_COPY_INP_TMP[0] = "ima";
      hv_Extensions_COPY_INP_TMP[1] = "tif";
      hv_Extensions_COPY_INP_TMP[2] = "tiff";
      hv_Extensions_COPY_INP_TMP[3] = "gif";
      hv_Extensions_COPY_INP_TMP[4] = "bmp";
      hv_Extensions_COPY_INP_TMP[5] = "jpg";
      hv_Extensions_COPY_INP_TMP[6] = "jpeg";
      hv_Extensions_COPY_INP_TMP[7] = "jp2";
      hv_Extensions_COPY_INP_TMP[8] = "jxr";
      hv_Extensions_COPY_INP_TMP[9] = "png";
      hv_Extensions_COPY_INP_TMP[10] = "pcx";
      hv_Extensions_COPY_INP_TMP[11] = "ras";
      hv_Extensions_COPY_INP_TMP[12] = "xwd";
      hv_Extensions_COPY_INP_TMP[13] = "pbm";
      hv_Extensions_COPY_INP_TMP[14] = "pnm";
      hv_Extensions_COPY_INP_TMP[15] = "pgm";
      hv_Extensions_COPY_INP_TMP[16] = "ppm";
      //
    }
    hv_ImageFiles.Dispose();
    hv_ImageFiles = new HTuple();
    //Loop through all given image directories.
    for (hv_ImageDirectoryIndex=0; (int)hv_ImageDirectoryIndex<=(int)((new HTuple(hv_ImageDirectory.TupleLength()
        ))-1); hv_ImageDirectoryIndex = (int)hv_ImageDirectoryIndex + 1)
    {
      hv_ImageFilesTmp.Dispose();
      hv_ImageFilesTmp = new HTuple();
      hv_CurrentImageDirectory.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentImageDirectory = hv_ImageDirectory.TupleSelect(
          hv_ImageDirectoryIndex);
      }
      if ((int)(new HTuple(hv_CurrentImageDirectory.TupleEqual(""))) != 0)
      {
        hv_CurrentImageDirectory.Dispose();
        hv_CurrentImageDirectory = ".";
      }
      hv_HalconImages.Dispose();
      HOperatorSet.GetSystem("image_dir", out hv_HalconImages);
      hv_OS.Dispose();
      HOperatorSet.GetSystem("operating_system", out hv_OS);
      if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_HalconImages = hv_HalconImages.TupleSplit(
            ";");
        hv_HalconImages.Dispose();
        hv_HalconImages = ExpTmpLocalVar_HalconImages;
        }
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_HalconImages = hv_HalconImages.TupleSplit(
            ":");
        hv_HalconImages.Dispose();
        hv_HalconImages = ExpTmpLocalVar_HalconImages;
        }
        }
      }
      hv_Directories.Dispose();
      hv_Directories = new HTuple(hv_CurrentImageDirectory);
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_HalconImages.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Directories = hv_Directories.TupleConcat(
            ((hv_HalconImages.TupleSelect(hv_Index))+"/")+hv_CurrentImageDirectory);
        hv_Directories.Dispose();
        hv_Directories = ExpTmpLocalVar_Directories;
        }
        }
      }
      hv_Length.Dispose();
      HOperatorSet.TupleStrlen(hv_Directories, out hv_Length);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NetworkDrive.Dispose();
      HOperatorSet.TupleGenConst(new HTuple(hv_Length.TupleLength()), 0, out hv_NetworkDrive);
      }
      if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
      {
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Length.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          if ((int)(new HTuple(((((hv_Directories.TupleSelect(hv_Index))).TupleStrlen()
              )).TupleGreater(1))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Substring.Dispose();
            HOperatorSet.TupleStrFirstN(hv_Directories.TupleSelect(hv_Index), 1, 
                out hv_Substring);
            }
            if ((int)((new HTuple(hv_Substring.TupleEqual("//"))).TupleOr(new HTuple(hv_Substring.TupleEqual(
                "\\\\")))) != 0)
            {
              if (hv_NetworkDrive == null)
                hv_NetworkDrive = new HTuple();
              hv_NetworkDrive[hv_Index] = 1;
            }
          }
        }
      }
      hv_ImageFilesTmp.Dispose();
      hv_ImageFilesTmp = new HTuple();
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Directories.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FileExists.Dispose();
        HOperatorSet.FileExists(hv_Directories.TupleSelect(hv_Index), out hv_FileExists);
        }
        if ((int)(hv_FileExists) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AllFiles.Dispose();
          HOperatorSet.ListFiles(hv_Directories.TupleSelect(hv_Index), (new HTuple("files")).TupleConcat(
              hv_Options), out hv_AllFiles);
          }
          hv_ImageFilesTmp.Dispose();
          hv_ImageFilesTmp = new HTuple();
          for (hv_i=0; (int)hv_i<=(int)((new HTuple(hv_Extensions_COPY_INP_TMP.TupleLength()
              ))-1); hv_i = (int)hv_i + 1)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Selection.Dispose();
            HOperatorSet.TupleRegexpSelect(hv_AllFiles, (((".*"+(hv_Extensions_COPY_INP_TMP.TupleSelect(
                hv_i)))+"$")).TupleConcat("ignore_case"), out hv_Selection);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ImageFilesTmp = hv_ImageFilesTmp.TupleConcat(
                hv_Selection);
            hv_ImageFilesTmp.Dispose();
            hv_ImageFilesTmp = ExpTmpLocalVar_ImageFilesTmp;
            }
            }
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRegexpReplace(hv_ImageFilesTmp, (new HTuple("\\\\")).TupleConcat(
              "replace_all"), "/", out ExpTmpOutVar_0);
          hv_ImageFilesTmp.Dispose();
          hv_ImageFilesTmp = ExpTmpOutVar_0;
          }
          if ((int)(hv_NetworkDrive.TupleSelect(hv_Index)) != 0)
          {
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.TupleRegexpReplace(hv_ImageFilesTmp, (new HTuple("//")).TupleConcat(
                "replace_all"), "/", out ExpTmpOutVar_0);
            hv_ImageFilesTmp.Dispose();
            hv_ImageFilesTmp = ExpTmpOutVar_0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ImageFilesTmp = "/"+hv_ImageFilesTmp;
            hv_ImageFilesTmp.Dispose();
            hv_ImageFilesTmp = ExpTmpLocalVar_ImageFilesTmp;
            }
            }
          }
          else
          {
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.TupleRegexpReplace(hv_ImageFilesTmp, (new HTuple("//")).TupleConcat(
                "replace_all"), "/", out ExpTmpOutVar_0);
            hv_ImageFilesTmp.Dispose();
            hv_ImageFilesTmp = ExpTmpOutVar_0;
            }
          }
          break;
        }
      }
      //Concatenate the output image paths.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageFiles = hv_ImageFiles.TupleConcat(
          hv_ImageFilesTmp);
      hv_ImageFiles.Dispose();
      hv_ImageFiles = ExpTmpLocalVar_ImageFiles;
      }
      }
    }

    hv_Extensions_COPY_INP_TMP.Dispose();
    hv_ImageDirectoryIndex.Dispose();
    hv_ImageFilesTmp.Dispose();
    hv_CurrentImageDirectory.Dispose();
    hv_HalconImages.Dispose();
    hv_OS.Dispose();
    hv_Directories.Dispose();
    hv_Index.Dispose();
    hv_Length.Dispose();
    hv_NetworkDrive.Dispose();
    hv_Substring.Dispose();
    hv_FileExists.Dispose();
    hv_AllFiles.Dispose();
    hv_i.Dispose();
    hv_Selection.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: shuffles the input colors in a deterministic way 
  public void make_neighboring_colors_distinguishable (HTuple hv_ColorsRainbow, out HTuple hv_Colors)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_NumChunks = new HTuple();
    HTuple hv_NumLeftOver = new HTuple(), hv_ColorsPerChunk = new HTuple();
    HTuple hv_StartIdx = new HTuple(), hv_S = new HTuple();
    HTuple hv_EndIdx = new HTuple(), hv_IdxsLeft = new HTuple();
    HTuple hv_IdxsRight = new HTuple();
    // Initialize local and output iconic variables 
    hv_Colors = new HTuple();
    //
    //Shuffle the input colors in a deterministic way
    //to make adjacent colors more distinguishable.
    //Neighboring colors from the input are distributed to every NumChunks
    //position in the output.
    //Depending on the number of colors, increase NumChunks.
    hv_NumColors.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumColors = new HTuple(hv_ColorsRainbow.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(8))) != 0)
    {
      hv_NumChunks.Dispose();
      hv_NumChunks = 3;
      if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(40))) != 0)
      {
        hv_NumChunks.Dispose();
        hv_NumChunks = 6;
      }
      else if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(20))) != 0)
      {
        hv_NumChunks.Dispose();
        hv_NumChunks = 4;
      }
      hv_Colors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Colors = HTuple.TupleGenConst(
          hv_NumColors,-1);
      }
      //Check if the Number of Colors is dividable by NumChunks.
      hv_NumLeftOver.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumLeftOver = hv_NumColors%hv_NumChunks;
      }
      hv_ColorsPerChunk.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColorsPerChunk = ((hv_NumColors/hv_NumChunks)).TupleInt()
          ;
      }
      hv_StartIdx.Dispose();
      hv_StartIdx = 0;
      HTuple end_val19 = hv_NumChunks-1;
      HTuple step_val19 = 1;
      for (hv_S=0; hv_S.Continue(end_val19, step_val19); hv_S = hv_S.TupleAdd(step_val19))
      {
        hv_EndIdx.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_EndIdx = (hv_StartIdx+hv_ColorsPerChunk)-1;
        }
        if ((int)(new HTuple(hv_S.TupleLess(hv_NumLeftOver))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_EndIdx = hv_EndIdx+1;
          hv_EndIdx.Dispose();
          hv_EndIdx = ExpTmpLocalVar_EndIdx;
          }
          }
        }
        hv_IdxsLeft.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_IdxsLeft = HTuple.TupleGenSequence(
            hv_S,hv_NumColors-1,hv_NumChunks);
        }
        hv_IdxsRight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_IdxsRight = HTuple.TupleGenSequence(
            hv_StartIdx,hv_EndIdx,1);
        }
        if (hv_Colors == null)
          hv_Colors = new HTuple();
        hv_Colors[HTuple.TupleGenSequence(hv_S,hv_NumColors-1,hv_NumChunks)] = hv_ColorsRainbow.TupleSelectRange(
            hv_StartIdx,hv_EndIdx);
        hv_StartIdx.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_StartIdx = hv_EndIdx+1;
        }
      }
    }
    else
    {
      hv_Colors.Dispose();
      hv_Colors = new HTuple(hv_ColorsRainbow);
    }

    hv_NumColors.Dispose();
    hv_NumChunks.Dispose();
    hv_NumLeftOver.Dispose();
    hv_ColorsPerChunk.Dispose();
    hv_StartIdx.Dispose();
    hv_S.Dispose();
    hv_EndIdx.Dispose();
    hv_IdxsLeft.Dispose();
    hv_IdxsRight.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Get string extends of several lines. 
  public void max_line_width (HTuple hv_WindowHandle, HTuple hv_Lines, out HTuple hv_MaxWidth)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Index = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_LineWidth = new HTuple();
    HTuple hv_LineHeight = new HTuple();
    // Initialize local and output iconic variables 
    hv_MaxWidth = new HTuple();
    //
    hv_MaxWidth.Dispose();
    hv_MaxWidth = 0;
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Lines.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_LineWidth.Dispose();hv_LineHeight.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Lines.TupleSelect(hv_Index), 
          out hv_Ascent, out hv_Descent, out hv_LineWidth, out hv_LineHeight);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_MaxWidth = ((hv_LineWidth.TupleConcat(
          hv_MaxWidth))).TupleMax();
      hv_MaxWidth.Dispose();
      hv_MaxWidth = ExpTmpLocalVar_MaxWidth;
      }
      }
    }

    hv_Index.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_LineWidth.Dispose();
    hv_LineHeight.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Get string extends of several lines. 
  public void max_line_width_visualize_object_model_3d (HTuple hv_WindowHandle, HTuple hv_Lines, 
      out HTuple hv_MaxWidth)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Index = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_LineWidth = new HTuple();
    HTuple hv_LineHeight = new HTuple();
    // Initialize local and output iconic variables 
    hv_MaxWidth = new HTuple();
    //
    hv_MaxWidth.Dispose();
    hv_MaxWidth = 0;
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Lines.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_LineWidth.Dispose();hv_LineHeight.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Lines.TupleSelect(hv_Index), 
          out hv_Ascent, out hv_Descent, out hv_LineWidth, out hv_LineHeight);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_MaxWidth = ((hv_LineWidth.TupleConcat(
          hv_MaxWidth))).TupleMax();
      hv_MaxWidth.Dispose();
      hv_MaxWidth = ExpTmpLocalVar_MaxWidth;
      }
      }
    }

    hv_Index.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_LineWidth.Dispose();
    hv_LineHeight.Dispose();

    return;
  }

  // Chapter: Transformations / Misc
  // Short Description: Obtain the pose of the matched model in the base coordinate system. 
  public void obtain_3d_pose_of_match_moving_cam (HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_Angle, HTuple hv_ToolInBasePose, HTuple hv_HandEyeCalibData, HTuple hv_Poses, 
      HTuple hv_RectificationData, out HTuple hv_ModelInBasePose)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CamParam = new HTuple(), hv_ToolInCamPose = new HTuple();
    HTuple hv_PlaneInModelPose = new HTuple(), hv_RectifyImage = new HTuple();
    HTuple hv_ScaleRectification = new HTuple(), hv_MatchingPlaneRectifiedPartInCamPose = new HTuple();
    HTuple hv_OrderOfTransform = new HTuple(), hv_OrderOfRotation = new HTuple();
    HTuple hv_ViewOfTransform = new HTuple(), hv_HomMat2DObject = new HTuple();
    HTuple hv_RowObject = new HTuple(), hv_ColObject = new HTuple();
    HTuple hv_PXM = new HTuple(), hv_PYM = new HTuple(), hv_HomMat3DObject = new HTuple();
    HTuple hv_ModelToMatchInPlanePose = new HTuple(), hv_ModelInPlanePose = new HTuple();
    HTuple hv_ModelInCamPose = new HTuple(), hv_ModelToMatchInPlanePartRectPose = new HTuple();
    HTuple hv_ModelInMatchingPlaneRectifiedPartPose = new HTuple();
    HTuple hv_BaseInToolPose = new HTuple(), hv_BaseInCamPose = new HTuple();
    HTuple hv_CamInBasePose = new HTuple();
    HTuple   hv_ToolInBasePose_COPY_INP_TMP = new HTuple(hv_ToolInBasePose);

    // Initialize local and output iconic variables 
    hv_ModelInBasePose = new HTuple();
    //This procedure obtains the 3D pose from the model to the base of
    //the robot.
    hv_CamParam.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "CamParam", out hv_CamParam);
    hv_ToolInCamPose.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "ToolInCamPose", out hv_ToolInCamPose);
    hv_PlaneInModelPose.Dispose();
    read_dict_tuple(hv_Poses, "PlaneInModelPose", out hv_PlaneInModelPose);
    hv_RectifyImage.Dispose();
    read_dict_tuple(hv_RectificationData, "RectifyImage", out hv_RectifyImage);
    if ((int)(new HTuple(hv_RectifyImage.TupleNotEqual("no_rectification"))) != 0)
    {
      hv_ScaleRectification.Dispose();
      read_dict_tuple(hv_RectificationData, "ScaleRectification", out hv_ScaleRectification);
    }
    hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
    read_dict_tuple(hv_RectificationData, "MatchingPlaneRectifiedPartInCamPose", 
        out hv_MatchingPlaneRectifiedPartInCamPose);
    //
    //Keep track of the pose type used by the robot.
    hv_OrderOfTransform.Dispose();hv_OrderOfRotation.Dispose();hv_ViewOfTransform.Dispose();
    HOperatorSet.GetPoseType(hv_ToolInBasePose_COPY_INP_TMP, out hv_OrderOfTransform, 
        out hv_OrderOfRotation, out hv_ViewOfTransform);
    //Convert to default pose type.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_MatchingPlaneRectifiedPartInCamPose, "Rp+T", 
        "gba", "point", out ExpTmpOutVar_0);
    hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
    hv_MatchingPlaneRectifiedPartInCamPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInModelPose, "Rp+T", "gba", "point", out ExpTmpOutVar_0);
    hv_PlaneInModelPose.Dispose();
    hv_PlaneInModelPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_ToolInBasePose_COPY_INP_TMP, "Rp+T", "gba", "point", 
        out ExpTmpOutVar_0);
    hv_ToolInBasePose_COPY_INP_TMP.Dispose();
    hv_ToolInBasePose_COPY_INP_TMP = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_ToolInCamPose, "Rp+T", "gba", "point", out ExpTmpOutVar_0);
    hv_ToolInCamPose.Dispose();
    hv_ToolInCamPose = ExpTmpOutVar_0;
    }
    if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(1))) != 0)
    {
      hv_HomMat2DObject.Dispose();
      HOperatorSet.VectorAngleToRigid(0, 0, 0, hv_Row, hv_Column, hv_Angle, out hv_HomMat2DObject);
      //Col = x, Row = y.
      if ((int)(new HTuple(hv_RectifyImage.TupleEqual("no_rectification"))) != 0)
      {
        hv_RowObject.Dispose();hv_ColObject.Dispose();
        HOperatorSet.AffineTransPixel(hv_HomMat2DObject, 0, 0, out hv_RowObject, 
            out hv_ColObject);
        hv_PXM.Dispose();hv_PYM.Dispose();
        HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneRectifiedPartInCamPose, 
            hv_RowObject, hv_ColObject, "m", out hv_PXM, out hv_PYM);
        hv_HomMat3DObject.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HomMat3DObject = new HTuple();
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            4));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            3));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(0);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_PXM);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            1));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            0));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(0);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_PYM);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(new HTuple(0, 0, 1, 0));
        }
        hv_ModelToMatchInPlanePose.Dispose();
        HOperatorSet.HomMat3dToPose(hv_HomMat3DObject, out hv_ModelToMatchInPlanePose);
        hv_ModelInPlanePose.Dispose();
        HOperatorSet.PoseCompose(hv_ModelToMatchInPlanePose, hv_PlaneInModelPose, 
            out hv_ModelInPlanePose);
        hv_ModelInCamPose.Dispose();
        HOperatorSet.PoseCompose(hv_MatchingPlaneRectifiedPartInCamPose, hv_ModelInPlanePose, 
            out hv_ModelInCamPose);
      }
      else if ((int)((new HTuple(hv_RectifyImage.TupleEqual("only_rectify"))).TupleOr(
          new HTuple(hv_RectifyImage.TupleEqual("align_and_rectify")))) != 0)
      {
        hv_HomMat3DObject.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HomMat3DObject = new HTuple();
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            4));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            3));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(0);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat((hv_HomMat2DObject.TupleSelect(
            5))*hv_ScaleRectification);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            1));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            0));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(0);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat((hv_HomMat2DObject.TupleSelect(
            2))*hv_ScaleRectification);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(new HTuple(0, 0, 1, 0));
        }
        hv_ModelToMatchInPlanePartRectPose.Dispose();
        HOperatorSet.HomMat3dToPose(hv_HomMat3DObject, out hv_ModelToMatchInPlanePartRectPose);
        hv_ModelInMatchingPlaneRectifiedPartPose.Dispose();
        HOperatorSet.PoseCompose(hv_ModelToMatchInPlanePartRectPose, hv_PlaneInModelPose, 
            out hv_ModelInMatchingPlaneRectifiedPartPose);
        hv_ModelInCamPose.Dispose();
        HOperatorSet.PoseCompose(hv_MatchingPlaneRectifiedPartInCamPose, hv_ModelInMatchingPlaneRectifiedPartPose, 
            out hv_ModelInCamPose);
      }
      else
      {
        throw new HalconException("Please set the parameter RectifyImage correctly");
      }
      hv_BaseInToolPose.Dispose();
      HOperatorSet.PoseInvert(hv_ToolInBasePose_COPY_INP_TMP, out hv_BaseInToolPose);
      hv_BaseInCamPose.Dispose();
      HOperatorSet.PoseCompose(hv_ToolInCamPose, hv_BaseInToolPose, out hv_BaseInCamPose);
      hv_CamInBasePose.Dispose();
      HOperatorSet.PoseInvert(hv_BaseInCamPose, out hv_CamInBasePose);
      hv_ModelInBasePose.Dispose();
      HOperatorSet.PoseCompose(hv_CamInBasePose, hv_ModelInCamPose, out hv_ModelInBasePose);
      //
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.ConvertPoseType(hv_ModelInBasePose, hv_OrderOfTransform, hv_OrderOfRotation, 
          hv_ViewOfTransform, out ExpTmpOutVar_0);
      hv_ModelInBasePose.Dispose();
      hv_ModelInBasePose = ExpTmpOutVar_0;
      }
    }
    else
    {
      throw new HalconException("Exactly one match should be given as input");
    }

    hv_ToolInBasePose_COPY_INP_TMP.Dispose();
    hv_CamParam.Dispose();
    hv_ToolInCamPose.Dispose();
    hv_PlaneInModelPose.Dispose();
    hv_RectifyImage.Dispose();
    hv_ScaleRectification.Dispose();
    hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
    hv_OrderOfTransform.Dispose();
    hv_OrderOfRotation.Dispose();
    hv_ViewOfTransform.Dispose();
    hv_HomMat2DObject.Dispose();
    hv_RowObject.Dispose();
    hv_ColObject.Dispose();
    hv_PXM.Dispose();
    hv_PYM.Dispose();
    hv_HomMat3DObject.Dispose();
    hv_ModelToMatchInPlanePose.Dispose();
    hv_ModelInPlanePose.Dispose();
    hv_ModelInCamPose.Dispose();
    hv_ModelToMatchInPlanePartRectPose.Dispose();
    hv_ModelInMatchingPlaneRectifiedPartPose.Dispose();
    hv_BaseInToolPose.Dispose();
    hv_BaseInCamPose.Dispose();
    hv_CamInBasePose.Dispose();

    return;
  }

  // Chapter: Transformations / Misc
  // Short Description: Obtain the pose of the matched model in the base coordinate system in a stationary camera setup. 
  public void obtain_3d_pose_of_match_stationary_cam (HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_Angle, HTuple hv_HandEyeCalibData, HTuple hv_Poses, HTuple hv_RectificationData, 
      out HTuple hv_ModelInBasePose)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CamParam = new HTuple(), hv_BaseInCamPose = new HTuple();
    HTuple hv_PlaneInModelPose = new HTuple(), hv_MatchingPlaneInCamPose = new HTuple();
    HTuple hv_RectifyImage = new HTuple(), hv_ScaleRectification = new HTuple();
    HTuple hv_OrderOfTransform = new HTuple(), hv_OrderOfRotation = new HTuple();
    HTuple hv_ViewOfTransform = new HTuple(), hv_HomMat2DObject = new HTuple();
    HTuple hv_RowObject = new HTuple(), hv_ColObject = new HTuple();
    HTuple hv_PXM = new HTuple(), hv_PYM = new HTuple(), hv_HomMat3DObject = new HTuple();
    HTuple hv_ModelToMatchInPlanePose = new HTuple(), hv_ModelInPlanePose = new HTuple();
    HTuple hv_ModelInCamPose = new HTuple(), hv_ModelToMatchInPlanePartRectPose = new HTuple();
    HTuple hv_ModelInPlanePartRectPose = new HTuple(), hv_CamInBasePose = new HTuple();
    // Initialize local and output iconic variables 
    hv_ModelInBasePose = new HTuple();
    //This procedure obtains the 3D pose from the model to the base of
    //the robot.
    hv_CamParam.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "CamParam", out hv_CamParam);
    hv_BaseInCamPose.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "BaseInCamPose", out hv_BaseInCamPose);
    hv_PlaneInModelPose.Dispose();
    read_dict_tuple(hv_Poses, "PlaneInModelPose", out hv_PlaneInModelPose);
    hv_MatchingPlaneInCamPose.Dispose();
    read_dict_tuple(hv_Poses, "MatchingPlaneInCamPose", out hv_MatchingPlaneInCamPose);
    hv_RectifyImage.Dispose();
    read_dict_tuple(hv_RectificationData, "RectifyImage", out hv_RectifyImage);
    if ((int)(new HTuple(hv_RectifyImage.TupleEqual("true"))) != 0)
    {
      hv_ScaleRectification.Dispose();
      read_dict_tuple(hv_RectificationData, "ScaleRectification", out hv_ScaleRectification);
    }
    //
    //Keep track of the pose type used by the robot.
    hv_OrderOfTransform.Dispose();hv_OrderOfRotation.Dispose();hv_ViewOfTransform.Dispose();
    HOperatorSet.GetPoseType(hv_PlaneInModelPose, out hv_OrderOfTransform, out hv_OrderOfRotation, 
        out hv_ViewOfTransform);
    //Convert to default pose type.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_MatchingPlaneInCamPose, "Rp+T", "gba", "point", 
        out ExpTmpOutVar_0);
    hv_MatchingPlaneInCamPose.Dispose();
    hv_MatchingPlaneInCamPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInModelPose, "Rp+T", "gba", "point", out ExpTmpOutVar_0);
    hv_PlaneInModelPose.Dispose();
    hv_PlaneInModelPose = ExpTmpOutVar_0;
    }
    if ((int)((new HTuple((new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(
        1))).TupleAnd(new HTuple((new HTuple(hv_Column.TupleLength())).TupleEqual(
        1))))).TupleAnd(new HTuple((new HTuple(hv_Angle.TupleLength())).TupleEqual(
        1)))) != 0)
    {
      hv_HomMat2DObject.Dispose();
      HOperatorSet.VectorAngleToRigid(0, 0, 0, hv_Row, hv_Column, hv_Angle, out hv_HomMat2DObject);
      //col = x, row = y
      if ((int)(new HTuple(hv_RectifyImage.TupleEqual("false"))) != 0)
      {
        hv_RowObject.Dispose();hv_ColObject.Dispose();
        HOperatorSet.AffineTransPixel(hv_HomMat2DObject, 0, 0, out hv_RowObject, 
            out hv_ColObject);
        hv_PXM.Dispose();hv_PYM.Dispose();
        HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, 
            hv_RowObject, hv_ColObject, "m", out hv_PXM, out hv_PYM);
        hv_HomMat3DObject.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HomMat3DObject = new HTuple();
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            4));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            3));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(0);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_PXM);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            1));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            0));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(0);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_PYM);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(new HTuple(0, 0, 1, 0));
        }
        hv_ModelToMatchInPlanePose.Dispose();
        HOperatorSet.HomMat3dToPose(hv_HomMat3DObject, out hv_ModelToMatchInPlanePose);
        hv_ModelInPlanePose.Dispose();
        HOperatorSet.PoseCompose(hv_ModelToMatchInPlanePose, hv_PlaneInModelPose, 
            out hv_ModelInPlanePose);
        hv_ModelInCamPose.Dispose();
        HOperatorSet.PoseCompose(hv_MatchingPlaneInCamPose, hv_ModelInPlanePose, 
            out hv_ModelInCamPose);
      }
      else if ((int)(new HTuple(hv_RectifyImage.TupleEqual("true"))) != 0)
      {
        hv_HomMat3DObject.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HomMat3DObject = new HTuple();
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            4));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            3));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(0);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat((hv_HomMat2DObject.TupleSelect(
            5))*hv_ScaleRectification);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            1));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(hv_HomMat2DObject.TupleSelect(
            0));
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(0);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat((hv_HomMat2DObject.TupleSelect(
            2))*hv_ScaleRectification);
        hv_HomMat3DObject = hv_HomMat3DObject.TupleConcat(new HTuple(0, 0, 1, 0));
        }
        hv_ModelToMatchInPlanePartRectPose.Dispose();
        HOperatorSet.HomMat3dToPose(hv_HomMat3DObject, out hv_ModelToMatchInPlanePartRectPose);
        hv_ModelInPlanePartRectPose.Dispose();
        HOperatorSet.PoseCompose(hv_ModelToMatchInPlanePartRectPose, hv_PlaneInModelPose, 
            out hv_ModelInPlanePartRectPose);
        hv_ModelInCamPose.Dispose();
        HOperatorSet.PoseCompose(hv_MatchingPlaneInCamPose, hv_ModelInPlanePartRectPose, 
            out hv_ModelInCamPose);
      }
      else
      {
        throw new HalconException("Please set the parameter RectifyImage correctly");
      }
      hv_CamInBasePose.Dispose();
      HOperatorSet.PoseInvert(hv_BaseInCamPose, out hv_CamInBasePose);
      hv_ModelInBasePose.Dispose();
      HOperatorSet.PoseCompose(hv_CamInBasePose, hv_ModelInCamPose, out hv_ModelInBasePose);
      //
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.ConvertPoseType(hv_ModelInBasePose, hv_OrderOfTransform, hv_OrderOfRotation, 
          hv_ViewOfTransform, out ExpTmpOutVar_0);
      hv_ModelInBasePose.Dispose();
      hv_ModelInBasePose = ExpTmpOutVar_0;
      }
    }
    else
    {
      throw new HalconException("Exactly one match should be given as input");
    }

    hv_CamParam.Dispose();
    hv_BaseInCamPose.Dispose();
    hv_PlaneInModelPose.Dispose();
    hv_MatchingPlaneInCamPose.Dispose();
    hv_RectifyImage.Dispose();
    hv_ScaleRectification.Dispose();
    hv_OrderOfTransform.Dispose();
    hv_OrderOfRotation.Dispose();
    hv_ViewOfTransform.Dispose();
    hv_HomMat2DObject.Dispose();
    hv_RowObject.Dispose();
    hv_ColObject.Dispose();
    hv_PXM.Dispose();
    hv_PYM.Dispose();
    hv_HomMat3DObject.Dispose();
    hv_ModelToMatchInPlanePose.Dispose();
    hv_ModelInPlanePose.Dispose();
    hv_ModelInCamPose.Dispose();
    hv_ModelToMatchInPlanePartRectPose.Dispose();
    hv_ModelInPlanePartRectPose.Dispose();
    hv_CamInBasePose.Dispose();

    return;
  }

  // Chapter: Graphics / Window
  // Short Description: Open a window next to the given WindowHandleFather.  
  public void open_child_window (HTuple hv_WindowHandleFather, HTuple hv_Font, HTuple hv_FontSize, 
      HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleChild, out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_StringWidth = new HTuple(), hv_IndexText = new HTuple();
    HTuple hv__ = new HTuple(), hv_TextWidth = new HTuple();
    HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    HTuple hv_MetaInfo = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandleChild = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    //
    //This procedure opens a window next to the given WindowHandleFather.
    //
    //Get the maximum width of the text to be displayed.
    hv_StringWidth.Dispose();
    hv_StringWidth = 0;
    for (hv_IndexText=0; (int)hv_IndexText<=(int)((new HTuple(hv_Text.TupleLength()
        ))-1); hv_IndexText = (int)hv_IndexText + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv__.Dispose();hv__.Dispose();hv_TextWidth.Dispose();hv__.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandleFather, hv_Text.TupleSelect(hv_IndexText), 
          out hv__, out hv__, out hv_TextWidth, out hv__);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_StringWidth = hv_StringWidth.TupleMax2(
          hv_TextWidth);
      hv_StringWidth.Dispose();
      hv_StringWidth = ExpTmpLocalVar_StringWidth;
      }
      }
    }
    //
    //Define window coordinates.
    hv_WindowRow.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowRow = hv_PrevWindowCoordinates.TupleSelect(
        0);
    }
    hv_WindowColumn.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowColumn = ((hv_PrevWindowCoordinates.TupleSelect(
        1))+(hv_PrevWindowCoordinates.TupleSelect(2)))+5;
    }
    hv_WindowWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowWidth = hv_StringWidth+(2*12.0);
    }
    hv_WindowHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowHeight = hv_PrevWindowCoordinates.TupleSelect(
        3);
    }
    //
    HOperatorSet.SetWindowAttr("background_color","black");
    HOperatorSet.OpenWindow(hv_WindowRow,hv_WindowColumn,hv_WindowWidth,hv_WindowHeight,0,"visible","",out hv_WindowHandleChild);
    HDevWindowStack.Push(hv_WindowHandleChild);
    set_display_font(hv_WindowHandleChild, hv_FontSize, hv_Font, "true", "false");
    //
    //Return the coordinates of the new window.
    hv_PrevWindowCoordinatesOut.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PrevWindowCoordinatesOut = new HTuple();
    hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight);
    }
    //
    //Set some meta information about the new child window handle.
    hv_MetaInfo.Dispose();
    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_child_window_coordinates", 
        hv_PrevWindowCoordinatesOut);
    }
    HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
    //

    hv_StringWidth.Dispose();
    hv_IndexText.Dispose();
    hv__.Dispose();
    hv_TextWidth.Dispose();
    hv_WindowRow.Dispose();
    hv_WindowColumn.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();
    hv_MetaInfo.Dispose();

    return;
  }

  // Chapter: Graphics / Window
  // Short Description: Open a new window next to an existing one. 
  public void open_new_window (out HTuple hv_WindowHandle, out HTuple hv_WindowHandleGraphics)
  {


    // Local control variables 

    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandle = new HTuple();
    hv_WindowHandleGraphics = new HTuple();
    HOperatorSet.WaitSeconds(0.1);
    if (HDevWindowStack.IsOpen())
    {
      hv_WindowHandle = HDevWindowStack.GetActive();
    }
    hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width, 
        out hv_Height);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowHandleGraphics.Dispose();
    dev_open_window_fit_size(0, hv_Width+8, hv_Width, hv_Height, 600, -1, out hv_WindowHandleGraphics);
    }
    set_display_font(hv_WindowHandleGraphics, 14, "mono", "true", "false");
    HOperatorSet.SetPartStyle(hv_WindowHandleGraphics, 2);

    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();

    return;
  }

  // Chapter: Graphics / Window
  // Short Description: Open a new window, either next to the last ones, or in a new row. 
  public void open_next_window (HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc, 
      HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows, 
      HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleNew, out HTuple hv_WindowImageRatio, 
      out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_PrevWindowRow = new HTuple(), hv_PrevWindowColumn = new HTuple();
    HTuple hv_PrevWindowWidth = new HTuple(), hv_PrevWindowHeight = new HTuple();
    HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
    HTuple hv_SetPartRow2 = new HTuple(), hv_SetPartColumn2 = new HTuple();
    HTuple hv_MarginBottom = new HTuple(), hv__ = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    HTuple hv_MetaInfo = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandleNew = new HTuple();
    hv_WindowImageRatio = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    //
    //This procedure opens a new window, either next to
    //the last ones, or in a new row.
    //
    //Get coordinates of previous window.
    hv_PrevWindowRow.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PrevWindowRow = hv_PrevWindowCoordinates.TupleSelect(
        0);
    }
    hv_PrevWindowColumn.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PrevWindowColumn = hv_PrevWindowCoordinates.TupleSelect(
        1);
    }
    hv_PrevWindowWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PrevWindowWidth = hv_PrevWindowCoordinates.TupleSelect(
        2);
    }
    hv_PrevWindowHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PrevWindowHeight = hv_PrevWindowCoordinates.TupleSelect(
        3);
    }
    //
    if ((int)(new HTuple(((hv_PrevWindowColumn+hv_PrevWindowWidth)).TupleGreater(
        hv_ThresholdWidth))) != 0)
    {
      //Open window in new row.
      hv_WindowRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowRow = (hv_PrevWindowRow+hv_PrevWindowHeight)+55;
      }
      hv_WindowColumn.Dispose();
      hv_WindowColumn = 0;
    }
    else
    {
      //Open window in same row.
      hv_WindowRow.Dispose();
      hv_WindowRow = new HTuple(hv_PrevWindowRow);
      hv_WindowColumn.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowColumn = hv_PrevWindowColumn+hv_PrevWindowWidth;
      }
      if ((int)(new HTuple(hv_WindowColumn.TupleNotEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_WindowColumn = hv_WindowColumn+5;
        hv_WindowColumn.Dispose();
        hv_WindowColumn = ExpTmpLocalVar_WindowColumn;
        }
        }
      }
    }
    //
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_WindowHandleNew.Dispose();
    dev_open_window_fit_size(hv_WindowRow, hv_WindowColumn, hv_WidthImage, hv_HeightImage, 
        (new HTuple(500)).TupleConcat(800)*hv_ScaleWindows, (new HTuple(400)).TupleConcat(
        600)*hv_ScaleWindows, out hv_WindowHandleNew);
    }
    set_display_font(hv_WindowHandleNew, hv_FontSize, hv_Font, "true", "false");
    //
    //Get meta information of new window handle
    hv_WindowImageRatio.Dispose();hv_SetPartRow2.Dispose();hv_SetPartColumn2.Dispose();hv_PrevWindowCoordinatesOut.Dispose();hv_MarginBottom.Dispose();
    get_window_meta_information(hv_WindowHandleNew, hv_WidthImage, hv_HeightImage, 
        hv_MapColorBarWidth, hv_WindowRow, hv_WindowColumn, hv_ShowBottomDesc, out hv_WindowImageRatio, 
        out hv_SetPartRow2, out hv_SetPartColumn2, out hv_PrevWindowCoordinatesOut, 
        out hv_MarginBottom);
    //
    //Add space for displaying text at the bottom of the window
    hv__.Dispose();hv__.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandleNew, out hv__, out hv__, out hv_WindowWidth, 
        out hv_WindowHeight);
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowRow, hv_WindowColumn, 
          hv_WindowWidth+hv_MapColorBarWidth, hv_WindowHeight+hv_MarginBottom);
      }
    }
    if (hv_PrevWindowCoordinatesOut == null)
      hv_PrevWindowCoordinatesOut = new HTuple();
    hv_PrevWindowCoordinatesOut[2] = hv_WindowWidth+hv_MapColorBarWidth;
    if (hv_PrevWindowCoordinatesOut == null)
      hv_PrevWindowCoordinatesOut = new HTuple();
    hv_PrevWindowCoordinatesOut[3] = hv_WindowHeight+hv_MarginBottom;
    //
    //Set window handle and some meta information about the new window handle.
    HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_WindowHandleNew);
    hv_MetaInfo.Dispose();
    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio", 
        hv_WindowImageRatio);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_row2", hv_SetPartRow2);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_column2", 
        hv_SetPartColumn2);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_margin_bottom", hv_MarginBottom);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_map_color_bar_with", 
        hv_MapColorBarWidth);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_coordinates", 
        hv_PrevWindowCoordinatesOut);
    }
    HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
    //

    hv_PrevWindowRow.Dispose();
    hv_PrevWindowColumn.Dispose();
    hv_PrevWindowWidth.Dispose();
    hv_PrevWindowHeight.Dispose();
    hv_WindowRow.Dispose();
    hv_WindowColumn.Dispose();
    hv_SetPartRow2.Dispose();
    hv_SetPartColumn2.Dispose();
    hv_MarginBottom.Dispose();
    hv__.Dispose();
    hv_WindowWidth.Dispose();
    hv_WindowHeight.Dispose();
    hv_MetaInfo.Dispose();

    return;
  }

  // Chapter: File / Misc
  // Short Description: Parse a filename into directory, base filename, and extension 
  public void parse_filename (HTuple hv_FileName, out HTuple hv_BaseName, out HTuple hv_Extension, 
      out HTuple hv_Directory)
  {



    // Local control variables 

    HTuple hv_DirectoryTmp = new HTuple(), hv_Substring = new HTuple();
    // Initialize local and output iconic variables 
    hv_BaseName = new HTuple();
    hv_Extension = new HTuple();
    hv_Directory = new HTuple();
    //This procedure gets a filename (with full path) as input
    //and returns the directory path, the base filename and the extension
    //in three different strings.
    //
    //In the output path the path separators will be replaced
    //by '/' in all cases.
    //
    //The procedure shows the possibilities of regular expressions in HALCON.
    //
    //Input parameters:
    //FileName: The input filename
    //
    //Output parameters:
    //BaseName: The filename without directory description and file extension
    //Extension: The file extension
    //Directory: The directory path
    //
    //Example:
    //basename('C:/images/part_01.png',...) returns
    //BaseName = 'part_01'
    //Extension = 'png'
    //Directory = 'C:\\images\\' (on Windows systems)
    //
    //Explanation of the regular expressions:
    //
    //'([^\\\\/]*?)(?:\\.[^.]*)?$':
    //To start at the end, the '$' matches the end of the string,
    //so it is best to read the expression from right to left.
    //The part in brackets (?:\\.[^.}*) denotes a non-capturing group.
    //That means, that this part is matched, but not captured
    //in contrast to the first bracketed group ([^\\\\/], see below.)
    //\\.[^.]* matches a dot '.' followed by as many non-dots as possible.
    //So (?:\\.[^.]*)? matches the file extension, if any.
    //The '?' at the end assures, that even if no extension exists,
    //a correct match is returned.
    //The first part in brackets ([^\\\\/]*?) is a capture group,
    //which means, that if a match is found, only the part in
    //brackets is returned as a result.
    //Because both HDevelop strings and regular expressions need a '\\'
    //to describe a backslash, inside regular expressions within HDevelop
    //a backslash has to be written as '\\\\'.
    //[^\\\\/] matches any character but a slash or backslash ('\\' in HDevelop)
    //[^\\\\/]*? matches a string od 0..n characters (except '/' or '\\')
    //where the '?' after the '*' switches the greediness off,
    //that means, that the shortest possible match is returned.
    //This option is necessary to cut off the extension
    //but only if (?:\\.[^.]*)? is able to match one.
    //To summarize, the regular expression matches that part of
    //the input string, that follows after the last '/' or '\\' and
    //cuts off the extension (if any) after the last '.'.
    //
    //'\\.([^.]*)$':
    //This matches everything after the last '.' of the input string.
    //Because ([^.]) is a capturing group,
    //only the part after the dot is returned.
    //
    //'.*[\\\\/]':
    //This matches the longest substring with a '/' or a '\\' at the end.
    //
    hv_DirectoryTmp.Dispose();
    HOperatorSet.TupleRegexpMatch(hv_FileName, ".*[\\\\/]", out hv_DirectoryTmp);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Substring.Dispose();
    HOperatorSet.TupleSubstr(hv_FileName, hv_DirectoryTmp.TupleStrlen(), (hv_FileName.TupleStrlen()
        )-1, out hv_Substring);
    }
    hv_BaseName.Dispose();
    HOperatorSet.TupleRegexpMatch(hv_Substring, "([^\\\\/]*?)(?:\\.[^.]*)?$", out hv_BaseName);
    hv_Extension.Dispose();
    HOperatorSet.TupleRegexpMatch(hv_Substring, "\\.([^.]*)$", out hv_Extension);
    //
    //
    //Finally all found backslashes ('\\') are converted
    //to a slash to get consistent paths
    hv_Directory.Dispose();
    HOperatorSet.TupleRegexpReplace(hv_DirectoryTmp, (new HTuple("\\\\")).TupleConcat(
        "replace_all"), "/", out hv_Directory);

    hv_DirectoryTmp.Dispose();
    hv_Substring.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Plot the training error, validation error and learning rate during deep learning classifier training. 
  public void plot_dl_classifier_training_progress (HTuple hv_TrainingErrors, HTuple hv_ValidationErrors, 
      HTuple hv_LearningRates, HTuple hv_Epochs, HTuple hv_NumEpochs, HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_TrainingErrorPercent = new HTuple();
    HTuple hv_ValidationErrorPercent = new HTuple(), hv_AxesColor = new HTuple();
    HTuple hv_TrainingErrorColor = new HTuple(), hv_ValidationErrorColor = new HTuple();
    HTuple hv_LearningRateColor = new HTuple(), hv_TrainingErrorFunction = new HTuple();
    HTuple hv_ValidationErrorFunction = new HTuple(), hv_LearningRateFunction = new HTuple();
    HTuple hv_GenParamName = new HTuple(), hv_GenParamValue = new HTuple();
    HTuple hv_EndYError = new HTuple(), hv_EndYLearningRate = new HTuple();
    HTuple hv_Style = new HTuple(), hv_Flush = new HTuple();
    HTuple hv_IndexMinValError = new HTuple(), hv_Text = new HTuple();
    HTuple   hv_NumEpochs_COPY_INP_TMP = new HTuple(hv_NumEpochs);

    // Initialize local and output iconic variables 
    //This procedure plots the tuples training error and
    //validation error with the y-axis on the left side,
    //and the learning rate with the y-axis on the right side,
    //versus the epochs over batches on the x-axis.
    //The maximum number of epochs should be given by NumEpochs,
    //to scale the x-axis appropriately.
    //The plot is displayed in the graphics window given by WindowHandle.
    //
    //The procedure expects the input tuples TrainingErrors, ValidationErrors,
    //LearningRates, and Epochs with their values sorted in chronological order,
    //the current value in each case as last element.
    //
    //Check input parameters.
    if ((int)(new HTuple(hv_NumEpochs_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_NumEpochs_COPY_INP_TMP.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumEpochs_COPY_INP_TMP = hv_Epochs.TupleMax()
          ;
      }
    }
    else if ((int)(new HTuple(((hv_NumEpochs_COPY_INP_TMP.TupleIsNumber())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("NumEpochs must be a number or an empty tuple.");
    }
    hv_TrainingErrorPercent.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TrainingErrorPercent = hv_TrainingErrors*100;
    }
    hv_ValidationErrorPercent.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ValidationErrorPercent = hv_ValidationErrors*100;
    }
    //
    //Set the colors of the axes, plots and texts.
    hv_AxesColor.Dispose();
    hv_AxesColor = "white";
    hv_TrainingErrorColor.Dispose();
    hv_TrainingErrorColor = "magenta";
    hv_ValidationErrorColor.Dispose();
    hv_ValidationErrorColor = "gold";
    hv_LearningRateColor.Dispose();
    hv_LearningRateColor = "dark turquoise";
    //
    //Create functions from the input tuples.
    hv_TrainingErrorFunction.Dispose();
    HOperatorSet.CreateFunct1dPairs(hv_Epochs, hv_TrainingErrorPercent, out hv_TrainingErrorFunction);
    hv_ValidationErrorFunction.Dispose();
    HOperatorSet.CreateFunct1dPairs(hv_Epochs, hv_ValidationErrorPercent, out hv_ValidationErrorFunction);
    hv_LearningRateFunction.Dispose();
    HOperatorSet.CreateFunct1dPairs(hv_Epochs, hv_LearningRates, out hv_LearningRateFunction);
    //
    //Assemble generic parameters for the plots.
    hv_GenParamName.Dispose();
    hv_GenParamName = new HTuple();
    hv_GenParamName[0] = "axis_location_x";
    hv_GenParamName[1] = "end_x";
    hv_GenParamName[2] = "ticks_x";
    hv_GenParamName[3] = "start_y";
    hv_GenParamName[4] = "margin_top";
    hv_GenParamName[5] = "margin_right";
    hv_GenParamValue.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_GenParamValue = new HTuple();
    hv_GenParamValue[0] = "origin";
    hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_NumEpochs_COPY_INP_TMP);
    hv_GenParamValue = hv_GenParamValue.TupleConcat((hv_NumEpochs_COPY_INP_TMP/5)+1);
    hv_GenParamValue = hv_GenParamValue.TupleConcat(new HTuple(0, 70, 100));
    }
    hv_EndYError.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EndYError = ((((hv_TrainingErrorPercent.TupleConcat(
        hv_ValidationErrorPercent))).TupleConcat(0.1))).TupleMax();
    }
    //Round the maximum value of the left Y-axis
    //to an integer or a real value with one decimal.
    if ((int)(new HTuple(hv_EndYError.TupleGreaterEqual(1.0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_EndYError = ((hv_EndYError.TupleCeil()
          )).TupleInt();
      hv_EndYError.Dispose();
      hv_EndYError = ExpTmpLocalVar_EndYError;
      }
      }
    }
    else
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_EndYError = (((hv_EndYError*10.0)).TupleCeil()
          )/10.0;
      hv_EndYError.Dispose();
      hv_EndYError = ExpTmpLocalVar_EndYError;
      }
      }
    }
    hv_EndYLearningRate.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EndYLearningRate = hv_LearningRates.TupleMax()
        ;
    }
    //Display the first values as crosses
    //for better visibility.
    if ((int)(new HTuple((new HTuple(hv_Epochs.TupleLength())).TupleEqual(1))) != 0)
    {
      hv_Style.Dispose();
      hv_Style = "cross";
    }
    else
    {
      hv_Style.Dispose();
      hv_Style = "line";
    }
    //
    //Disable flushing the graphics window temporarily
    //to avoid flickering.
    hv_Flush.Dispose();
    HOperatorSet.GetWindowParam(hv_WindowHandle, "flush", out hv_Flush);
    HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", "false");
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
    }
    //
    //Display plots.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    plot_funct_1d(hv_WindowHandle, hv_TrainingErrorFunction, new HTuple(), "Error [%]", 
        hv_TrainingErrorColor, hv_GenParamName.TupleConcat((((new HTuple("axes_color")).TupleConcat(
        "end_y")).TupleConcat("ticks_y")).TupleConcat("style")), ((((((hv_GenParamValue.TupleConcat(
        hv_AxesColor))).TupleConcat(hv_EndYError))).TupleConcat(hv_EndYError/5))).TupleConcat(
        hv_Style));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    plot_funct_1d(hv_WindowHandle, hv_ValidationErrorFunction, new HTuple(), new HTuple(), 
        hv_ValidationErrorColor, hv_GenParamName.TupleConcat(((new HTuple("axes_color")).TupleConcat(
        "end_y")).TupleConcat("style")), ((((hv_GenParamValue.TupleConcat("none"))).TupleConcat(
        hv_EndYError))).TupleConcat(hv_Style));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    plot_funct_1d(hv_WindowHandle, hv_LearningRateFunction, new HTuple(), "Learning rate", 
        hv_LearningRateColor, hv_GenParamName.TupleConcat((((((new HTuple("axes_color")).TupleConcat(
        "axis_location_y")).TupleConcat("end_y")).TupleConcat("ticks_y")).TupleConcat(
        "format_y")).TupleConcat("style")), ((((((((hv_GenParamValue.TupleConcat(
        hv_AxesColor))).TupleConcat("right"))).TupleConcat(hv_EndYLearningRate))).TupleConcat(
        hv_EndYLearningRate/5))).TupleConcat((new HTuple(".1e")).TupleConcat("step")));
    }
    //
    //Display current values in appropriate colors.
    hv_IndexMinValError.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IndexMinValError = hv_ValidationErrorPercent.TupleFindLast(
        hv_ValidationErrorPercent.TupleMin());
    }
    hv_Text.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Text = "Best validation error: "+(((hv_ValidationErrorPercent.TupleSelect(
        hv_IndexMinValError))).TupleString(".1f"));
    }
    if (hv_Text == null)
      hv_Text = new HTuple();
    hv_Text[1] = "Associated training error: "+(((hv_TrainingErrorPercent.TupleSelect(
        hv_IndexMinValError))).TupleString(".1f"));
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text+" %", "window", 
          "top", "left", hv_ValidationErrorColor.TupleConcat(hv_TrainingErrorColor), 
          "box", "false");
      }
    }
    hv_Text.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Text = "Learning rate: "+(((hv_LearningRates.TupleSelect(
        (new HTuple(hv_LearningRates.TupleLength()))-1))).TupleString(".1e"));
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
          "right", hv_LearningRateColor, "box", "false");
    }
    hv_Text.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Text = "Epoch: "+(((hv_Epochs.TupleSelect(
        (new HTuple(hv_Epochs.TupleLength()))-1))).TupleString(".1f"));
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "bottom", 
          "center", "white", "box", "false");
    }
    //
    //Flush the buffer and re-enable flushing.
    HOperatorSet.FlushBuffer(hv_WindowHandle);
    HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", hv_Flush);

    hv_NumEpochs_COPY_INP_TMP.Dispose();
    hv_TrainingErrorPercent.Dispose();
    hv_ValidationErrorPercent.Dispose();
    hv_AxesColor.Dispose();
    hv_TrainingErrorColor.Dispose();
    hv_ValidationErrorColor.Dispose();
    hv_LearningRateColor.Dispose();
    hv_TrainingErrorFunction.Dispose();
    hv_ValidationErrorFunction.Dispose();
    hv_LearningRateFunction.Dispose();
    hv_GenParamName.Dispose();
    hv_GenParamValue.Dispose();
    hv_EndYError.Dispose();
    hv_EndYLearningRate.Dispose();
    hv_Style.Dispose();
    hv_Flush.Dispose();
    hv_IndexMinValError.Dispose();
    hv_Text.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description:  This procedure plots tuples representing functions or curves in a coordinate system. 
  public void plot_funct_1d (HTuple hv_WindowHandle, HTuple hv_Function, HTuple hv_XLabel, 
      HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName, HTuple hv_GenParamValue)
  {



    // Local control variables 

    HTuple hv_XValues = new HTuple(), hv_YValues = new HTuple();
    // Initialize local and output iconic variables 
    //This procedure plots a function in a coordinate system.
    //
    //Input parameters:
    //
    //Function: 1D function
    //
    //XLabel: X-axis label
    //
    //XLabel: Y-axis label
    //
    //Color: Color of the plotted function
    //       If [] is given, the currently set display color is used.
    //       If 'none is given, the function is not plotted, but only
    //       the coordinate axes as specified.
    //
    //GenParamName:  Generic parameters to control the presentation
    //               The parameters are evaluated from left to right.
    //
    //               Possible Values:
    //   'axes_color': coordinate system color
    //                 Default: 'white'
    //                 If 'none' is given, no coordinate system is shown.
    //   'style': Graph style
    //            Possible values: 'line' (default), 'cross', 'step', 'filled'
    //   'clip': Clip graph to coordinate system area
    //           Possible values: 'yes' (default), 'no'
    //   'ticks': Control display of ticks on the axes
    //            If 'min_max_origin' is given (default), ticks are shown
    //            at the minimum and maximum values of the axes and at the
    //            intercept point of x- and y-axis.
    //            If 'none' is given, no ticks are shown.
    //            If any number != 0 is given, it is interpreted as distance
    //            between the ticks.
    //   'ticks_x': Control display of ticks on x-axis only
    //   'ticks_y': Control display of ticks on y-axis only
    //   'format_x': Format of the values next to the ticks of the x-axis
    //               (see tuple_string for more details).
    //   'format_y': Format of the values next to the ticks of the y-axis
    //               (see tuple_string for more details).
    //   'grid': Control display of grid lines within the coordinate system
    //           If 'min_max_origin' is given (default), grid lines are shown
    //           at the minimum and maximum values of the axes.
    //           If 'none' is given, no grid lines are shown.
    //           If any number != 0 is given, it is interpreted as distance
    //           between the grid lines.
    //   'grid_x': Control display of grid lines for the x-axis only
    //   'grid_y': Control display of grid lines for the y-axis only
    //   'grid_color': Color of the grid (default: 'dim gray')
    //   'margin': The distance in pixels of the coordinate system area
    //             to all four window borders.
    //   'margin_left': The distance in pixels of the coordinate system area
    //                  to the left window border.
    //   'margin_right': The distance in pixels of the coordinate system area
    //                   to the right window border.
    //   'margin_top': The distance in pixels of the coordinate system area
    //                 to the upper window border.
    //   'margin_bottom': The distance in pixels of the coordinate system area
    //                    to the lower window border.
    //   'start_x': Lowest x value of the x-axis
    //              Default: min(XValues)
    //   'end_x': Highest x value of the x-axis
    //            Default: max(XValues)
    //   'start_y': Lowest y value of the y-axis
    //              Default: min(YValues)
    //   'end_y': Highest y value of the y-axis
    //            Default: max(YValues)
    //   'axis_location_x': Either 'bottom', 'origin', or 'top'
    //               to position the x-axis conveniently,
    //               or the Y coordinate of the intercept point of x- and y-axis.
    //               Default: 'bottom'
    //               (Used to be called 'origin_y')
    //   'axis_location_y': Either 'left', 'origin', or 'right'
    //               to position the y-axis conveniently,
    //               or the X coordinate of the intercept point of x- and y-axis.
    //               Default: 'left'
    //               (Used to be called 'origin_x')
    //
    //GenParamValue: Values of the generic parameters of GenericParamName
    //
    //
    hv_XValues.Dispose();hv_YValues.Dispose();
    HOperatorSet.Funct1dToPairs(hv_Function, out hv_XValues, out hv_YValues);
    plot_tuple(hv_WindowHandle, hv_XValues, hv_YValues, hv_XLabel, hv_YLabel, hv_Color, 
        hv_GenParamName, hv_GenParamValue);

    hv_XValues.Dispose();
    hv_YValues.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description:  This procedure plots tuples representing functions or curves in a coordinate system. 
  public void plot_tuple (HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues, 
      HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName, 
      HTuple hv_GenParamValue)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ContourXGrid=null, ho_ContourYGrid=null;
    HObject ho_XArrow=null, ho_YArrow=null, ho_ContourXTick=null;
    HObject ho_ContourYTick=null, ho_Contour=null, ho_Cross=null;
    HObject ho_Filled=null, ho_Stair=null, ho_StairTmp=null;

    // Local control variables 

    HTuple hv_PreviousWindowHandle = new HTuple();
    HTuple hv_ClipRegion = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_PartRow1 = new HTuple();
    HTuple hv_PartColumn1 = new HTuple(), hv_PartRow2 = new HTuple();
    HTuple hv_PartColumn2 = new HTuple(), hv_Red = new HTuple();
    HTuple hv_Green = new HTuple(), hv_Blue = new HTuple();
    HTuple hv_DrawMode = new HTuple(), hv_OriginStyle = new HTuple();
    HTuple hv_XAxisEndValue = new HTuple(), hv_YAxisEndValue = new HTuple();
    HTuple hv_XAxisStartValue = new HTuple(), hv_YAxisStartValue = new HTuple();
    HTuple hv_XValuesAreStrings = new HTuple(), hv_XTickValues = new HTuple();
    HTuple hv_XTicks = new HTuple(), hv_YAxisPosition = new HTuple();
    HTuple hv_XAxisPosition = new HTuple(), hv_LeftBorder = new HTuple();
    HTuple hv_RightBorder = new HTuple(), hv_UpperBorder = new HTuple();
    HTuple hv_LowerBorder = new HTuple(), hv_AxesColor = new HTuple();
    HTuple hv_Style = new HTuple(), hv_Clip = new HTuple();
    HTuple hv_YTicks = new HTuple(), hv_XGrid = new HTuple();
    HTuple hv_YGrid = new HTuple(), hv_GridColor = new HTuple();
    HTuple hv_YPosition = new HTuple(), hv_FormatX = new HTuple();
    HTuple hv_FormatY = new HTuple(), hv_NumGenParamNames = new HTuple();
    HTuple hv_NumGenParamValues = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_XGridTicks = new HTuple(), hv_YTickDirection = new HTuple();
    HTuple hv_XTickDirection = new HTuple(), hv_XAxisWidthPx = new HTuple();
    HTuple hv_XAxisWidth = new HTuple(), hv_XScaleFactor = new HTuple();
    HTuple hv_YAxisHeightPx = new HTuple(), hv_YAxisHeight = new HTuple();
    HTuple hv_YScaleFactor = new HTuple(), hv_YAxisOffsetPx = new HTuple();
    HTuple hv_XAxisOffsetPx = new HTuple(), hv_DotStyle = new HTuple();
    HTuple hv_XGridValues = new HTuple(), hv_XGridStart = new HTuple();
    HTuple hv_XCoord = new HTuple(), hv_IndexGrid = new HTuple();
    HTuple hv_YGridValues = new HTuple(), hv_YGridStart = new HTuple();
    HTuple hv_YCoord = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_TextWidthXLabel = new HTuple();
    HTuple hv_TextHeightXLabel = new HTuple(), hv_TextWidthYLabel = new HTuple();
    HTuple hv_TextHeightYLabel = new HTuple(), hv_XTickStart = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_TypeTicks = new HTuple();
    HTuple hv_IndexTicks = new HTuple(), hv_Ascent1 = new HTuple();
    HTuple hv_Descent1 = new HTuple(), hv_TextWidthXTicks = new HTuple();
    HTuple hv_TextHeightXTicks = new HTuple(), hv_YTickValues = new HTuple();
    HTuple hv_YTickStart = new HTuple(), hv_TextWidthYTicks = new HTuple();
    HTuple hv_TextHeightYTicks = new HTuple(), hv_Num = new HTuple();
    HTuple hv_I = new HTuple(), hv_YSelected = new HTuple();
    HTuple hv_Y1Selected = new HTuple(), hv_X1Selected = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Row1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Col1 = new HTuple();
    HTuple hv_Col2 = new HTuple();
    HTuple   hv_XValues_COPY_INP_TMP = new HTuple(hv_XValues);
    HTuple   hv_YValues_COPY_INP_TMP = new HTuple(hv_YValues);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ContourXGrid);
    HOperatorSet.GenEmptyObj(out ho_ContourYGrid);
    HOperatorSet.GenEmptyObj(out ho_XArrow);
    HOperatorSet.GenEmptyObj(out ho_YArrow);
    HOperatorSet.GenEmptyObj(out ho_ContourXTick);
    HOperatorSet.GenEmptyObj(out ho_ContourYTick);
    HOperatorSet.GenEmptyObj(out ho_Contour);
    HOperatorSet.GenEmptyObj(out ho_Cross);
    HOperatorSet.GenEmptyObj(out ho_Filled);
    HOperatorSet.GenEmptyObj(out ho_Stair);
    HOperatorSet.GenEmptyObj(out ho_StairTmp);
    //This procedure plots tuples representing functions
    //or curves in a coordinate system.
    //
    //Input parameters:
    //
    //XValues: X values of the function to be plotted
    //         If XValues is set to [], it is internally set to 0,1,2,...,|YValues|-1.
    //         If XValues is a tuple of strings, the values are taken as categories.
    //
    //YValues: Y values of the function(s) to be plotted
    //         If YValues is set to [], it is internally set to 0,1,2,...,|XValues|-1.
    //         The number of y values must be equal to the number of x values
    //         or an integral multiple. In the latter case,
    //         multiple functions are plotted, that share the same x values.
    //
    //XLabel: X-axis label
    //
    //XLabel: Y-axis label
    //
    //Color: Color of the plotted function
    //       If [] is given, the currently set display color is used.
    //       If 'none is given, the function is not plotted, but only
    //       the coordinate axes as specified.
    //       If more than one color is given, multiple functions
    //       can be displayed in different colors.
    //
    //GenParamName:  Generic parameters to control the presentation
    //               Possible Values:
    //   'axes_color': coordinate system color
    //                 Default: 'white'
    //                 If 'none' is given, no coordinate system is shown.
    //   'style': Graph style
    //            Possible values: 'line' (default), 'cross', 'step', 'filled'
    //   'clip': Clip graph to coordinate system area
    //           Possible values: 'yes', 'no' (default)
    //   'ticks': Control display of ticks on the axes
    //            If 'min_max_origin' is given (default), ticks are shown
    //            at the minimum and maximum values of the axes and at the
    //            intercept point of x- and y-axis.
    //            If 'none' is given, no ticks are shown.
    //            If any number != 0 is given, it is interpreted as distance
    //            between the ticks.
    //   'ticks_x': Control display of ticks on x-axis only
    //   'ticks_y': Control display of ticks on y-axis only
    //   'format_x': Format of the values next to the ticks of the x-axis
    //               (see tuple_string for more details).
    //   'format_y': Format of the values next to the ticks of the y-axis
    //               (see tuple_string for more details).
    //   'grid': Control display of grid lines within the coordinate system
    //           If 'min_max_origin' is given (default), grid lines are shown
    //           at the minimum and maximum values of the axes.
    //           If 'none' is given, no grid lines are shown.
    //           If any number != 0 is given, it is interpreted as distance
    //           between the grid lines.
    //   'grid_x': Control display of grid lines for the x-axis only
    //   'grid_y': Control display of grid lines for the y-axis only
    //   'grid_color': Color of the grid (default: 'dim gray')
    //   'margin': The distance in pixels of the coordinate system area
    //             to all four window borders.
    //   'margin_left': The distance in pixels of the coordinate system area
    //                  to the left window border.
    //   'margin_right': The distance in pixels of the coordinate system area
    //                   to the right window border.
    //   'margin_top': The distance in pixels of the coordinate system area
    //                 to the upper window border.
    //   'margin_bottom': The distance in pixels of the coordinate system area
    //                    to the lower window border.
    //   'start_x': Lowest x value of the x-axis
    //              Default: min(XValues)
    //   'end_x': Highest x value of the x-axis
    //            Default: max(XValues)
    //   'start_y': Lowest y value of the y-axis
    //              Default: min(YValues)
    //   'end_y': Highest y value of the y-axis
    //            Default: max(YValues)
    //   'axis_location_x': Either 'bottom', 'origin', or 'top'
    //               to position the x-axis conveniently,
    //               or the Y coordinate of the intercept point of x- and y-axis.
    //               Default: 'bottom'
    //               (Used to be called 'origin_y')
    //   'axis_location_y': Either 'left', 'origin', or 'right'
    //               to position the y-axis conveniently,
    //               or the X coordinate of the intercept point of x- and y-axis.
    //               Default: 'left'
    //               (Used to be called 'origin_x')
    //
    //GenParamValue: Values of the generic parameters of GenericParamName
    //
    //
    //Store current display settings
    if (HDevWindowStack.IsOpen())
    {
      hv_PreviousWindowHandle = HDevWindowStack.GetActive();
    }
    HDevWindowStack.SetActive(hv_WindowHandle);
    hv_ClipRegion.Dispose();
    HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
    hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width, 
        out hv_Height);
    hv_PartRow1.Dispose();hv_PartColumn1.Dispose();hv_PartRow2.Dispose();hv_PartColumn2.Dispose();
    HOperatorSet.GetPart(hv_WindowHandle, out hv_PartRow1, out hv_PartColumn1, out hv_PartRow2, 
        out hv_PartColumn2);
    hv_Red.Dispose();hv_Green.Dispose();hv_Blue.Dispose();
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    hv_DrawMode.Dispose();
    HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
    hv_OriginStyle.Dispose();
    HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_OriginStyle);
    //
    //Set display parameters
    HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
    HOperatorSet.SetSystem("clip_region", "false");
    if (HDevWindowStack.IsOpen())
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height-1, hv_Width-1);
      }
    }
    //
    //Check input coordinates
    //
    if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleAnd(
        new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
    {
      //Neither XValues nor YValues are given:
      //Set axes to interval [0,1]
      hv_XAxisEndValue.Dispose();
      hv_XAxisEndValue = 1;
      hv_YAxisEndValue.Dispose();
      hv_YAxisEndValue = 1;
      hv_XAxisStartValue.Dispose();
      hv_XAxisStartValue = 0;
      hv_YAxisStartValue.Dispose();
      hv_YAxisStartValue = 0;
      hv_XValuesAreStrings.Dispose();
      hv_XValuesAreStrings = 0;
    }
    else
    {
      if ((int)(new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
      {
        //XValues are omitted:
        //Set equidistant XValues
        hv_XValues_COPY_INP_TMP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XValues_COPY_INP_TMP = HTuple.TupleGenSequence(
            0,(new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()))-1,1);
        }
        hv_XValuesAreStrings.Dispose();
        hv_XValuesAreStrings = 0;
      }
      else if ((int)(new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
      {
        //YValues are omitted:
        //Set equidistant YValues
        hv_YValues_COPY_INP_TMP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YValues_COPY_INP_TMP = HTuple.TupleGenSequence(
            0,(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()))-1,1);
        }
      }
      if ((int)(new HTuple((new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
          ))%(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())))).TupleNotEqual(
          0))) != 0)
      {
        //Number of YValues does not match number of XValues
        throw new HalconException("Number of YValues is no multiple of the number of XValues!");
        ho_ContourXGrid.Dispose();
        ho_ContourYGrid.Dispose();
        ho_XArrow.Dispose();
        ho_YArrow.Dispose();
        ho_ContourXTick.Dispose();
        ho_ContourYTick.Dispose();
        ho_Contour.Dispose();
        ho_Cross.Dispose();
        ho_Filled.Dispose();
        ho_Stair.Dispose();
        ho_StairTmp.Dispose();

        hv_XValues_COPY_INP_TMP.Dispose();
        hv_YValues_COPY_INP_TMP.Dispose();
        hv_PreviousWindowHandle.Dispose();
        hv_ClipRegion.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_PartRow1.Dispose();
        hv_PartColumn1.Dispose();
        hv_PartRow2.Dispose();
        hv_PartColumn2.Dispose();
        hv_Red.Dispose();
        hv_Green.Dispose();
        hv_Blue.Dispose();
        hv_DrawMode.Dispose();
        hv_OriginStyle.Dispose();
        hv_XAxisEndValue.Dispose();
        hv_YAxisEndValue.Dispose();
        hv_XAxisStartValue.Dispose();
        hv_YAxisStartValue.Dispose();
        hv_XValuesAreStrings.Dispose();
        hv_XTickValues.Dispose();
        hv_XTicks.Dispose();
        hv_YAxisPosition.Dispose();
        hv_XAxisPosition.Dispose();
        hv_LeftBorder.Dispose();
        hv_RightBorder.Dispose();
        hv_UpperBorder.Dispose();
        hv_LowerBorder.Dispose();
        hv_AxesColor.Dispose();
        hv_Style.Dispose();
        hv_Clip.Dispose();
        hv_YTicks.Dispose();
        hv_XGrid.Dispose();
        hv_YGrid.Dispose();
        hv_GridColor.Dispose();
        hv_YPosition.Dispose();
        hv_FormatX.Dispose();
        hv_FormatY.Dispose();
        hv_NumGenParamNames.Dispose();
        hv_NumGenParamValues.Dispose();
        hv_GenParamIndex.Dispose();
        hv_XGridTicks.Dispose();
        hv_YTickDirection.Dispose();
        hv_XTickDirection.Dispose();
        hv_XAxisWidthPx.Dispose();
        hv_XAxisWidth.Dispose();
        hv_XScaleFactor.Dispose();
        hv_YAxisHeightPx.Dispose();
        hv_YAxisHeight.Dispose();
        hv_YScaleFactor.Dispose();
        hv_YAxisOffsetPx.Dispose();
        hv_XAxisOffsetPx.Dispose();
        hv_DotStyle.Dispose();
        hv_XGridValues.Dispose();
        hv_XGridStart.Dispose();
        hv_XCoord.Dispose();
        hv_IndexGrid.Dispose();
        hv_YGridValues.Dispose();
        hv_YGridStart.Dispose();
        hv_YCoord.Dispose();
        hv_Ascent.Dispose();
        hv_Descent.Dispose();
        hv_TextWidthXLabel.Dispose();
        hv_TextHeightXLabel.Dispose();
        hv_TextWidthYLabel.Dispose();
        hv_TextHeightYLabel.Dispose();
        hv_XTickStart.Dispose();
        hv_Indices.Dispose();
        hv_TypeTicks.Dispose();
        hv_IndexTicks.Dispose();
        hv_Ascent1.Dispose();
        hv_Descent1.Dispose();
        hv_TextWidthXTicks.Dispose();
        hv_TextHeightXTicks.Dispose();
        hv_YTickValues.Dispose();
        hv_YTickStart.Dispose();
        hv_TextWidthYTicks.Dispose();
        hv_TextHeightYTicks.Dispose();
        hv_Num.Dispose();
        hv_I.Dispose();
        hv_YSelected.Dispose();
        hv_Y1Selected.Dispose();
        hv_X1Selected.Dispose();
        hv_Index.Dispose();
        hv_Row1.Dispose();
        hv_Row2.Dispose();
        hv_Col1.Dispose();
        hv_Col2.Dispose();

        return;
      }
      hv_XValuesAreStrings.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_XValuesAreStrings = hv_XValues_COPY_INP_TMP.TupleIsStringElem()
          ;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_XValuesAreStrings = new HTuple(((hv_XValuesAreStrings.TupleSum()
          )).TupleEqual(new HTuple(hv_XValuesAreStrings.TupleLength())));
      hv_XValuesAreStrings.Dispose();
      hv_XValuesAreStrings = ExpTmpLocalVar_XValuesAreStrings;
      }
      }
      if ((int)(hv_XValuesAreStrings) != 0)
      {
        //XValues are given as strings:
        //Show XValues as ticks
        hv_XTickValues.Dispose();
        hv_XTickValues = new HTuple(hv_XValues_COPY_INP_TMP);
        hv_XTicks.Dispose();
        hv_XTicks = 1;
        //Set x-axis dimensions
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_XValues = HTuple.TupleGenSequence(
            1,new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()),1);
        hv_XValues_COPY_INP_TMP.Dispose();
        hv_XValues_COPY_INP_TMP = ExpTmpLocalVar_XValues;
        }
        }
      }
      //Set default x-axis dimensions
      if ((int)(new HTuple((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())).TupleGreater(
          1))) != 0)
      {
        hv_XAxisStartValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisStartValue = hv_XValues_COPY_INP_TMP.TupleMin()
            ;
        }
        hv_XAxisEndValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisEndValue = hv_XValues_COPY_INP_TMP.TupleMax()
            ;
        }
      }
      else
      {
        hv_XAxisEndValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisEndValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
            0))+0.5;
        }
        hv_XAxisStartValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisStartValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
            0))-0.5;
        }
      }
    }
    //Set default y-axis dimensions
    if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())).TupleGreater(
        1))) != 0)
    {
      hv_YAxisStartValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisStartValue = hv_YValues_COPY_INP_TMP.TupleMin()
          ;
      }
      hv_YAxisEndValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisEndValue = hv_YValues_COPY_INP_TMP.TupleMax()
          ;
      }
    }
    else if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
        )).TupleEqual(1))) != 0)
    {
      hv_YAxisStartValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisStartValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
          0))-0.5;
      }
      hv_YAxisEndValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisEndValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
          0))+0.5;
      }
    }
    else
    {
      hv_YAxisStartValue.Dispose();
      hv_YAxisStartValue = 0;
      hv_YAxisEndValue.Dispose();
      hv_YAxisEndValue = 1;
    }
    //Set default interception point of x- and y- axis
    hv_YAxisPosition.Dispose();
    hv_YAxisPosition = "default";
    hv_XAxisPosition.Dispose();
    hv_XAxisPosition = "default";
    //
    //Set more defaults
    hv_LeftBorder.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_LeftBorder = hv_Width*0.1;
    }
    hv_RightBorder.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RightBorder = hv_Width*0.1;
    }
    hv_UpperBorder.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_UpperBorder = hv_Height*0.1;
    }
    hv_LowerBorder.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_LowerBorder = hv_Height*0.1;
    }
    hv_AxesColor.Dispose();
    hv_AxesColor = "white";
    hv_Style.Dispose();
    hv_Style = "line";
    hv_Clip.Dispose();
    hv_Clip = "no";
    hv_XTicks.Dispose();
    hv_XTicks = "min_max_origin";
    hv_YTicks.Dispose();
    hv_YTicks = "min_max_origin";
    hv_XGrid.Dispose();
    hv_XGrid = "none";
    hv_YGrid.Dispose();
    hv_YGrid = "none";
    hv_GridColor.Dispose();
    hv_GridColor = "dim gray";
    hv_YPosition.Dispose();
    hv_YPosition = "left";
    hv_FormatX.Dispose();
    hv_FormatX = "default";
    hv_FormatY.Dispose();
    hv_FormatY = "default";
    //
    //Parse generic parameters
    //
    hv_NumGenParamNames.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumGenParamNames = new HTuple(hv_GenParamName.TupleLength()
        );
    }
    hv_NumGenParamValues.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumGenParamValues = new HTuple(hv_GenParamValue.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumGenParamNames.TupleNotEqual(hv_NumGenParamValues))) != 0)
    {
      throw new HalconException("Number of generic parameter names does not match generic parameter values!");
      ho_ContourXGrid.Dispose();
      ho_ContourYGrid.Dispose();
      ho_XArrow.Dispose();
      ho_YArrow.Dispose();
      ho_ContourXTick.Dispose();
      ho_ContourYTick.Dispose();
      ho_Contour.Dispose();
      ho_Cross.Dispose();
      ho_Filled.Dispose();
      ho_Stair.Dispose();
      ho_StairTmp.Dispose();

      hv_XValues_COPY_INP_TMP.Dispose();
      hv_YValues_COPY_INP_TMP.Dispose();
      hv_PreviousWindowHandle.Dispose();
      hv_ClipRegion.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_PartRow1.Dispose();
      hv_PartColumn1.Dispose();
      hv_PartRow2.Dispose();
      hv_PartColumn2.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_DrawMode.Dispose();
      hv_OriginStyle.Dispose();
      hv_XAxisEndValue.Dispose();
      hv_YAxisEndValue.Dispose();
      hv_XAxisStartValue.Dispose();
      hv_YAxisStartValue.Dispose();
      hv_XValuesAreStrings.Dispose();
      hv_XTickValues.Dispose();
      hv_XTicks.Dispose();
      hv_YAxisPosition.Dispose();
      hv_XAxisPosition.Dispose();
      hv_LeftBorder.Dispose();
      hv_RightBorder.Dispose();
      hv_UpperBorder.Dispose();
      hv_LowerBorder.Dispose();
      hv_AxesColor.Dispose();
      hv_Style.Dispose();
      hv_Clip.Dispose();
      hv_YTicks.Dispose();
      hv_XGrid.Dispose();
      hv_YGrid.Dispose();
      hv_GridColor.Dispose();
      hv_YPosition.Dispose();
      hv_FormatX.Dispose();
      hv_FormatY.Dispose();
      hv_NumGenParamNames.Dispose();
      hv_NumGenParamValues.Dispose();
      hv_GenParamIndex.Dispose();
      hv_XGridTicks.Dispose();
      hv_YTickDirection.Dispose();
      hv_XTickDirection.Dispose();
      hv_XAxisWidthPx.Dispose();
      hv_XAxisWidth.Dispose();
      hv_XScaleFactor.Dispose();
      hv_YAxisHeightPx.Dispose();
      hv_YAxisHeight.Dispose();
      hv_YScaleFactor.Dispose();
      hv_YAxisOffsetPx.Dispose();
      hv_XAxisOffsetPx.Dispose();
      hv_DotStyle.Dispose();
      hv_XGridValues.Dispose();
      hv_XGridStart.Dispose();
      hv_XCoord.Dispose();
      hv_IndexGrid.Dispose();
      hv_YGridValues.Dispose();
      hv_YGridStart.Dispose();
      hv_YCoord.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv_TextWidthXLabel.Dispose();
      hv_TextHeightXLabel.Dispose();
      hv_TextWidthYLabel.Dispose();
      hv_TextHeightYLabel.Dispose();
      hv_XTickStart.Dispose();
      hv_Indices.Dispose();
      hv_TypeTicks.Dispose();
      hv_IndexTicks.Dispose();
      hv_Ascent1.Dispose();
      hv_Descent1.Dispose();
      hv_TextWidthXTicks.Dispose();
      hv_TextHeightXTicks.Dispose();
      hv_YTickValues.Dispose();
      hv_YTickStart.Dispose();
      hv_TextWidthYTicks.Dispose();
      hv_TextHeightYTicks.Dispose();
      hv_Num.Dispose();
      hv_I.Dispose();
      hv_YSelected.Dispose();
      hv_Y1Selected.Dispose();
      hv_X1Selected.Dispose();
      hv_Index.Dispose();
      hv_Row1.Dispose();
      hv_Row2.Dispose();
      hv_Col1.Dispose();
      hv_Col2.Dispose();

      return;
    }
    //
    for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
        ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
    {
      //
      //Set 'axes_color'
      if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "axes_color"))) != 0)
      {
        hv_AxesColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AxesColor = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'style'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "style"))) != 0)
      {
        hv_Style.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Style = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'clip'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "clip"))) != 0)
      {
        hv_Clip.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Clip = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        if ((int)((new HTuple(hv_Clip.TupleNotEqual("yes"))).TupleAnd(new HTuple(hv_Clip.TupleNotEqual(
            "no")))) != 0)
        {
          throw new HalconException(("Unsupported clipping option: '"+hv_Clip)+"'");
        }
        //
        //Set 'ticks'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "ticks"))) != 0)
      {
        hv_XTicks.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XTicks = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_YTicks.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YTicks = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'ticks_x'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "ticks_x"))) != 0)
      {
        hv_XTicks.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XTicks = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'ticks_y'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "ticks_y"))) != 0)
      {
        hv_YTicks.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YTicks = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'grid'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "grid"))) != 0)
      {
        hv_XGrid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XGrid = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_YGrid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YGrid = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_XGridTicks.Dispose();
        hv_XGridTicks = new HTuple(hv_XTicks);
        //
        //Set 'grid_x'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "grid_x"))) != 0)
      {
        hv_XGrid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XGrid = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'grid_y'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "grid_y"))) != 0)
      {
        hv_YGrid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YGrid = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'grid_color'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "grid_color"))) != 0)
      {
        hv_GridColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GridColor = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'start_x'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "start_x"))) != 0)
      {
        hv_XAxisStartValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisStartValue = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'end_x'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "end_x"))) != 0)
      {
        hv_XAxisEndValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisEndValue = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'start_y'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "start_y"))) != 0)
      {
        hv_YAxisStartValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YAxisStartValue = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'end_y'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "end_y"))) != 0)
      {
        hv_YAxisEndValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YAxisEndValue = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'axis_location_y' (old name 'origin_x')
      }
      else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "axis_location_y"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "origin_x")))) != 0)
      {
        hv_YAxisPosition.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YAxisPosition = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'axis_location_x' (old name: 'origin_y')
      }
      else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "axis_location_x"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "origin_y")))) != 0)
      {
        hv_XAxisPosition.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisPosition = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'margin'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "margin"))) != 0)
      {
        hv_LeftBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LeftBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_RightBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RightBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_UpperBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_UpperBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_LowerBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LowerBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'margin_left'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "margin_left"))) != 0)
      {
        hv_LeftBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LeftBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'margin_right'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "margin_right"))) != 0)
      {
        hv_RightBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RightBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'margin_top'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "margin_top"))) != 0)
      {
        hv_UpperBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_UpperBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'margin_bottom'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "margin_bottom"))) != 0)
      {
        hv_LowerBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LowerBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "format_x"))) != 0)
      {
        hv_FormatX.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FormatX = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "format_y"))) != 0)
      {
        hv_FormatY.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FormatY = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else
      {
        throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
            hv_GenParamIndex)))+"'");
      }
    }
    //
    //Check consistency of start and end values
    //of the axes.
    if ((int)(new HTuple(hv_XAxisStartValue.TupleGreater(hv_XAxisEndValue))) != 0)
    {
      throw new HalconException("Value for 'start_x' is greater than value for 'end_x'");
    }
    if ((int)(new HTuple(hv_YAxisStartValue.TupleGreater(hv_YAxisEndValue))) != 0)
    {
      throw new HalconException("Value for 'start_y' is greater than value for 'end_y'");
    }
    //
    //Set the position of the y-axis.
    if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("default"))) != 0)
    {
      hv_YAxisPosition.Dispose();
      hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
    }
    if ((int)(new HTuple(((hv_YAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
    {
      if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("left"))) != 0)
      {
        hv_YAxisPosition.Dispose();
        hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
      }
      else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("right"))) != 0)
      {
        hv_YAxisPosition.Dispose();
        hv_YAxisPosition = new HTuple(hv_XAxisEndValue);
      }
      else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("origin"))) != 0)
      {
        hv_YAxisPosition.Dispose();
        hv_YAxisPosition = 0;
      }
      else
      {
        throw new HalconException(("Unsupported axis_location_y: '"+hv_YAxisPosition)+"'");
      }
    }
    //Set the position of the ticks on the y-axis
    //depending of the location of the y-axis.
    if ((int)(new HTuple((new HTuple(((hv_XAxisStartValue.TupleConcat(hv_XAxisEndValue))).TupleMean()
        )).TupleGreater(hv_YAxisPosition))) != 0)
    {
      hv_YTickDirection.Dispose();
      hv_YTickDirection = "right";
    }
    else
    {
      hv_YTickDirection.Dispose();
      hv_YTickDirection = "left";
    }
    //
    //Set the position of the x-axis.
    if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("default"))) != 0)
    {
      hv_XAxisPosition.Dispose();
      hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
    }
    if ((int)(new HTuple(((hv_XAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
    {
      if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("bottom"))) != 0)
      {
        hv_XAxisPosition.Dispose();
        hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
      }
      else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("top"))) != 0)
      {
        hv_XAxisPosition.Dispose();
        hv_XAxisPosition = new HTuple(hv_YAxisEndValue);
      }
      else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("origin"))) != 0)
      {
        hv_XAxisPosition.Dispose();
        hv_XAxisPosition = 0;
      }
      else
      {
        throw new HalconException(("Unsupported axis_location_x: '"+hv_XAxisPosition)+"'");
      }
    }
    //Set the position of the ticks on the y-axis
    //depending of the location of the y-axis.
    if ((int)(new HTuple((new HTuple(((hv_YAxisStartValue.TupleConcat(hv_YAxisEndValue))).TupleMean()
        )).TupleGreater(hv_XAxisPosition))) != 0)
    {
      hv_XTickDirection.Dispose();
      hv_XTickDirection = "up";
    }
    else
    {
      hv_XTickDirection.Dispose();
      hv_XTickDirection = "down";
    }
    //
    //Calculate basic pixel coordinates and scale factors
    //
    hv_XAxisWidthPx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XAxisWidthPx = (hv_Width-hv_LeftBorder)-hv_RightBorder;
    }
    hv_XAxisWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XAxisWidth = hv_XAxisEndValue-hv_XAxisStartValue;
    }
    if ((int)(new HTuple(hv_XAxisWidth.TupleEqual(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_XAxisStartValue = hv_XAxisStartValue-0.5;
      hv_XAxisStartValue.Dispose();
      hv_XAxisStartValue = ExpTmpLocalVar_XAxisStartValue;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_XAxisEndValue = hv_XAxisEndValue+0.5;
      hv_XAxisEndValue.Dispose();
      hv_XAxisEndValue = ExpTmpLocalVar_XAxisEndValue;
      }
      }
      hv_XAxisWidth.Dispose();
      hv_XAxisWidth = 1;
    }
    hv_XScaleFactor.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XScaleFactor = hv_XAxisWidthPx/(hv_XAxisWidth.TupleReal()
        );
    }
    hv_YAxisHeightPx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YAxisHeightPx = (hv_Height-hv_LowerBorder)-hv_UpperBorder;
    }
    hv_YAxisHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YAxisHeight = hv_YAxisEndValue-hv_YAxisStartValue;
    }
    if ((int)(new HTuple(hv_YAxisHeight.TupleEqual(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_YAxisStartValue = hv_YAxisStartValue-0.5;
      hv_YAxisStartValue.Dispose();
      hv_YAxisStartValue = ExpTmpLocalVar_YAxisStartValue;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_YAxisEndValue = hv_YAxisEndValue+0.5;
      hv_YAxisEndValue.Dispose();
      hv_YAxisEndValue = ExpTmpLocalVar_YAxisEndValue;
      }
      }
      hv_YAxisHeight.Dispose();
      hv_YAxisHeight = 1;
    }
    hv_YScaleFactor.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YScaleFactor = hv_YAxisHeightPx/(hv_YAxisHeight.TupleReal()
        );
    }
    hv_YAxisOffsetPx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YAxisOffsetPx = (hv_YAxisPosition-hv_XAxisStartValue)*hv_XScaleFactor;
    }
    hv_XAxisOffsetPx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XAxisOffsetPx = (hv_XAxisPosition-hv_YAxisStartValue)*hv_YScaleFactor;
    }
    //
    //Display grid lines
    //
    if ((int)(new HTuple(hv_GridColor.TupleNotEqual("none"))) != 0)
    {
      hv_DotStyle.Dispose();
      hv_DotStyle = new HTuple();
      hv_DotStyle[0] = 5;
      hv_DotStyle[1] = 7;
      HOperatorSet.SetLineStyle(hv_WindowHandle, hv_DotStyle);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GridColor);
      }
      //
      //Display x grid lines
      if ((int)(new HTuple(hv_XGrid.TupleNotEqual("none"))) != 0)
      {
        if ((int)(new HTuple(hv_XGrid.TupleEqual("min_max_origin"))) != 0)
        {
          //Calculate 'min_max_origin' grid line coordinates
          if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
          {
            hv_XGridValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XGridValues = new HTuple();
            hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
            }
          }
          else
          {
            hv_XGridValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XGridValues = new HTuple();
            hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
            }
          }
        }
        else
        {
          //Calculate equidistant grid line coordinates
          hv_XGridStart.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XGridStart = (((hv_XAxisStartValue/hv_XGrid)).TupleCeil()
              )*hv_XGrid;
          }
          hv_XGridValues.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XGridValues = HTuple.TupleGenSequence(
              hv_XGridStart,hv_XAxisEndValue,hv_XGrid);
          }
        }
        hv_XCoord.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XCoord = (hv_XGridValues-hv_XAxisStartValue)*hv_XScaleFactor;
        }
        //Generate and display grid lines
        for (hv_IndexGrid=0; (int)hv_IndexGrid<=(int)((new HTuple(hv_XGridValues.TupleLength()
            ))-1); hv_IndexGrid = (int)hv_IndexGrid + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ContourXGrid.Dispose();
          HOperatorSet.GenContourPolygonXld(out ho_ContourXGrid, ((hv_Height-hv_LowerBorder)).TupleConcat(
              hv_UpperBorder), ((hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexGrid)))).TupleConcat(
              hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexGrid))));
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ContourXGrid, HDevWindowStack.GetActive());
          }
        }
      }
      //
      //Display y grid lines
      if ((int)(new HTuple(hv_YGrid.TupleNotEqual("none"))) != 0)
      {
        if ((int)(new HTuple(hv_YGrid.TupleEqual("min_max_origin"))) != 0)
        {
          //Calculate 'min_max_origin' grid line coordinates
          if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
          {
            hv_YGridValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YGridValues = new HTuple();
            hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
            }
          }
          else
          {
            hv_YGridValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YGridValues = new HTuple();
            hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
            }
          }
        }
        else
        {
          //Calculate equidistant grid line coordinates
          hv_YGridStart.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YGridStart = (((hv_YAxisStartValue/hv_YGrid)).TupleCeil()
              )*hv_YGrid;
          }
          hv_YGridValues.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YGridValues = HTuple.TupleGenSequence(
              hv_YGridStart,hv_YAxisEndValue,hv_YGrid);
          }
        }
        hv_YCoord.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YCoord = (hv_YGridValues-hv_YAxisStartValue)*hv_YScaleFactor;
        }
        //Generate and display grid lines
        for (hv_IndexGrid=0; (int)hv_IndexGrid<=(int)((new HTuple(hv_YGridValues.TupleLength()
            ))-1); hv_IndexGrid = (int)hv_IndexGrid + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ContourYGrid.Dispose();
          HOperatorSet.GenContourPolygonXld(out ho_ContourYGrid, (((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
              hv_IndexGrid)))).TupleConcat((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
              hv_IndexGrid))), hv_LeftBorder.TupleConcat(hv_Width-hv_RightBorder));
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ContourYGrid, HDevWindowStack.GetActive());
          }
        }
      }
    }
    HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
    //
    //
    //Display the coordinate system axes
    if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
    {
      //Display axes
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_XArrow.Dispose();
      gen_arrow_contour_xld(out ho_XArrow, (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx, 
          hv_LeftBorder, (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx, hv_Width-hv_RightBorder, 
          0, 0);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_XArrow, HDevWindowStack.GetActive());
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_YArrow.Dispose();
      gen_arrow_contour_xld(out ho_YArrow, hv_Height-hv_LowerBorder, hv_LeftBorder+hv_YAxisOffsetPx, 
          hv_UpperBorder, hv_LeftBorder+hv_YAxisOffsetPx, 0, 0);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_YArrow, HDevWindowStack.GetActive());
      }
      //Display labels
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidthXLabel.Dispose();hv_TextHeightXLabel.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XLabel, out hv_Ascent, out hv_Descent, 
          out hv_TextWidthXLabel, out hv_TextHeightXLabel);
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidthYLabel.Dispose();hv_TextHeightYLabel.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YLabel, out hv_Ascent, out hv_Descent, 
          out hv_TextWidthYLabel, out hv_TextHeightYLabel);
      if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
      {
        if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-3, ((hv_Width-hv_RightBorder)-hv_TextWidthXLabel)-3, 
                hv_AxesColor, "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                hv_UpperBorder, (hv_LeftBorder+3)+hv_YAxisOffsetPx, hv_AxesColor, 
                "box", "false");
            }
          }
        }
        else
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                ((hv_Height-hv_LowerBorder)+3)-hv_XAxisOffsetPx, ((hv_Width-hv_RightBorder)-hv_TextWidthXLabel)-3, 
                hv_AxesColor, "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-3, (hv_LeftBorder+3)+hv_YAxisOffsetPx, 
                hv_AxesColor, "box", "false");
            }
          }
        }
      }
      else
      {
        if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                ((hv_Height-hv_LowerBorder)-(2*hv_TextHeightXLabel))+3, hv_LeftBorder-3, 
                hv_AxesColor, "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                hv_UpperBorder, ((hv_Width-hv_RightBorder)-hv_TextWidthYLabel)-13, 
                hv_AxesColor, "box", "false");
            }
          }
        }
        else
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                ((hv_Height-hv_LowerBorder)+3)-hv_XAxisOffsetPx, hv_LeftBorder-3, 
                hv_AxesColor, "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-3, ((hv_Width-hv_RightBorder)-(2*hv_TextWidthYLabel))-3, 
                hv_AxesColor, "box", "false");
            }
          }
        }
      }
    }
    //
    //Display ticks
    //
    if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
    {
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
      }
      if ((int)(new HTuple(hv_XTicks.TupleNotEqual("none"))) != 0)
      {
        //
        //Display x ticks
        if ((int)(hv_XValuesAreStrings) != 0)
        {
          //Display string XValues as categories
          hv_XTicks.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XTicks = (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
              ))/(new HTuple(hv_XTickValues.TupleLength()));
          }
          hv_XCoord.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XCoord = (hv_XValues_COPY_INP_TMP-hv_XAxisStartValue)*hv_XScaleFactor;
          }
        }
        else
        {
          //Display tick values
          if ((int)(new HTuple(hv_XTicks.TupleEqual("min_max_origin"))) != 0)
          {
            //Calculate 'min_max_origin' tick coordinates
            if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
            {
              hv_XTickValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_XTickValues = new HTuple();
              hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
              }
            }
            else
            {
              hv_XTickValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_XTickValues = new HTuple();
              hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
              }
            }
          }
          else
          {
            //Calculate equidistant tick coordinates
            hv_XTickStart.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XTickStart = (((hv_XAxisStartValue/hv_XTicks)).TupleCeil()
                )*hv_XTicks;
            }
            hv_XTickValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XTickValues = HTuple.TupleGenSequence(
                hv_XTickStart,hv_XAxisEndValue,hv_XTicks);
            }
          }
          //Remove ticks that are smaller than the x-axis start.
          hv_Indices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Indices = ((hv_XTickValues.TupleLessElem(
              hv_XAxisStartValue))).TupleFind(1);
          }
          hv_XCoord.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XCoord = (hv_XTickValues-hv_XAxisStartValue)*hv_XScaleFactor;
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_XCoord = hv_XCoord.TupleRemove(
              hv_Indices);
          hv_XCoord.Dispose();
          hv_XCoord = ExpTmpLocalVar_XCoord;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleRemove(
              hv_Indices);
          hv_XTickValues.Dispose();
          hv_XTickValues = ExpTmpLocalVar_XTickValues;
          }
          }
          //
          if ((int)(new HTuple(hv_FormatX.TupleEqual("default"))) != 0)
          {
            hv_TypeTicks.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TypeTicks = hv_XTicks.TupleType()
                ;
            }
            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
            {
              //String ('min_max_origin')
              //Format depends on actual values
              hv_TypeTicks.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TypeTicks = hv_XTickValues.TupleType()
                  ;
              }
            }
            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
            {
              //Round to integer
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleInt()
                  ;
              hv_XTickValues.Dispose();
              hv_XTickValues = ExpTmpLocalVar_XTickValues;
              }
              }
            }
            else
            {
              //Use floating point numbers
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                  ".2f");
              hv_XTickValues.Dispose();
              hv_XTickValues = ExpTmpLocalVar_XTickValues;
              }
              }
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                hv_FormatX);
            hv_XTickValues.Dispose();
            hv_XTickValues = ExpTmpLocalVar_XTickValues;
            }
            }
          }
        }
        //Generate and display ticks
        for (hv_IndexTicks=0; (int)hv_IndexTicks<=(int)((new HTuple(hv_XTickValues.TupleLength()
            ))-1); hv_IndexTicks = (int)hv_IndexTicks + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Ascent1.Dispose();hv_Descent1.Dispose();hv_TextWidthXTicks.Dispose();hv_TextHeightXTicks.Dispose();
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XTickValues.TupleSelect(
              hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthXTicks, 
              out hv_TextHeightXTicks);
          }
          if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ContourXTick.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, (((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)).TupleConcat(
                ((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)-5), ((hv_LeftBorder+(hv_XCoord.TupleSelect(
                hv_IndexTicks)))).TupleConcat(hv_LeftBorder+(hv_XCoord.TupleSelect(
                hv_IndexTicks))));
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                  hv_IndexTicks), "image", ((hv_Height-hv_LowerBorder)+2)-hv_XAxisOffsetPx, 
                  hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexTicks)), hv_AxesColor, 
                  "box", "false");
              }
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ContourXTick.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, ((((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)+5)).TupleConcat(
                (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx), ((hv_LeftBorder+(hv_XCoord.TupleSelect(
                hv_IndexTicks)))).TupleConcat(hv_LeftBorder+(hv_XCoord.TupleSelect(
                hv_IndexTicks))));
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                  hv_IndexTicks), "image", ((hv_Height-hv_LowerBorder)-(2*hv_TextHeightXTicks))-hv_XAxisOffsetPx, 
                  hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexTicks)), hv_AxesColor, 
                  "box", "false");
              }
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ContourXTick, HDevWindowStack.GetActive());
          }
        }
      }
      //
      if ((int)(new HTuple(hv_YTicks.TupleNotEqual("none"))) != 0)
      {
        //
        //Display y ticks
        if ((int)(new HTuple(hv_YTicks.TupleEqual("min_max_origin"))) != 0)
        {
          //Calculate 'min_max_origin' tick coordinates
          if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
          {
            hv_YTickValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YTickValues = new HTuple();
            hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
            }
          }
          else
          {
            hv_YTickValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YTickValues = new HTuple();
            hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
            }
          }
        }
        else
        {
          //Calculate equidistant tick coordinates
          hv_YTickStart.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YTickStart = (((hv_YAxisStartValue/hv_YTicks)).TupleCeil()
              )*hv_YTicks;
          }
          hv_YTickValues.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YTickValues = HTuple.TupleGenSequence(
              hv_YTickStart,hv_YAxisEndValue,hv_YTicks);
          }
        }
        //Remove ticks that are smaller than the y-axis start.
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = ((hv_YTickValues.TupleLessElem(
            hv_YAxisStartValue))).TupleFind(1);
        }
        hv_YCoord.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YCoord = (hv_YTickValues-hv_YAxisStartValue)*hv_YScaleFactor;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_YCoord = hv_YCoord.TupleRemove(
            hv_Indices);
        hv_YCoord.Dispose();
        hv_YCoord = ExpTmpLocalVar_YCoord;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleRemove(
            hv_Indices);
        hv_YTickValues.Dispose();
        hv_YTickValues = ExpTmpLocalVar_YTickValues;
        }
        }
        //
        if ((int)(new HTuple(hv_FormatY.TupleEqual("default"))) != 0)
        {
          hv_TypeTicks.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TypeTicks = hv_YTicks.TupleType()
              ;
          }
          if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
          {
            //String ('min_max_origin')
            //Format depends on actual values
            hv_TypeTicks.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TypeTicks = hv_YTickValues.TupleType()
                ;
            }
          }
          if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
          {
            //Round to integer
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleInt()
                ;
            hv_YTickValues.Dispose();
            hv_YTickValues = ExpTmpLocalVar_YTickValues;
            }
            }
          }
          else
          {
            //Use floating point numbers
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
                ".2f");
            hv_YTickValues.Dispose();
            hv_YTickValues = ExpTmpLocalVar_YTickValues;
            }
            }
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
              hv_FormatY);
          hv_YTickValues.Dispose();
          hv_YTickValues = ExpTmpLocalVar_YTickValues;
          }
          }
        }
        //Generate and display ticks
        for (hv_IndexTicks=0; (int)hv_IndexTicks<=(int)((new HTuple(hv_YTickValues.TupleLength()
            ))-1); hv_IndexTicks = (int)hv_IndexTicks + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Ascent1.Dispose();hv_Descent1.Dispose();hv_TextWidthYTicks.Dispose();hv_TextHeightYTicks.Dispose();
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YTickValues.TupleSelect(
              hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthYTicks, 
              out hv_TextHeightYTicks);
          }
          if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ContourYTick.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                hv_IndexTicks)))).TupleConcat((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                hv_IndexTicks))), ((hv_LeftBorder+hv_YAxisOffsetPx)).TupleConcat(
                (hv_LeftBorder+hv_YAxisOffsetPx)+5));
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                  hv_IndexTicks), "image", (((hv_Height-hv_LowerBorder)-hv_TextHeightYTicks)+3)-(hv_YCoord.TupleSelect(
                  hv_IndexTicks)), ((hv_LeftBorder-hv_TextWidthYTicks)-2)+hv_YAxisOffsetPx, 
                  hv_AxesColor, "box", "false");
              }
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ContourYTick.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                hv_IndexTicks)))).TupleConcat((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                hv_IndexTicks))), (((hv_LeftBorder+hv_YAxisOffsetPx)-5)).TupleConcat(
                hv_LeftBorder+hv_YAxisOffsetPx));
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                  hv_IndexTicks), "image", (((hv_Height-hv_LowerBorder)-hv_TextHeightYTicks)+3)-(hv_YCoord.TupleSelect(
                  hv_IndexTicks)), (hv_LeftBorder+2)+hv_YAxisOffsetPx, hv_AxesColor, 
                  "box", "false");
              }
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ContourYTick, HDevWindowStack.GetActive());
          }
        }
      }
    }
    //
    //Display function plot
    //
    if ((int)(new HTuple(hv_Color.TupleNotEqual("none"))) != 0)
    {
      if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleNotEqual(new HTuple()))).TupleAnd(
          new HTuple(hv_YValues_COPY_INP_TMP.TupleNotEqual(new HTuple())))) != 0)
      {
        hv_Num.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Num = (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
            ))/(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()));
        }
        //
        //Iterate over all functions to be displayed
        HTuple end_val576 = hv_Num-1;
        HTuple step_val576 = 1;
        for (hv_I=0; hv_I.Continue(end_val576, step_val576); hv_I = hv_I.TupleAdd(step_val576))
        {
          //Select y values for current function
          hv_YSelected.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YSelected = hv_YValues_COPY_INP_TMP.TupleSelectRange(
              hv_I*(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())),((hv_I+1)*(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
              )))-1);
          }
          //Set color
          if ((int)(new HTuple(hv_Color.TupleEqual(new HTuple()))) != 0)
          {
            HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
          }
          else
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
                  hv_I%(new HTuple(hv_Color.TupleLength()))));
              }
            }
          }
          //
          //Display in different styles
          //
          if ((int)((new HTuple(hv_Style.TupleEqual("line"))).TupleOr(new HTuple(hv_Style.TupleEqual(
              new HTuple())))) != 0)
          {
            //Line
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Contour.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour, ((hv_Height-hv_LowerBorder)-(hv_YSelected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
                ((hv_XValues_COPY_INP_TMP*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor));
            }
            //Clip, if necessary
            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ClipContoursXld(ho_Contour, out ExpTmpOutVar_0, hv_UpperBorder, 
                  hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
              ho_Contour.Dispose();
              ho_Contour = ExpTmpOutVar_0;
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Contour, HDevWindowStack.GetActive());
            }
          }
          else if ((int)(new HTuple(hv_Style.TupleEqual("cross"))) != 0)
          {
            //Cross
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Cross.Dispose();
            HOperatorSet.GenCrossContourXld(out ho_Cross, ((hv_Height-hv_LowerBorder)-(hv_YSelected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
                ((hv_XValues_COPY_INP_TMP*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor), 
                6, 0.785398);
            }
            //Clip, if necessary
            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ClipContoursXld(ho_Cross, out ExpTmpOutVar_0, hv_UpperBorder, 
                  hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
              ho_Cross.Dispose();
              ho_Cross = ExpTmpOutVar_0;
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
            }
          }
          else if ((int)(new HTuple(hv_Style.TupleEqual("filled"))) != 0)
          {
            //Filled
            hv_Y1Selected.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Y1Selected = new HTuple();
            hv_Y1Selected = hv_Y1Selected.TupleConcat(0+hv_XAxisPosition);
            hv_Y1Selected = hv_Y1Selected.TupleConcat(hv_YSelected);
            hv_Y1Selected = hv_Y1Selected.TupleConcat(0+hv_XAxisPosition);
            }
            hv_X1Selected.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_X1Selected = new HTuple();
            hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMin()
                );
            hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP);
            hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMax()
                );
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Filled.Dispose();
            HOperatorSet.GenRegionPolygonFilled(out ho_Filled, ((hv_Height-hv_LowerBorder)-(hv_Y1Selected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
                ((hv_X1Selected*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor));
            }
            //Clip, if necessary
            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ClipRegion(ho_Filled, out ExpTmpOutVar_0, hv_UpperBorder, 
                  hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
              ho_Filled.Dispose();
              ho_Filled = ExpTmpOutVar_0;
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Filled, HDevWindowStack.GetActive());
            }
          }
          else if ((int)(new HTuple(hv_Style.TupleEqual("step"))) != 0)
          {
            ho_Stair.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Stair);
            for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                ))-2); hv_Index = (int)hv_Index + 1)
            {
              hv_Row1.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Row1 = ((hv_Height-hv_LowerBorder)-((hv_YSelected.TupleSelect(
                  hv_Index))*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor);
              }
              hv_Row2.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Row2 = ((hv_Height-hv_LowerBorder)-((hv_YSelected.TupleSelect(
                  hv_Index+1))*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor);
              }
              hv_Col1.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Col1 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                  hv_Index))*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor);
              }
              hv_Col2.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Col2 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                  hv_Index+1))*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor);
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_StairTmp.Dispose();
              HOperatorSet.GenContourPolygonXld(out ho_StairTmp, ((hv_Row1.TupleConcat(
                  hv_Row1))).TupleConcat(hv_Row2), ((hv_Col1.TupleConcat(hv_Col2))).TupleConcat(
                  hv_Col2));
              }
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ConcatObj(ho_Stair, ho_StairTmp, out ExpTmpOutVar_0);
              ho_Stair.Dispose();
              ho_Stair = ExpTmpOutVar_0;
              }
            }
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.UnionAdjacentContoursXld(ho_Stair, out ExpTmpOutVar_0, 0.1, 
                0.1, "attr_keep");
            ho_Stair.Dispose();
            ho_Stair = ExpTmpOutVar_0;
            }
            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ClipRegion(ho_Stair, out ExpTmpOutVar_0, hv_UpperBorder, 
                  hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
              ho_Stair.Dispose();
              ho_Stair = ExpTmpOutVar_0;
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Stair, HDevWindowStack.GetActive());
            }
          }
          else
          {
            throw new HalconException("Unsupported style: "+hv_Style);
          }
        }
      }
    }
    //
    //
    //Reset original display settings
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), hv_PartRow1, hv_PartColumn1, 
          hv_PartRow2, hv_PartColumn2);
    }
    HDevWindowStack.SetActive(hv_PreviousWindowHandle);
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
    }
    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_OriginStyle);
    HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
    ho_ContourXGrid.Dispose();
    ho_ContourYGrid.Dispose();
    ho_XArrow.Dispose();
    ho_YArrow.Dispose();
    ho_ContourXTick.Dispose();
    ho_ContourYTick.Dispose();
    ho_Contour.Dispose();
    ho_Cross.Dispose();
    ho_Filled.Dispose();
    ho_Stair.Dispose();
    ho_StairTmp.Dispose();

    hv_XValues_COPY_INP_TMP.Dispose();
    hv_YValues_COPY_INP_TMP.Dispose();
    hv_PreviousWindowHandle.Dispose();
    hv_ClipRegion.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_PartRow1.Dispose();
    hv_PartColumn1.Dispose();
    hv_PartRow2.Dispose();
    hv_PartColumn2.Dispose();
    hv_Red.Dispose();
    hv_Green.Dispose();
    hv_Blue.Dispose();
    hv_DrawMode.Dispose();
    hv_OriginStyle.Dispose();
    hv_XAxisEndValue.Dispose();
    hv_YAxisEndValue.Dispose();
    hv_XAxisStartValue.Dispose();
    hv_YAxisStartValue.Dispose();
    hv_XValuesAreStrings.Dispose();
    hv_XTickValues.Dispose();
    hv_XTicks.Dispose();
    hv_YAxisPosition.Dispose();
    hv_XAxisPosition.Dispose();
    hv_LeftBorder.Dispose();
    hv_RightBorder.Dispose();
    hv_UpperBorder.Dispose();
    hv_LowerBorder.Dispose();
    hv_AxesColor.Dispose();
    hv_Style.Dispose();
    hv_Clip.Dispose();
    hv_YTicks.Dispose();
    hv_XGrid.Dispose();
    hv_YGrid.Dispose();
    hv_GridColor.Dispose();
    hv_YPosition.Dispose();
    hv_FormatX.Dispose();
    hv_FormatY.Dispose();
    hv_NumGenParamNames.Dispose();
    hv_NumGenParamValues.Dispose();
    hv_GenParamIndex.Dispose();
    hv_XGridTicks.Dispose();
    hv_YTickDirection.Dispose();
    hv_XTickDirection.Dispose();
    hv_XAxisWidthPx.Dispose();
    hv_XAxisWidth.Dispose();
    hv_XScaleFactor.Dispose();
    hv_YAxisHeightPx.Dispose();
    hv_YAxisHeight.Dispose();
    hv_YScaleFactor.Dispose();
    hv_YAxisOffsetPx.Dispose();
    hv_XAxisOffsetPx.Dispose();
    hv_DotStyle.Dispose();
    hv_XGridValues.Dispose();
    hv_XGridStart.Dispose();
    hv_XCoord.Dispose();
    hv_IndexGrid.Dispose();
    hv_YGridValues.Dispose();
    hv_YGridStart.Dispose();
    hv_YCoord.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_TextWidthXLabel.Dispose();
    hv_TextHeightXLabel.Dispose();
    hv_TextWidthYLabel.Dispose();
    hv_TextHeightYLabel.Dispose();
    hv_XTickStart.Dispose();
    hv_Indices.Dispose();
    hv_TypeTicks.Dispose();
    hv_IndexTicks.Dispose();
    hv_Ascent1.Dispose();
    hv_Descent1.Dispose();
    hv_TextWidthXTicks.Dispose();
    hv_TextHeightXTicks.Dispose();
    hv_YTickValues.Dispose();
    hv_YTickStart.Dispose();
    hv_TextWidthYTicks.Dispose();
    hv_TextHeightYTicks.Dispose();
    hv_Num.Dispose();
    hv_I.Dispose();
    hv_YSelected.Dispose();
    hv_Y1Selected.Dispose();
    hv_X1Selected.Dispose();
    hv_Index.Dispose();
    hv_Row1.Dispose();
    hv_Row2.Dispose();
    hv_Col1.Dispose();
    hv_Col2.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description:  This procedure plots tuples representing functions or curves in a coordinate system. 
  public void plot_tuple_no_window_handling (HTuple hv_WindowHandle, HTuple hv_XValues, 
      HTuple hv_YValues, HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName, 
      HTuple hv_GenParamValue)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ContourXGrid=null, ho_ContourYGrid=null;
    HObject ho_XArrow=null, ho_YArrow=null, ho_ContourXTick=null;
    HObject ho_ContourYTick=null, ho_Contour=null, ho_Cross=null;
    HObject ho_Filled=null, ho_Stair=null, ho_StairTmp=null;

    // Local control variables 

    HTuple hv_ClipRegion = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_PartRow1 = new HTuple();
    HTuple hv_PartColumn1 = new HTuple(), hv_PartRow2 = new HTuple();
    HTuple hv_PartColumn2 = new HTuple(), hv_Red = new HTuple();
    HTuple hv_Green = new HTuple(), hv_Blue = new HTuple();
    HTuple hv_DrawMode = new HTuple(), hv_OriginStyle = new HTuple();
    HTuple hv_PartDiffers = new HTuple(), hv_PlotYLog = new HTuple();
    HTuple hv_YLogIndices = new HTuple(), hv_PlotYLogUser = new HTuple();
    HTuple hv_IsString = new HTuple(), hv_YInd = new HTuple();
    HTuple hv_Indices1 = new HTuple(), hv_XAxisEndValue = new HTuple();
    HTuple hv_YAxisEndValue = new HTuple(), hv_XAxisStartValue = new HTuple();
    HTuple hv_YAxisStartValue = new HTuple(), hv_XValuesAreStrings = new HTuple();
    HTuple hv_XTickValues = new HTuple(), hv_XTicks = new HTuple();
    HTuple hv_YAxisPosition = new HTuple(), hv_XAxisPosition = new HTuple();
    HTuple hv_LeftBorder = new HTuple(), hv_RightBorder = new HTuple();
    HTuple hv_UpperBorder = new HTuple(), hv_LowerBorder = new HTuple();
    HTuple hv_AxesColor = new HTuple(), hv_Style = new HTuple();
    HTuple hv_Clip = new HTuple(), hv_YTicks = new HTuple();
    HTuple hv_XGrid = new HTuple(), hv_YGrid = new HTuple();
    HTuple hv_GridColor = new HTuple(), hv_YPosition = new HTuple();
    HTuple hv_FormatX = new HTuple(), hv_FormatY = new HTuple();
    HTuple hv_LineWidth = new HTuple(), hv_NumGenParamNames = new HTuple();
    HTuple hv_NumGenParamValues = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_XGridTicks = new HTuple(), hv_YTickDirection = new HTuple();
    HTuple hv_XTickDirection = new HTuple(), hv_XAxisWidthPx = new HTuple();
    HTuple hv_XAxisWidth = new HTuple(), hv_XScaleFactor = new HTuple();
    HTuple hv_YAxisHeightPx = new HTuple(), hv_YAxisHeight = new HTuple();
    HTuple hv_YScaleFactor = new HTuple(), hv_YAxisOffsetPx = new HTuple();
    HTuple hv_XAxisOffsetPx = new HTuple(), hv_DotStyle = new HTuple();
    HTuple hv_XGridValues = new HTuple(), hv_XGridStart = new HTuple();
    HTuple hv_XCoord = new HTuple(), hv_IndexGrid = new HTuple();
    HTuple hv_YGridValues = new HTuple(), hv_YGridStart = new HTuple();
    HTuple hv_YCoord = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_TextWidthXLabel = new HTuple();
    HTuple hv_TextHeightXLabel = new HTuple(), hv_TextWidthYLabel = new HTuple();
    HTuple hv_TextHeightYLabel = new HTuple(), hv_XTickStart = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_TypeTicks = new HTuple();
    HTuple hv_IndexTicks = new HTuple(), hv_Ascent1 = new HTuple();
    HTuple hv_Descent1 = new HTuple(), hv_TextWidthXTicks = new HTuple();
    HTuple hv_TextHeightXTicks = new HTuple(), hv_YTickValues = new HTuple();
    HTuple hv_YTickStart = new HTuple(), hv_TextWidthYTicks = new HTuple();
    HTuple hv_TextHeightYTicks = new HTuple(), hv_Num = new HTuple();
    HTuple hv_I = new HTuple(), hv_YSelected = new HTuple();
    HTuple hv_OldLineWidth = new HTuple(), hv_Y1Selected = new HTuple();
    HTuple hv_X1Selected = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Row2 = new HTuple();
    HTuple hv_Col1 = new HTuple(), hv_Col2 = new HTuple();
    HTuple   hv_XValues_COPY_INP_TMP = new HTuple(hv_XValues);
    HTuple   hv_YValues_COPY_INP_TMP = new HTuple(hv_YValues);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ContourXGrid);
    HOperatorSet.GenEmptyObj(out ho_ContourYGrid);
    HOperatorSet.GenEmptyObj(out ho_XArrow);
    HOperatorSet.GenEmptyObj(out ho_YArrow);
    HOperatorSet.GenEmptyObj(out ho_ContourXTick);
    HOperatorSet.GenEmptyObj(out ho_ContourYTick);
    HOperatorSet.GenEmptyObj(out ho_Contour);
    HOperatorSet.GenEmptyObj(out ho_Cross);
    HOperatorSet.GenEmptyObj(out ho_Filled);
    HOperatorSet.GenEmptyObj(out ho_Stair);
    HOperatorSet.GenEmptyObj(out ho_StairTmp);
    //
    //This procedure plots tuples representing functions
    //or curves in a coordinate system.

    //In the following, the possible values are listed for the parameters:
    //
    //- XValues: X values of the function to be plotted. Thereby you have the following options:
    //  -- []: XValues are internally set to 0,1,2,...,|YValues|-1.
    //  -- a tuple of strings: These values are taken as categories.
    //
    //- YValues: Y values of the function(s) to be plotted. Thereby you have the following options:
    //  -- []: YValues are internally set to 0,1,2,...,|XValues|-1.
    //  -- a tuple of values: The number of y values must be equal to the number of x values or an integral multiple.
    //     In the latter case, multiple functions are plotted, that share the same x values.
    //
    //- XLabel: X-axis label.
    //
    //- XLabel: Y-axis label.
    //
    //- Color: Color of the plotted function. Thereby you have the following options:
    //  -- []: The currently set display color is used.
    //  -- 'none': The function is not plotted, but only the coordinate axes as specified.
    //  -- string: Defining the color of the plotted function.
    //  -- tuple of strings: -nultiple functions can be displayed in different colors.
    //
    //- GenParamName: Generic parameter names to control the presentation.
    // The corresponding values are taken from GenParamValue. Possible Values string/value pairs:
    //  -- 'axes_color': Color of the coordinate axes. The default value is 'white'.
    //     If 'none' is given, no coordinate axes are shown.
    //  -- 'style': Graph style. Possible values:
    //     --- 'line' (default)
    //     --- 'cross'
    //     --- 'step'
    //     --- 'filled'
    //  -- 'clip': Clip graph to coordinate system area. Possible values:
    //     --- 'no' (default)
    //     --- 'yes''
    //  -- 'ticks': Control display of ticks on the axes. Thereby you have the following options:
    //     --- 'min_max_origin' (default): Ticks are shown at the minimum and maximum values
    //         of the axes and at the intercept point of x- and y-axis.
    //     --- 'none': No ticks are shown.
    //     --- any number != 0: This number specifies the distance between the ticks.
    //  -- 'ticks_x': Control display of ticks on x-axis only. You have the same options as for 'ticks'.
    //  -- 'ticks_y': Control display of ticks on y-axis only. You have the same options as for 'ticks'.
    //  -- 'format_x': Format of the values next to the ticks of the x-axis (see tuple_string for more details).
    //  -- 'format_y': Format of the values next to the ticks of the y-axis (see tuple_string for more details).
    //  -- 'grid': Control display of grid lines within the coordinate system.
    //     Thereby you have the following options:
    //    --- 'min_max_origin' (default): Grid lines are shown at the minimum and maximum values of the axes.
    //    --- 'none': No grid lines are shown.
    //    --- If any number != 0: This number specifies the distance between the grid lines.
    //  -- 'grid_x': Control display of grid lines for the x-axis only.
    //  -- 'grid_y': Control display of grid lines for the y-axis only.
    //  -- 'grid_color': Color of the grid (default: 'dim gray').
    //  -- 'margin': The distance in pixels of the plot area to all four window borders.
    //  -- 'margin_left': The distance in pixels of the plot area to the left window border.
    //  -- 'margin_right': The distance in pixels of the plot area to the right window border.
    //  -- 'margin_top': The distance in pixels of the plot area to the upper window border.
    //  -- 'margin_bottom'': The distance in pixels of the plot area to the lower window border.
    //  -- 'start_x': Lowest x value of the x-axis. The default value is min(XValues).
    //  -- 'end_x': Highest x value of the x-axis. The default value is max(XValues).
    //  -- 'start_y': Lowest y value of the y-axis. The default value is min(YValues).
    //  -- 'end_y': Highest y value of the y-axis. The default value is max(YValues).
    //  -- 'axis_location_x': Position of the x-axis (Used to be called 'origin_y').
    //     Thereby you have the following options:
    //     --- 'bottom' (default)
    //     --- 'origin'
    //     --- 'top'
    //     --- Y coordinate of the intercept point of x- and y-axis.
    //  -- 'axis_location_y': Position of the y-axis (Used to be called 'origin_x').
    //     Thereby you have the following options:
    //     --- 'left' (default)
    //     --- 'right'
    //     --- 'origin'
    //     --- X coordinate of the intercept point of x- and y-axis.
    //
    //
    hv_ClipRegion.Dispose();
    HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
    hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width, 
        out hv_Height);
    hv_PartRow1.Dispose();hv_PartColumn1.Dispose();hv_PartRow2.Dispose();hv_PartColumn2.Dispose();
    HOperatorSet.GetPart(hv_WindowHandle, out hv_PartRow1, out hv_PartColumn1, out hv_PartRow2, 
        out hv_PartColumn2);
    hv_Width.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Width = (hv_PartColumn2-hv_PartColumn1)+1;
    }
    hv_Height.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Height = (hv_PartRow2-hv_PartRow1)+1;
    }
    hv_Red.Dispose();hv_Green.Dispose();hv_Blue.Dispose();
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    hv_DrawMode.Dispose();
    HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
    hv_OriginStyle.Dispose();
    HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_OriginStyle);
    //
    //Set the display parameters.
    HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
    HOperatorSet.SetSystem("clip_region", "false");

    hv_PartDiffers.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_PartDiffers = (new HTuple((new HTuple((new HTuple((new HTuple(0)).TupleNotEqual(
        hv_PartRow1))).TupleOr(new HTuple((new HTuple(0)).TupleNotEqual(hv_Column))))).TupleOr(
        new HTuple(((hv_Width-1)).TupleNotEqual(hv_PartColumn2))))).TupleOr(new HTuple(((hv_Height-1)).TupleNotEqual(
        hv_PartRow2)));
    }
    //Only use set part if it differs.
    if ((int)(hv_PartDiffers) != 0)
    {
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height-1, hv_Width-1);
        }
      }
    }
    //
    //Check if we need to plot y-values logarithmically.
    //It is checked here because we want to convert the YValues tuple
    //immediately so that derived values will be correct.
    hv_PlotYLog.Dispose();
    hv_PlotYLog = 0;
    if ((int)((new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleGreater(
        0))).TupleAnd(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleEqual(
        new HTuple(hv_GenParamValue.TupleLength()))))) != 0)
    {
      hv_YLogIndices.Dispose();
      HOperatorSet.TupleFind(hv_GenParamName, "log_y", out hv_YLogIndices);
      if ((int)(new HTuple(hv_YLogIndices.TupleGreaterEqual(0))) != 0)
      {
        hv_PlotYLogUser.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PlotYLogUser = hv_GenParamValue.TupleSelect(
            hv_YLogIndices.TupleSelect(0));
        }
        hv_IsString.Dispose();
        HOperatorSet.TupleIsString(hv_PlotYLogUser, out hv_IsString);
        if ((int)(hv_IsString) != 0)
        {
          if ((int)(new HTuple(hv_PlotYLogUser.TupleEqual("true"))) != 0)
          {
            hv_PlotYLog.Dispose();
            hv_PlotYLog = 1;
          }
          else if ((int)(new HTuple(hv_PlotYLogUser.TupleEqual("false"))) != 0)
          {
            hv_PlotYLog.Dispose();
            hv_PlotYLog = 0;
          }
          else
          {
            throw new HalconException(("Unknown generic param value: '"+hv_PlotYLogUser)+"' for value: 'log_y'");
          }
          hv_PlotYLog.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PlotYLog = new HTuple(hv_PlotYLogUser.TupleEqual(
              "true"));
          }
        }
        else
        {
          hv_PlotYLog.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PlotYLog = new HTuple(hv_PlotYLogUser.TupleEqual(
              1));
          }
        }
      }
    }
    if ((int)(hv_PlotYLog) != 0)
    {
      //Clamp values to be >= 0.00001.
      hv_YInd.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YInd = hv_YValues_COPY_INP_TMP.TupleLessEqualElem(
          0);
      }
      hv_Indices1.Dispose();
      HOperatorSet.TupleFind(hv_YInd, 1, out hv_Indices1);
      if ((int)(new HTuple(hv_Indices1.TupleGreaterEqual(0))) != 0)
      {
        if (hv_YValues_COPY_INP_TMP == null)
          hv_YValues_COPY_INP_TMP = new HTuple();
        hv_YValues_COPY_INP_TMP[hv_Indices1] = 0.00001;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_YValues = hv_YValues_COPY_INP_TMP.TupleLog10()
          ;
      hv_YValues_COPY_INP_TMP.Dispose();
      hv_YValues_COPY_INP_TMP = ExpTmpLocalVar_YValues;
      }
      }
    }
    //
    //Check input coordinate values.
    //
    if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleAnd(
        new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
    {
      //Neither XValues nor YValues are given:
      //Set axes to interval [0,1]
      hv_XAxisEndValue.Dispose();
      hv_XAxisEndValue = 1;
      hv_YAxisEndValue.Dispose();
      hv_YAxisEndValue = 1;
      hv_XAxisStartValue.Dispose();
      hv_XAxisStartValue = 0;
      hv_YAxisStartValue.Dispose();
      hv_YAxisStartValue = 0;
      hv_XValuesAreStrings.Dispose();
      hv_XValuesAreStrings = 0;
    }
    else
    {
      if ((int)(new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
      {
        //XValues are omitted: Set equidistant XValues.
        hv_XValues_COPY_INP_TMP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XValues_COPY_INP_TMP = HTuple.TupleGenSequence(
            0,(new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()))-1,1);
        }
        hv_XValuesAreStrings.Dispose();
        hv_XValuesAreStrings = 0;
      }
      else if ((int)(new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
      {
        //YValues are omitted: Set equidistant YValues.
        hv_YValues_COPY_INP_TMP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YValues_COPY_INP_TMP = HTuple.TupleGenSequence(
            0,(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()))-1,1);
        }
      }
      if ((int)(new HTuple((new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
          ))%(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())))).TupleNotEqual(
          0))) != 0)
      {
        //Number of YValues does not match number of XValues.
        throw new HalconException("Number of YValues is no multiple of the number of XValues.");
        ho_ContourXGrid.Dispose();
        ho_ContourYGrid.Dispose();
        ho_XArrow.Dispose();
        ho_YArrow.Dispose();
        ho_ContourXTick.Dispose();
        ho_ContourYTick.Dispose();
        ho_Contour.Dispose();
        ho_Cross.Dispose();
        ho_Filled.Dispose();
        ho_Stair.Dispose();
        ho_StairTmp.Dispose();

        hv_XValues_COPY_INP_TMP.Dispose();
        hv_YValues_COPY_INP_TMP.Dispose();
        hv_ClipRegion.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_PartRow1.Dispose();
        hv_PartColumn1.Dispose();
        hv_PartRow2.Dispose();
        hv_PartColumn2.Dispose();
        hv_Red.Dispose();
        hv_Green.Dispose();
        hv_Blue.Dispose();
        hv_DrawMode.Dispose();
        hv_OriginStyle.Dispose();
        hv_PartDiffers.Dispose();
        hv_PlotYLog.Dispose();
        hv_YLogIndices.Dispose();
        hv_PlotYLogUser.Dispose();
        hv_IsString.Dispose();
        hv_YInd.Dispose();
        hv_Indices1.Dispose();
        hv_XAxisEndValue.Dispose();
        hv_YAxisEndValue.Dispose();
        hv_XAxisStartValue.Dispose();
        hv_YAxisStartValue.Dispose();
        hv_XValuesAreStrings.Dispose();
        hv_XTickValues.Dispose();
        hv_XTicks.Dispose();
        hv_YAxisPosition.Dispose();
        hv_XAxisPosition.Dispose();
        hv_LeftBorder.Dispose();
        hv_RightBorder.Dispose();
        hv_UpperBorder.Dispose();
        hv_LowerBorder.Dispose();
        hv_AxesColor.Dispose();
        hv_Style.Dispose();
        hv_Clip.Dispose();
        hv_YTicks.Dispose();
        hv_XGrid.Dispose();
        hv_YGrid.Dispose();
        hv_GridColor.Dispose();
        hv_YPosition.Dispose();
        hv_FormatX.Dispose();
        hv_FormatY.Dispose();
        hv_LineWidth.Dispose();
        hv_NumGenParamNames.Dispose();
        hv_NumGenParamValues.Dispose();
        hv_GenParamIndex.Dispose();
        hv_XGridTicks.Dispose();
        hv_YTickDirection.Dispose();
        hv_XTickDirection.Dispose();
        hv_XAxisWidthPx.Dispose();
        hv_XAxisWidth.Dispose();
        hv_XScaleFactor.Dispose();
        hv_YAxisHeightPx.Dispose();
        hv_YAxisHeight.Dispose();
        hv_YScaleFactor.Dispose();
        hv_YAxisOffsetPx.Dispose();
        hv_XAxisOffsetPx.Dispose();
        hv_DotStyle.Dispose();
        hv_XGridValues.Dispose();
        hv_XGridStart.Dispose();
        hv_XCoord.Dispose();
        hv_IndexGrid.Dispose();
        hv_YGridValues.Dispose();
        hv_YGridStart.Dispose();
        hv_YCoord.Dispose();
        hv_Ascent.Dispose();
        hv_Descent.Dispose();
        hv_TextWidthXLabel.Dispose();
        hv_TextHeightXLabel.Dispose();
        hv_TextWidthYLabel.Dispose();
        hv_TextHeightYLabel.Dispose();
        hv_XTickStart.Dispose();
        hv_Indices.Dispose();
        hv_TypeTicks.Dispose();
        hv_IndexTicks.Dispose();
        hv_Ascent1.Dispose();
        hv_Descent1.Dispose();
        hv_TextWidthXTicks.Dispose();
        hv_TextHeightXTicks.Dispose();
        hv_YTickValues.Dispose();
        hv_YTickStart.Dispose();
        hv_TextWidthYTicks.Dispose();
        hv_TextHeightYTicks.Dispose();
        hv_Num.Dispose();
        hv_I.Dispose();
        hv_YSelected.Dispose();
        hv_OldLineWidth.Dispose();
        hv_Y1Selected.Dispose();
        hv_X1Selected.Dispose();
        hv_Index.Dispose();
        hv_Row1.Dispose();
        hv_Row2.Dispose();
        hv_Col1.Dispose();
        hv_Col2.Dispose();

        return;
      }

      hv_XValuesAreStrings.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_XValuesAreStrings = hv_XValues_COPY_INP_TMP.TupleIsStringElem()
          ;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_XValuesAreStrings = new HTuple(((hv_XValuesAreStrings.TupleSum()
          )).TupleEqual(new HTuple(hv_XValuesAreStrings.TupleLength())));
      hv_XValuesAreStrings.Dispose();
      hv_XValuesAreStrings = ExpTmpLocalVar_XValuesAreStrings;
      }
      }
      if ((int)(hv_XValuesAreStrings) != 0)
      {
        //XValues are given as strings: Show XValues as ticks.
        hv_XTickValues.Dispose();
        hv_XTickValues = new HTuple(hv_XValues_COPY_INP_TMP);
        hv_XTicks.Dispose();
        hv_XTicks = 1;
        //Set x-axis dimensions.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_XValues = HTuple.TupleGenSequence(
            1,new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()),1);
        hv_XValues_COPY_INP_TMP.Dispose();
        hv_XValues_COPY_INP_TMP = ExpTmpLocalVar_XValues;
        }
        }
      }
      //Set default x-axis dimensions.
      if ((int)(new HTuple((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())).TupleGreater(
          1))) != 0)
      {
        hv_XAxisStartValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisStartValue = hv_XValues_COPY_INP_TMP.TupleMin()
            ;
        }
        hv_XAxisEndValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisEndValue = hv_XValues_COPY_INP_TMP.TupleMax()
            ;
        }
      }
      else
      {
        hv_XAxisEndValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisEndValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
            0))+0.5;
        }
        hv_XAxisStartValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisStartValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
            0))-0.5;
        }
      }
    }
    //Set default y-axis dimensions.
    if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())).TupleGreater(
        1))) != 0)
    {
      hv_YAxisStartValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisStartValue = hv_YValues_COPY_INP_TMP.TupleMin()
          ;
      }
      hv_YAxisEndValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisEndValue = hv_YValues_COPY_INP_TMP.TupleMax()
          ;
      }
    }
    else if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
        )).TupleEqual(1))) != 0)
    {
      hv_YAxisStartValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisStartValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
          0))-0.5;
      }
      hv_YAxisEndValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisEndValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
          0))+0.5;
      }
    }
    else
    {
      hv_YAxisStartValue.Dispose();
      hv_YAxisStartValue = 0;
      hv_YAxisEndValue.Dispose();
      hv_YAxisEndValue = 1;
    }
    //Set default interception point of x- and y- axis.
    hv_YAxisPosition.Dispose();
    hv_YAxisPosition = "default";
    hv_XAxisPosition.Dispose();
    hv_XAxisPosition = "default";
    //
    //Set further default values:
    hv_LeftBorder.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_LeftBorder = hv_Width*0.1;
    }
    hv_RightBorder.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RightBorder = hv_Width*0.1;
    }
    hv_UpperBorder.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_UpperBorder = hv_Height*0.1;
    }
    hv_LowerBorder.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_LowerBorder = hv_Height*0.1;
    }
    hv_AxesColor.Dispose();
    hv_AxesColor = "white";
    hv_Style.Dispose();
    hv_Style = "line";
    hv_Clip.Dispose();
    hv_Clip = "no";
    hv_XTicks.Dispose();
    hv_XTicks = "min_max_origin";
    hv_YTicks.Dispose();
    hv_YTicks = "min_max_origin";
    hv_XGrid.Dispose();
    hv_XGrid = "none";
    hv_YGrid.Dispose();
    hv_YGrid = "none";
    hv_GridColor.Dispose();
    hv_GridColor = "dim gray";
    hv_YPosition.Dispose();
    hv_YPosition = "left";
    hv_FormatX.Dispose();
    hv_FormatX = "default";
    hv_FormatY.Dispose();
    hv_FormatY = "default";
    hv_LineWidth.Dispose();
    hv_LineWidth = 1;
    //
    //Parse generic parameters.
    //
    hv_NumGenParamNames.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumGenParamNames = new HTuple(hv_GenParamName.TupleLength()
        );
    }
    hv_NumGenParamValues.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumGenParamValues = new HTuple(hv_GenParamValue.TupleLength()
        );
    }
    if ((int)(new HTuple(hv_NumGenParamNames.TupleNotEqual(hv_NumGenParamValues))) != 0)
    {
      throw new HalconException("Number of generic parameter names does not match generic parameter values.");
      ho_ContourXGrid.Dispose();
      ho_ContourYGrid.Dispose();
      ho_XArrow.Dispose();
      ho_YArrow.Dispose();
      ho_ContourXTick.Dispose();
      ho_ContourYTick.Dispose();
      ho_Contour.Dispose();
      ho_Cross.Dispose();
      ho_Filled.Dispose();
      ho_Stair.Dispose();
      ho_StairTmp.Dispose();

      hv_XValues_COPY_INP_TMP.Dispose();
      hv_YValues_COPY_INP_TMP.Dispose();
      hv_ClipRegion.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_PartRow1.Dispose();
      hv_PartColumn1.Dispose();
      hv_PartRow2.Dispose();
      hv_PartColumn2.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_DrawMode.Dispose();
      hv_OriginStyle.Dispose();
      hv_PartDiffers.Dispose();
      hv_PlotYLog.Dispose();
      hv_YLogIndices.Dispose();
      hv_PlotYLogUser.Dispose();
      hv_IsString.Dispose();
      hv_YInd.Dispose();
      hv_Indices1.Dispose();
      hv_XAxisEndValue.Dispose();
      hv_YAxisEndValue.Dispose();
      hv_XAxisStartValue.Dispose();
      hv_YAxisStartValue.Dispose();
      hv_XValuesAreStrings.Dispose();
      hv_XTickValues.Dispose();
      hv_XTicks.Dispose();
      hv_YAxisPosition.Dispose();
      hv_XAxisPosition.Dispose();
      hv_LeftBorder.Dispose();
      hv_RightBorder.Dispose();
      hv_UpperBorder.Dispose();
      hv_LowerBorder.Dispose();
      hv_AxesColor.Dispose();
      hv_Style.Dispose();
      hv_Clip.Dispose();
      hv_YTicks.Dispose();
      hv_XGrid.Dispose();
      hv_YGrid.Dispose();
      hv_GridColor.Dispose();
      hv_YPosition.Dispose();
      hv_FormatX.Dispose();
      hv_FormatY.Dispose();
      hv_LineWidth.Dispose();
      hv_NumGenParamNames.Dispose();
      hv_NumGenParamValues.Dispose();
      hv_GenParamIndex.Dispose();
      hv_XGridTicks.Dispose();
      hv_YTickDirection.Dispose();
      hv_XTickDirection.Dispose();
      hv_XAxisWidthPx.Dispose();
      hv_XAxisWidth.Dispose();
      hv_XScaleFactor.Dispose();
      hv_YAxisHeightPx.Dispose();
      hv_YAxisHeight.Dispose();
      hv_YScaleFactor.Dispose();
      hv_YAxisOffsetPx.Dispose();
      hv_XAxisOffsetPx.Dispose();
      hv_DotStyle.Dispose();
      hv_XGridValues.Dispose();
      hv_XGridStart.Dispose();
      hv_XCoord.Dispose();
      hv_IndexGrid.Dispose();
      hv_YGridValues.Dispose();
      hv_YGridStart.Dispose();
      hv_YCoord.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv_TextWidthXLabel.Dispose();
      hv_TextHeightXLabel.Dispose();
      hv_TextWidthYLabel.Dispose();
      hv_TextHeightYLabel.Dispose();
      hv_XTickStart.Dispose();
      hv_Indices.Dispose();
      hv_TypeTicks.Dispose();
      hv_IndexTicks.Dispose();
      hv_Ascent1.Dispose();
      hv_Descent1.Dispose();
      hv_TextWidthXTicks.Dispose();
      hv_TextHeightXTicks.Dispose();
      hv_YTickValues.Dispose();
      hv_YTickStart.Dispose();
      hv_TextWidthYTicks.Dispose();
      hv_TextHeightYTicks.Dispose();
      hv_Num.Dispose();
      hv_I.Dispose();
      hv_YSelected.Dispose();
      hv_OldLineWidth.Dispose();
      hv_Y1Selected.Dispose();
      hv_X1Selected.Dispose();
      hv_Index.Dispose();
      hv_Row1.Dispose();
      hv_Row2.Dispose();
      hv_Col1.Dispose();
      hv_Col2.Dispose();

      return;
    }
    //
    for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
        ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
    {
      //
      //Set 'axes_color'.
      if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "axes_color"))) != 0)
      {
        hv_AxesColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AxesColor = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'style'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "style"))) != 0)
      {
        hv_Style.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Style = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'clip'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "clip"))) != 0)
      {
        hv_Clip.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Clip = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        if ((int)((new HTuple(hv_Clip.TupleNotEqual("yes"))).TupleAnd(new HTuple(hv_Clip.TupleNotEqual(
            "no")))) != 0)
        {
          throw new HalconException(("Unsupported clipping option: '"+hv_Clip)+"'");
        }
        //
        //Set 'ticks'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "ticks"))) != 0)
      {
        hv_XTicks.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XTicks = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_YTicks.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YTicks = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'ticks_x'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "ticks_x"))) != 0)
      {
        hv_XTicks.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XTicks = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'ticks_y'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "ticks_y"))) != 0)
      {
        hv_YTicks.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YTicks = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'grid'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "grid"))) != 0)
      {
        hv_XGrid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XGrid = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_YGrid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YGrid = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_XGridTicks.Dispose();
        hv_XGridTicks = new HTuple(hv_XTicks);
        //
        //Set 'grid_x'
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "grid_x"))) != 0)
      {
        hv_XGrid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XGrid = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'grid_y'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "grid_y"))) != 0)
      {
        hv_YGrid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YGrid = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'grid_color'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "grid_color"))) != 0)
      {
        hv_GridColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GridColor = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'start_x'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "start_x"))) != 0)
      {
        hv_XAxisStartValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisStartValue = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'end_x'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "end_x"))) != 0)
      {
        hv_XAxisEndValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisEndValue = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'start_y'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "start_y"))) != 0)
      {
        hv_YAxisStartValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YAxisStartValue = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        if ((int)(hv_PlotYLog) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_YAxisStartValue = (((new HTuple(0.00001)).TupleMax2(
              hv_YAxisStartValue))).TupleLog10();
          hv_YAxisStartValue.Dispose();
          hv_YAxisStartValue = ExpTmpLocalVar_YAxisStartValue;
          }
          }
        }
        //
        //Set 'end_y'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "end_y"))) != 0)
      {
        hv_YAxisEndValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YAxisEndValue = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        if ((int)(hv_PlotYLog) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_YAxisEndValue = (((new HTuple(0.00001)).TupleMax2(
              hv_YAxisEndValue))).TupleLog10();
          hv_YAxisEndValue.Dispose();
          hv_YAxisEndValue = ExpTmpLocalVar_YAxisEndValue;
          }
          }
        }
        //
        //Set 'axis_location_y' (old name 'origin_x').
      }
      else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "axis_location_y"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "origin_x")))) != 0)
      {
        hv_YAxisPosition.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YAxisPosition = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'axis_location_x' (old name: 'origin_y').
      }
      else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "axis_location_x"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "origin_y")))) != 0)
      {
        hv_XAxisPosition.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XAxisPosition = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'margin'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "margin"))) != 0)
      {
        hv_LeftBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LeftBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_RightBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RightBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_UpperBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_UpperBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        hv_LowerBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LowerBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'margin_left'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "margin_left"))) != 0)
      {
        hv_LeftBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LeftBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'margin_right'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "margin_right"))) != 0)
      {
        hv_RightBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RightBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'margin_top'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "margin_top"))) != 0)
      {
        hv_UpperBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_UpperBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
        //
        //Set 'margin_bottom'.
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "margin_bottom"))) != 0)
      {
        hv_LowerBorder.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LowerBorder = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "format_x"))) != 0)
      {
        hv_FormatX.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FormatX = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "format_y"))) != 0)
      {
        hv_FormatY.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FormatY = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "line_width"))) != 0)
      {
        hv_LineWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LineWidth = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "log_y"))) != 0)
      {
        //log_y already checked before because some other values depend on it.
      }
      else
      {
        throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
            hv_GenParamIndex)))+"'");
      }
    }
    //
    //Check consistency of start and end values of the axes.
    if ((int)(new HTuple(hv_XAxisStartValue.TupleGreater(hv_XAxisEndValue))) != 0)
    {
      throw new HalconException("Value for 'start_x' is greater than value for 'end_x'");
    }
    if ((int)(new HTuple(hv_YAxisStartValue.TupleGreater(hv_YAxisEndValue))) != 0)
    {
      throw new HalconException("Value for 'start_y' is greater than value for 'end_y'");
    }
    //
    //Set the position of the y-axis.
    if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("default"))) != 0)
    {
      hv_YAxisPosition.Dispose();
      hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
    }
    if ((int)(new HTuple(((hv_YAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
    {
      if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("left"))) != 0)
      {
        hv_YAxisPosition.Dispose();
        hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
      }
      else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("right"))) != 0)
      {
        hv_YAxisPosition.Dispose();
        hv_YAxisPosition = new HTuple(hv_XAxisEndValue);
      }
      else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("origin"))) != 0)
      {
        hv_YAxisPosition.Dispose();
        hv_YAxisPosition = 0;
      }
      else
      {
        throw new HalconException(("Unsupported axis_location_y: '"+hv_YAxisPosition)+"'");
      }
    }
    //Set the position of the ticks on the y-axis
    //depending of the location of the y-axis.
    if ((int)(new HTuple((new HTuple(((hv_XAxisStartValue.TupleConcat(hv_XAxisEndValue))).TupleMean()
        )).TupleGreater(hv_YAxisPosition))) != 0)
    {
      hv_YTickDirection.Dispose();
      hv_YTickDirection = "right";
    }
    else
    {
      hv_YTickDirection.Dispose();
      hv_YTickDirection = "left";
    }
    //
    //Set the position of the x-axis.
    if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("default"))) != 0)
    {
      hv_XAxisPosition.Dispose();
      hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
    }
    if ((int)(new HTuple(((hv_XAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
    {
      if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("bottom"))) != 0)
      {
        hv_XAxisPosition.Dispose();
        hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
      }
      else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("top"))) != 0)
      {
        hv_XAxisPosition.Dispose();
        hv_XAxisPosition = new HTuple(hv_YAxisEndValue);
      }
      else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("origin"))) != 0)
      {
        hv_XAxisPosition.Dispose();
        hv_XAxisPosition = 0;
      }
      else
      {
        throw new HalconException(("Unsupported axis_location_x: '"+hv_XAxisPosition)+"'");
      }
    }
    //Set the position of the ticks on the y-axis
    //depending of the location of the y-axis.
    if ((int)(new HTuple((new HTuple(((hv_YAxisStartValue.TupleConcat(hv_YAxisEndValue))).TupleMean()
        )).TupleGreater(hv_XAxisPosition))) != 0)
    {
      hv_XTickDirection.Dispose();
      hv_XTickDirection = "up";
    }
    else
    {
      hv_XTickDirection.Dispose();
      hv_XTickDirection = "down";
    }
    //
    //Calculate basic pixel coordinates and scale factors.
    //
    hv_XAxisWidthPx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XAxisWidthPx = (hv_Width-hv_LeftBorder)-hv_RightBorder;
    }
    hv_XAxisWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XAxisWidth = hv_XAxisEndValue-hv_XAxisStartValue;
    }
    if ((int)(new HTuple(hv_XAxisWidth.TupleEqual(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_XAxisStartValue = hv_XAxisStartValue-0.5;
      hv_XAxisStartValue.Dispose();
      hv_XAxisStartValue = ExpTmpLocalVar_XAxisStartValue;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_XAxisEndValue = hv_XAxisEndValue+0.5;
      hv_XAxisEndValue.Dispose();
      hv_XAxisEndValue = ExpTmpLocalVar_XAxisEndValue;
      }
      }
      hv_XAxisWidth.Dispose();
      hv_XAxisWidth = 1;
    }
    hv_XScaleFactor.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XScaleFactor = hv_XAxisWidthPx/(hv_XAxisWidth.TupleReal()
        );
    }
    hv_YAxisHeightPx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YAxisHeightPx = (hv_Height-hv_LowerBorder)-hv_UpperBorder;
    }
    hv_YAxisHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YAxisHeight = hv_YAxisEndValue-hv_YAxisStartValue;
    }
    if ((int)(new HTuple(hv_YAxisHeight.TupleEqual(0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_YAxisStartValue = hv_YAxisStartValue-0.5;
      hv_YAxisStartValue.Dispose();
      hv_YAxisStartValue = ExpTmpLocalVar_YAxisStartValue;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_YAxisEndValue = hv_YAxisEndValue+0.5;
      hv_YAxisEndValue.Dispose();
      hv_YAxisEndValue = ExpTmpLocalVar_YAxisEndValue;
      }
      }
      hv_YAxisHeight.Dispose();
      hv_YAxisHeight = 1;
    }
    hv_YScaleFactor.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YScaleFactor = hv_YAxisHeightPx/(hv_YAxisHeight.TupleReal()
        );
    }
    hv_YAxisOffsetPx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_YAxisOffsetPx = (hv_YAxisPosition-hv_XAxisStartValue)*hv_XScaleFactor;
    }
    hv_XAxisOffsetPx.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_XAxisOffsetPx = (hv_XAxisPosition-hv_YAxisStartValue)*hv_YScaleFactor;
    }
    //
    //Display grid lines.
    //
    if ((int)(new HTuple(hv_GridColor.TupleNotEqual("none"))) != 0)
    {
      hv_DotStyle.Dispose();
      hv_DotStyle = new HTuple();
      hv_DotStyle[0] = 5;
      hv_DotStyle[1] = 7;
      HOperatorSet.SetLineStyle(hv_WindowHandle, hv_DotStyle);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GridColor);
      }
      //
      //Display x grid lines.
      if ((int)(new HTuple(hv_XGrid.TupleNotEqual("none"))) != 0)
      {
        if ((int)(new HTuple(hv_XGrid.TupleEqual("min_max_origin"))) != 0)
        {
          //Calculate 'min_max_origin' grid line coordinates.
          if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
          {
            hv_XGridValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XGridValues = new HTuple();
            hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
            }
          }
          else
          {
            hv_XGridValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XGridValues = new HTuple();
            hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
            }
          }
        }
        else
        {
          //Calculate equidistant grid line coordinates.
          hv_XGridStart.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XGridStart = (((hv_XAxisStartValue/hv_XGrid)).TupleCeil()
              )*hv_XGrid;
          }
          hv_XGridValues.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XGridValues = HTuple.TupleGenSequence(
              hv_XGridStart,hv_XAxisEndValue,hv_XGrid);
          }
        }
        hv_XCoord.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XCoord = (hv_XGridValues-hv_XAxisStartValue)*hv_XScaleFactor;
        }
        //Generate and display grid lines.
        for (hv_IndexGrid=0; (int)hv_IndexGrid<=(int)((new HTuple(hv_XGridValues.TupleLength()
            ))-1); hv_IndexGrid = (int)hv_IndexGrid + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ContourXGrid.Dispose();
          HOperatorSet.GenContourPolygonXld(out ho_ContourXGrid, ((hv_Height-hv_LowerBorder)).TupleConcat(
              hv_UpperBorder), ((hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexGrid)))).TupleConcat(
              hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexGrid))));
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ContourXGrid, HDevWindowStack.GetActive());
          }
        }
      }
      //
      //Display y grid lines.
      if ((int)(new HTuple(hv_YGrid.TupleNotEqual("none"))) != 0)
      {
        if ((int)(new HTuple(hv_YGrid.TupleEqual("min_max_origin"))) != 0)
        {
          //Calculate 'min_max_origin' grid line coordinates.
          if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
          {
            hv_YGridValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YGridValues = new HTuple();
            hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
            }
          }
          else
          {
            hv_YGridValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YGridValues = new HTuple();
            hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
            }
          }
        }
        else
        {
          //Calculate equidistant grid line coordinates.
          hv_YGridStart.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YGridStart = (((hv_YAxisStartValue/hv_YGrid)).TupleCeil()
              )*hv_YGrid;
          }
          hv_YGridValues.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YGridValues = HTuple.TupleGenSequence(
              hv_YGridStart,hv_YAxisEndValue,hv_YGrid);
          }
        }
        hv_YCoord.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YCoord = (hv_YGridValues-hv_YAxisStartValue)*hv_YScaleFactor;
        }
        //Generate and display grid lines.
        for (hv_IndexGrid=0; (int)hv_IndexGrid<=(int)((new HTuple(hv_YGridValues.TupleLength()
            ))-1); hv_IndexGrid = (int)hv_IndexGrid + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ContourYGrid.Dispose();
          HOperatorSet.GenContourPolygonXld(out ho_ContourYGrid, (((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
              hv_IndexGrid)))).TupleConcat((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
              hv_IndexGrid))), hv_LeftBorder.TupleConcat(hv_Width-hv_RightBorder));
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ContourYGrid, HDevWindowStack.GetActive());
          }
        }
      }
    }
    HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
    //
    //
    //Display the coordinate system axes.
    if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
    {
      //Display axes.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_XArrow.Dispose();
      gen_arrow_contour_xld(out ho_XArrow, (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx, 
          hv_LeftBorder, (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx, hv_Width-hv_RightBorder, 
          0, 0);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_XArrow, HDevWindowStack.GetActive());
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_YArrow.Dispose();
      gen_arrow_contour_xld(out ho_YArrow, hv_Height-hv_LowerBorder, hv_LeftBorder+hv_YAxisOffsetPx, 
          hv_UpperBorder, hv_LeftBorder+hv_YAxisOffsetPx, 0, 0);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_YArrow, HDevWindowStack.GetActive());
      }
      //Display labels.
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidthXLabel.Dispose();hv_TextHeightXLabel.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XLabel, out hv_Ascent, out hv_Descent, 
          out hv_TextWidthXLabel, out hv_TextHeightXLabel);
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidthYLabel.Dispose();hv_TextHeightYLabel.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YLabel, out hv_Ascent, out hv_Descent, 
          out hv_TextWidthYLabel, out hv_TextHeightYLabel);
      if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
      {
        if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-3, ((hv_Width-hv_RightBorder)-hv_TextWidthXLabel)-3, 
                hv_AxesColor, "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                hv_UpperBorder, (hv_LeftBorder+3)+hv_YAxisOffsetPx, hv_AxesColor, 
                "box", "false");
            }
          }
        }
        else
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                ((hv_Height-hv_LowerBorder)+3)-hv_XAxisOffsetPx, ((hv_Width-hv_RightBorder)-hv_TextWidthXLabel)-3, 
                hv_AxesColor, "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-3, (hv_LeftBorder+3)+hv_YAxisOffsetPx, 
                hv_AxesColor, "box", "false");
            }
          }
        }
      }
      else
      {
        if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                ((hv_Height-hv_LowerBorder)-(2*hv_TextHeightXLabel))+3, hv_LeftBorder-3, 
                hv_AxesColor, "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                hv_UpperBorder, ((hv_Width-hv_RightBorder)-hv_TextWidthYLabel)-13, 
                hv_AxesColor, "box", "false");
            }
          }
        }
        else
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                ((hv_Height-hv_LowerBorder)+3)-hv_XAxisOffsetPx, hv_LeftBorder-3, 
                hv_AxesColor, "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-3, ((hv_Width-hv_RightBorder)-(2*hv_TextWidthYLabel))-3, 
                hv_AxesColor, "box", "false");
            }
          }
        }
      }
    }
    //
    //Display ticks.
    //
    if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
    {
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
      }
      if ((int)(new HTuple(hv_XTicks.TupleNotEqual("none"))) != 0)
      {
        //
        //Display x ticks.
        if ((int)(hv_XValuesAreStrings) != 0)
        {
          //Display string XValues as categories.
          hv_XTicks.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XTicks = (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
              ))/(new HTuple(hv_XTickValues.TupleLength()));
          }
          hv_XCoord.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XCoord = (hv_XValues_COPY_INP_TMP-hv_XAxisStartValue)*hv_XScaleFactor;
          }
        }
        else
        {
          //Display tick values.
          if ((int)(new HTuple(hv_XTicks.TupleEqual("min_max_origin"))) != 0)
          {
            //Calculate 'min_max_origin' tick coordinates.
            if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
            {
              hv_XTickValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_XTickValues = new HTuple();
              hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
              }
            }
            else
            {
              hv_XTickValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_XTickValues = new HTuple();
              hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
              }
            }
          }
          else
          {
            //Calculate equidistant tick coordinates.
            hv_XTickStart.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XTickStart = (((hv_XAxisStartValue/hv_XTicks)).TupleCeil()
                )*hv_XTicks;
            }
            hv_XTickValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XTickValues = HTuple.TupleGenSequence(
                hv_XTickStart,hv_XAxisEndValue,hv_XTicks);
            }
          }
          //Remove ticks that are smaller than the x-axis start.
          hv_Indices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Indices = ((hv_XTickValues.TupleLessElem(
              hv_XAxisStartValue))).TupleFind(1);
          }
          hv_XCoord.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XCoord = (hv_XTickValues-hv_XAxisStartValue)*hv_XScaleFactor;
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_XCoord = hv_XCoord.TupleRemove(
              hv_Indices);
          hv_XCoord.Dispose();
          hv_XCoord = ExpTmpLocalVar_XCoord;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleRemove(
              hv_Indices);
          hv_XTickValues.Dispose();
          hv_XTickValues = ExpTmpLocalVar_XTickValues;
          }
          }
          //
          if ((int)(new HTuple(hv_FormatX.TupleEqual("default"))) != 0)
          {
            hv_TypeTicks.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TypeTicks = hv_XTicks.TupleType()
                ;
            }
            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
            {
              //String ('min_max_origin').
              //Format depends on actual values.
              hv_TypeTicks.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TypeTicks = hv_XTickValues.TupleType()
                  ;
              }
            }
            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
            {
              //Round to integer.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleInt()
                  ;
              hv_XTickValues.Dispose();
              hv_XTickValues = ExpTmpLocalVar_XTickValues;
              }
              }
            }
            else
            {
              //Use floating point numbers.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                  ".2f");
              hv_XTickValues.Dispose();
              hv_XTickValues = ExpTmpLocalVar_XTickValues;
              }
              }
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                hv_FormatX);
            hv_XTickValues.Dispose();
            hv_XTickValues = ExpTmpLocalVar_XTickValues;
            }
            }
          }
        }
        //Generate and display ticks.
        for (hv_IndexTicks=0; (int)hv_IndexTicks<=(int)((new HTuple(hv_XTickValues.TupleLength()
            ))-1); hv_IndexTicks = (int)hv_IndexTicks + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Ascent1.Dispose();hv_Descent1.Dispose();hv_TextWidthXTicks.Dispose();hv_TextHeightXTicks.Dispose();
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XTickValues.TupleSelect(
              hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthXTicks, 
              out hv_TextHeightXTicks);
          }
          if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ContourXTick.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, (((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)).TupleConcat(
                ((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)-5), ((hv_LeftBorder+(hv_XCoord.TupleSelect(
                hv_IndexTicks)))).TupleConcat(hv_LeftBorder+(hv_XCoord.TupleSelect(
                hv_IndexTicks))));
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                  hv_IndexTicks), "image", ((hv_Height-hv_LowerBorder)+2)-hv_XAxisOffsetPx, 
                  (hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexTicks)))-(0.5*hv_TextWidthXTicks), 
                  hv_AxesColor, "box", "false");
              }
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ContourXTick.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, ((((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)+5)).TupleConcat(
                (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx), ((hv_LeftBorder+(hv_XCoord.TupleSelect(
                hv_IndexTicks)))).TupleConcat(hv_LeftBorder+(hv_XCoord.TupleSelect(
                hv_IndexTicks))));
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                  hv_IndexTicks), "image", ((hv_Height-hv_LowerBorder)-(2*hv_TextHeightXTicks))-hv_XAxisOffsetPx, 
                  (hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexTicks)))-(0.5*hv_TextWidthXTicks), 
                  hv_AxesColor, "box", "false");
              }
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ContourXTick, HDevWindowStack.GetActive());
          }
        }
      }
      //
      if ((int)(new HTuple(hv_YTicks.TupleNotEqual("none"))) != 0)
      {
        //
        //Display y ticks.

        if ((int)(new HTuple(hv_YTicks.TupleEqual("min_max_origin"))) != 0)
        {
          //Calculate 'min_max_origin' tick coordinates.
          if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
          {
            hv_YTickValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YTickValues = new HTuple();
            hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
            }
          }
          else
          {
            hv_YTickValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YTickValues = new HTuple();
            hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
            }
          }
        }
        else
        {
          //Calculate equidistant tick coordinates.
          hv_YTickStart.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YTickStart = (((hv_YAxisStartValue/hv_YTicks)).TupleCeil()
              )*hv_YTicks;
          }
          hv_YTickValues.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YTickValues = HTuple.TupleGenSequence(
              hv_YTickStart,hv_YAxisEndValue,hv_YTicks);
          }
        }

        //Remove ticks that are smaller than the y-axis start.
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = ((hv_YTickValues.TupleLessElem(
            hv_YAxisStartValue))).TupleFind(1);
        }
        hv_YCoord.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YCoord = (hv_YTickValues-hv_YAxisStartValue)*hv_YScaleFactor;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_YCoord = hv_YCoord.TupleRemove(
            hv_Indices);
        hv_YCoord.Dispose();
        hv_YCoord = ExpTmpLocalVar_YCoord;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleRemove(
            hv_Indices);
        hv_YTickValues.Dispose();
        hv_YTickValues = ExpTmpLocalVar_YTickValues;
        }
        }
        //
        if ((int)(hv_PlotYLog) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_YTickValues = (new HTuple(10)).TuplePow(
              hv_YTickValues);
          hv_YTickValues.Dispose();
          hv_YTickValues = ExpTmpLocalVar_YTickValues;
          }
          }
        }
        if ((int)(new HTuple(hv_FormatY.TupleEqual("default"))) != 0)
        {
          hv_TypeTicks.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TypeTicks = hv_YTicks.TupleType()
              ;
          }
          if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
          {
            //String ('min_max_origin').
            //Format depends on actual values.
            hv_TypeTicks.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TypeTicks = hv_YTickValues.TupleType()
                ;
            }
          }
          if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
          {
            //Round to integer.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleInt()
                ;
            hv_YTickValues.Dispose();
            hv_YTickValues = ExpTmpLocalVar_YTickValues;
            }
            }
          }
          else
          {
            //Use floating point numbers.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
                ".2f");
            hv_YTickValues.Dispose();
            hv_YTickValues = ExpTmpLocalVar_YTickValues;
            }
            }
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
              hv_FormatY);
          hv_YTickValues.Dispose();
          hv_YTickValues = ExpTmpLocalVar_YTickValues;
          }
          }
        }
        //Generate and display ticks.
        for (hv_IndexTicks=0; (int)hv_IndexTicks<=(int)((new HTuple(hv_YTickValues.TupleLength()
            ))-1); hv_IndexTicks = (int)hv_IndexTicks + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Ascent1.Dispose();hv_Descent1.Dispose();hv_TextWidthYTicks.Dispose();hv_TextHeightYTicks.Dispose();
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YTickValues.TupleSelect(
              hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthYTicks, 
              out hv_TextHeightYTicks);
          }
          //Since we only deal with numbers, use the Ascent as text height.
          hv_TextHeightYTicks.Dispose();
          hv_TextHeightYTicks = new HTuple(hv_Ascent);
          if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ContourYTick.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                hv_IndexTicks)))).TupleConcat((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                hv_IndexTicks))), ((hv_LeftBorder+hv_YAxisOffsetPx)).TupleConcat(
                (hv_LeftBorder+hv_YAxisOffsetPx)+5));
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                  hv_IndexTicks), "image", (((hv_Height-hv_LowerBorder)-hv_TextHeightYTicks)+3)-(hv_YCoord.TupleSelect(
                  hv_IndexTicks)), ((hv_LeftBorder-hv_TextWidthYTicks)-4)+hv_YAxisOffsetPx, 
                  hv_AxesColor, "box", "false");
              }
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ContourYTick.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                hv_IndexTicks)))).TupleConcat((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                hv_IndexTicks))), (((hv_LeftBorder+hv_YAxisOffsetPx)-5)).TupleConcat(
                hv_LeftBorder+hv_YAxisOffsetPx));
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                  hv_IndexTicks), "image", (((hv_Height-hv_LowerBorder)-hv_TextHeightYTicks)+3)-(hv_YCoord.TupleSelect(
                  hv_IndexTicks)), (hv_LeftBorder+4)+hv_YAxisOffsetPx, hv_AxesColor, 
                  "box", "false");
              }
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ContourYTick, HDevWindowStack.GetActive());
          }
        }
      }
    }
    //
    //Display function plot.
    //
    if ((int)(new HTuple(hv_Color.TupleNotEqual("none"))) != 0)
    {
      if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleNotEqual(new HTuple()))).TupleAnd(
          new HTuple(hv_YValues_COPY_INP_TMP.TupleNotEqual(new HTuple())))) != 0)
      {
        hv_Num.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Num = (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
            ))/(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()));
        }
        //
        //Iterate over all functions to be displayed.
        HTuple end_val616 = hv_Num-1;
        HTuple step_val616 = 1;
        for (hv_I=0; hv_I.Continue(end_val616, step_val616); hv_I = hv_I.TupleAdd(step_val616))
        {
          //Select y values for current function.
          hv_YSelected.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YSelected = hv_YValues_COPY_INP_TMP.TupleSelectRange(
              hv_I*(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())),((hv_I+1)*(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
              )))-1);
          }
          //Set color
          if ((int)(new HTuple(hv_Color.TupleEqual(new HTuple()))) != 0)
          {
            HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
          }
          else
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
                  hv_I%(new HTuple(hv_Color.TupleLength()))));
              }
            }
          }
          //
          //Display in different styles.
          //
          if ((int)((new HTuple(hv_Style.TupleEqual("line"))).TupleOr(new HTuple(hv_Style.TupleEqual(
              new HTuple())))) != 0)
          {
            //Style = Line.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Contour.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour, ((hv_Height-hv_LowerBorder)-(hv_YSelected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
                ((hv_XValues_COPY_INP_TMP*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor));
            }
            //Clip, if necessary.
            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ClipContoursXld(ho_Contour, out ExpTmpOutVar_0, hv_UpperBorder, 
                  hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
              ho_Contour.Dispose();
              ho_Contour = ExpTmpOutVar_0;
              }
            }
            hv_OldLineWidth.Dispose();
            HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_OldLineWidth);
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth.TupleInt()
                  );
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Contour, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_OldLineWidth.TupleInt()
                  );
              }
            }
          }
          else if ((int)(new HTuple(hv_Style.TupleEqual("cross"))) != 0)
          {
            //Style = Cross.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Cross.Dispose();
            HOperatorSet.GenCrossContourXld(out ho_Cross, ((hv_Height-hv_LowerBorder)-(hv_YSelected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
                ((hv_XValues_COPY_INP_TMP*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor), 
                6, 0.785398);
            }
            //Clip, if necessary.
            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ClipContoursXld(ho_Cross, out ExpTmpOutVar_0, hv_UpperBorder, 
                  hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
              ho_Cross.Dispose();
              ho_Cross = ExpTmpOutVar_0;
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
            }
          }
          else if ((int)(new HTuple(hv_Style.TupleEqual("filled"))) != 0)
          {
            //Style = Filled.
            hv_Y1Selected.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Y1Selected = new HTuple();
            hv_Y1Selected = hv_Y1Selected.TupleConcat(0+hv_XAxisPosition);
            hv_Y1Selected = hv_Y1Selected.TupleConcat(hv_YSelected);
            hv_Y1Selected = hv_Y1Selected.TupleConcat(0+hv_XAxisPosition);
            }
            hv_X1Selected.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_X1Selected = new HTuple();
            hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMin()
                );
            hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP);
            hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMax()
                );
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Filled.Dispose();
            HOperatorSet.GenRegionPolygonFilled(out ho_Filled, ((hv_Height-hv_LowerBorder)-(hv_Y1Selected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
                ((hv_X1Selected*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor));
            }
            //Clip, if necessary.
            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ClipRegion(ho_Filled, out ExpTmpOutVar_0, hv_UpperBorder, 
                  hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
              ho_Filled.Dispose();
              ho_Filled = ExpTmpOutVar_0;
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Filled, HDevWindowStack.GetActive());
            }
          }
          else if ((int)(new HTuple(hv_Style.TupleEqual("step"))) != 0)
          {
            ho_Stair.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Stair);
            for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                ))-2); hv_Index = (int)hv_Index + 1)
            {
              hv_Row1.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Row1 = ((hv_Height-hv_LowerBorder)-((hv_YSelected.TupleSelect(
                  hv_Index))*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor);
              }
              hv_Row2.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Row2 = ((hv_Height-hv_LowerBorder)-((hv_YSelected.TupleSelect(
                  hv_Index+1))*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor);
              }
              hv_Col1.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Col1 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                  hv_Index))*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor);
              }
              hv_Col2.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Col2 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                  hv_Index+1))*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor);
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_StairTmp.Dispose();
              HOperatorSet.GenContourPolygonXld(out ho_StairTmp, ((hv_Row1.TupleConcat(
                  hv_Row1))).TupleConcat(hv_Row2), ((hv_Col1.TupleConcat(hv_Col2))).TupleConcat(
                  hv_Col2));
              }
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ConcatObj(ho_Stair, ho_StairTmp, out ExpTmpOutVar_0);
              ho_Stair.Dispose();
              ho_Stair = ExpTmpOutVar_0;
              }
            }
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.UnionAdjacentContoursXld(ho_Stair, out ExpTmpOutVar_0, 0.1, 
                0.1, "attr_keep");
            ho_Stair.Dispose();
            ho_Stair = ExpTmpOutVar_0;
            }
            if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ClipRegion(ho_Stair, out ExpTmpOutVar_0, hv_UpperBorder, 
                  hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
              ho_Stair.Dispose();
              ho_Stair = ExpTmpOutVar_0;
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Stair, HDevWindowStack.GetActive());
            }
          }
          else
          {
            throw new HalconException("Unsupported style: "+hv_Style);
          }
        }
      }
    }
    //
    //
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
    }
    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_OriginStyle);
    HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
    ho_ContourXGrid.Dispose();
    ho_ContourYGrid.Dispose();
    ho_XArrow.Dispose();
    ho_YArrow.Dispose();
    ho_ContourXTick.Dispose();
    ho_ContourYTick.Dispose();
    ho_Contour.Dispose();
    ho_Cross.Dispose();
    ho_Filled.Dispose();
    ho_Stair.Dispose();
    ho_StairTmp.Dispose();

    hv_XValues_COPY_INP_TMP.Dispose();
    hv_YValues_COPY_INP_TMP.Dispose();
    hv_ClipRegion.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_PartRow1.Dispose();
    hv_PartColumn1.Dispose();
    hv_PartRow2.Dispose();
    hv_PartColumn2.Dispose();
    hv_Red.Dispose();
    hv_Green.Dispose();
    hv_Blue.Dispose();
    hv_DrawMode.Dispose();
    hv_OriginStyle.Dispose();
    hv_PartDiffers.Dispose();
    hv_PlotYLog.Dispose();
    hv_YLogIndices.Dispose();
    hv_PlotYLogUser.Dispose();
    hv_IsString.Dispose();
    hv_YInd.Dispose();
    hv_Indices1.Dispose();
    hv_XAxisEndValue.Dispose();
    hv_YAxisEndValue.Dispose();
    hv_XAxisStartValue.Dispose();
    hv_YAxisStartValue.Dispose();
    hv_XValuesAreStrings.Dispose();
    hv_XTickValues.Dispose();
    hv_XTicks.Dispose();
    hv_YAxisPosition.Dispose();
    hv_XAxisPosition.Dispose();
    hv_LeftBorder.Dispose();
    hv_RightBorder.Dispose();
    hv_UpperBorder.Dispose();
    hv_LowerBorder.Dispose();
    hv_AxesColor.Dispose();
    hv_Style.Dispose();
    hv_Clip.Dispose();
    hv_YTicks.Dispose();
    hv_XGrid.Dispose();
    hv_YGrid.Dispose();
    hv_GridColor.Dispose();
    hv_YPosition.Dispose();
    hv_FormatX.Dispose();
    hv_FormatY.Dispose();
    hv_LineWidth.Dispose();
    hv_NumGenParamNames.Dispose();
    hv_NumGenParamValues.Dispose();
    hv_GenParamIndex.Dispose();
    hv_XGridTicks.Dispose();
    hv_YTickDirection.Dispose();
    hv_XTickDirection.Dispose();
    hv_XAxisWidthPx.Dispose();
    hv_XAxisWidth.Dispose();
    hv_XScaleFactor.Dispose();
    hv_YAxisHeightPx.Dispose();
    hv_YAxisHeight.Dispose();
    hv_YScaleFactor.Dispose();
    hv_YAxisOffsetPx.Dispose();
    hv_XAxisOffsetPx.Dispose();
    hv_DotStyle.Dispose();
    hv_XGridValues.Dispose();
    hv_XGridStart.Dispose();
    hv_XCoord.Dispose();
    hv_IndexGrid.Dispose();
    hv_YGridValues.Dispose();
    hv_YGridStart.Dispose();
    hv_YCoord.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_TextWidthXLabel.Dispose();
    hv_TextHeightXLabel.Dispose();
    hv_TextWidthYLabel.Dispose();
    hv_TextHeightYLabel.Dispose();
    hv_XTickStart.Dispose();
    hv_Indices.Dispose();
    hv_TypeTicks.Dispose();
    hv_IndexTicks.Dispose();
    hv_Ascent1.Dispose();
    hv_Descent1.Dispose();
    hv_TextWidthXTicks.Dispose();
    hv_TextHeightXTicks.Dispose();
    hv_YTickValues.Dispose();
    hv_YTickStart.Dispose();
    hv_TextWidthYTicks.Dispose();
    hv_TextHeightYTicks.Dispose();
    hv_Num.Dispose();
    hv_I.Dispose();
    hv_YSelected.Dispose();
    hv_OldLineWidth.Dispose();
    hv_Y1Selected.Dispose();
    hv_X1Selected.Dispose();
    hv_Index.Dispose();
    hv_Row1.Dispose();
    hv_Row2.Dispose();
    hv_Col1.Dispose();
    hv_Col2.Dispose();

    return;
  }

  // Chapter: File / Misc
  public void prepare_image_lists (HTuple hv_ImageDirs, out HTuple hv_ImageBaseNames, 
      out HTuple hv_ImageExtensions, out HTuple hv_ImageDirectories)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ImageDirIndex = new HTuple(), hv_ImageFilesTmp = new HTuple();
    HTuple hv_ImageBaseNamesTmp = new HTuple(), hv_ImageExtensionsTmp = new HTuple();
    HTuple hv_ImageDirectoriesTmp = new HTuple();
    // Initialize local and output iconic variables 
    hv_ImageBaseNames = new HTuple();
    hv_ImageExtensions = new HTuple();
    hv_ImageDirectories = new HTuple();
    //
    //This procedure returns for all images in ImageDirs:
    //- the base names,
    //- the extensions,
    //- the directories.

    hv_ImageBaseNames.Dispose();
    hv_ImageBaseNames = new HTuple();
    hv_ImageExtensions.Dispose();
    hv_ImageExtensions = new HTuple();
    hv_ImageDirectories.Dispose();
    hv_ImageDirectories = new HTuple();
    for (hv_ImageDirIndex=0; (int)hv_ImageDirIndex<=(int)((new HTuple(hv_ImageDirs.TupleLength()
        ))-1); hv_ImageDirIndex = (int)hv_ImageDirIndex + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageFilesTmp.Dispose();
      list_image_files(hv_ImageDirs.TupleSelect(hv_ImageDirIndex), "default", (new HTuple("recursive")).TupleConcat(
          "follow_links"), out hv_ImageFilesTmp);
      }
      hv_ImageBaseNamesTmp.Dispose();hv_ImageExtensionsTmp.Dispose();hv_ImageDirectoriesTmp.Dispose();
      parse_filename(hv_ImageFilesTmp, out hv_ImageBaseNamesTmp, out hv_ImageExtensionsTmp, 
          out hv_ImageDirectoriesTmp);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageBaseNames = hv_ImageBaseNames.TupleConcat(
          hv_ImageBaseNamesTmp);
      hv_ImageBaseNames.Dispose();
      hv_ImageBaseNames = ExpTmpLocalVar_ImageBaseNames;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageExtensions = hv_ImageExtensions.TupleConcat(
          hv_ImageExtensionsTmp);
      hv_ImageExtensions.Dispose();
      hv_ImageExtensions = ExpTmpLocalVar_ImageExtensions;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageDirectories = hv_ImageDirectories.TupleConcat(
          hv_ImageDirectoriesTmp);
      hv_ImageDirectories.Dispose();
      hv_ImageDirectories = ExpTmpLocalVar_ImageDirectories;
      }
      }
    }

    hv_ImageDirIndex.Dispose();
    hv_ImageFilesTmp.Dispose();
    hv_ImageBaseNamesTmp.Dispose();
    hv_ImageExtensionsTmp.Dispose();
    hv_ImageDirectoriesTmp.Dispose();

    return;
  }

  // Chapter: Calibration / Hand-Eye
  // Short Description: Prepares the model to match and grasp. 
  public void prepare_poses_and_rectification_data_moving_cam (HTuple hv_ToolInBasePose, 
      HTuple hv_ObjectHeight, HTuple hv_RectifyImage, HTuple hv_HandEyeCalibData, 
      out HTuple hv_Poses, out HTuple hv_RectificationData)
  {



    // Local iconic variables 

    HObject ho_RegionGrid=null, ho_ContCircle=null;
    HObject ho_ContCircleWorldPlane=null, ho_ImageArea=null;
    HObject ho_RegionBorder=null, ho_RectificationMap=null;

    // Local control variables 

    HTuple hv_CamParam = new HTuple(), hv_ToolInCamPose = new HTuple();
    HTuple hv_PlaneInBasePose0 = new HTuple(), hv_OrderOfTransform = new HTuple();
    HTuple hv_OrderOfRotation = new HTuple(), hv_ViewOfTransform = new HTuple();
    HTuple hv_BaseInToolPose = new HTuple(), hv_BaseInCamPose = new HTuple();
    HTuple hv_PlaneInCamPose0 = new HTuple(), hv_PlaneInCamPose0Rot = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_Qx = new HTuple();
    HTuple hv_Qy = new HTuple(), hv_CosAngleBetweenZAxis = new HTuple();
    HTuple hv_SwitchZDirection = new HTuple(), hv_PlaneInCamPose1 = new HTuple();
    HTuple hv_PlaneInCamPose = new HTuple(), hv_CamInBasePose = new HTuple();
    HTuple hv_PlaneInBasePose = new HTuple(), hv_MatchingPlaneInPlanePose = new HTuple();
    HTuple hv_MatchingPlaneInBasePose = new HTuple(), hv_MatchingPlaneInCamPose = new HTuple();
    HTuple hv_MatchingPlaneRectifiedPartInCamPose = new HTuple();
    HTuple hv_ScaleRectification = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_Rows = new HTuple();
    HTuple hv_Columns = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Phi = new HTuple();
    HTuple hv_Radius1 = new HTuple(), hv_Radius2 = new HTuple();
    HTuple hv_StartPhi = new HTuple(), hv_EndPhi = new HTuple();
    HTuple hv_PointOrder = new HTuple(), hv_ClipRegion = new HTuple();
    HTuple hv_BorderRows = new HTuple(), hv_BorderColumns = new HTuple();
    HTuple hv_BorderX = new HTuple(), hv_BorderY = new HTuple();
    HTuple hv_MatchingPlaneRectifiedPartInMatchingPlanePose = new HTuple();
    HTuple hv_WidthRect = new HTuple(), hv_HeightRect = new HTuple();
    HTuple hv_ModelInPlanePose = new HTuple(), hv_PlaneInModelPose = new HTuple();
    HTuple   hv_ToolInBasePose_COPY_INP_TMP = new HTuple(hv_ToolInBasePose);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_RegionGrid);
    HOperatorSet.GenEmptyObj(out ho_ContCircle);
    HOperatorSet.GenEmptyObj(out ho_ContCircleWorldPlane);
    HOperatorSet.GenEmptyObj(out ho_ImageArea);
    HOperatorSet.GenEmptyObj(out ho_RegionBorder);
    HOperatorSet.GenEmptyObj(out ho_RectificationMap);
    hv_Poses = new HTuple();
    hv_RectificationData = new HTuple();
    //Prepare the needed poses to match and grasp, and compute the rectification map.
    //
    //RectifyImage Parameter can have one of the following 3 values:
    //'no_rectification', 'align_and_rectify', or 'only_rectify'
    //
    hv_CamParam.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "CamParam", out hv_CamParam);
    hv_ToolInCamPose.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "ToolInCamPose", out hv_ToolInCamPose);
    hv_PlaneInBasePose0.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "PlaneInBasePose0", out hv_PlaneInBasePose0);
    //
    //Check input
    if ((int)(new HTuple(hv_ObjectHeight.TupleLess(0.0))) != 0)
    {
      throw new HalconException("The parameter ObjectHeight cannot be negative");
    }
    if ((int)(new HTuple(((hv_CamParam.TupleSelect(0))).TupleEqual("line_scan"))) != 0)
    {
      throw new HalconException("Line-scan cameras are not supported");
    }
    //
    //Keep track of the pose type used by the robot.
    hv_OrderOfTransform.Dispose();hv_OrderOfRotation.Dispose();hv_ViewOfTransform.Dispose();
    HOperatorSet.GetPoseType(hv_ToolInBasePose_COPY_INP_TMP, out hv_OrderOfTransform, 
        out hv_OrderOfRotation, out hv_ViewOfTransform);
    //Convert to default pose type.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_ToolInBasePose_COPY_INP_TMP, "Rp+T", "gba", "point", 
        out ExpTmpOutVar_0);
    hv_ToolInBasePose_COPY_INP_TMP.Dispose();
    hv_ToolInBasePose_COPY_INP_TMP = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_ToolInCamPose, "Rp+T", "gba", "point", out ExpTmpOutVar_0);
    hv_ToolInCamPose.Dispose();
    hv_ToolInCamPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInBasePose0, "Rp+T", "gba", "point", out ExpTmpOutVar_0);
    hv_PlaneInBasePose0.Dispose();
    hv_PlaneInBasePose0 = ExpTmpOutVar_0;
    }
    //
    //Create the plane for matching and adapt the PlaneInBasePose0 such
    //that the z-axis of the plane points away from the reference camera,
    //and x/y coordinates are aligned with the current image, i.e.
    //PlaneInCamPose0 has Rot_z=0.
    hv_BaseInToolPose.Dispose();
    HOperatorSet.PoseInvert(hv_ToolInBasePose_COPY_INP_TMP, out hv_BaseInToolPose);
    hv_BaseInCamPose.Dispose();
    HOperatorSet.PoseCompose(hv_ToolInCamPose, hv_BaseInToolPose, out hv_BaseInCamPose);
    hv_PlaneInCamPose0.Dispose();
    HOperatorSet.PoseCompose(hv_BaseInCamPose, hv_PlaneInBasePose0, out hv_PlaneInCamPose0);
    //The z-axis of the plane should point away from the camera.
    hv_PlaneInCamPose0Rot.Dispose();
    hv_PlaneInCamPose0Rot = new HTuple(hv_PlaneInCamPose0);
    if (hv_PlaneInCamPose0Rot == null)
      hv_PlaneInCamPose0Rot = new HTuple();
    hv_PlaneInCamPose0Rot[HTuple.TupleGenSequence(0,2,1)] = ((new HTuple(0)).TupleConcat(
        0)).TupleConcat(0);
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_PlaneInCamPose0Rot, out hv_HomMat3D);
    hv_Qx.Dispose();hv_Qy.Dispose();hv_CosAngleBetweenZAxis.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, 0, 0, 1, out hv_Qx, out hv_Qy, out hv_CosAngleBetweenZAxis);
    if ((int)(new HTuple(hv_CosAngleBetweenZAxis.TupleLess(0))) != 0)
    {
      hv_SwitchZDirection.Dispose();
      HOperatorSet.CreatePose(0, 0, 0, 180, 0, 0, "Rp+T", "gba", "point", out hv_SwitchZDirection);
      hv_PlaneInCamPose1.Dispose();
      HOperatorSet.PoseCompose(hv_PlaneInCamPose0, hv_SwitchZDirection, out hv_PlaneInCamPose1);
      hv_PlaneInCamPose0.Dispose();
      hv_PlaneInCamPose0 = new HTuple(hv_PlaneInCamPose1);
    }
    //Align with the current image.
    hv_PlaneInCamPose.Dispose();
    hv_PlaneInCamPose = new HTuple(hv_PlaneInCamPose0);
    if (hv_PlaneInCamPose == null)
      hv_PlaneInCamPose = new HTuple();
    hv_PlaneInCamPose[5] = 0.0;
    //Adapt the PlaneInBasePose.
    hv_CamInBasePose.Dispose();
    HOperatorSet.PoseInvert(hv_BaseInCamPose, out hv_CamInBasePose);
    hv_PlaneInBasePose.Dispose();
    HOperatorSet.PoseCompose(hv_CamInBasePose, hv_PlaneInCamPose, out hv_PlaneInBasePose);
    //
    //Create the plane for matching.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MatchingPlaneInPlanePose.Dispose();
    HOperatorSet.CreatePose(0, 0, -hv_ObjectHeight, 0, 0, 0, "Rp+T", "gba", "point", 
        out hv_MatchingPlaneInPlanePose);
    }
    hv_MatchingPlaneInBasePose.Dispose();
    HOperatorSet.PoseCompose(hv_PlaneInBasePose, hv_MatchingPlaneInPlanePose, out hv_MatchingPlaneInBasePose);
    hv_MatchingPlaneInCamPose.Dispose();
    HOperatorSet.PoseCompose(hv_PlaneInCamPose, hv_MatchingPlaneInPlanePose, out hv_MatchingPlaneInCamPose);
    //
    if ((int)(new HTuple(hv_RectifyImage.TupleEqual("no_rectification"))) != 0)
    {
      hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
      hv_MatchingPlaneRectifiedPartInCamPose = new HTuple(hv_MatchingPlaneInCamPose);
      hv_ScaleRectification.Dispose();
      hv_ScaleRectification = new HTuple();
    }
    else if ((int)((new HTuple(hv_RectifyImage.TupleEqual("only_rectify"))).TupleOr(
        new HTuple(hv_RectifyImage.TupleEqual("align_and_rectify")))) != 0)
    {
      //Determine the scale such that the mapped image has at least
      //the same resolution as the current image.
      hv_Width.Dispose();
      get_cam_par_data(hv_CamParam, "image_width", out hv_Width);
      hv_Height.Dispose();
      get_cam_par_data(hv_CamParam, "image_height", out hv_Height);
      ho_RegionGrid.Dispose();
      HOperatorSet.GenGridRegion(out ho_RegionGrid, 20, 20, "points", hv_Width, hv_Height);
      hv_Rows.Dispose();hv_Columns.Dispose();
      HOperatorSet.GetRegionPoints(ho_RegionGrid, out hv_Rows, out hv_Columns);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ContCircle.Dispose();
      HOperatorSet.GenCircleContourXld(out ho_ContCircle, hv_Rows, hv_Columns, HTuple.TupleGenConst(
          new HTuple(hv_Rows.TupleLength()),1.0), 0, 6.28318, "positive", 0.1);
      }
      ho_ContCircleWorldPlane.Dispose();
      HOperatorSet.ContourToWorldPlaneXld(ho_ContCircle, out ho_ContCircleWorldPlane, 
          hv_CamParam, hv_MatchingPlaneInCamPose, "m");
      hv_Row.Dispose();hv_Column.Dispose();hv_Phi.Dispose();hv_Radius1.Dispose();hv_Radius2.Dispose();hv_StartPhi.Dispose();hv_EndPhi.Dispose();hv_PointOrder.Dispose();
      HOperatorSet.FitEllipseContourXld(ho_ContCircleWorldPlane, "fitzgibbon", -1, 
          0, 0, 200, 3, 2, out hv_Row, out hv_Column, out hv_Phi, out hv_Radius1, 
          out hv_Radius2, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);
      hv_ScaleRectification.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ScaleRectification = hv_Radius2.TupleMin()
          ;
      }
      //
      //Rectify the current image and create the shape model.
      //
      //The image dimensions should cover the entire original field
      //of view in the current rectification.
      //Look at border of the current image in the world plane.
      hv_ClipRegion.Dispose();
      HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
      HOperatorSet.SetSystem("clip_region", "false");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ImageArea.Dispose();
      HOperatorSet.GenRectangle1(out ho_ImageArea, 0, 0, hv_Height-1, hv_Width-1);
      }
      ho_RegionBorder.Dispose();
      HOperatorSet.Boundary(ho_ImageArea, out ho_RegionBorder, "outer");
      HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
      hv_BorderRows.Dispose();hv_BorderColumns.Dispose();
      HOperatorSet.GetRegionPoints(ho_RegionBorder, out hv_BorderRows, out hv_BorderColumns);
      hv_BorderX.Dispose();hv_BorderY.Dispose();
      HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, 
          hv_BorderRows, hv_BorderColumns, "m", out hv_BorderX, out hv_BorderY);
      //Adapt parameters.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MatchingPlaneRectifiedPartInMatchingPlanePose.Dispose();
      HOperatorSet.CreatePose(hv_BorderX.TupleMin(), hv_BorderY.TupleMin(), 0, 0, 
          0, 0, "Rp+T", "gba", "point", out hv_MatchingPlaneRectifiedPartInMatchingPlanePose);
      }
      hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
      HOperatorSet.PoseCompose(hv_MatchingPlaneInCamPose, hv_MatchingPlaneRectifiedPartInMatchingPlanePose, 
          out hv_MatchingPlaneRectifiedPartInCamPose);
      hv_WidthRect.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WidthRect = (((((hv_BorderX.TupleMax()
          )-(hv_BorderX.TupleMin()))/hv_ScaleRectification)+0.5)).TupleInt();
      }
      hv_HeightRect.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HeightRect = (((((hv_BorderY.TupleMax()
          )-(hv_BorderY.TupleMin()))/hv_ScaleRectification)+0.5)).TupleInt();
      }
      //
      //Create a map for repeated use.
      ho_RectificationMap.Dispose();
      HOperatorSet.GenImageToWorldPlaneMap(out ho_RectificationMap, hv_CamParam, 
          hv_MatchingPlaneInCamPose, hv_Width, hv_Height, hv_WidthRect, hv_HeightRect, 
          hv_ScaleRectification, "bilinear");
    }
    else
    {
      throw new HalconException("Please set the parameter RectifyImage correctly");
    }
    //Convert to output pose type.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInCamPose, hv_OrderOfTransform, hv_OrderOfRotation, 
        hv_ViewOfTransform, out ExpTmpOutVar_0);
    hv_PlaneInCamPose.Dispose();
    hv_PlaneInCamPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_CamInBasePose, hv_OrderOfTransform, hv_OrderOfRotation, 
        hv_ViewOfTransform, out ExpTmpOutVar_0);
    hv_CamInBasePose.Dispose();
    hv_CamInBasePose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInBasePose, hv_OrderOfTransform, hv_OrderOfRotation, 
        hv_ViewOfTransform, out ExpTmpOutVar_0);
    hv_PlaneInBasePose.Dispose();
    hv_PlaneInBasePose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_MatchingPlaneInCamPose, hv_OrderOfTransform, 
        hv_OrderOfRotation, hv_ViewOfTransform, out ExpTmpOutVar_0);
    hv_MatchingPlaneInCamPose.Dispose();
    hv_MatchingPlaneInCamPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_MatchingPlaneInBasePose, hv_OrderOfTransform, 
        hv_OrderOfRotation, hv_ViewOfTransform, out ExpTmpOutVar_0);
    hv_MatchingPlaneInBasePose.Dispose();
    hv_MatchingPlaneInBasePose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_MatchingPlaneRectifiedPartInCamPose, hv_OrderOfTransform, 
        hv_OrderOfRotation, hv_ViewOfTransform, out ExpTmpOutVar_0);
    hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
    hv_MatchingPlaneRectifiedPartInCamPose = ExpTmpOutVar_0;
    }
    //
    hv_ModelInPlanePose.Dispose();
    HOperatorSet.CreatePose(0, 0, hv_ObjectHeight, 180, 0, 0, "Rp+T", "gba", "point", 
        out hv_ModelInPlanePose);
    //Remember the transformation.
    hv_PlaneInModelPose.Dispose();
    HOperatorSet.PoseInvert(hv_ModelInPlanePose, out hv_PlaneInModelPose);
    //
    //Create dict for Poses.
    hv_Poses.Dispose();
    HOperatorSet.CreateDict(out hv_Poses);
    HOperatorSet.SetDictTuple(hv_Poses, "PlaneInCamPose", hv_PlaneInCamPose);
    HOperatorSet.SetDictTuple(hv_Poses, "CamInBasePose", hv_CamInBasePose);
    HOperatorSet.SetDictTuple(hv_Poses, "PlaneInBasePose", hv_PlaneInBasePose);
    HOperatorSet.SetDictTuple(hv_Poses, "MatchingPlaneInCamPose", hv_MatchingPlaneInCamPose);
    HOperatorSet.SetDictTuple(hv_Poses, "MatchingPlaneInBasePose", hv_MatchingPlaneInBasePose);
    HOperatorSet.SetDictTuple(hv_Poses, "PlaneInModelPose", hv_PlaneInModelPose);
    //
    //Create dict for rectification data.
    hv_RectificationData.Dispose();
    HOperatorSet.CreateDict(out hv_RectificationData);
    HOperatorSet.SetDictTuple(hv_RectificationData, "RectifyImage", hv_RectifyImage);
    if ((int)(new HTuple(hv_RectifyImage.TupleNotEqual("no_rectification"))) != 0)
    {
      HOperatorSet.SetDictTuple(hv_RectificationData, "ScaleRectification", hv_ScaleRectification);
      HOperatorSet.SetDictObject(ho_RectificationMap, hv_RectificationData, "RectificationMap");
    }
    HOperatorSet.SetDictTuple(hv_RectificationData, "MatchingPlaneRectifiedPartInCamPose", 
        hv_MatchingPlaneRectifiedPartInCamPose);
    ho_RegionGrid.Dispose();
    ho_ContCircle.Dispose();
    ho_ContCircleWorldPlane.Dispose();
    ho_ImageArea.Dispose();
    ho_RegionBorder.Dispose();
    ho_RectificationMap.Dispose();

    hv_ToolInBasePose_COPY_INP_TMP.Dispose();
    hv_CamParam.Dispose();
    hv_ToolInCamPose.Dispose();
    hv_PlaneInBasePose0.Dispose();
    hv_OrderOfTransform.Dispose();
    hv_OrderOfRotation.Dispose();
    hv_ViewOfTransform.Dispose();
    hv_BaseInToolPose.Dispose();
    hv_BaseInCamPose.Dispose();
    hv_PlaneInCamPose0.Dispose();
    hv_PlaneInCamPose0Rot.Dispose();
    hv_HomMat3D.Dispose();
    hv_Qx.Dispose();
    hv_Qy.Dispose();
    hv_CosAngleBetweenZAxis.Dispose();
    hv_SwitchZDirection.Dispose();
    hv_PlaneInCamPose1.Dispose();
    hv_PlaneInCamPose.Dispose();
    hv_CamInBasePose.Dispose();
    hv_PlaneInBasePose.Dispose();
    hv_MatchingPlaneInPlanePose.Dispose();
    hv_MatchingPlaneInBasePose.Dispose();
    hv_MatchingPlaneInCamPose.Dispose();
    hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
    hv_ScaleRectification.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Phi.Dispose();
    hv_Radius1.Dispose();
    hv_Radius2.Dispose();
    hv_StartPhi.Dispose();
    hv_EndPhi.Dispose();
    hv_PointOrder.Dispose();
    hv_ClipRegion.Dispose();
    hv_BorderRows.Dispose();
    hv_BorderColumns.Dispose();
    hv_BorderX.Dispose();
    hv_BorderY.Dispose();
    hv_MatchingPlaneRectifiedPartInMatchingPlanePose.Dispose();
    hv_WidthRect.Dispose();
    hv_HeightRect.Dispose();
    hv_ModelInPlanePose.Dispose();
    hv_PlaneInModelPose.Dispose();

    return;
  }

  // Chapter: Calibration / Hand-Eye
  // Short Description: Prepares the model to match and grasp in a stationary camera setup. 
  public void prepare_poses_and_rectification_data_stationary_cam (HTuple hv_ObjectHeight, 
      HTuple hv_RectifyImage, HTuple hv_HandEyeCalibData, out HTuple hv_Poses, out HTuple hv_RectificationData)
  {



    // Local iconic variables 

    HObject ho_RegionGrid=null, ho_ContCircle=null;
    HObject ho_ContCircleWorldPlane=null, ho_ImageArea=null;
    HObject ho_RegionBorder=null, ho_RectificationMap=null;

    // Local control variables 

    HTuple hv_CamParam = new HTuple(), hv_PlaneInCamPose0 = new HTuple();
    HTuple hv_OrderOfTransform = new HTuple(), hv_OrderOfRotation = new HTuple();
    HTuple hv_ViewOfTransform = new HTuple(), hv_PlaneInCamPose0Rot = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_Qx = new HTuple();
    HTuple hv_Qy = new HTuple(), hv_CosAngleBetweenZAxis = new HTuple();
    HTuple hv_SwitchZDirection = new HTuple(), hv_PlaneInCamPose = new HTuple();
    HTuple hv_MatchingPlaneInPlanePose = new HTuple(), hv_MatchingPlaneInCamPose = new HTuple();
    HTuple hv_ScaleRectification = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_Rows = new HTuple();
    HTuple hv_Columns = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Phi = new HTuple();
    HTuple hv_Radius1 = new HTuple(), hv_Radius2 = new HTuple();
    HTuple hv_StartPhi = new HTuple(), hv_EndPhi = new HTuple();
    HTuple hv_PointOrder = new HTuple(), hv_ClipRegion = new HTuple();
    HTuple hv_BorderRows = new HTuple(), hv_BorderColumns = new HTuple();
    HTuple hv_BorderX = new HTuple(), hv_BorderY = new HTuple();
    HTuple hv_PoseOffset = new HTuple(), hv_WidthRect = new HTuple();
    HTuple hv_HeightRect = new HTuple(), hv_ModelInPlanePose = new HTuple();
    HTuple hv_PlaneInModelPose = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_RegionGrid);
    HOperatorSet.GenEmptyObj(out ho_ContCircle);
    HOperatorSet.GenEmptyObj(out ho_ContCircleWorldPlane);
    HOperatorSet.GenEmptyObj(out ho_ImageArea);
    HOperatorSet.GenEmptyObj(out ho_RegionBorder);
    HOperatorSet.GenEmptyObj(out ho_RectificationMap);
    hv_Poses = new HTuple();
    hv_RectificationData = new HTuple();
    //Prepare the needed poses to match and grasp, and compute the rectification
    //map in case rectification is set by the user.
    //
    hv_CamParam.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "CamParam", out hv_CamParam);
    hv_PlaneInCamPose0.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "PlaneInCamPose0", out hv_PlaneInCamPose0);
    //
    //Check input
    if ((int)(new HTuple(hv_ObjectHeight.TupleLess(0.0))) != 0)
    {
      throw new HalconException("The parameter ObjectHeight cannot be negative");
    }
    if ((int)(new HTuple(((hv_CamParam.TupleSelect(0))).TupleEqual("line_scan"))) != 0)
    {
      throw new HalconException("Line-scan cameras are not supported");
    }
    //Keep track of the pose type used by the robot.
    hv_OrderOfTransform.Dispose();hv_OrderOfRotation.Dispose();hv_ViewOfTransform.Dispose();
    HOperatorSet.GetPoseType(hv_PlaneInCamPose0, out hv_OrderOfTransform, out hv_OrderOfRotation, 
        out hv_ViewOfTransform);
    //Convert to default pose type.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInCamPose0, "Rp+T", "gba", "point", out ExpTmpOutVar_0);
    hv_PlaneInCamPose0.Dispose();
    hv_PlaneInCamPose0 = ExpTmpOutVar_0;
    }
    //The z-axis of the plane should point away from the camera.
    hv_PlaneInCamPose0Rot.Dispose();
    hv_PlaneInCamPose0Rot = new HTuple(hv_PlaneInCamPose0);
    if (hv_PlaneInCamPose0Rot == null)
      hv_PlaneInCamPose0Rot = new HTuple();
    hv_PlaneInCamPose0Rot[HTuple.TupleGenSequence(0,2,1)] = ((new HTuple(0)).TupleConcat(
        0)).TupleConcat(0);
    hv_HomMat3D.Dispose();
    HOperatorSet.PoseToHomMat3d(hv_PlaneInCamPose0Rot, out hv_HomMat3D);
    hv_Qx.Dispose();hv_Qy.Dispose();hv_CosAngleBetweenZAxis.Dispose();
    HOperatorSet.AffineTransPoint3d(hv_HomMat3D, 0, 0, 1, out hv_Qx, out hv_Qy, out hv_CosAngleBetweenZAxis);
    if ((int)(new HTuple(hv_CosAngleBetweenZAxis.TupleLess(0))) != 0)
    {
      hv_SwitchZDirection.Dispose();
      HOperatorSet.CreatePose(0, 0, 0, 180, 0, 0, "Rp+T", "gba", "point", out hv_SwitchZDirection);
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.PoseCompose(hv_PlaneInCamPose0, hv_SwitchZDirection, out ExpTmpOutVar_0);
      hv_PlaneInCamPose0.Dispose();
      hv_PlaneInCamPose0 = ExpTmpOutVar_0;
      }
    }
    //Align with the current image.
    hv_PlaneInCamPose.Dispose();
    hv_PlaneInCamPose = new HTuple(hv_PlaneInCamPose0);
    if (hv_PlaneInCamPose == null)
      hv_PlaneInCamPose = new HTuple();
    hv_PlaneInCamPose[5] = 0.0;
    //
    //Create the plane for matching.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MatchingPlaneInPlanePose.Dispose();
    HOperatorSet.CreatePose(0, 0, -hv_ObjectHeight, 0, 0, 0, "Rp+T", "gba", "point", 
        out hv_MatchingPlaneInPlanePose);
    }
    hv_MatchingPlaneInCamPose.Dispose();
    HOperatorSet.PoseCompose(hv_PlaneInCamPose, hv_MatchingPlaneInPlanePose, out hv_MatchingPlaneInCamPose);
    //
    if ((int)(new HTuple(hv_RectifyImage.TupleEqual("false"))) != 0)
    {
      hv_ScaleRectification.Dispose();
      hv_ScaleRectification = new HTuple();
    }
    else if ((int)(new HTuple(hv_RectifyImage.TupleEqual("true"))) != 0)
    {
      //Determine the scale such that the mapped image has at least the same
      //resolution as the current image.
      hv_Width.Dispose();
      get_cam_par_data(hv_CamParam, "image_width", out hv_Width);
      hv_Height.Dispose();
      get_cam_par_data(hv_CamParam, "image_height", out hv_Height);
      ho_RegionGrid.Dispose();
      HOperatorSet.GenGridRegion(out ho_RegionGrid, 20, 20, "points", hv_Width, hv_Height);
      hv_Rows.Dispose();hv_Columns.Dispose();
      HOperatorSet.GetRegionPoints(ho_RegionGrid, out hv_Rows, out hv_Columns);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ContCircle.Dispose();
      HOperatorSet.GenCircleContourXld(out ho_ContCircle, hv_Rows, hv_Columns, HTuple.TupleGenConst(
          new HTuple(hv_Rows.TupleLength()),1.0), 0, 6.28318, "positive", 0.1);
      }
      ho_ContCircleWorldPlane.Dispose();
      HOperatorSet.ContourToWorldPlaneXld(ho_ContCircle, out ho_ContCircleWorldPlane, 
          hv_CamParam, hv_MatchingPlaneInCamPose, "m");
      hv_Row.Dispose();hv_Column.Dispose();hv_Phi.Dispose();hv_Radius1.Dispose();hv_Radius2.Dispose();hv_StartPhi.Dispose();hv_EndPhi.Dispose();hv_PointOrder.Dispose();
      HOperatorSet.FitEllipseContourXld(ho_ContCircleWorldPlane, "fitzgibbon", -1, 
          0, 0, 200, 3, 2, out hv_Row, out hv_Column, out hv_Phi, out hv_Radius1, 
          out hv_Radius2, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);
      hv_ScaleRectification.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ScaleRectification = hv_Radius2.TupleMin()
          ;
      }
      //
      //Rectify the current image and create the shape model.
      //
      //The image dimensions should cover the entire original field of view
      //in the current rectification.
      //Look at border of the current image in the world plane.
      hv_ClipRegion.Dispose();
      HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
      HOperatorSet.SetSystem("clip_region", "false");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ImageArea.Dispose();
      HOperatorSet.GenRectangle1(out ho_ImageArea, 0, 0, hv_Height-1, hv_Width-1);
      }
      ho_RegionBorder.Dispose();
      HOperatorSet.Boundary(ho_ImageArea, out ho_RegionBorder, "outer");
      HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
      hv_BorderRows.Dispose();hv_BorderColumns.Dispose();
      HOperatorSet.GetRegionPoints(ho_RegionBorder, out hv_BorderRows, out hv_BorderColumns);
      hv_BorderX.Dispose();hv_BorderY.Dispose();
      HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, 
          hv_BorderRows, hv_BorderColumns, "m", out hv_BorderX, out hv_BorderY);
      //Adapt parameters.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PoseOffset.Dispose();
      HOperatorSet.CreatePose(hv_BorderX.TupleMin(), hv_BorderY.TupleMin(), 0, 0, 
          0, 0, "Rp+T", "gba", "point", out hv_PoseOffset);
      }
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.PoseCompose(hv_MatchingPlaneInCamPose, hv_PoseOffset, out ExpTmpOutVar_0);
      hv_MatchingPlaneInCamPose.Dispose();
      hv_MatchingPlaneInCamPose = ExpTmpOutVar_0;
      }
      hv_WidthRect.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WidthRect = (((((hv_BorderX.TupleMax()
          )-(hv_BorderX.TupleMin()))/hv_ScaleRectification)+0.5)).TupleInt();
      }
      hv_HeightRect.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HeightRect = (((((hv_BorderY.TupleMax()
          )-(hv_BorderY.TupleMin()))/hv_ScaleRectification)+0.5)).TupleInt();
      }
      //
      //Create a map for repeated use.
      ho_RectificationMap.Dispose();
      HOperatorSet.GenImageToWorldPlaneMap(out ho_RectificationMap, hv_CamParam, 
          hv_MatchingPlaneInCamPose, hv_Width, hv_Height, hv_WidthRect, hv_HeightRect, 
          hv_ScaleRectification, "bilinear");
    }
    else
    {
      throw new HalconException("Please set the parameter RectifyImage correctly");
    }
    //Convert to output pose type.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_PlaneInCamPose, hv_OrderOfTransform, hv_OrderOfRotation, 
        hv_ViewOfTransform, out ExpTmpOutVar_0);
    hv_PlaneInCamPose.Dispose();
    hv_PlaneInCamPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_MatchingPlaneInCamPose, hv_OrderOfTransform, 
        hv_OrderOfRotation, hv_ViewOfTransform, out ExpTmpOutVar_0);
    hv_MatchingPlaneInCamPose.Dispose();
    hv_MatchingPlaneInCamPose = ExpTmpOutVar_0;
    }
    //
    hv_ModelInPlanePose.Dispose();
    HOperatorSet.CreatePose(0, 0, hv_ObjectHeight, 180, 0, 0, "Rp+T", "gba", "point", 
        out hv_ModelInPlanePose);
    //Remember the transformation.
    hv_PlaneInModelPose.Dispose();
    HOperatorSet.PoseInvert(hv_ModelInPlanePose, out hv_PlaneInModelPose);
    //
    //Create dict for Poses.
    hv_Poses.Dispose();
    HOperatorSet.CreateDict(out hv_Poses);
    HOperatorSet.SetDictTuple(hv_Poses, "PlaneInModelPose", hv_PlaneInModelPose);
    HOperatorSet.SetDictTuple(hv_Poses, "MatchingPlaneInCamPose", hv_MatchingPlaneInCamPose);
    HOperatorSet.SetDictTuple(hv_Poses, "PlaneInCamPose", hv_PlaneInCamPose);
    //
    //Create dict for rectification data.
    hv_RectificationData.Dispose();
    HOperatorSet.CreateDict(out hv_RectificationData);
    HOperatorSet.SetDictTuple(hv_RectificationData, "RectifyImage", hv_RectifyImage);
    if ((int)(new HTuple(hv_RectifyImage.TupleEqual("true"))) != 0)
    {
      HOperatorSet.SetDictTuple(hv_RectificationData, "ScaleRectification", hv_ScaleRectification);
      HOperatorSet.SetDictObject(ho_RectificationMap, hv_RectificationData, "RectificationMap");
    }
    ho_RegionGrid.Dispose();
    ho_ContCircle.Dispose();
    ho_ContCircleWorldPlane.Dispose();
    ho_ImageArea.Dispose();
    ho_RegionBorder.Dispose();
    ho_RectificationMap.Dispose();

    hv_CamParam.Dispose();
    hv_PlaneInCamPose0.Dispose();
    hv_OrderOfTransform.Dispose();
    hv_OrderOfRotation.Dispose();
    hv_ViewOfTransform.Dispose();
    hv_PlaneInCamPose0Rot.Dispose();
    hv_HomMat3D.Dispose();
    hv_Qx.Dispose();
    hv_Qy.Dispose();
    hv_CosAngleBetweenZAxis.Dispose();
    hv_SwitchZDirection.Dispose();
    hv_PlaneInCamPose.Dispose();
    hv_MatchingPlaneInPlanePose.Dispose();
    hv_MatchingPlaneInCamPose.Dispose();
    hv_ScaleRectification.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Phi.Dispose();
    hv_Radius1.Dispose();
    hv_Radius2.Dispose();
    hv_StartPhi.Dispose();
    hv_EndPhi.Dispose();
    hv_PointOrder.Dispose();
    hv_ClipRegion.Dispose();
    hv_BorderRows.Dispose();
    hv_BorderColumns.Dispose();
    hv_BorderX.Dispose();
    hv_BorderY.Dispose();
    hv_PoseOffset.Dispose();
    hv_WidthRect.Dispose();
    hv_HeightRect.Dispose();
    hv_ModelInPlanePose.Dispose();
    hv_PlaneInModelPose.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Preprocess images for deep-learning-based classification training and inference. 
  public void preprocess_dl_classifier_images (HObject ho_Images, out HObject ho_ImagesPreprocessed, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_DLClassifierHandle)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ObjectSelected=null, ho_ThreeChannelImage=null;
    HObject ho_SingleChannelImage=null;

    // Local copy input parameter variables 
    HObject ho_Images_COPY_INP_TMP;
    ho_Images_COPY_INP_TMP = new HObject(ho_Images);



    // Local control variables 

    HTuple hv_ContrastNormalization = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
    HTuple hv_ImageNumChannels = new HTuple(), hv_ImageWidthInput = new HTuple();
    HTuple hv_ImageHeightInput = new HTuple(), hv_EqualWidth = new HTuple();
    HTuple hv_EqualHeight = new HTuple(), hv_Type = new HTuple();
    HTuple hv_NumMatches = new HTuple(), hv_NumImages = new HTuple();
    HTuple hv_EqualByte = new HTuple(), hv_RescaleRange = new HTuple();
    HTuple hv_ImageIndex = new HTuple(), hv_NumChannels = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImagesPreprocessed);
    HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
    HOperatorSet.GenEmptyObj(out ho_ThreeChannelImage);
    HOperatorSet.GenEmptyObj(out ho_SingleChannelImage);
    //This procedure preprocesses the provided images given by Image
    //so that they can be handled by
    //train_dl_classifier_batch and apply_dl_classifier_batch.
    //Note that depending on the images,
    //additional preprocessing steps might be beneficial.
    //
    //Set defaults.
    hv_ContrastNormalization.Dispose();
    hv_ContrastNormalization = "false";
    hv_DomainHandling.Dispose();
    hv_DomainHandling = "full_domain";
    //Set generic parameters.
    for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
        ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
    {
      if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "contrast_normalization"))) != 0)
      {
        //Set 'contrast_normalization'
        hv_ContrastNormalization.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ContrastNormalization = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
          "domain_handling"))) != 0)
      {
        //Set 'domain_handling'
        hv_DomainHandling.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DomainHandling = hv_GenParamValue.TupleSelect(
            hv_GenParamIndex);
        }
      }
      else
      {
        throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
            hv_GenParamIndex)))+"'");
      }
    }
    //
    //Get the network's image requirements
    //from the handle of the classifier
    //and use them as preprocessing parameters.
    //
    //Expected input image size:
    hv_ImageWidth.Dispose();
    HOperatorSet.GetDlClassifierParam(hv_DLClassifierHandle, "image_width", out hv_ImageWidth);
    hv_ImageHeight.Dispose();
    HOperatorSet.GetDlClassifierParam(hv_DLClassifierHandle, "image_height", out hv_ImageHeight);
    //Expected gray value range:
    hv_ImageRangeMin.Dispose();
    HOperatorSet.GetDlClassifierParam(hv_DLClassifierHandle, "image_range_min", out hv_ImageRangeMin);
    hv_ImageRangeMax.Dispose();
    HOperatorSet.GetDlClassifierParam(hv_DLClassifierHandle, "image_range_max", out hv_ImageRangeMax);
    //Expected number of channels:
    hv_ImageNumChannels.Dispose();
    HOperatorSet.GetDlClassifierParam(hv_DLClassifierHandle, "image_num_channels", 
        out hv_ImageNumChannels);
    //
    //Preprocess the images.
    //
    if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.FullDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.CropDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    else
    {
      throw new HalconException("Unsupported parameter value for 'domain_handling'");
    }
    //
    //Zoom images only if they have a different size than the specified size
    hv_ImageWidthInput.Dispose();hv_ImageHeightInput.Dispose();
    HOperatorSet.GetImageSize(ho_Images_COPY_INP_TMP, out hv_ImageWidthInput, out hv_ImageHeightInput);
    hv_EqualWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EqualWidth = hv_ImageWidth.TupleEqualElem(
        hv_ImageWidthInput);
    }
    hv_EqualHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EqualHeight = hv_ImageHeight.TupleEqualElem(
        hv_ImageHeightInput);
    }
    if ((int)((new HTuple(((hv_EqualWidth.TupleMin())).TupleEqual(0))).TupleOr(new HTuple(((hv_EqualHeight.TupleMin()
        )).TupleEqual(0)))) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ZoomImageSize(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, hv_ImageWidth, 
          hv_ImageHeight, "constant");
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    if ((int)(new HTuple(hv_ContrastNormalization.TupleEqual("true"))) != 0)
    {
      //Scale the gray values to [0-255].
      //Note that this converts the image to 'byte'.
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ScaleImageMax(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    else if ((int)(new HTuple(hv_ContrastNormalization.TupleNotEqual("false"))) != 0)
    {
      throw new HalconException("Unsupported parameter value for 'contrast_normalization'");
    }
    //Check the type of the input images.
    //If the type is not 'byte',
    //the gray value scaling does not work correctly.
    hv_Type.Dispose();
    HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_Type);
    hv_NumMatches.Dispose();
    HOperatorSet.TupleRegexpTest(hv_Type, "byte|real", out hv_NumMatches);
    hv_NumImages.Dispose();
    HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
    if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
    {
      throw new HalconException("Please provide only images of type 'byte' or 'real'.");
    }
    hv_EqualByte.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EqualByte = hv_Type.TupleEqualElem(
        "byte");
    }
    if ((int)(new HTuple(((hv_EqualByte.TupleMax())).TupleEqual(1))) != 0)
    {
      if ((int)(new HTuple(((hv_EqualByte.TupleMin())).TupleEqual(0))) != 0)
      {
        throw new HalconException("Passing mixed type images is not supported.");
      }
      //Convert the image type from byte to real,
      //because the classifier expects 'real' images.
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConvertImageType(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, "real");
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
      //Scale/Shift the gray values from [0-255] to the expected range.
      hv_RescaleRange.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RescaleRange = (hv_ImageRangeMax-hv_ImageRangeMin)/255.0;
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ScaleImage(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, hv_RescaleRange, 
          hv_ImageRangeMin);
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    else
    {
      //For real images it is assumed that the range is already correct
    }

    //Check the number of channels.
    hv_NumImages.Dispose();
    HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
    HTuple end_val85 = hv_NumImages;
    HTuple step_val85 = 1;
    for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val85, step_val85); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val85))
    {
      ho_ObjectSelected.Dispose();
      HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ObjectSelected, hv_ImageIndex);
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_ObjectSelected, out hv_NumChannels);
      if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(hv_ImageNumChannels))) != 0)
      {
        //
        if ((int)((new HTuple(hv_NumChannels.TupleEqual(1))).TupleAnd(new HTuple(hv_ImageNumChannels.TupleEqual(
            3)))) != 0)
        {
          //If the image is a grayscale image, but the classifier expects a color image:
          //convert it to an image with three channels.
          ho_ThreeChannelImage.Dispose();
          HOperatorSet.Compose3(ho_ObjectSelected, ho_ObjectSelected, ho_ObjectSelected, 
              out ho_ThreeChannelImage);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ThreeChannelImage, out ExpTmpOutVar_0, 
              hv_ImageIndex);
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        else if ((int)((new HTuple(hv_NumChannels.TupleEqual(3))).TupleAnd(
            new HTuple(hv_ImageNumChannels.TupleEqual(1)))) != 0)
        {
          //If the image is a color image, but the classifier expects a grayscale image:
          //convert it to an image with only one channel.
          ho_SingleChannelImage.Dispose();
          HOperatorSet.Rgb1ToGray(ho_ObjectSelected, out ho_SingleChannelImage);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_SingleChannelImage, 
              out ExpTmpOutVar_0, hv_ImageIndex);
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        else
        {
          throw new HalconException("Number of channels not supported. Please provide a grayscale or an RGB image.");
        }
        //
      }
    }
    ho_ImagesPreprocessed.Dispose();
    ho_ImagesPreprocessed = new HObject(ho_Images_COPY_INP_TMP);
    ho_Images_COPY_INP_TMP.Dispose();
    ho_ObjectSelected.Dispose();
    ho_ThreeChannelImage.Dispose();
    ho_SingleChannelImage.Dispose();

    hv_ContrastNormalization.Dispose();
    hv_DomainHandling.Dispose();
    hv_GenParamIndex.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_ImageRangeMin.Dispose();
    hv_ImageRangeMax.Dispose();
    hv_ImageNumChannels.Dispose();
    hv_ImageWidthInput.Dispose();
    hv_ImageHeightInput.Dispose();
    hv_EqualWidth.Dispose();
    hv_EqualHeight.Dispose();
    hv_Type.Dispose();
    hv_NumMatches.Dispose();
    hv_NumImages.Dispose();
    hv_EqualByte.Dispose();
    hv_RescaleRange.Dispose();
    hv_ImageIndex.Dispose();
    hv_NumChannels.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Standard preprocessing on the entire dataset declared in DLDataset. 
  public void preprocess_dl_dataset (HTuple hv_DLDataset, HTuple hv_DataDirectory, 
      HTuple hv_DLPreprocessParam, HTuple hv_GenParam, out HTuple hv_DLDatasetFileName)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OverwriteFiles = new HTuple(), hv_ShowProgress = new HTuple();
    HTuple hv_ClassWeightsSegmentation = new HTuple(), hv_MaxWeight = new HTuple();
    HTuple hv_DLModelType = new HTuple(), hv_ClassIDsDataset = new HTuple();
    HTuple hv_SetBackgroundID = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_GenParamName = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_FileExists = new HTuple(), hv_DLSampleDir = new HTuple();
    HTuple hv_DLDatasetSamples = new HTuple(), hv_Progress = new HTuple();
    HTuple hv_SecondsStart = new HTuple(), hv_SampleIndex = new HTuple();
    HTuple hv_DLSampleBatch = new HTuple(), hv_SecondsElapsed = new HTuple();
    HTuple hv_SecondsRemaining = new HTuple(), hv_ProgressPercent = new HTuple();
    HTuple hv_ProgressPerSecond = new HTuple(), hv_TimeElapsedString = new HTuple();
    HTuple hv_TimeRemainingString = new HTuple(), hv_IgnoreClassIDs = new HTuple();
    HTuple   hv_DataDirectory_COPY_INP_TMP = new HTuple(hv_DataDirectory);

    // Initialize local and output iconic variables 
    hv_DLDatasetFileName = new HTuple();
    //
    //This procedure preprocesses the samples in the dictionary DLDataset.
    //
    //** Parameters values: ***
    //
    //Set the default values.
    //Overwrite existing DLDataset file and DLSample directory.
    hv_OverwriteFiles.Dispose();
    hv_OverwriteFiles = 0;
    //By default we show the progress of preprocessing.
    hv_ShowProgress.Dispose();
    hv_ShowProgress = 1;
    //Class weights specified by user (needed for segmentation)
    hv_ClassWeightsSegmentation.Dispose();
    hv_ClassWeightsSegmentation = new HTuple();
    //Set max weight. Parameter for calculating the weights (needed for segmentation).
    hv_MaxWeight.Dispose();
    hv_MaxWeight = 1000;
    //
    //Check the validity of the preprocessing parameters.
    check_dl_preprocess_param(hv_DLPreprocessParam);
    //Get the model type.
    hv_DLModelType.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_DLModelType);
    //
    //Check if the background class ID is part of the DLDataset class IDs.
    if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
    {
      hv_ClassIDsDataset.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDsDataset);
      hv_SetBackgroundID.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "set_background_id", out hv_SetBackgroundID);
      if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleGreater(
          0))) != 0)
      {
        hv_Indices.Dispose();
        HOperatorSet.TupleFind(hv_ClassIDsDataset, hv_SetBackgroundID, out hv_Indices);
        if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
        {
          throw new HalconException(("The 'set_background_id':'"+hv_SetBackgroundID)+"' needs to be part of the DLDataset 'class_ids' tuple.");
        }
      }
    }
    //
    //Set the parameters for preprocess_dl_samples.
    HOperatorSet.SetDictTuple(hv_DLDataset, "preprocess_param", hv_DLPreprocessParam);
    //
    //Transfer generic parameters.
    if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_GenParamName.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamName);
      for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
          ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
      {
        if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "overwrite_files"))) != 0)
        {
          hv_OverwriteFiles.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "overwrite_files", out hv_OverwriteFiles);
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "show_progress"))) != 0)
        {
          hv_ShowProgress.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "show_progress", out hv_ShowProgress);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ShowProgress = (new HTuple(hv_ShowProgress.TupleEqual(
              "true"))).TupleOr(new HTuple(hv_ShowProgress.TupleEqual(1)));
          hv_ShowProgress.Dispose();
          hv_ShowProgress = ExpTmpLocalVar_ShowProgress;
          }
          }
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "max_weight"))) != 0)
        {
          hv_MaxWeight.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "max_weight", out hv_MaxWeight);
          if ((int)(new HTuple(hv_DLModelType.TupleNotEqual("segmentation"))) != 0)
          {
            throw new HalconException("The preprocessing parameter 'max_weight' only applies for segmentation models.");
          }
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "class_weights"))) != 0)
        {
          hv_ClassWeightsSegmentation.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "class_weights", out hv_ClassWeightsSegmentation);
          if ((int)(new HTuple(hv_DLModelType.TupleNotEqual("segmentation"))) != 0)
          {
            throw new HalconException("The preprocessing parameter 'class_weights' only applies for segmentation models.");
          }
        }
        else
        {
          throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
              hv_GenParamIndex)))+"'");
        }
      }
    }
    //
    //** Clean/Create data directory: ***
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.TupleRegexpReplace(hv_DataDirectory_COPY_INP_TMP, "/+$", "", out ExpTmpOutVar_0);
    hv_DataDirectory_COPY_INP_TMP.Dispose();
    hv_DataDirectory_COPY_INP_TMP = ExpTmpOutVar_0;
    }
    hv_FileExists.Dispose();
    HOperatorSet.FileExists(hv_DataDirectory_COPY_INP_TMP, out hv_FileExists);
    if ((int)(hv_FileExists.TupleAnd(hv_OverwriteFiles.TupleNot())) != 0)
    {
      throw new HalconException(("The folder "+hv_DataDirectory_COPY_INP_TMP)+" already exists. Either give a different directory or force overwriting using the parameter 'overwrite_files'.");
    }
    if ((int)(hv_FileExists) != 0)
    {
      remove_dir_recursively(hv_DataDirectory_COPY_INP_TMP);
    }
    HOperatorSet.MakeDir(hv_DataDirectory_COPY_INP_TMP);
    //
    //Create the directory for the DLSamples, if it does not exist.
    //
    //Sample directory name.
    hv_DLSampleDir.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DLSampleDir = hv_DataDirectory_COPY_INP_TMP+"/samples";
    }
    HOperatorSet.MakeDir(hv_DLSampleDir);
    //
    //Set the output path.
    HOperatorSet.SetDictTuple(hv_DLDataset, "dlsample_dir", hv_DLSampleDir);
    //
    //** Preprocess all images in the dataset: ***
    //During training/validation and testing those preprocessed images
    //will be used for performance reasons.
    //
    //Get the samples to be preprocessed.
    hv_DLDatasetSamples.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLDatasetSamples);
    //
    //Initialize progress variables.
    if ((int)(hv_ShowProgress) != 0)
    {
      hv_Progress.Dispose();
      hv_Progress = new HTuple();
      hv_Progress[0] = "Procedure: preprocess_dl_dataset";
      hv_Progress[1] = "";
      hv_Progress[2] = "";
      hv_Progress[3] = "";
      if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Progress = hv_Progress.TupleConcat(
            "Task: 1/2: image preprocessing");
        hv_Progress.Dispose();
        hv_Progress = ExpTmpLocalVar_Progress;
        }
        }
      }
      hv_SecondsStart.Dispose();
      HOperatorSet.CountSeconds(out hv_SecondsStart);
      // dev_inspect_ctrl(...); only in hdevelop
    }
    //
    //Loop over all samples.
    for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_DLDatasetSamples.TupleLength()
        ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
    {
      //
      //Generate the dictionary DLSample.
      hv_DLSampleBatch.Dispose();
      gen_dl_samples(hv_DLDataset, hv_SampleIndex, hv_DLModelType, new HTuple(), 
          out hv_DLSampleBatch);
      //
      //Preprocess the DLSample.
      preprocess_dl_samples(hv_DLSampleBatch, hv_DLPreprocessParam);
      //
      //Write the preprocessed images.
      write_dl_samples(hv_DLDataset, hv_SampleIndex, hv_DLSampleBatch, new HTuple(), 
          new HTuple());
      //
      //Provide progress information.
      if ((int)(hv_ShowProgress.TupleAnd((new HTuple(((hv_SampleIndex%10)).TupleEqual(
          1))).TupleOr(new HTuple(hv_SampleIndex.TupleEqual((new HTuple(hv_DLDatasetSamples.TupleLength()
          ))-1))))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SecondsElapsed.Dispose();hv_SecondsRemaining.Dispose();hv_ProgressPercent.Dispose();hv_ProgressPerSecond.Dispose();
        estimate_progress(hv_SecondsStart, 0, hv_SampleIndex, (new HTuple(hv_DLDatasetSamples.TupleLength()
            ))-1, out hv_SecondsElapsed, out hv_SecondsRemaining, out hv_ProgressPercent, 
            out hv_ProgressPerSecond);
        }
        hv_TimeElapsedString.Dispose();
        timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
        hv_TimeRemainingString.Dispose();
        timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
        if (hv_Progress == null)
          hv_Progress = new HTuple();
        hv_Progress[1] = ("Progress: "+(hv_ProgressPercent.TupleRound()))+" %";
        if (hv_Progress == null)
          hv_Progress = new HTuple();
        hv_Progress[2] = "Time elapsed: "+hv_TimeElapsedString;
        if (hv_Progress == null)
          hv_Progress = new HTuple();
        hv_Progress[3] = "Time left: "+hv_TimeRemainingString;
      }
    }
    //
    //If the model is of type segmentation, generate weight images.
    if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
    {
      //
      if ((int)(hv_ShowProgress) != 0)
      {
        hv_Progress.Dispose();
        hv_Progress = new HTuple();
        hv_Progress[0] = "Procedure: preprocess_dl_dataset";
        hv_Progress[1] = "";
        hv_Progress[2] = "";
        if (hv_Progress == null)
          hv_Progress = new HTuple();
        hv_Progress[1] = "Please wait...";
        if (hv_Progress == null)
          hv_Progress = new HTuple();
        hv_Progress[2] = "Task: 2/2: calculating class weights";
      }
      if ((int)(new HTuple((new HTuple(hv_ClassWeightsSegmentation.TupleLength())).TupleEqual(
          0))) != 0)
      {
        //Calculate the class weights for segmentation.
        hv_IgnoreClassIDs.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
        hv_ClassWeightsSegmentation.Dispose();
        calculate_dl_segmentation_class_weights(hv_DLDataset, hv_MaxWeight, hv_IgnoreClassIDs, 
            out hv_ClassWeightsSegmentation);
      }
      //
      //Generate the weight images.
      gen_dl_segmentation_weight_images(hv_DLDataset, hv_DLPreprocessParam, hv_ClassWeightsSegmentation, 
          new HTuple());
    }
    if ((int)(hv_ShowProgress.TupleNot()) != 0)
    {
      hv_Progress.Dispose();
      hv_Progress = "Done.";
      // dev_close_inspect_ctrl(...); only in hdevelop
    }
    //
    //Write the DLDataset dict.
    hv_DLDatasetFileName.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_DLDatasetFileName = hv_DataDirectory_COPY_INP_TMP+"/dl_dataset.hdict";
    }
    HOperatorSet.WriteDict(hv_DLDataset, hv_DLDatasetFileName, new HTuple(), new HTuple());

    hv_DataDirectory_COPY_INP_TMP.Dispose();
    hv_OverwriteFiles.Dispose();
    hv_ShowProgress.Dispose();
    hv_ClassWeightsSegmentation.Dispose();
    hv_MaxWeight.Dispose();
    hv_DLModelType.Dispose();
    hv_ClassIDsDataset.Dispose();
    hv_SetBackgroundID.Dispose();
    hv_Indices.Dispose();
    hv_GenParamName.Dispose();
    hv_GenParamIndex.Dispose();
    hv_FileExists.Dispose();
    hv_DLSampleDir.Dispose();
    hv_DLDatasetSamples.Dispose();
    hv_Progress.Dispose();
    hv_SecondsStart.Dispose();
    hv_SampleIndex.Dispose();
    hv_DLSampleBatch.Dispose();
    hv_SecondsElapsed.Dispose();
    hv_SecondsRemaining.Dispose();
    hv_ProgressPercent.Dispose();
    hv_ProgressPerSecond.Dispose();
    hv_TimeElapsedString.Dispose();
    hv_TimeRemainingString.Dispose();
    hv_IgnoreClassIDs.Dispose();

    return;
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: This procedure preprocesses the bounding boxes of a given sample. 
  public void preprocess_dl_model_bbox_rect1 (HObject ho_ImageRaw, HTuple hv_DLSample, 
      HTuple hv_DLPreprocessParam)
  {




    // Local iconic variables 

    HObject ho_DomainRaw=null;

    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_BBoxCol1 = new HTuple();
    HTuple hv_BBoxCol2 = new HTuple(), hv_BBoxRow1 = new HTuple();
    HTuple hv_BBoxRow2 = new HTuple(), hv_BBoxLabel = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_ImageId = new HTuple();
    HTuple hv_ExceptionMessage = new HTuple(), hv_BoxesInvalid = new HTuple();
    HTuple hv_RowDomain1 = new HTuple(), hv_ColumnDomain1 = new HTuple();
    HTuple hv_RowDomain2 = new HTuple(), hv_ColumnDomain2 = new HTuple();
    HTuple hv_WidthRaw = new HTuple(), hv_HeightRaw = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Col2 = new HTuple();
    HTuple hv_MaskDelete = new HTuple(), hv_MaskNewBbox = new HTuple();
    HTuple hv_BBoxCol1New = new HTuple(), hv_BBoxCol2New = new HTuple();
    HTuple hv_BBoxRow1New = new HTuple(), hv_BBoxRow2New = new HTuple();
    HTuple hv_BBoxLabelNew = new HTuple(), hv_FactorResampleWidth = new HTuple();
    HTuple hv_FactorResampleHeight = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_DomainRaw);
    //
    //This procedure preprocesses the bounding box coordinates of a given sample.
    //
    //Check the validity of the preprocessing parameters.
    check_dl_preprocess_param(hv_DLPreprocessParam);
    //
    //Get the preprocessing parameters.
    hv_ImageWidth.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
    hv_ImageHeight.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
    hv_DomainHandling.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
    //
    //Get bounding box coordinates and labels.
    try
    {
      hv_BBoxCol1.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BBoxCol1);
      hv_BBoxCol2.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BBoxCol2);
      hv_BBoxRow1.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BBoxRow1);
      hv_BBoxRow2.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BBoxRow2);
      hv_BBoxLabel.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BBoxLabel);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_ImageId.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
      if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1302))) != 0)
      {
        hv_ExceptionMessage.Dispose();
        hv_ExceptionMessage = "A bounding box coordinate key is missing.";
      }
      else
      {
        hv_ExceptionMessage.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ExceptionMessage = hv_Exception.TupleSelect(
            2);
        }
      }
      throw new HalconException((("An error has occurred during preprocessing image_id "+hv_ImageId)+" when getting bounding box coordinates : ")+hv_ExceptionMessage);
    }
    //
    //Check that there are no invalid boxes.
    if ((int)(new HTuple((new HTuple(hv_BBoxRow1.TupleLength())).TupleGreater(0))) != 0)
    {
      hv_BoxesInvalid.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BoxesInvalid = ((hv_BBoxRow1.TupleGreaterEqualElem(
          hv_BBoxRow2))).TupleOr(hv_BBoxCol1.TupleGreaterEqualElem(hv_BBoxCol2));
      }
      if ((int)(new HTuple(((hv_BoxesInvalid.TupleSum())).TupleGreater(0))) != 0)
      {
        hv_ImageId.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
        throw new HalconException(("An error has occurred during preprocessing image_id "+hv_ImageId)+new HTuple(": Sample contains at least one box with zero-area, i.e. bbox_col1 >= bbox_col2 or bbox_row1 >= bbox_row2."));
      }
    }
    //
    //If the domain is cropped, crop bboxes.
    //
    if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
    {
      //
      //Get domain.
      ho_DomainRaw.Dispose();
      HOperatorSet.GetDomain(ho_ImageRaw, out ho_DomainRaw);
      //
      //Set the size of the raw image to the domain extensions.
      hv_RowDomain1.Dispose();hv_ColumnDomain1.Dispose();hv_RowDomain2.Dispose();hv_ColumnDomain2.Dispose();
      HOperatorSet.SmallestRectangle1(ho_DomainRaw, out hv_RowDomain1, out hv_ColumnDomain1, 
          out hv_RowDomain2, out hv_ColumnDomain2);
      hv_WidthRaw.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WidthRaw = (hv_ColumnDomain2-hv_ColumnDomain1)+1;
      }
      hv_HeightRaw.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HeightRaw = (hv_RowDomain2-hv_RowDomain1)+1;
      }
      //
      //Crop the bounding boxes.
      hv_Row1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row1 = hv_BBoxRow1.TupleMax2(
          hv_RowDomain1);
      }
      hv_Col1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col1 = hv_BBoxCol1.TupleMax2(
          hv_ColumnDomain1);
      }
      hv_Row2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row2 = hv_BBoxRow2.TupleMin2(
          hv_RowDomain2);
      }
      hv_Col2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col2 = hv_BBoxCol2.TupleMin2(
          hv_ColumnDomain2);
      }
      hv_MaskDelete.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaskDelete = ((hv_Row1.TupleGreaterEqualElem(
          hv_Row2))).TupleOr(hv_Col1.TupleGreaterEqualElem(hv_Col2));
      }
      hv_MaskNewBbox.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaskNewBbox = 1-hv_MaskDelete;
      }
      //Store the preprocessed bbox entries.
      hv_BBoxCol1New.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BBoxCol1New = (hv_Col1.TupleSelectMask(
          hv_MaskNewBbox))-hv_ColumnDomain1;
      }
      hv_BBoxCol2New.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BBoxCol2New = (hv_Col2.TupleSelectMask(
          hv_MaskNewBbox))-hv_ColumnDomain1;
      }
      hv_BBoxRow1New.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BBoxRow1New = (hv_Row1.TupleSelectMask(
          hv_MaskNewBbox))-hv_RowDomain1;
      }
      hv_BBoxRow2New.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BBoxRow2New = (hv_Row2.TupleSelectMask(
          hv_MaskNewBbox))-hv_RowDomain1;
      }
      hv_BBoxLabelNew.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BBoxLabelNew = hv_BBoxLabel.TupleSelectMask(
          hv_MaskNewBbox);
      }
      //
    }
    else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
    {
      //If the entire image is used, set the variables accordingly.
      //Get the original size.
      hv_WidthRaw.Dispose();hv_HeightRaw.Dispose();
      HOperatorSet.GetImageSize(ho_ImageRaw, out hv_WidthRaw, out hv_HeightRaw);
      //Set new coordinates to input coordinates.
      hv_BBoxCol1New.Dispose();
      hv_BBoxCol1New = new HTuple(hv_BBoxCol1);
      hv_BBoxCol2New.Dispose();
      hv_BBoxCol2New = new HTuple(hv_BBoxCol2);
      hv_BBoxRow1New.Dispose();
      hv_BBoxRow1New = new HTuple(hv_BBoxRow1);
      hv_BBoxRow2New.Dispose();
      hv_BBoxRow2New = new HTuple(hv_BBoxRow2);
      hv_BBoxLabelNew.Dispose();
      hv_BBoxLabelNew = new HTuple(hv_BBoxLabel);
    }
    else
    {
      throw new HalconException("Unsupported parameter value for 'domain_handling'");
    }
    //
    //Rescale the bounding boxes.
    //
    //Get required images width and height.
    //
    //Only rescale bounding boxes if the required image dimensions are not the raw dimensions.
    if ((int)((new HTuple(hv_ImageHeight.TupleNotEqual(hv_HeightRaw))).TupleOr(new HTuple(hv_ImageWidth.TupleNotEqual(
        hv_WidthRaw)))) != 0)
    {
      //Calculate rescaling factor.
      hv_FactorResampleWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FactorResampleWidth = (hv_ImageWidth.TupleReal()
          )/hv_WidthRaw;
      }
      hv_FactorResampleHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FactorResampleHeight = (hv_ImageHeight.TupleReal()
          )/hv_HeightRaw;
      }
      //Rescale the bbox coordinates.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_BBoxCol1New = ((hv_BBoxCol1New*hv_FactorResampleWidth)).TupleRound()
          ;
      hv_BBoxCol1New.Dispose();
      hv_BBoxCol1New = ExpTmpLocalVar_BBoxCol1New;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_BBoxCol2New = ((hv_BBoxCol2New*hv_FactorResampleWidth)).TupleRound()
          ;
      hv_BBoxCol2New.Dispose();
      hv_BBoxCol2New = ExpTmpLocalVar_BBoxCol2New;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_BBoxRow1New = ((hv_BBoxRow1New*hv_FactorResampleHeight)).TupleRound()
          ;
      hv_BBoxRow1New.Dispose();
      hv_BBoxRow1New = ExpTmpLocalVar_BBoxRow1New;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_BBoxRow2New = ((hv_BBoxRow2New*hv_FactorResampleHeight)).TupleRound()
          ;
      hv_BBoxRow2New.Dispose();
      hv_BBoxRow2New = ExpTmpLocalVar_BBoxRow2New;
      }
      }
      //
    }
    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_BBoxCol1New);
    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_BBoxCol2New);
    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_BBoxRow1New);
    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_BBoxRow2New);
    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_BBoxLabelNew);
    ho_DomainRaw.Dispose();

    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_DomainHandling.Dispose();
    hv_BBoxCol1.Dispose();
    hv_BBoxCol2.Dispose();
    hv_BBoxRow1.Dispose();
    hv_BBoxRow2.Dispose();
    hv_BBoxLabel.Dispose();
    hv_Exception.Dispose();
    hv_ImageId.Dispose();
    hv_ExceptionMessage.Dispose();
    hv_BoxesInvalid.Dispose();
    hv_RowDomain1.Dispose();
    hv_ColumnDomain1.Dispose();
    hv_RowDomain2.Dispose();
    hv_ColumnDomain2.Dispose();
    hv_WidthRaw.Dispose();
    hv_HeightRaw.Dispose();
    hv_Row1.Dispose();
    hv_Col1.Dispose();
    hv_Row2.Dispose();
    hv_Col2.Dispose();
    hv_MaskDelete.Dispose();
    hv_MaskNewBbox.Dispose();
    hv_BBoxCol1New.Dispose();
    hv_BBoxCol2New.Dispose();
    hv_BBoxRow1New.Dispose();
    hv_BBoxRow2New.Dispose();
    hv_BBoxLabelNew.Dispose();
    hv_FactorResampleWidth.Dispose();
    hv_FactorResampleHeight.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Preprocess images for deep-learning-based training and inference. 
  public void preprocess_dl_model_images (HObject ho_Images, out HObject ho_ImagesPreprocessed, 
      HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ObjectSelected=null, ho_ThreeChannelImage=null;
    HObject ho_SingleChannelImage=null;

    // Local copy input parameter variables 
    HObject ho_Images_COPY_INP_TMP;
    ho_Images_COPY_INP_TMP = new HObject(ho_Images);



    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_ImageNumChannels = new HTuple(), hv_ImageRangeMin = new HTuple();
    HTuple hv_ImageRangeMax = new HTuple(), hv_DomainHandling = new HTuple();
    HTuple hv_ContrastNormalization = new HTuple(), hv_ImageWidthInput = new HTuple();
    HTuple hv_ImageHeightInput = new HTuple(), hv_EqualWidth = new HTuple();
    HTuple hv_EqualHeight = new HTuple(), hv_Type = new HTuple();
    HTuple hv_NumMatches = new HTuple(), hv_NumImages = new HTuple();
    HTuple hv_EqualByte = new HTuple(), hv_RescaleRange = new HTuple();
    HTuple hv_NumChannelsAllImages = new HTuple(), hv_ImageNumChannelsTuple = new HTuple();
    HTuple hv_IndicesWrongChannels = new HTuple(), hv_IndexWrongImages = new HTuple();
    HTuple hv_ImageIndex = new HTuple(), hv_NumChannels = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImagesPreprocessed);
    HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
    HOperatorSet.GenEmptyObj(out ho_ThreeChannelImage);
    HOperatorSet.GenEmptyObj(out ho_SingleChannelImage);
    //
    //This procedure preprocesses the provided Images
    //according to the parameters in the dictionary DLPreprocessParam.
    //Note that depending on the images,
    //additional preprocessing steps might be beneficial.
    //
    //Check the validity of the preprocessing parameters.
    check_dl_preprocess_param(hv_DLPreprocessParam);
    //
    //Get the preprocessing parameters.
    hv_ImageWidth.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
    hv_ImageHeight.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
    hv_ImageNumChannels.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
    hv_ImageRangeMin.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
    hv_ImageRangeMax.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
    hv_DomainHandling.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
    hv_ContrastNormalization.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "contrast_normalization", out hv_ContrastNormalization);
    //
    //Preprocess the images.
    //
    if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.FullDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.CropDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    else
    {
      throw new HalconException("Unsupported parameter value for 'domain_handling'");
    }
    //
    //Zoom images only if they have a different size than the specified size.
    hv_ImageWidthInput.Dispose();hv_ImageHeightInput.Dispose();
    HOperatorSet.GetImageSize(ho_Images_COPY_INP_TMP, out hv_ImageWidthInput, out hv_ImageHeightInput);
    hv_EqualWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EqualWidth = hv_ImageWidth.TupleEqualElem(
        hv_ImageWidthInput);
    }
    hv_EqualHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EqualHeight = hv_ImageHeight.TupleEqualElem(
        hv_ImageHeightInput);
    }
    if ((int)((new HTuple(((hv_EqualWidth.TupleMin())).TupleEqual(0))).TupleOr(new HTuple(((hv_EqualHeight.TupleMin()
        )).TupleEqual(0)))) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ZoomImageSize(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, hv_ImageWidth, 
          hv_ImageHeight, "constant");
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    if ((int)(new HTuple(hv_ContrastNormalization.TupleEqual("true"))) != 0)
    {
      //Scale the gray values to [0-255].
      //Note that this converts the image to 'byte'.
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ScaleImageMax(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    else if ((int)(new HTuple(hv_ContrastNormalization.TupleNotEqual("false"))) != 0)
    {
      throw new HalconException("Unsupported parameter value for 'contrast_normalization'");
    }
    //
    //Check the type of the input images.
    hv_Type.Dispose();
    HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_Type);
    hv_NumMatches.Dispose();
    HOperatorSet.TupleRegexpTest(hv_Type, "byte|real", out hv_NumMatches);
    hv_NumImages.Dispose();
    HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
    if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
    {
      throw new HalconException("Please provide only images of type 'byte' or 'real'.");
    }
    //If the type is 'byte', convert it to 'real' and scale it.
    //The gray value scaling does not work on 'byte' images.
    //For 'real' images it is assumed that the range is already correct.
    hv_EqualByte.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EqualByte = hv_Type.TupleEqualElem(
        "byte");
    }
    if ((int)(new HTuple(((hv_EqualByte.TupleMax())).TupleEqual(1))) != 0)
    {
      if ((int)(new HTuple(((hv_EqualByte.TupleMin())).TupleEqual(0))) != 0)
      {
        throw new HalconException("Passing mixed type images is not supported.");
      }
      //Convert the image type from 'byte' to 'real',
      //because the model expects 'real' images.
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConvertImageType(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, "real");
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
      //Scale/Shift the gray values from [0-255] to the expected range.
      hv_RescaleRange.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RescaleRange = (hv_ImageRangeMax-hv_ImageRangeMin)/255.0;
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ScaleImage(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, hv_RescaleRange, 
          hv_ImageRangeMin);
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    //
    //Check the number of channels.
    hv_NumImages.Dispose();
    HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
    //Check all images for number of channels.
    hv_NumChannelsAllImages.Dispose();
    HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_NumChannelsAllImages);
    hv_ImageNumChannelsTuple.Dispose();
    HOperatorSet.TupleGenConst(hv_NumImages, hv_ImageNumChannels, out hv_ImageNumChannelsTuple);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_IndicesWrongChannels.Dispose();
    HOperatorSet.TupleFind(hv_NumChannelsAllImages.TupleNotEqualElem(hv_ImageNumChannelsTuple), 
        1, out hv_IndicesWrongChannels);
    }
    //
    //Correct images with a wrong number of channels.
    //
    if ((int)(new HTuple(hv_IndicesWrongChannels.TupleNotEqual(-1))) != 0)
    {
      //
      for (hv_IndexWrongImages=0; (int)hv_IndexWrongImages<=(int)((new HTuple(hv_IndicesWrongChannels.TupleLength()
          ))-1); hv_IndexWrongImages = (int)hv_IndexWrongImages + 1)
      {
        //Get the index, the number of channels and the image
        //for each image with wrong number of channels.
        hv_ImageIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageIndex = (hv_IndicesWrongChannels.TupleSelect(
            hv_IndexWrongImages))+1;
        }
        hv_NumChannels.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumChannels = hv_NumChannelsAllImages.TupleSelect(
            hv_ImageIndex-1);
        }
        ho_ObjectSelected.Dispose();
        HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ObjectSelected, hv_ImageIndex);
        //
        if ((int)((new HTuple(hv_NumChannels.TupleEqual(1))).TupleAnd(new HTuple(hv_ImageNumChannels.TupleEqual(
            3)))) != 0)
        {
          //If the image is a grayscale image, but the model expects a color image:
          //convert it to an image with three channels.
          ho_ThreeChannelImage.Dispose();
          HOperatorSet.Compose3(ho_ObjectSelected, ho_ObjectSelected, ho_ObjectSelected, 
              out ho_ThreeChannelImage);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ThreeChannelImage, out ExpTmpOutVar_0, 
              hv_ImageIndex);
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        else if ((int)((new HTuple(hv_NumChannels.TupleEqual(3))).TupleAnd(
            new HTuple(hv_ImageNumChannels.TupleEqual(1)))) != 0)
        {
          //If the image is a color image, but the model expects a grayscale image:
          //convert it to an image with only one channel.
          ho_SingleChannelImage.Dispose();
          HOperatorSet.Rgb1ToGray(ho_ObjectSelected, out ho_SingleChannelImage);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_SingleChannelImage, 
              out ExpTmpOutVar_0, hv_ImageIndex);
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        else
        {
          throw new HalconException("Number of channels is not supported. Please check for images with a number of channels different to 1 and 3 and perform their preprocessing yourself.");
        }
        //
      }
    }
    //
    //Write preprocessed image to output variable.
    ho_ImagesPreprocessed.Dispose();
    ho_ImagesPreprocessed = new HObject(ho_Images_COPY_INP_TMP);
    ho_Images_COPY_INP_TMP.Dispose();
    ho_ObjectSelected.Dispose();
    ho_ThreeChannelImage.Dispose();
    ho_SingleChannelImage.Dispose();

    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_ImageNumChannels.Dispose();
    hv_ImageRangeMin.Dispose();
    hv_ImageRangeMax.Dispose();
    hv_DomainHandling.Dispose();
    hv_ContrastNormalization.Dispose();
    hv_ImageWidthInput.Dispose();
    hv_ImageHeightInput.Dispose();
    hv_EqualWidth.Dispose();
    hv_EqualHeight.Dispose();
    hv_Type.Dispose();
    hv_NumMatches.Dispose();
    hv_NumImages.Dispose();
    hv_EqualByte.Dispose();
    hv_RescaleRange.Dispose();
    hv_NumChannelsAllImages.Dispose();
    hv_ImageNumChannelsTuple.Dispose();
    hv_IndicesWrongChannels.Dispose();
    hv_IndexWrongImages.Dispose();
    hv_ImageIndex.Dispose();
    hv_NumChannels.Dispose();

    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Preprocess segmentation and weight images for deep-learning-based segmentation training and inference. 
  public void preprocess_dl_model_segmentations (HObject ho_ImagesRaw, HObject ho_Segmentations, 
      out HObject ho_SegmentationsPreprocessed, HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Domain=null, ho_SelectedSeg=null;
    HObject ho_SelectedDomain=null;

    // Local copy input parameter variables 
    HObject ho_Segmentations_COPY_INP_TMP;
    ho_Segmentations_COPY_INP_TMP = new HObject(ho_Segmentations);



    // Local control variables 

    HTuple hv_NumberImages = new HTuple(), hv_NumberSegmentations = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_WidthSeg = new HTuple(), hv_HeightSeg = new HTuple();
    HTuple hv_DLModelType = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_ImageNumChannels = new HTuple();
    HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_SetBackgroundID = new HTuple();
    HTuple hv_ClassesToBackground = new HTuple(), hv_IgnoreClassIDs = new HTuple();
    HTuple hv_IsInt = new HTuple(), hv_IndexImage = new HTuple();
    HTuple hv_ImageWidthRaw = new HTuple(), hv_ImageHeightRaw = new HTuple();
    HTuple hv_EqualWidth = new HTuple(), hv_EqualHeight = new HTuple();
    HTuple hv_Type = new HTuple(), hv_EqualReal = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationsPreprocessed);
    HOperatorSet.GenEmptyObj(out ho_Domain);
    HOperatorSet.GenEmptyObj(out ho_SelectedSeg);
    HOperatorSet.GenEmptyObj(out ho_SelectedDomain);
    //
    //This procedure preprocesses the segmentation or weight images
    //given by Segmentations so that they can be handled by
    //train_dl_model_batch and apply_dl_model.
    //
    //Check input data.
    //Examine umber of images.
    hv_NumberImages.Dispose();
    HOperatorSet.CountObj(ho_ImagesRaw, out hv_NumberImages);
    hv_NumberSegmentations.Dispose();
    HOperatorSet.CountObj(ho_Segmentations_COPY_INP_TMP, out hv_NumberSegmentations);
    if ((int)(new HTuple(hv_NumberImages.TupleNotEqual(hv_NumberSegmentations))) != 0)
    {
      throw new HalconException("Equal number of images given in ImagesRaw and Segmentations required");
    }
    //Size of images.
    hv_Width.Dispose();hv_Height.Dispose();
    HOperatorSet.GetImageSize(ho_ImagesRaw, out hv_Width, out hv_Height);
    hv_WidthSeg.Dispose();hv_HeightSeg.Dispose();
    HOperatorSet.GetImageSize(ho_Segmentations_COPY_INP_TMP, out hv_WidthSeg, out hv_HeightSeg);
    if ((int)((new HTuple(hv_Width.TupleNotEqual(hv_WidthSeg))).TupleOr(new HTuple(hv_Height.TupleNotEqual(
        hv_HeightSeg)))) != 0)
    {
      throw new HalconException("Equal size of the images given in ImagesRaw and Segmentations required.");
    }
    //Check the validity of the preprocessing parameters.
    check_dl_preprocess_param(hv_DLPreprocessParam);
    //
    //Get the relevant preprocessing parameters.
    hv_DLModelType.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_DLModelType);
    hv_ImageWidth.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
    hv_ImageHeight.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
    hv_ImageNumChannels.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
    hv_ImageRangeMin.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
    hv_ImageRangeMax.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
    hv_DomainHandling.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
    //Segmentation specific parameters.
    hv_SetBackgroundID.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "set_background_id", out hv_SetBackgroundID);
    hv_ClassesToBackground.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_background", out hv_ClassesToBackground);
    hv_IgnoreClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
    //
    //Check the input parameter for setting the background ID.
    if ((int)(new HTuple(hv_SetBackgroundID.TupleNotEqual(new HTuple()))) != 0)
    {
      //Check that the model is a segmentation model.
      if ((int)(new HTuple(hv_DLModelType.TupleNotEqual("segmentation"))) != 0)
      {
        throw new HalconException("Setting class IDs to background is only implemented for segmentation.");
      }
      //Check the background ID.
      hv_IsInt.Dispose();
      HOperatorSet.TupleIsIntElem(hv_SetBackgroundID, out hv_IsInt);
      if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("Only one class_id as 'set_background_id' allowed.");
      }
      else if ((int)(hv_IsInt.TupleNot()) != 0)
      {
        //Given class_id has to be of type int.
        throw new HalconException("The class_id given as 'set_background_id' has to be of type int.");
      }
      //Check the values of ClassesToBackground.
      if ((int)(new HTuple((new HTuple(hv_ClassesToBackground.TupleLength())).TupleEqual(
          0))) != 0)
      {
        //Check that the given classes are of length > 0.
        throw new HalconException(new HTuple("If 'set_background_id' is given, 'class_ids_background' must at least contain this class ID."));
      }
      else if ((int)(new HTuple(((hv_ClassesToBackground.TupleIntersection(
          hv_IgnoreClassIDs))).TupleNotEqual(new HTuple()))) != 0)
      {
        //Check that class_ids_background is not included in the ignore_class_ids of the DLModel.
        throw new HalconException("The given 'class_ids_background' must not be included in the 'ignore_class_ids' of the model.");
      }
    }
    //
    //Domain handling of the image to be preprocessed.
    //
    if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.FullDomain(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0);
      ho_Segmentations_COPY_INP_TMP.Dispose();
      ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
    {
      //If the domain should be cropped the domain has to be transferred
      //from the raw image to the segmentation image.
      ho_Domain.Dispose();
      HOperatorSet.GetDomain(ho_ImagesRaw, out ho_Domain);
      HTuple end_val66 = hv_NumberImages;
      HTuple step_val66 = 1;
      for (hv_IndexImage=1; hv_IndexImage.Continue(end_val66, step_val66); hv_IndexImage = hv_IndexImage.TupleAdd(step_val66))
      {
        ho_SelectedSeg.Dispose();
        HOperatorSet.SelectObj(ho_Segmentations_COPY_INP_TMP, out ho_SelectedSeg, 
            hv_IndexImage);
        ho_SelectedDomain.Dispose();
        HOperatorSet.SelectObj(ho_Domain, out ho_SelectedDomain, hv_IndexImage);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ChangeDomain(ho_SelectedSeg, ho_SelectedDomain, out ExpTmpOutVar_0
            );
        ho_SelectedSeg.Dispose();
        ho_SelectedSeg = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ReplaceObj(ho_Segmentations_COPY_INP_TMP, ho_SelectedSeg, out ExpTmpOutVar_0, 
            hv_IndexImage);
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.CropDomain(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0);
      ho_Segmentations_COPY_INP_TMP.Dispose();
      ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    else
    {
      throw new HalconException("Unsupported parameter value for 'domain_handling'");
    }
    //
    //Preprocess the segmentation images.
    //
    //Set all background classes to the given background class ID.
    if ((int)(new HTuple(hv_SetBackgroundID.TupleNotEqual(new HTuple()))) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      reassign_pixel_values(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0, hv_ClassesToBackground, 
          hv_SetBackgroundID);
      ho_Segmentations_COPY_INP_TMP.Dispose();
      ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    //
    //Zoom images only if they have a different size than the specified size.
    hv_ImageWidthRaw.Dispose();hv_ImageHeightRaw.Dispose();
    HOperatorSet.GetImageSize(ho_Segmentations_COPY_INP_TMP, out hv_ImageWidthRaw, 
        out hv_ImageHeightRaw);
    hv_EqualWidth.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EqualWidth = hv_ImageWidth.TupleEqualElem(
        hv_ImageWidthRaw);
    }
    hv_EqualHeight.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EqualHeight = hv_ImageHeight.TupleEqualElem(
        hv_ImageHeightRaw);
    }
    if ((int)((new HTuple(((hv_EqualWidth.TupleMin())).TupleEqual(0))).TupleOr(new HTuple(((hv_EqualHeight.TupleMin()
        )).TupleEqual(0)))) != 0)
    {
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ZoomImageSize(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0, 
          hv_ImageWidth, hv_ImageHeight, "nearest_neighbor");
      ho_Segmentations_COPY_INP_TMP.Dispose();
      ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    //
    //Check the type of the input images
    //and convert if necessary.
    hv_Type.Dispose();
    HOperatorSet.GetImageType(ho_Segmentations_COPY_INP_TMP, out hv_Type);
    hv_EqualReal.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_EqualReal = hv_Type.TupleEqualElem(
        "real");
    }
    //
    if ((int)(new HTuple(((hv_EqualReal.TupleMin())).TupleEqual(0))) != 0)
    {
      //Convert the image type to 'real',
      //because the model expects 'real' images.
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConvertImageType(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0, 
          "real");
      ho_Segmentations_COPY_INP_TMP.Dispose();
      ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    //
    //Write preprocessed Segmentations to output variable.
    ho_SegmentationsPreprocessed.Dispose();
    ho_SegmentationsPreprocessed = new HObject(ho_Segmentations_COPY_INP_TMP);
    ho_Segmentations_COPY_INP_TMP.Dispose();
    ho_Domain.Dispose();
    ho_SelectedSeg.Dispose();
    ho_SelectedDomain.Dispose();

    hv_NumberImages.Dispose();
    hv_NumberSegmentations.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_WidthSeg.Dispose();
    hv_HeightSeg.Dispose();
    hv_DLModelType.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_ImageNumChannels.Dispose();
    hv_ImageRangeMin.Dispose();
    hv_ImageRangeMax.Dispose();
    hv_DomainHandling.Dispose();
    hv_SetBackgroundID.Dispose();
    hv_ClassesToBackground.Dispose();
    hv_IgnoreClassIDs.Dispose();
    hv_IsInt.Dispose();
    hv_IndexImage.Dispose();
    hv_ImageWidthRaw.Dispose();
    hv_ImageHeightRaw.Dispose();
    hv_EqualWidth.Dispose();
    hv_EqualHeight.Dispose();
    hv_Type.Dispose();
    hv_EqualReal.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Preprocess given DLSamples according to the preprocessing parameters given in DLPreprocessParam. 
  public void preprocess_dl_samples (HTuple hv_DLSampleBatch, HTuple hv_DLPreprocessParam)
  {



    // Local iconic variables 

    HObject ho_ImageRaw=null, ho_ImagePreprocessed=null;
    HObject ho_SegmentationRaw=null, ho_SegmentationPreprocessed=null;

    // Local control variables 

    HTuple hv_SampleIndex = new HTuple(), hv_KeysExists = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageRaw);
    HOperatorSet.GenEmptyObj(out ho_ImagePreprocessed);
    HOperatorSet.GenEmptyObj(out ho_SegmentationRaw);
    HOperatorSet.GenEmptyObj(out ho_SegmentationPreprocessed);
    //
    //This procedure preprocesses all images of the sample dictionaries in the tuple DLSampleBatch.
    //The images are preprocessed according to the parameters provided in DLPreprocessParam.
    //
    //
    //Check the validity of the preprocessing parameters.
    check_dl_preprocess_param(hv_DLPreprocessParam);
    //
    //Preprocess the sample entries.
    //
    for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_DLSampleBatch.TupleLength()
        ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
    {
      //Check the existence of the sample keys.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_KeysExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLSampleBatch.TupleSelect(hv_SampleIndex), "key_exists", 
          ((new HTuple("image")).TupleConcat("bbox_label_id")).TupleConcat("segmentation_image"), 
          out hv_KeysExists);
      }
      //
      //Preprocess the images.
      if ((int)(hv_KeysExists.TupleSelect(0)) != 0)
      {
        //
        //Get the image.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ImageRaw.Dispose();
        HOperatorSet.GetDictObject(out ho_ImageRaw, hv_DLSampleBatch.TupleSelect(
            hv_SampleIndex), "image");
        }
        //
        //Preprocess the image.
        ho_ImagePreprocessed.Dispose();
        preprocess_dl_model_images(ho_ImageRaw, out ho_ImagePreprocessed, hv_DLPreprocessParam);
        //
        //Replace the image in the dictionary.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictObject(ho_ImagePreprocessed, hv_DLSampleBatch.TupleSelect(
            hv_SampleIndex), "image");
        }
        //
        //If bounding boxes are given rescale them as well.
        if ((int)(hv_KeysExists.TupleSelect(1)) != 0)
        {
          //
          //Preprocess the bounding boxes of the sample.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          preprocess_dl_model_bbox_rect1(ho_ImageRaw, hv_DLSampleBatch.TupleSelect(
              hv_SampleIndex), hv_DLPreprocessParam);
          }
        }
        //
        //Preprocess the segmentation image if present.
        if ((int)(hv_KeysExists.TupleSelect(2)) != 0)
        {
          //
          //Get the segmentation image.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_SegmentationRaw.Dispose();
          HOperatorSet.GetDictObject(out ho_SegmentationRaw, hv_DLSampleBatch.TupleSelect(
              hv_SampleIndex), "segmentation_image");
          }
          //
          //Preprocess the segmentation image.
          ho_SegmentationPreprocessed.Dispose();
          preprocess_dl_model_segmentations(ho_ImageRaw, ho_SegmentationRaw, out ho_SegmentationPreprocessed, 
              hv_DLPreprocessParam);
          //
          //Set preprocessed segmentation image.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictObject(ho_SegmentationPreprocessed, hv_DLSampleBatch.TupleSelect(
              hv_SampleIndex), "segmentation_image");
          }
        }
        //
      }
      else
      {
        throw new HalconException((new HTuple("All samples processed need to include an image, but the sample with index ")+hv_SampleIndex)+" does not.");
      }
    }
    ho_ImageRaw.Dispose();
    ho_ImagePreprocessed.Dispose();
    ho_SegmentationRaw.Dispose();
    ho_SegmentationPreprocessed.Dispose();

    hv_SampleIndex.Dispose();
    hv_KeysExists.Dispose();

    return;
  }

  // Chapter: Tuple / Conversion
  // Short Description: Prints a tuple of values to a string. 
  public void pretty_print_tuple (HTuple hv_Tuple, out HTuple hv_TupleStr)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_J = new HTuple();
    // Initialize local and output iconic variables 
    hv_TupleStr = new HTuple();
    //
    //This procedure prints a tuple of values to a string.
    //
    if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleGreater(1))) != 0)
    {
      hv_TupleStr.Dispose();
      hv_TupleStr = "[";
      for (hv_J=0; (int)hv_J<=(int)((new HTuple(hv_Tuple.TupleLength()))-1); hv_J = (int)hv_J + 1)
      {
        if ((int)(new HTuple(hv_J.TupleGreater(0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_TupleStr = hv_TupleStr+new HTuple(",");
          hv_TupleStr.Dispose();
          hv_TupleStr = ExpTmpLocalVar_TupleStr;
          }
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TupleStr = hv_TupleStr+(hv_Tuple.TupleSelect(
            hv_J));
        hv_TupleStr.Dispose();
        hv_TupleStr = ExpTmpLocalVar_TupleStr;
        }
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TupleStr = hv_TupleStr+"]";
      hv_TupleStr.Dispose();
      hv_TupleStr = ExpTmpLocalVar_TupleStr;
      }
      }
    }
    else
    {
      hv_TupleStr.Dispose();
      hv_TupleStr = new HTuple(hv_Tuple);
    }

    hv_J.Dispose();

    return;
  }

  public void process_slider_events (HTuple hv_WindowHandle, HTuple hv_MessageQueues, 
      HTuple hv_PreviousState, out HTuple hv_CurrentState, out HTuple hv_DidFinish)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MessageHandle = new HTuple(), hv_Type = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Button = new HTuple();
    HTuple hv_Current = new HTuple(), hv_MessageHandleIgnore = new HTuple();
    HTuple hv_EventHappened1 = new HTuple();
    // Initialize local and output iconic variables 
    hv_CurrentState = new HTuple();
    hv_DidFinish = new HTuple();
    hv_CurrentState.Dispose();
    hv_CurrentState = new HTuple(hv_PreviousState);

    hv_DidFinish.Dispose();
    hv_DidFinish = 0;
    try
    {
      try
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MessageHandle.Dispose();
        HOperatorSet.DequeueMessage(hv_MessageQueues.TupleSelect(2), "timeout", 0, 
            out hv_MessageHandle);
        }
        hv_Type.Dispose();
        HOperatorSet.GetMessageTuple(hv_MessageHandle, "type", out hv_Type);
        if ((int)(new HTuple(hv_Type.TupleEqual("done"))) != 0)
        {
          //The visualization function has finished and has exited
          hv_DidFinish.Dispose();
          hv_DidFinish = 1;
        }
        else if ((int)(new HTuple(hv_Type.TupleEqual("exception"))) != 0)
        {
          hv_DidFinish.Dispose();
          hv_DidFinish = 1;
          hv_Exception.Dispose();
          HOperatorSet.GetMessageTuple(hv_MessageHandle, "exception", out hv_Exception);
          throw new HalconException(hv_Exception);
        }
        else
        {
          //Unknown / unexpected Message
          // stop(...); only in hdevelop
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException2)
      {
        HDevExpDefaultException2.ToHTuple(out hv_Exception);
        //Ignore timeout (no message in queue)
        if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(9400))) != 0)
        {
          throw new HalconException(hv_Exception);
        }
      }
      //
      hv_Row.Dispose();hv_Column.Dispose();hv_Button.Dispose();
      get_mouse_info(hv_WindowHandle, new HTuple(), new HTuple(), out hv_Row, out hv_Column, 
          out hv_Button);
      hv_Current.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Current = new HTuple();
      hv_Current = hv_Current.TupleConcat(hv_Row, hv_Column, hv_Button);
      }
      if ((int)(new HTuple(hv_Current.TupleNotEqual(hv_PreviousState))) != 0)
      {
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "mouse_event");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "mouse_row", hv_Row);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "mouse_col", hv_Column);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "mouse_button", hv_Button);
        //Remove any previous mouse message and overwrite it with the new
        //message. If the sub thread is too slow to process the mouse events,
        //we rather skip one and only use the last one. This avoids
        //the "lagging" GUI effect.
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MessageHandleIgnore.Dispose();
          HOperatorSet.DequeueMessage(hv_MessageQueues.TupleSelect(0), "timeout", 
              0, out hv_MessageHandleIgnore);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException2)
        {
          HDevExpDefaultException2.ToHTuple(out hv_Exception);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues.TupleSelect(0), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        hv_CurrentState.Dispose();
        hv_CurrentState = new HTuple(hv_Current);
        hv_EventHappened1.Dispose();
        hv_EventHappened1 = 1;
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(2891))) != 0)
      {
        //Message queue overflow
        //-> there is already a mouse event in the queue, do not add another one
        //   to avoid overflowing the queue

        hv_MessageHandle.Dispose();
        hv_Type.Dispose();
        hv_Exception.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_Button.Dispose();
        hv_Current.Dispose();
        hv_MessageHandleIgnore.Dispose();
        hv_EventHappened1.Dispose();

        return;
      }
      else if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
          5))).TupleAnd(new HTuple(((hv_Exception.TupleSelect(5))).TupleEqual("get_mposition_sub_pix")))) != 0)
      {
        //Mouse not in window
        //Ignore
        HOperatorSet.WaitSeconds(0.01);
      }
      else if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
          2454))).TupleOr(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(5100)))) != 0)
      {
        //Handle was already cleared -> indicates that the window was closed (by the user)
        //Abort gracefully.
        hv_DidFinish.Dispose();
        hv_DidFinish = 1;

        hv_MessageHandle.Dispose();
        hv_Type.Dispose();
        hv_Exception.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_Button.Dispose();
        hv_Current.Dispose();
        hv_MessageHandleIgnore.Dispose();
        hv_EventHappened1.Dispose();

        return;
      }
      else
      {
        //Unknown / Unexpected exception
        throw new HalconException(hv_Exception);
      }
    }

    hv_MessageHandle.Dispose();
    hv_Type.Dispose();
    hv_Exception.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Button.Dispose();
    hv_Current.Dispose();
    hv_MessageHandleIgnore.Dispose();
    hv_EventHappened1.Dispose();

    return;

  }

  // Short Description: Generic processor for events of visualize_object_model_3d_ext 
  public void process_visualize_events_generic (HTuple hv_WindowHandle, HTuple hv_MessageQueues, 
      HTuple hv_PreviousState, out HTuple hv_DidFinish, out HTuple hv_NewState, out HTuple hv_ButtonPressed, 
      out HTuple hv_Poses)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MessageHandle = new HTuple(), hv_Type = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_ButtonID = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Button = new HTuple(), hv_Current = new HTuple();
    HTuple hv_MessageHandleIgnore = new HTuple();
    // Initialize local and output iconic variables 
    hv_DidFinish = new HTuple();
    hv_NewState = new HTuple();
    hv_ButtonPressed = new HTuple();
    hv_Poses = new HTuple();
    hv_NewState.Dispose();
    hv_NewState = new HTuple(hv_PreviousState);
    hv_ButtonPressed.Dispose();
    hv_ButtonPressed = new HTuple();
    hv_Poses.Dispose();
    hv_Poses = new HTuple();
    hv_DidFinish.Dispose();
    hv_DidFinish = 0;
    //
    try
    {
      try
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MessageHandle.Dispose();
        HOperatorSet.DequeueMessage(hv_MessageQueues.TupleSelect(2), "timeout", 0, 
            out hv_MessageHandle);
        }
        hv_Type.Dispose();
        HOperatorSet.GetMessageTuple(hv_MessageHandle, "type", out hv_Type);
        if ((int)(new HTuple(hv_Type.TupleEqual("done"))) != 0)
        {
          //The visualization function has finished and has exited
          hv_DidFinish.Dispose();
          hv_DidFinish = 1;
        }
        else if ((int)(new HTuple(hv_Type.TupleEqual("exception"))) != 0)
        {
          hv_DidFinish.Dispose();
          hv_DidFinish = 1;
          hv_Exception.Dispose();
          HOperatorSet.GetMessageTuple(hv_MessageHandle, "exception", out hv_Exception);
          throw new HalconException(hv_Exception);
        }
        else if ((int)(new HTuple(hv_Type.TupleEqual("button_pressed"))) != 0)
        {
          //The user pressed one of the buttons
          hv_ButtonID.Dispose();
          HOperatorSet.GetMessageTuple(hv_MessageHandle, "button", out hv_ButtonID);
          hv_ButtonPressed.Dispose();
          hv_ButtonPressed = new HTuple(hv_ButtonID);
        }
        else if ((int)(new HTuple(hv_Type.TupleEqual("redraw"))) != 0)
        {
          hv_Poses.Dispose();
          HOperatorSet.GetMessageTuple(hv_MessageHandle, "poses", out hv_Poses);
          //Nothing TBD
        }
        else
        {
          //Unknown / unexpected Message
          // stop(...); only in hdevelop
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException2)
      {
        HDevExpDefaultException2.ToHTuple(out hv_Exception);
        //Ignore timeout (no message in queue)
        if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(9400))) != 0)
        {
          throw new HalconException(hv_Exception);
        }
      }

      hv_Row.Dispose();hv_Column.Dispose();hv_Button.Dispose();
      get_mouse_info(hv_WindowHandle, new HTuple(), new HTuple(), out hv_Row, out hv_Column, 
          out hv_Button);

      hv_Current.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Current = new HTuple();
      hv_Current = hv_Current.TupleConcat(hv_Row, hv_Column, hv_Button);
      }
      if ((int)(new HTuple(hv_Current.TupleNotEqual(hv_PreviousState))) != 0)
      {
        hv_MessageHandle.Dispose();
        HOperatorSet.CreateMessage(out hv_MessageHandle);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "mouse_event");
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "mouse_row", hv_Row);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "mouse_col", hv_Column);
        HOperatorSet.SetMessageTuple(hv_MessageHandle, "mouse_button", hv_Button);
        //Remove any previous mouse message and overwrite it with the new
        //message. If the sub thread is too slow to process the mouse events,
        //we rather skip one and only use the last one. This avoids
        //the "lagging" GUI effect.
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MessageHandleIgnore.Dispose();
          HOperatorSet.DequeueMessage(hv_MessageQueues.TupleSelect(0), "timeout", 
              0, out hv_MessageHandleIgnore);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException2)
        {
          HDevExpDefaultException2.ToHTuple(out hv_Exception);
          //Ignore
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.EnqueueMessage(hv_MessageQueues.TupleSelect(0), hv_MessageHandle, 
            new HTuple(), new HTuple());
        }
        hv_NewState.Dispose();
        hv_NewState = new HTuple(hv_Current);
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(2891))) != 0)
      {
        //Message Queue overflow (usually of the mouse event queue)

        hv_MessageHandle.Dispose();
        hv_Type.Dispose();
        hv_Exception.Dispose();
        hv_ButtonID.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_Button.Dispose();
        hv_Current.Dispose();
        hv_MessageHandleIgnore.Dispose();

        return;
      }
      else if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
          5))).TupleAnd(new HTuple(((hv_Exception.TupleSelect(5))).TupleEqual("get_mposition_sub_pix")))) != 0)
      {
        //Mouse not in window
        //Ignore
        HOperatorSet.WaitSeconds(0.01);
      }
      else if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
          2454))).TupleOr(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(5100)))) != 0)
      {
        //Handle was already cleared -> indicates that the window was closed (by the user)
        //Abort gracefully.
        hv_DidFinish.Dispose();
        hv_DidFinish = 1;

        hv_MessageHandle.Dispose();
        hv_Type.Dispose();
        hv_Exception.Dispose();
        hv_ButtonID.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_Button.Dispose();
        hv_Current.Dispose();
        hv_MessageHandleIgnore.Dispose();

        return;
      }
      else
      {
        //Unknown / Unexpected exception
        throw new HalconException(hv_Exception);
      }
    }

    hv_MessageHandle.Dispose();
    hv_Type.Dispose();
    hv_Exception.Dispose();
    hv_ButtonID.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Button.Dispose();
    hv_Current.Dispose();
    hv_MessageHandleIgnore.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Project an image point onto the trackball 
  public void project_point_on_trackball (HTuple hv_X, HTuple hv_Y, HTuple hv_VirtualTrackball, 
      HTuple hv_TrackballSize, out HTuple hv_V)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_R = new HTuple(), hv_XP = new HTuple();
    HTuple hv_YP = new HTuple(), hv_ZP = new HTuple();
    // Initialize local and output iconic variables 
    hv_V = new HTuple();
    //
    if ((int)(new HTuple(hv_VirtualTrackball.TupleEqual("shoemake"))) != 0)
    {
      //Virtual Trackball according to Shoemake
      hv_R.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_R = (((hv_X*hv_X)+(hv_Y*hv_Y))).TupleSqrt()
          ;
      }
      if ((int)(new HTuple(hv_R.TupleLessEqual(hv_TrackballSize))) != 0)
      {
        hv_XP.Dispose();
        hv_XP = new HTuple(hv_X);
        hv_YP.Dispose();
        hv_YP = new HTuple(hv_Y);
        hv_ZP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZP = (((hv_TrackballSize*hv_TrackballSize)-(hv_R*hv_R))).TupleSqrt()
            ;
        }
      }
      else
      {
        hv_XP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XP = (hv_X*hv_TrackballSize)/hv_R;
        }
        hv_YP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YP = (hv_Y*hv_TrackballSize)/hv_R;
        }
        hv_ZP.Dispose();
        hv_ZP = 0;
      }
    }
    else
    {
      //Virtual Trackball according to Bell
      hv_R.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_R = (((hv_X*hv_X)+(hv_Y*hv_Y))).TupleSqrt()
          ;
      }
      if ((int)(new HTuple(hv_R.TupleLessEqual(hv_TrackballSize*0.70710678))) != 0)
      {
        hv_XP.Dispose();
        hv_XP = new HTuple(hv_X);
        hv_YP.Dispose();
        hv_YP = new HTuple(hv_Y);
        hv_ZP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZP = (((hv_TrackballSize*hv_TrackballSize)-(hv_R*hv_R))).TupleSqrt()
            ;
        }
      }
      else
      {
        hv_XP.Dispose();
        hv_XP = new HTuple(hv_X);
        hv_YP.Dispose();
        hv_YP = new HTuple(hv_Y);
        hv_ZP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZP = ((0.6*hv_TrackballSize)*hv_TrackballSize)/hv_R;
        }
      }
    }
    hv_V.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_V = new HTuple();
    hv_V = hv_V.TupleConcat(hv_XP, hv_YP, hv_ZP);
    }

    hv_R.Dispose();
    hv_XP.Dispose();
    hv_YP.Dispose();
    hv_ZP.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Project an image point onto the trackball 
  public void project_point_on_trackball_visualize_object_model_3d (HTuple hv_X, 
      HTuple hv_Y, HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, out HTuple hv_V)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_R = new HTuple(), hv_XP = new HTuple();
    HTuple hv_YP = new HTuple(), hv_ZP = new HTuple();
    // Initialize local and output iconic variables 
    hv_V = new HTuple();
    //
    if ((int)(new HTuple(hv_VirtualTrackball.TupleEqual("shoemake"))) != 0)
    {
      //Virtual Trackball according to Shoemake
      hv_R.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_R = (((hv_X*hv_X)+(hv_Y*hv_Y))).TupleSqrt()
          ;
      }
      if ((int)(new HTuple(hv_R.TupleLessEqual(hv_TrackballSize))) != 0)
      {
        hv_XP.Dispose();
        hv_XP = new HTuple(hv_X);
        hv_YP.Dispose();
        hv_YP = new HTuple(hv_Y);
        hv_ZP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZP = (((hv_TrackballSize*hv_TrackballSize)-(hv_R*hv_R))).TupleSqrt()
            ;
        }
      }
      else
      {
        hv_XP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XP = (hv_X*hv_TrackballSize)/hv_R;
        }
        hv_YP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YP = (hv_Y*hv_TrackballSize)/hv_R;
        }
        hv_ZP.Dispose();
        hv_ZP = 0;
      }
    }
    else
    {
      //Virtual Trackball according to Bell
      hv_R.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_R = (((hv_X*hv_X)+(hv_Y*hv_Y))).TupleSqrt()
          ;
      }
      if ((int)(new HTuple(hv_R.TupleLessEqual(hv_TrackballSize*0.70710678))) != 0)
      {
        hv_XP.Dispose();
        hv_XP = new HTuple(hv_X);
        hv_YP.Dispose();
        hv_YP = new HTuple(hv_Y);
        hv_ZP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZP = (((hv_TrackballSize*hv_TrackballSize)-(hv_R*hv_R))).TupleSqrt()
            ;
        }
      }
      else
      {
        hv_XP.Dispose();
        hv_XP = new HTuple(hv_X);
        hv_YP.Dispose();
        hv_YP = new HTuple(hv_Y);
        hv_ZP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZP = ((0.6*hv_TrackballSize)*hv_TrackballSize)/hv_R;
        }
      }
    }
    hv_V.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_V = new HTuple();
    hv_V = hv_V.TupleConcat(hv_XP, hv_YP, hv_ZP);
    }

    hv_R.Dispose();
    hv_XP.Dispose();
    hv_YP.Dispose();
    hv_ZP.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: List all available feature group names. 
  public void query_feature_group_names (out HTuple hv_GroupNames)
  {


    // Local iconic variables 

    HObject ho_Region, ho_Image;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_Image);
    hv_GroupNames = new HTuple();
    //
    //Return all available feature groups
    //
    ho_Region.Dispose();ho_Image.Dispose();
    gen_dummy_objects(out ho_Region, out ho_Image);
    hv_GroupNames.Dispose();
    get_features(ho_Region, ho_Image, "", "get_groups", out hv_GroupNames);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_GroupNames = ((hv_GroupNames.TupleSort()
        )).TupleUniq();
    hv_GroupNames.Dispose();
    hv_GroupNames = ExpTmpLocalVar_GroupNames;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_GroupNames = hv_GroupNames.TupleConcat(
        "all");
    hv_GroupNames.Dispose();
    hv_GroupNames = ExpTmpLocalVar_GroupNames;
    }
    }
    ho_Region.Dispose();
    ho_Image.Dispose();


    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Returns a table of feature names sorted by groups. 
  public void query_feature_names_by_group (HTuple hv_GroupNames, out HTuple hv_FeatureNames, 
      out HTuple hv_Groups)
  {



    // Local iconic variables 

    HObject ho_Region, ho_Image;

    // Local control variables 

    HTuple hv_I = new HTuple(), hv_Names = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_Image);
    hv_FeatureNames = new HTuple();
    hv_Groups = new HTuple();
    //
    //Return a table (consisting of two tuples)
    //of all features and the groups they belong to.
    //
    hv_FeatureNames.Dispose();
    hv_FeatureNames = new HTuple();
    hv_Groups.Dispose();
    hv_Groups = new HTuple();
    ho_Region.Dispose();ho_Image.Dispose();
    gen_dummy_objects(out ho_Region, out ho_Image);
    for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_GroupNames.TupleLength()))-1); hv_I = (int)hv_I + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Names.Dispose();
      get_features(ho_Region, ho_Image, hv_GroupNames.TupleSelect(hv_I), "get_names", 
          out hv_Names);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_FeatureNames = hv_FeatureNames.TupleConcat(
          hv_Names);
      hv_FeatureNames.Dispose();
      hv_FeatureNames = ExpTmpLocalVar_FeatureNames;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Groups = hv_Groups.TupleConcat(
          HTuple.TupleGenConst(new HTuple(hv_Names.TupleLength()),hv_GroupNames.TupleSelect(
          hv_I)));
      hv_Groups.Dispose();
      hv_Groups = ExpTmpLocalVar_Groups;
      }
      }
    }
    ho_Region.Dispose();
    ho_Image.Dispose();

    hv_I.Dispose();
    hv_Names.Dispose();

    return;
  }

  // Chapter: System / Multithreading
  public void read_dict_object (out HObject ho_ObjectData, HTuple hv_DictHandle, 
      HTuple hv_Key)
  {



    // Local control variables 

    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ObjectData);
    try
    {
      ho_ObjectData.Dispose();
      HOperatorSet.GetDictObject(out ho_ObjectData, hv_DictHandle, hv_Key);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      throw new HalconException((("The key "+hv_Key)+" is missing from the dict ")+hv_DictHandle);
    }

    hv_Exception.Dispose();

    return;
  }

  // Chapter: System / Multithreading
  public void read_dict_tuple (HTuple hv_DictHandle, HTuple hv_Key, out HTuple hv_TupleData)
  {



    // Local control variables 

    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    hv_TupleData = new HTuple();
    try
    {
      hv_TupleData.Dispose();
      HOperatorSet.GetDictTuple(hv_DictHandle, hv_Key, out hv_TupleData);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      throw new HalconException((("The key "+hv_Key)+" is missing from the dict ")+hv_DictHandle);
    }

    hv_Exception.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Read the data set containing the images and their respective ground truth labels.  
  public void read_dl_classifier_data_set (HTuple hv_ImageDirectory, HTuple hv_LabelSource, 
      out HTuple hv_ImageFiles, out HTuple hv_GroundTruthLabels, out HTuple hv_LabelIndices, 
      out HTuple hv_UniqueClasses)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_LabelsTmp = new HTuple(), hv_ClassIndex = new HTuple();
    // Initialize local and output iconic variables 
    hv_ImageFiles = new HTuple();
    hv_GroundTruthLabels = new HTuple();
    hv_LabelIndices = new HTuple();
    hv_UniqueClasses = new HTuple();
    //This procedures lists all ImageFiles
    //located in ImageDirectory and its subdirectories,
    //and returns the label of each image in GroundTruthLabels.
    //LabelSource determines how the ground truth labels are extracted.
    //Additionally, indices are assigned to the labels,
    //which can be used for the training instead
    //of the string labels, which is more time efficient.
    //The order of indices corresponds with the returned
    //unique Classes.
    //
    //Check the parameter ImageDirectory.
    if ((int)(((hv_ImageDirectory.TupleIsString())).TupleNot()) != 0)
    {
      throw new HalconException(("ImageDirectory "+hv_ImageDirectory)+"is not a string.");
    }
    //
    //List all images in the provided directory
    //and its subdirectories ('recursive').
    hv_ImageFiles.Dispose();
    list_image_files(hv_ImageDirectory, ((((((((((((((new HTuple("hobj")).TupleConcat(
        "ima")).TupleConcat("bmp")).TupleConcat("jpg")).TupleConcat("png")).TupleConcat(
        "tiff")).TupleConcat("tif")).TupleConcat("gif")).TupleConcat("jpeg")).TupleConcat(
        "pcx")).TupleConcat("pgm")).TupleConcat("ppm")).TupleConcat("pbm")).TupleConcat(
        "xwd")).TupleConcat("pnm"), (new HTuple("recursive")).TupleConcat("follow_links"), 
        out hv_ImageFiles);
    if ((int)(new HTuple((new HTuple(hv_ImageFiles.TupleLength())).TupleEqual(0))) != 0)
    {
      throw new HalconException(("Error: Could not find any image files in folder: \""+hv_ImageDirectory)+"\"");
    }
    //
    //Get the ground truth labels.
    //Note that when configuring your own LabelSource mode,
    //you might find the procedure parse_filename helpful.
    if ((int)(new HTuple(hv_LabelSource.TupleEqual("last_folder"))) != 0)
    {
      //The last folder name containing the image
      //is used as label.
      hv_GroundTruthLabels.Dispose();
      HOperatorSet.TupleRegexpMatch(hv_ImageFiles, ".*/([^/]+)/[^/]*$", out hv_GroundTruthLabels);
    }
    else if ((int)(new HTuple(hv_LabelSource.TupleEqual("file_name"))) != 0)
    {
      //The file name of each image is used as label.
      hv_GroundTruthLabels.Dispose();
      HOperatorSet.TupleRegexpMatch(hv_ImageFiles, ".*/([^/]+)[.][^/]*$", out hv_GroundTruthLabels);
    }
    else if ((int)(new HTuple(hv_LabelSource.TupleEqual("file_name_remove_index"))) != 0)
    {
      //The file name of each image is used as label.
      //All consecutive digits and underscores
      //at the end of the file name are removed.
      hv_LabelsTmp.Dispose();
      HOperatorSet.TupleRegexpMatch(hv_ImageFiles, ".*/([^/]+)[.][^/]*$", out hv_LabelsTmp);
      hv_GroundTruthLabels.Dispose();
      HOperatorSet.TupleRegexpReplace(hv_LabelsTmp, "[0-9_]*$", "", out hv_GroundTruthLabels);
    }
    else if ((int)(new HTuple(hv_LabelSource.TupleEqual(new HTuple()))) != 0)
    {
      hv_GroundTruthLabels.Dispose();
      hv_GroundTruthLabels = new HTuple();
    }
    else
    {
      throw new HalconException("LabelSource not supported.");
    }
    //Get the unique elements of Labels,
    //which represent the classes.
    hv_UniqueClasses.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_UniqueClasses = ((hv_GroundTruthLabels.TupleSort()
        )).TupleUniq();
    }
    //Assign indices to the labels.
    hv_LabelIndices.Dispose();
    hv_LabelIndices = new HTuple(hv_GroundTruthLabels);
    for (hv_ClassIndex=0; (int)hv_ClassIndex<=(int)((new HTuple(hv_UniqueClasses.TupleLength()
        ))-1); hv_ClassIndex = (int)hv_ClassIndex + 1)
    {
      if (hv_LabelIndices == null)
        hv_LabelIndices = new HTuple();
      hv_LabelIndices[hv_LabelIndices.TupleFind(hv_UniqueClasses.TupleSelect(hv_ClassIndex))] = hv_ClassIndex;
    }

    hv_LabelsTmp.Dispose();
    hv_ClassIndex.Dispose();

    return;
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: Read the COCO file and convert it to the dictionary DLDataset. 
  public void read_dl_dataset_from_coco (HTuple hv_CocoFileName, HTuple hv_ImageDir, 
      HTuple hv_GenParam, out HTuple hv_DLDataset)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ReadOnlyNonCrowd = new HTuple();
    HTuple hv_ReadRawAnnotations = new HTuple(), hv_GenParamNames = new HTuple();
    HTuple hv_ParamIndex = new HTuple(), hv_GenParamName = new HTuple();
    HTuple hv_GenParamValue = new HTuple(), hv_DictCocoJson = new HTuple();
    HTuple hv_ExceptionTopmostLevel = new HTuple(), hv_CategoryKeys = new HTuple();
    HTuple hv_CategoryList = new HTuple(), hv_ImageKeys = new HTuple();
    HTuple hv_ImageList = new HTuple(), hv_AnnotationKeys = new HTuple();
    HTuple hv_AnnotationList = new HTuple(), hv_Purpose = new HTuple();
    HTuple hv_Annotation = new HTuple(), hv_BBox = new HTuple();
    HTuple hv_ExceptionBBox = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Category = new HTuple(), hv_ID = new HTuple();
    HTuple hv_Name = new HTuple(), hv_ExceptionCategory = new HTuple();
    HTuple hv_ClassIDs = new HTuple(), hv_ClassNames = new HTuple();
    HTuple hv_AnnotImageIDs = new HTuple(), hv_ImageIDAnnot = new HTuple();
    HTuple hv_ExceptionAnnot = new HTuple(), hv_Image = new HTuple();
    HTuple hv_ImageName = new HTuple(), hv_ImageID = new HTuple();
    HTuple hv_ExceptionImage = new HTuple(), hv_FileExists = new HTuple();
    HTuple hv_AnnotationIndicesThisImage = new HTuple(), hv_AnnotClassIDs = new HTuple();
    HTuple hv_AnnotBboxColumn1s = new HTuple(), hv_AnnotBboxRow1s = new HTuple();
    HTuple hv_AnnotBboxColumn2s = new HTuple(), hv_AnnotBboxRow2s = new HTuple();
    HTuple hv_AnnotationPerImage = new HTuple(), hv_AnnotationKeysThisImage = new HTuple();
    HTuple hv_AnnotIndexCounter = new HTuple(), hv_AnnotIndex = new HTuple();
    HTuple hv_IsCrowd = new HTuple(), hv_ExceptionIsCrowd = new HTuple();
    HTuple hv_AnnotClassID = new HTuple(), hv_AnnotBboxColumn1 = new HTuple();
    HTuple hv_AnnotBboxRow1 = new HTuple(), hv_AnnotBboxWidth = new HTuple();
    HTuple hv_AnnotBboxHeight = new HTuple(), hv_AnnotBboxRow2 = new HTuple();
    HTuple hv_AnnotBboxColumn2 = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_DLSamples = new HTuple();
    HTuple   hv_ImageDir_COPY_INP_TMP = new HTuple(hv_ImageDir);

    // Initialize local and output iconic variables 
    hv_DLDataset = new HTuple();
    //
    //This procedure reads a COCO file and creates a DLDataset dictionary out of it.
    //Note, only the COCO annotation type 'Object Detection' is supported.
    //
    dev_update_off();
    //
    //Sanity checks of procedure inputs.
    //Check the given input for the COCO file CocoFileName.
    if ((int)(new HTuple((new HTuple(hv_CocoFileName.TupleLength())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("Only one coco file can be given.");
    }
    else if ((int)(new HTuple(((hv_CocoFileName.TupleIsString())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("CocoFileName is not a string.");
    }
    if ((int)(new HTuple((new HTuple(hv_ImageDir_COPY_INP_TMP.TupleLength())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("Only one base path for the images can be given.");
    }
    else if ((int)(new HTuple(((hv_ImageDir_COPY_INP_TMP.TupleIsString())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("ImageDir is not a string.");
    }
    //Make sure, ImageDir ends with a '/'.
    if ((int)(hv_ImageDir_COPY_INP_TMP.TupleRegexpTest("[^/]$")) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ImageDir = hv_ImageDir_COPY_INP_TMP+"/";
      hv_ImageDir_COPY_INP_TMP.Dispose();
      hv_ImageDir_COPY_INP_TMP = ExpTmpLocalVar_ImageDir;
      }
      }
    }
    //
    //Check the dictionary GenParam and transfer the given values.
    //
    //Default values.
    //Per default, do not read annotations, which have the attribute 'iscrowd'.
    hv_ReadOnlyNonCrowd.Dispose();
    hv_ReadOnlyNonCrowd = 1;
    //Per default, do not transfer the raw format of the annotations.
    hv_ReadRawAnnotations.Dispose();
    hv_ReadRawAnnotations = 0;
    //
    //Transfer the given GenParam entries.
    if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_GenParamNames.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
      for (hv_ParamIndex=0; (int)hv_ParamIndex<=(int)((new HTuple(hv_GenParamNames.TupleLength()
          ))-1); hv_ParamIndex = (int)hv_ParamIndex + 1)
      {
        hv_GenParamName.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GenParamName = hv_GenParamNames.TupleSelect(
            hv_ParamIndex);
        }
        hv_GenParamValue.Dispose();
        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamName, out hv_GenParamValue);
        if ((int)(new HTuple(hv_GenParamName.TupleEqual("read_only_non_crowd_detection"))) != 0)
        {
          if ((int)((new HTuple(hv_GenParamValue.TupleEqual("true"))).TupleOr(new HTuple(hv_GenParamValue.TupleEqual(
              1)))) != 0)
          {
            hv_ReadOnlyNonCrowd.Dispose();
            hv_ReadOnlyNonCrowd = 1;
          }
          else if ((int)((new HTuple(hv_GenParamValue.TupleEqual("false"))).TupleOr(
              new HTuple(hv_GenParamValue.TupleEqual(0)))) != 0)
          {
            hv_ReadOnlyNonCrowd.Dispose();
            hv_ReadOnlyNonCrowd = 0;
          }
          else
          {
            throw new HalconException("GenParamValue for GenParamName read_only_non_crowd_detection is not supported.");
          }
        }
        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("coco_raw_annotations"))) != 0)
        {
          if ((int)((new HTuple(hv_GenParamValue.TupleEqual("true"))).TupleOr(new HTuple(hv_GenParamValue.TupleEqual(
              1)))) != 0)
          {
            hv_ReadRawAnnotations.Dispose();
            hv_ReadRawAnnotations = 1;
          }
          else if ((int)((new HTuple(hv_GenParamValue.TupleEqual("false"))).TupleOr(
              new HTuple(hv_GenParamValue.TupleEqual(0)))) != 0)
          {
            hv_ReadRawAnnotations.Dispose();
            hv_ReadRawAnnotations = 0;
          }
          else
          {
            throw new HalconException("GenParamValue for GenParamName coco_raw_annotations is not supported.");
          }
        }
        else
        {
          throw new HalconException(("Unknown generic parameter: "+hv_GenParamName)+".");
        }
      }
    }
    //
    //Read the COCO file into a dictionary.
    hv_DictCocoJson.Dispose();
    HOperatorSet.ReadDict(hv_CocoFileName, new HTuple(), new HTuple(), out hv_DictCocoJson);
    //
    //Check topmost content of JSON file for categories.
    hv_ExceptionTopmostLevel.Dispose();
    hv_ExceptionTopmostLevel = new HTuple();
    hv_CategoryKeys.Dispose();
    hv_CategoryKeys = new HTuple();
    try
    {
      hv_CategoryList.Dispose();
      HOperatorSet.GetDictTuple(hv_DictCocoJson, "categories", out hv_CategoryList);
      hv_CategoryKeys.Dispose();
      HOperatorSet.GetDictParam(hv_CategoryList, "keys", new HTuple(), out hv_CategoryKeys);
    }
    // catch (ExceptionTopmostLevel) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_ExceptionTopmostLevel);
    }
    if ((int)((new HTuple(hv_ExceptionTopmostLevel.TupleNotEqual(new HTuple()))).TupleOr(
        new HTuple((new HTuple(hv_CategoryKeys.TupleLength())).TupleEqual(0)))) != 0)
    {
      throw new HalconException("The COCO file has to contain categories on the topmost level.");
    }
    //Check topmost content of JSON file for images.
    hv_ExceptionTopmostLevel.Dispose();
    hv_ExceptionTopmostLevel = new HTuple();
    hv_ImageKeys.Dispose();
    hv_ImageKeys = new HTuple();
    try
    {
      hv_ImageList.Dispose();
      HOperatorSet.GetDictTuple(hv_DictCocoJson, "images", out hv_ImageList);
      hv_ImageKeys.Dispose();
      HOperatorSet.GetDictParam(hv_ImageList, "keys", new HTuple(), out hv_ImageKeys);
    }
    // catch (ExceptionTopmostLevel) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_ExceptionTopmostLevel);
    }

    if ((int)((new HTuple(hv_ExceptionTopmostLevel.TupleNotEqual(new HTuple()))).TupleOr(
        new HTuple((new HTuple(hv_ImageKeys.TupleLength())).TupleEqual(0)))) != 0)
    {
      throw new HalconException("The COCO file has to contain images on the topmost level.");
    }
    //Check topmost content of JSON file for annotations.
    hv_ExceptionTopmostLevel.Dispose();
    hv_ExceptionTopmostLevel = new HTuple();
    hv_AnnotationKeys.Dispose();
    hv_AnnotationKeys = new HTuple();
    try
    {
      hv_AnnotationList.Dispose();
      HOperatorSet.GetDictTuple(hv_DictCocoJson, "annotations", out hv_AnnotationList);
      hv_AnnotationKeys.Dispose();
      HOperatorSet.GetDictParam(hv_AnnotationList, "keys", new HTuple(), out hv_AnnotationKeys);
    }
    // catch (ExceptionTopmostLevel) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_ExceptionTopmostLevel);
    }

    if ((int)((new HTuple(hv_ExceptionTopmostLevel.TupleNotEqual(new HTuple()))).TupleOr(
        new HTuple((new HTuple(hv_AnnotationKeys.TupleLength())).TupleEqual(0)))) != 0)
    {
      throw new HalconException("The first COCO annotation does not contain the entries bbox. This COCO format is not supported.");
    }
    //
    //Determine the purpose of this Dataset according to the content.
    hv_Purpose.Dispose();
    hv_Purpose = new HTuple();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Annotation.Dispose();
    HOperatorSet.GetDictTuple(hv_AnnotationList, hv_AnnotationKeys.TupleSelect(0), 
        out hv_Annotation);
    }
    try
    {
      hv_BBox.Dispose();
      HOperatorSet.GetDictTuple(hv_Annotation, "bbox", out hv_BBox);
      hv_Purpose.Dispose();
      hv_Purpose = "object_detection";
    }
    // catch (ExceptionBBox) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_ExceptionBBox);
      throw new HalconException("The first COCO annotation does not contain the entries bbox. This COCO format is not supported.");
    }
    //
    //Create the DLDataset dictionary.
    hv_DLDataset.Dispose();
    HOperatorSet.CreateDict(out hv_DLDataset);
    //
    //Set the base image directory.
    HOperatorSet.SetDictTuple(hv_DLDataset, "image_dir", hv_ImageDir_COPY_INP_TMP);
    //
    //Set the class information.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_CategoryKeys.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      try
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Category.Dispose();
        HOperatorSet.GetDictTuple(hv_CategoryList, hv_CategoryKeys.TupleSelect(hv_Index), 
            out hv_Category);
        }
        hv_ID.Dispose();
        HOperatorSet.GetDictTuple(hv_Category, "id", out hv_ID);
        hv_Name.Dispose();
        HOperatorSet.GetDictTuple(hv_Category, "name", out hv_Name);
      }
      // catch (ExceptionCategory) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_ExceptionCategory);
        throw new HalconException(("COCO category number "+hv_Index)+" does not contain the entry id or name.");
      }
      if (hv_ClassIDs == null)
        hv_ClassIDs = new HTuple();
      hv_ClassIDs[hv_Index] = hv_ID;
      if (hv_ClassNames == null)
        hv_ClassNames = new HTuple();
      hv_ClassNames[hv_Index] = hv_Name;
    }
    HOperatorSet.SetDictTuple(hv_DLDataset, "class_ids", hv_ClassIDs);
    HOperatorSet.SetDictTuple(hv_DLDataset, "class_names", hv_ClassNames);
    //
    //Generate the samples.
    //Get the 'image_id' for each annotation for looking it up later.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_AnnotImageIDs.Dispose();
    HOperatorSet.TupleGenConst(new HTuple(hv_AnnotationKeys.TupleLength()), -1, out hv_AnnotImageIDs);
    }
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_AnnotationKeys.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      try
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Annotation.Dispose();
        HOperatorSet.GetDictTuple(hv_AnnotationList, hv_AnnotationKeys.TupleSelect(
            hv_Index), out hv_Annotation);
        }
        hv_ImageIDAnnot.Dispose();
        HOperatorSet.GetDictTuple(hv_Annotation, "image_id", out hv_ImageIDAnnot);
      }
      // catch (ExceptionAnnot) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_ExceptionAnnot);
        throw new HalconException(("COCO annotation number "+hv_Index)+" does not contain image_id.");
      }
      if (hv_AnnotImageIDs == null)
        hv_AnnotImageIDs = new HTuple();
      hv_AnnotImageIDs[hv_Index] = hv_ImageIDAnnot;
    }
    //Iterate over the images and fill according sample.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ImageKeys.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      //
      //Get the image information.
      try
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Image.Dispose();
        HOperatorSet.GetDictTuple(hv_ImageList, hv_ImageKeys.TupleSelect(hv_Index), 
            out hv_Image);
        }
        hv_ImageName.Dispose();
        HOperatorSet.GetDictTuple(hv_Image, "file_name", out hv_ImageName);
        hv_ImageID.Dispose();
        HOperatorSet.GetDictTuple(hv_Image, "id", out hv_ImageID);
      }
      // catch (ExceptionImage) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_ExceptionImage);
        throw new HalconException(("COCO image number "+hv_Index)+" does not contain id or file_name.");
      }
      //
      //Check that the image is found at the given location.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FileExists.Dispose();
      HOperatorSet.FileExists(hv_ImageDir_COPY_INP_TMP+hv_ImageName, out hv_FileExists);
      }
      if ((int)(hv_FileExists.TupleNot()) != 0)
      {
        throw new HalconException(((((("COCO image number "+hv_Index)+" (id = ")+hv_ImageID)+") could not be found at the location ImageDir + file_name = ")+hv_ImageDir_COPY_INP_TMP)+hv_ImageName);
      }
      //
      //Get the annotation data for the selected image.
      hv_AnnotationIndicesThisImage.Dispose();
      HOperatorSet.TupleFind(hv_AnnotImageIDs, hv_ImageID, out hv_AnnotationIndicesThisImage);
      if ((int)(new HTuple(hv_Purpose.TupleEqual("object_detection"))) != 0)
      {
        //For object detection, several annotations per image are possible.
        hv_AnnotClassIDs.Dispose();
        hv_AnnotClassIDs = new HTuple();
        hv_AnnotBboxColumn1s.Dispose();
        hv_AnnotBboxColumn1s = new HTuple();
        hv_AnnotBboxRow1s.Dispose();
        hv_AnnotBboxRow1s = new HTuple();
        hv_AnnotBboxColumn2s.Dispose();
        hv_AnnotBboxColumn2s = new HTuple();
        hv_AnnotBboxRow2s.Dispose();
        hv_AnnotBboxRow2s = new HTuple();
      }
      if ((int)(new HTuple(hv_AnnotationIndicesThisImage.TupleEqual(-1))) != 0)
      {
        //If no annotation was found for this image.
        hv_AnnotationPerImage.Dispose();
        hv_AnnotationPerImage = new HTuple();
      }
      else
      {
        //Otherwise, process the annotations.
        hv_AnnotationKeysThisImage.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AnnotationKeysThisImage = hv_AnnotationKeys.TupleSelect(
            hv_AnnotationIndicesThisImage);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AnnotationPerImage.Dispose();
        HOperatorSet.TupleGenConst(new HTuple(hv_AnnotationKeysThisImage.TupleLength()
            ), HHandle.HNULL, out hv_AnnotationPerImage);
        }
        hv_AnnotIndexCounter.Dispose();
        hv_AnnotIndexCounter = 0;
        for (hv_AnnotIndex=0; (int)hv_AnnotIndex<=(int)((new HTuple(hv_AnnotationKeysThisImage.TupleLength()
            ))-1); hv_AnnotIndex = (int)hv_AnnotIndex + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Annotation.Dispose();
          HOperatorSet.GetDictTuple(hv_AnnotationList, hv_AnnotationKeysThisImage.TupleSelect(
              hv_AnnotIndex), out hv_Annotation);
          }
          //
          if ((int)(new HTuple(hv_Purpose.TupleEqual("object_detection"))) != 0)
          {
            try
            {
              hv_IsCrowd.Dispose();
              HOperatorSet.GetDictTuple(hv_Annotation, "iscrowd", out hv_IsCrowd);
            }
            // catch (ExceptionIsCrowd) 
            catch (HalconException HDevExpDefaultException1)
            {
              HDevExpDefaultException1.ToHTuple(out hv_ExceptionIsCrowd);
              //If IsCrowd is not set, we assume it is 0 and set IsCrowd=0.
              hv_IsCrowd.Dispose();
              hv_IsCrowd = 0;
            }
            if ((int)(hv_ReadOnlyNonCrowd.TupleAnd(hv_IsCrowd)) != 0)
            {
              continue;
            }
            if ((int)(hv_ReadRawAnnotations) != 0)
            {
              if (hv_AnnotationPerImage == null)
                hv_AnnotationPerImage = new HTuple();
              hv_AnnotationPerImage[hv_AnnotIndexCounter] = hv_Annotation;
            }
            try
            {
              hv_AnnotClassID.Dispose();
              HOperatorSet.GetDictTuple(hv_Annotation, "category_id", out hv_AnnotClassID);
              hv_BBox.Dispose();
              HOperatorSet.GetDictTuple(hv_Annotation, "bbox", out hv_BBox);
              hv_AnnotBboxColumn1.Dispose();
              HOperatorSet.GetDictTuple(hv_BBox, 0, out hv_AnnotBboxColumn1);
              hv_AnnotBboxRow1.Dispose();
              HOperatorSet.GetDictTuple(hv_BBox, 1, out hv_AnnotBboxRow1);
              hv_AnnotBboxWidth.Dispose();
              HOperatorSet.GetDictTuple(hv_BBox, 2, out hv_AnnotBboxWidth);
              hv_AnnotBboxHeight.Dispose();
              HOperatorSet.GetDictTuple(hv_BBox, 3, out hv_AnnotBboxHeight);
            }
            // catch (ExceptionAnnot) 
            catch (HalconException HDevExpDefaultException1)
            {
              HDevExpDefaultException1.ToHTuple(out hv_ExceptionAnnot);
              throw new HalconException(((("A COCO annotation for the COCO image number "+hv_Index)+" (id = ")+hv_ImageID)+") does not contain the entry category_id or correct bounding box.");
            }
            //Get the HALCON format for the bbox coordinates.
            //COCO-format assumes that the origin of the coordinate-system
            //is shifted by (-.5, -.5) compared to the origin of the
            //HALCON coordinate-system.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_AnnotBboxRow1 = hv_AnnotBboxRow1-0.5;
            hv_AnnotBboxRow1.Dispose();
            hv_AnnotBboxRow1 = ExpTmpLocalVar_AnnotBboxRow1;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_AnnotBboxColumn1 = hv_AnnotBboxColumn1-0.5;
            hv_AnnotBboxColumn1.Dispose();
            hv_AnnotBboxColumn1 = ExpTmpLocalVar_AnnotBboxColumn1;
            }
            }
            hv_AnnotBboxRow2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_AnnotBboxRow2 = hv_AnnotBboxRow1+hv_AnnotBboxHeight;
            }
            hv_AnnotBboxColumn2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_AnnotBboxColumn2 = hv_AnnotBboxColumn1+hv_AnnotBboxWidth;
            }
            //Store the annotations.
            if (hv_AnnotClassIDs == null)
              hv_AnnotClassIDs = new HTuple();
            hv_AnnotClassIDs[hv_AnnotIndexCounter] = hv_AnnotClassID;
            if (hv_AnnotBboxColumn1s == null)
              hv_AnnotBboxColumn1s = new HTuple();
            hv_AnnotBboxColumn1s[hv_AnnotIndexCounter] = hv_AnnotBboxColumn1;
            if (hv_AnnotBboxRow1s == null)
              hv_AnnotBboxRow1s = new HTuple();
            hv_AnnotBboxRow1s[hv_AnnotIndexCounter] = hv_AnnotBboxRow1;
            if (hv_AnnotBboxColumn2s == null)
              hv_AnnotBboxColumn2s = new HTuple();
            hv_AnnotBboxColumn2s[hv_AnnotIndexCounter] = hv_AnnotBboxColumn2;
            if (hv_AnnotBboxRow2s == null)
              hv_AnnotBboxRow2s = new HTuple();
            hv_AnnotBboxRow2s[hv_AnnotIndexCounter] = hv_AnnotBboxRow2;
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_AnnotIndexCounter = hv_AnnotIndexCounter+1;
            hv_AnnotIndexCounter.Dispose();
            hv_AnnotIndexCounter = ExpTmpLocalVar_AnnotIndexCounter;
            }
            }
          }
        }
      }
      //Generate the sample for this image.
      hv_DLSample.Dispose();
      HOperatorSet.CreateDict(out hv_DLSample);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_id", hv_ImageID);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_file_name", hv_ImageName);
      if ((int)(new HTuple(hv_Purpose.TupleEqual("object_detection"))) != 0)
      {
        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_AnnotBboxRow1s);
        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_AnnotBboxColumn1s);
        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_AnnotBboxRow2s);
        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_AnnotBboxColumn2s);
        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_AnnotClassIDs);
      }
      if ((int)(hv_ReadRawAnnotations) != 0)
      {
        HOperatorSet.SetDictTuple(hv_DLSample, "coco_raw_annotations", hv_AnnotationPerImage);
      }
      //Remember the sample for this image.
      if (hv_DLSamples == null)
        hv_DLSamples = new HTuple();
      hv_DLSamples[hv_Index] = hv_DLSample;
    }
    //Set the samples in the DLDataset dictionary.
    HOperatorSet.SetDictTuple(hv_DLDataset, "samples", hv_DLSamples);

    hv_ImageDir_COPY_INP_TMP.Dispose();
    hv_ReadOnlyNonCrowd.Dispose();
    hv_ReadRawAnnotations.Dispose();
    hv_GenParamNames.Dispose();
    hv_ParamIndex.Dispose();
    hv_GenParamName.Dispose();
    hv_GenParamValue.Dispose();
    hv_DictCocoJson.Dispose();
    hv_ExceptionTopmostLevel.Dispose();
    hv_CategoryKeys.Dispose();
    hv_CategoryList.Dispose();
    hv_ImageKeys.Dispose();
    hv_ImageList.Dispose();
    hv_AnnotationKeys.Dispose();
    hv_AnnotationList.Dispose();
    hv_Purpose.Dispose();
    hv_Annotation.Dispose();
    hv_BBox.Dispose();
    hv_ExceptionBBox.Dispose();
    hv_Index.Dispose();
    hv_Category.Dispose();
    hv_ID.Dispose();
    hv_Name.Dispose();
    hv_ExceptionCategory.Dispose();
    hv_ClassIDs.Dispose();
    hv_ClassNames.Dispose();
    hv_AnnotImageIDs.Dispose();
    hv_ImageIDAnnot.Dispose();
    hv_ExceptionAnnot.Dispose();
    hv_Image.Dispose();
    hv_ImageName.Dispose();
    hv_ImageID.Dispose();
    hv_ExceptionImage.Dispose();
    hv_FileExists.Dispose();
    hv_AnnotationIndicesThisImage.Dispose();
    hv_AnnotClassIDs.Dispose();
    hv_AnnotBboxColumn1s.Dispose();
    hv_AnnotBboxRow1s.Dispose();
    hv_AnnotBboxColumn2s.Dispose();
    hv_AnnotBboxRow2s.Dispose();
    hv_AnnotationPerImage.Dispose();
    hv_AnnotationKeysThisImage.Dispose();
    hv_AnnotIndexCounter.Dispose();
    hv_AnnotIndex.Dispose();
    hv_IsCrowd.Dispose();
    hv_ExceptionIsCrowd.Dispose();
    hv_AnnotClassID.Dispose();
    hv_AnnotBboxColumn1.Dispose();
    hv_AnnotBboxRow1.Dispose();
    hv_AnnotBboxWidth.Dispose();
    hv_AnnotBboxHeight.Dispose();
    hv_AnnotBboxRow2.Dispose();
    hv_AnnotBboxColumn2.Dispose();
    hv_DLSample.Dispose();
    hv_DLSamples.Dispose();

    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Generate a DLDataset dictionary for semantic segmentation. 
  public void read_dl_dataset_segmentation (HTuple hv_ImageDir, HTuple hv_SegmentationDir, 
      HTuple hv_ClassNames, HTuple hv_ClassIDs, HTuple hv_ImageList, HTuple hv_SegmentationList, 
      HTuple hv_GenParam, out HTuple hv_DLDataset)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumSamples = new HTuple(), hv_Samples = new HTuple();
    HTuple hv_SampleIndex = new HTuple(), hv_Sample = new HTuple();
    HTuple hv_ImageID = new HTuple();
    HTuple   hv_ImageDir_COPY_INP_TMP = new HTuple(hv_ImageDir);
    HTuple   hv_ImageList_COPY_INP_TMP = new HTuple(hv_ImageList);
    HTuple   hv_SegmentationDir_COPY_INP_TMP = new HTuple(hv_SegmentationDir);
    HTuple   hv_SegmentationList_COPY_INP_TMP = new HTuple(hv_SegmentationList);

    // Initialize local and output iconic variables 
    hv_DLDataset = new HTuple();
    //
    //This procedure creates a dictionary DLDataset,
    //which serves as an input for deep-learning-based semantic segmentation models.
    //Information needed to create this dictionary is given through the input parameters.
    //
    //The output dictionary DLDataset has the following structure:

    //DLDataset
    //{
    //    'image_dir'         : Common base path of all images
    //    'segmentation_dir'  : Common base path of all segmentation images
    //    'class_names'[]     : Tuple of strings
    //    'class_ids'[]       : Tuple of ints
    //    'samples'[]         : Tuple of dicts
    //    {
    //        'image_file_name'           : File path relative to 'image_dir' (including the file name)
    //        'segmentation_file_name'    : File path relative to 'segmentation_dir' (including the file name)
    //        'image_id'                  : Unique image ID
    //    }
    //}
    //
    //Sanity checks of inputs.
    //
    //The length of Classes has to match the length of ClassIDs.
    if ((int)(new HTuple((new HTuple(hv_ClassNames.TupleLength())).TupleNotEqual(
        new HTuple(hv_ClassIDs.TupleLength())))) != 0)
    {
      throw new HalconException("Number of class names does not match number of class IDs");
    }
    //ClassIDs must be unique.
    if ((int)(new HTuple(((((hv_ClassIDs.TupleSort())).TupleUniq())).TupleNotEqual(
        hv_ClassIDs.TupleSort()))) != 0)
    {
      throw new HalconException("Class IDs are not unique");
    }
    //ImageDir can only be one string.
    if ((int)(new HTuple((new HTuple(hv_ImageDir_COPY_INP_TMP.TupleLength())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("Only one base path for the images can be given");
    }
    else if ((int)(new HTuple(((hv_ImageDir_COPY_INP_TMP.TupleIsString())).TupleNotEqual(
        1))) != 0)
    {
      throw new HalconException("ImageDir is not a string");
    }
    //AnnotationDir can only be one string.
    if ((int)(new HTuple((new HTuple(hv_SegmentationDir_COPY_INP_TMP.TupleLength()
        )).TupleNotEqual(1))) != 0)
    {
      throw new HalconException("Only one base path for the annotation images can be given");
    }
    else if ((int)(new HTuple(((hv_SegmentationDir_COPY_INP_TMP.TupleIsString()
        )).TupleNotEqual(1))) != 0)
    {
      throw new HalconException("SegmentationDir is not a string");
    }
    //Check if ImageList and SegmentationList have the same length or if SegmentationList is empty.
    if ((int)((new HTuple(hv_SegmentationList_COPY_INP_TMP.TupleNotEqual(new HTuple()))).TupleAnd(
        new HTuple((new HTuple(hv_ImageList_COPY_INP_TMP.TupleLength())).TupleNotEqual(
        new HTuple(hv_SegmentationList_COPY_INP_TMP.TupleLength()))))) != 0)
    {
      throw new HalconException("SegmentationList must be empty or have the same length as ImageList");
    }
    //
    //Prepare the image lists.
    //
    //Replace any forward slashes at the end.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.TupleRegexpReplace(hv_ImageDir_COPY_INP_TMP, "/$", "", out ExpTmpOutVar_0);
    hv_ImageDir_COPY_INP_TMP.Dispose();
    hv_ImageDir_COPY_INP_TMP = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.TupleRegexpReplace(hv_SegmentationDir_COPY_INP_TMP, "/$", "", out ExpTmpOutVar_0);
    hv_SegmentationDir_COPY_INP_TMP.Dispose();
    hv_SegmentationDir_COPY_INP_TMP = ExpTmpOutVar_0;
    }
    //
    //If no SegmentationList is given, create it out of the given ImageList or create both lists.
    if ((int)(new HTuple(hv_SegmentationList_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      //Create the matching file lists for images and segmentations.
      {
      HTuple ExpTmpOutVar_0;hv_SegmentationList_COPY_INP_TMP.Dispose();
      list_image_and_segmentation_files(hv_ImageDir_COPY_INP_TMP, hv_SegmentationDir_COPY_INP_TMP, 
          hv_ImageList_COPY_INP_TMP, hv_GenParam, out ExpTmpOutVar_0, out hv_SegmentationList_COPY_INP_TMP);
      hv_ImageList_COPY_INP_TMP.Dispose();
      hv_ImageList_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    else
    {
      //Make sure that ImageList does not contain ImageDir.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleRegexpReplace(hv_ImageList_COPY_INP_TMP, ".*?"+hv_ImageDir_COPY_INP_TMP, 
          "", out ExpTmpOutVar_0);
      hv_ImageList_COPY_INP_TMP.Dispose();
      hv_ImageList_COPY_INP_TMP = ExpTmpOutVar_0;
      }
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleRegexpReplace(hv_ImageList_COPY_INP_TMP, "^/", "", out ExpTmpOutVar_0);
      hv_ImageList_COPY_INP_TMP.Dispose();
      hv_ImageList_COPY_INP_TMP = ExpTmpOutVar_0;
      }
      //Make sure that SegmentationList does not contain SegmentationDir.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleRegexpReplace(hv_SegmentationList_COPY_INP_TMP, ".*?"+hv_SegmentationDir_COPY_INP_TMP, 
          "", out ExpTmpOutVar_0);
      hv_SegmentationList_COPY_INP_TMP.Dispose();
      hv_SegmentationList_COPY_INP_TMP = ExpTmpOutVar_0;
      }
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleRegexpReplace(hv_SegmentationList_COPY_INP_TMP, "^/", "", 
          out ExpTmpOutVar_0);
      hv_SegmentationList_COPY_INP_TMP.Dispose();
      hv_SegmentationList_COPY_INP_TMP = ExpTmpOutVar_0;
      }
    }
    //
    //Check if all images exist.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    images_exist((hv_ImageDir_COPY_INP_TMP+"/")+hv_ImageList_COPY_INP_TMP);
    }
    //Check if all segmentation images exist.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    images_exist((hv_SegmentationDir_COPY_INP_TMP+"/")+hv_SegmentationList_COPY_INP_TMP);
    }
    //
    //Initialize the dictionary dataset.
    hv_DLDataset.Dispose();
    HOperatorSet.CreateDict(out hv_DLDataset);
    //
    //Set general information of the dataset.
    HOperatorSet.SetDictTuple(hv_DLDataset, "image_dir", hv_ImageDir_COPY_INP_TMP);
    HOperatorSet.SetDictTuple(hv_DLDataset, "segmentation_dir", hv_SegmentationDir_COPY_INP_TMP);
    HOperatorSet.SetDictTuple(hv_DLDataset, "class_names", hv_ClassNames);
    HOperatorSet.SetDictTuple(hv_DLDataset, "class_ids", hv_ClassIDs);
    //
    //Get number of samples to set unique image ID for each sample according to its index in ImageList.
    hv_NumSamples.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumSamples = new HTuple(hv_ImageList_COPY_INP_TMP.TupleLength()
        );
    }
    //
    //Initialize sample tuple.
    hv_Samples.Dispose();
    hv_Samples = new HTuple();
    //Loop over samples.
    HTuple end_val87 = hv_NumSamples-1;
    HTuple step_val87 = 1;
    for (hv_SampleIndex=0; hv_SampleIndex.Continue(end_val87, step_val87); hv_SampleIndex = hv_SampleIndex.TupleAdd(step_val87))
    {
      //
      //Create the dictionary Sample.
      hv_Sample.Dispose();
      HOperatorSet.CreateDict(out hv_Sample);
      //Set information about this sample.
      hv_ImageID.Dispose();
      hv_ImageID = new HTuple(hv_SampleIndex);
      HOperatorSet.SetDictTuple(hv_Sample, "image_id", hv_ImageID);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_Sample, "image_file_name", hv_ImageList_COPY_INP_TMP.TupleSelect(
          hv_SampleIndex));
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_Sample, "segmentation_file_name", hv_SegmentationList_COPY_INP_TMP.TupleSelect(
          hv_SampleIndex));
      }
      //
      //Append this sample.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Samples = hv_Samples.TupleConcat(
          hv_Sample);
      hv_Samples.Dispose();
      hv_Samples = ExpTmpLocalVar_Samples;
      }
      }
    }
    //
    //Set the sample tuple.
    HOperatorSet.SetDictTuple(hv_DLDataset, "samples", hv_Samples);

    hv_ImageDir_COPY_INP_TMP.Dispose();
    hv_ImageList_COPY_INP_TMP.Dispose();
    hv_SegmentationDir_COPY_INP_TMP.Dispose();
    hv_SegmentationList_COPY_INP_TMP.Dispose();
    hv_NumSamples.Dispose();
    hv_Samples.Dispose();
    hv_SampleIndex.Dispose();
    hv_Sample.Dispose();
    hv_ImageID.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Read the dictionaries DLSamples from files. 
  public void read_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, out HTuple hv_DLSampleBatch)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DatasetSamples = new HTuple(), hv_MinIndex = new HTuple();
    HTuple hv_MaxIndex = new HTuple(), hv_KeyDirExists = new HTuple();
    HTuple hv_DictDir = new HTuple(), hv_DLSamplesProc = new HTuple();
    HTuple hv_ImageIndex = new HTuple(), hv_KeyFileExists = new HTuple();
    HTuple hv_ImageID = new HTuple(), hv_FileNameRelative = new HTuple();
    HTuple hv_FileNameSample = new HTuple(), hv_FileExists = new HTuple();
    HTuple hv_DictPath = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    hv_DLSampleBatch = new HTuple();
    //
    //This procedure reads a batch of DLSample dictionaries from disk.
    //The wanted samples are selected from a DLDataset by their indices.
    //The indices of the wanted samples are handed over in SampleIndices.
    //It returns the tuple of read-in dictionaries in DLSampleBatch.
    //
    //Sanity checks of inputs.
    //
    if ((int)(new HTuple((new HTuple(hv_SampleIndices.TupleLength())).TupleLessEqual(
        0))) != 0)
    {
      //Check the length of selected indices.
      throw new HalconException(new HTuple("Invalid length of SelectedIndices: ")+(new HTuple(hv_SampleIndices.TupleLength()
          )));
    }
    else
    {
      //Get the samples from the DLDataset.
      hv_DatasetSamples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DatasetSamples);
      //Get min and max value of given indices.
      hv_MinIndex.Dispose();
      HOperatorSet.TupleMin(hv_SampleIndices, out hv_MinIndex);
      hv_MaxIndex.Dispose();
      HOperatorSet.TupleMax(hv_SampleIndices, out hv_MaxIndex);
      if ((int)((new HTuple(hv_MinIndex.TupleLess(0))).TupleOr(new HTuple(hv_MaxIndex.TupleGreater(
          (new HTuple(hv_DatasetSamples.TupleLength()))-1)))) != 0)
      {
        //Check the value range of the provided indices.
        throw new HalconException("The given SampleIndices are not within the range of available samples in DLDataset.");
      }
    }
    //
    //Check if the key dlsample_dir is given.
    hv_KeyDirExists.Dispose();
    HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "dlsample_dir", out hv_KeyDirExists);
    //
    if ((int)(hv_KeyDirExists) != 0)
    {
      //
      //Get the dlsample_dir.
      hv_DictDir.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "dlsample_dir", out hv_DictDir);
      //Get the samples to be processed.
      hv_DLSamplesProc.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLSamplesProc = hv_DatasetSamples.TupleSelect(
          hv_SampleIndices);
      }
      //
      //Initialize DLSampleBatch tuple.
      hv_DLSampleBatch.Dispose();
      hv_DLSampleBatch = new HTuple();
      //
      //Read in all DLSamples into the batch.
      for (hv_ImageIndex=0; (int)hv_ImageIndex<=(int)((new HTuple(hv_SampleIndices.TupleLength()
          ))-1); hv_ImageIndex = (int)hv_ImageIndex + 1)
      {
        //Check if dlsample key exist.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_KeyFileExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), "key_exists", 
            "dlsample_file_name", out hv_KeyFileExists);
        }
        //
        if ((int)(hv_KeyFileExists.TupleNot()) != 0)
        {
          //
          //If the key does not exist, check if a corresponding file exists.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImageID.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
              "image_id", out hv_ImageID);
          }
          hv_FileNameRelative.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_FileNameRelative = hv_ImageID+"_dlsample.hdict";
          }
          hv_FileNameSample.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_FileNameSample = (hv_DictDir+"/")+hv_FileNameRelative;
          }
          //
          hv_FileExists.Dispose();
          HOperatorSet.FileExists(hv_FileNameSample, out hv_FileExists);
          if ((int)(hv_FileExists) != 0)
          {
            //If it exists, create corresponding key.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                "dlsample_file_name", hv_FileNameRelative);
            }
          }
          else
          {
            //If not, throw an error.
            throw new HalconException("No 'dlsample_file_name' and hdict file available for image ID "+hv_ImageID);
          }
          //
        }
        //
        //If dlsample dictionary is available for reading, read it.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DictPath.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), "dlsample_file_name", 
            out hv_DictPath);
        }
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DLSample.Dispose();
          HOperatorSet.ReadDict((hv_DictDir+"/")+hv_DictPath, new HTuple(), new HTuple(), 
              out hv_DLSample);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          throw new HalconException((((("An error has occurred while reading "+hv_DictDir)+"/")+hv_DictPath)+new HTuple(" , HALCON error # "))+(hv_Exception.TupleSelect(
              0)));
        }
        //Add it to the DLSampleBatch.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_DLSampleBatch = hv_DLSampleBatch.TupleConcat(
            hv_DLSample);
        hv_DLSampleBatch.Dispose();
        hv_DLSampleBatch = ExpTmpLocalVar_DLSampleBatch;
        }
        }
        //
      }
    }
    else
    {
      throw new HalconException("The dataset needs to include the key 'dlsample_dir' for reading a DLSample from file.");
    }


    hv_DatasetSamples.Dispose();
    hv_MinIndex.Dispose();
    hv_MaxIndex.Dispose();
    hv_KeyDirExists.Dispose();
    hv_DictDir.Dispose();
    hv_DLSamplesProc.Dispose();
    hv_ImageIndex.Dispose();
    hv_KeyFileExists.Dispose();
    hv_ImageID.Dispose();
    hv_FileNameRelative.Dispose();
    hv_FileNameSample.Dispose();
    hv_FileExists.Dispose();
    hv_DictPath.Dispose();
    hv_DLSample.Dispose();
    hv_Exception.Dispose();

    return;
  }

  // Chapter: Image / Manipulation
  // Short Description: Changes a value of ValuesToChange in Image to NewValue. 
  public void reassign_pixel_values (HObject ho_Image, out HObject ho_ImageOut, HTuple hv_ValuesToChange, 
      HTuple hv_NewValue)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_RegionToChange, ho_RegionClass=null;

    // Local control variables 

    HTuple hv_IndexReset = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageOut);
    HOperatorSet.GenEmptyObj(out ho_RegionToChange);
    HOperatorSet.GenEmptyObj(out ho_RegionClass);
    //
    //This procedure sets all pixels of Image
    //with the values given in ValuesToChange to the given value NewValue.
    //
    ho_RegionToChange.Dispose();
    HOperatorSet.GenEmptyRegion(out ho_RegionToChange);
    for (hv_IndexReset=0; (int)hv_IndexReset<=(int)((new HTuple(hv_ValuesToChange.TupleLength()
        ))-1); hv_IndexReset = (int)hv_IndexReset + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_RegionClass.Dispose();
      HOperatorSet.Threshold(ho_Image, out ho_RegionClass, hv_ValuesToChange.TupleSelect(
          hv_IndexReset), hv_ValuesToChange.TupleSelect(hv_IndexReset));
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.Union2(ho_RegionToChange, ho_RegionClass, out ExpTmpOutVar_0);
      ho_RegionToChange.Dispose();
      ho_RegionToChange = ExpTmpOutVar_0;
      }
    }
    HOperatorSet.OverpaintRegion(ho_Image, ho_RegionToChange, hv_NewValue, "fill");
    ho_ImageOut.Dispose();
    ho_ImageOut = new HObject(ho_Image);
    ho_RegionToChange.Dispose();
    ho_RegionClass.Dispose();

    hv_IndexReset.Dispose();

    return;
  }

  // Chapter: Calibration / Hand-Eye
  // Short Description: Prepare the input image for matching and compute the needed pose. 
  public void rectify_image_and_compute_matching_plane_moving_cam (HObject ho_Image, 
      out HObject ho_ImageRectified, HTuple hv_ToolInBasePose, HTuple hv_HandEyeCalibData, 
      HTuple hv_Poses, HTuple hv_RectificationData)
  {




    // Local iconic variables 

    HObject ho_ImageArea=null, ho_RegionBorder=null;

    // Local control variables 

    HTuple hv_RectifyImage = new HTuple(), hv_OrderOfTransform = new HTuple();
    HTuple hv_OrderOfRotation = new HTuple(), hv_ViewOfTransform = new HTuple();
    HTuple hv_ToolInCamPose = new HTuple(), hv_MatchingPlaneInBasePose = new HTuple();
    HTuple hv_BaseInToolPose = new HTuple(), hv_BaseInCamPose = new HTuple();
    HTuple hv_MatchingPlaneInCamPose = new HTuple(), hv_MatchingPlaneRectifiedPartInCamPose = new HTuple();
    HTuple hv_CamParam = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_ClipRegion = new HTuple();
    HTuple hv_BorderRows = new HTuple(), hv_BorderColumns = new HTuple();
    HTuple hv_BorderX = new HTuple(), hv_BorderY = new HTuple();
    HTuple hv_MatchingPlaneRectifiedPartInMatchingPlanePose = new HTuple();
    HTuple hv_ScaleRectification = new HTuple(), hv_WidthRect = new HTuple();
    HTuple hv_HeightRect = new HTuple();
    HTuple   hv_ToolInBasePose_COPY_INP_TMP = new HTuple(hv_ToolInBasePose);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageRectified);
    HOperatorSet.GenEmptyObj(out ho_ImageArea);
    HOperatorSet.GenEmptyObj(out ho_RegionBorder);
    //This procedure finds the pose of the matching part on the plane
    //in the camera coordinate system. Rectification is applied if it
    //is set by the user.
    //
    hv_CamParam.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "CamParam", out hv_CamParam);
    hv_ToolInCamPose.Dispose();
    read_dict_tuple(hv_HandEyeCalibData, "ToolInCamPose", out hv_ToolInCamPose);
    hv_RectifyImage.Dispose();
    read_dict_tuple(hv_RectificationData, "RectifyImage", out hv_RectifyImage);
    if ((int)((new HTuple(hv_RectifyImage.TupleEqual("only_rectify"))).TupleOr(new HTuple(hv_RectifyImage.TupleEqual(
        "align_and_rectify")))) != 0)
    {
      hv_ScaleRectification.Dispose();
      read_dict_tuple(hv_RectificationData, "ScaleRectification", out hv_ScaleRectification);
    }
    hv_MatchingPlaneInBasePose.Dispose();
    read_dict_tuple(hv_Poses, "MatchingPlaneInBasePose", out hv_MatchingPlaneInBasePose);
    //
    //Keep track of the pose type used by the robot.
    hv_OrderOfTransform.Dispose();hv_OrderOfRotation.Dispose();hv_ViewOfTransform.Dispose();
    HOperatorSet.GetPoseType(hv_ToolInBasePose_COPY_INP_TMP, out hv_OrderOfTransform, 
        out hv_OrderOfRotation, out hv_ViewOfTransform);
    //Convert to default pose type.
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_ToolInBasePose_COPY_INP_TMP, "Rp+T", "gba", "point", 
        out ExpTmpOutVar_0);
    hv_ToolInBasePose_COPY_INP_TMP.Dispose();
    hv_ToolInBasePose_COPY_INP_TMP = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_ToolInCamPose, "Rp+T", "gba", "point", out ExpTmpOutVar_0);
    hv_ToolInCamPose.Dispose();
    hv_ToolInCamPose = ExpTmpOutVar_0;
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_MatchingPlaneInBasePose, "Rp+T", "gba", "point", 
        out ExpTmpOutVar_0);
    hv_MatchingPlaneInBasePose.Dispose();
    hv_MatchingPlaneInBasePose = ExpTmpOutVar_0;
    }
    //
    hv_BaseInToolPose.Dispose();
    HOperatorSet.PoseInvert(hv_ToolInBasePose_COPY_INP_TMP, out hv_BaseInToolPose);
    hv_BaseInCamPose.Dispose();
    HOperatorSet.PoseCompose(hv_ToolInCamPose, hv_BaseInToolPose, out hv_BaseInCamPose);
    hv_MatchingPlaneInCamPose.Dispose();
    HOperatorSet.PoseCompose(hv_BaseInCamPose, hv_MatchingPlaneInBasePose, out hv_MatchingPlaneInCamPose);
    //
    if ((int)(new HTuple(hv_RectifyImage.TupleEqual("no_rectification"))) != 0)
    {
      hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
      hv_MatchingPlaneRectifiedPartInCamPose = new HTuple(hv_MatchingPlaneInCamPose);
      ho_ImageRectified.Dispose();
      HOperatorSet.CopyObj(ho_Image, out ho_ImageRectified, 1, 1);
    }
    else if ((int)((new HTuple(hv_RectifyImage.TupleEqual("only_rectify"))).TupleOr(
        new HTuple(hv_RectifyImage.TupleEqual("align_and_rectify")))) != 0)
    {
      if ((int)(new HTuple(hv_RectifyImage.TupleEqual("only_rectify"))) != 0)
      {
        if (hv_MatchingPlaneInCamPose == null)
          hv_MatchingPlaneInCamPose = new HTuple();
        hv_MatchingPlaneInCamPose[5] = 0.0;
      }
      //The image dimensions should cover the entire original
      //field of view in the current rectification. Look at the
      //border of the current image in the world plane.
      hv_Width.Dispose();
      get_cam_par_data(hv_CamParam, "image_width", out hv_Width);
      hv_Height.Dispose();
      get_cam_par_data(hv_CamParam, "image_height", out hv_Height);
      hv_ClipRegion.Dispose();
      HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
      HOperatorSet.SetSystem("clip_region", "false");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ImageArea.Dispose();
      HOperatorSet.GenRectangle1(out ho_ImageArea, 0, 0, hv_Height-1, hv_Width-1);
      }
      ho_RegionBorder.Dispose();
      HOperatorSet.Boundary(ho_ImageArea, out ho_RegionBorder, "outer");
      HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
      hv_BorderRows.Dispose();hv_BorderColumns.Dispose();
      HOperatorSet.GetRegionPoints(ho_RegionBorder, out hv_BorderRows, out hv_BorderColumns);
      hv_BorderX.Dispose();hv_BorderY.Dispose();
      HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_MatchingPlaneInCamPose, 
          hv_BorderRows, hv_BorderColumns, "m", out hv_BorderX, out hv_BorderY);
      //Adapt parameters.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MatchingPlaneRectifiedPartInMatchingPlanePose.Dispose();
      HOperatorSet.CreatePose(hv_BorderX.TupleMin(), hv_BorderY.TupleMin(), 0, 0, 
          0, 0, "Rp+T", "gba", "point", out hv_MatchingPlaneRectifiedPartInMatchingPlanePose);
      }
      hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
      HOperatorSet.PoseCompose(hv_MatchingPlaneInCamPose, hv_MatchingPlaneRectifiedPartInMatchingPlanePose, 
          out hv_MatchingPlaneRectifiedPartInCamPose);
      hv_WidthRect.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WidthRect = (((((hv_BorderX.TupleMax()
          )-(hv_BorderX.TupleMin()))/hv_ScaleRectification)+0.5)).TupleInt();
      }
      hv_HeightRect.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HeightRect = (((((hv_BorderY.TupleMax()
          )-(hv_BorderY.TupleMin()))/hv_ScaleRectification)+0.5)).TupleInt();
      }
      //
      ho_ImageRectified.Dispose();
      HOperatorSet.ImageToWorldPlane(ho_Image, out ho_ImageRectified, hv_CamParam, 
          hv_MatchingPlaneRectifiedPartInCamPose, hv_WidthRect, hv_HeightRect, hv_ScaleRectification, 
          "bilinear");
    }
    else
    {
      throw new HalconException("Please set the parameter RectifyImage correctly");
    }
    {
    HTuple ExpTmpOutVar_0;
    HOperatorSet.ConvertPoseType(hv_MatchingPlaneRectifiedPartInCamPose, hv_OrderOfTransform, 
        hv_OrderOfRotation, hv_ViewOfTransform, out ExpTmpOutVar_0);
    hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
    hv_MatchingPlaneRectifiedPartInCamPose = ExpTmpOutVar_0;
    }
    HOperatorSet.SetDictTuple(hv_RectificationData, "MatchingPlaneRectifiedPartInCamPose", 
        hv_MatchingPlaneRectifiedPartInCamPose);
    ho_ImageArea.Dispose();
    ho_RegionBorder.Dispose();

    hv_ToolInBasePose_COPY_INP_TMP.Dispose();
    hv_RectifyImage.Dispose();
    hv_OrderOfTransform.Dispose();
    hv_OrderOfRotation.Dispose();
    hv_ViewOfTransform.Dispose();
    hv_ToolInCamPose.Dispose();
    hv_MatchingPlaneInBasePose.Dispose();
    hv_BaseInToolPose.Dispose();
    hv_BaseInCamPose.Dispose();
    hv_MatchingPlaneInCamPose.Dispose();
    hv_MatchingPlaneRectifiedPartInCamPose.Dispose();
    hv_CamParam.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_ClipRegion.Dispose();
    hv_BorderRows.Dispose();
    hv_BorderColumns.Dispose();
    hv_BorderX.Dispose();
    hv_BorderY.Dispose();
    hv_MatchingPlaneRectifiedPartInMatchingPlanePose.Dispose();
    hv_ScaleRectification.Dispose();
    hv_WidthRect.Dispose();
    hv_HeightRect.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Reduce the evaluation result to a single value. 
  public void reduce_dl_evaluation_result (HTuple hv_EvaluationResult, HTuple hv_EvaluationComparisonKeys, 
      out HTuple hv_Value, out HTuple hv_ValidEvaluationKeys)
  {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_KeysEvalResult = new HTuple();
        HTuple hv_NumMatches = new HTuple(), hv_FirstMaxNumDetections = new HTuple();
        HTuple hv_KeysFirstMaxNumDetections = new HTuple(), hv_DetectionResult = new HTuple();
        HTuple hv_KeysExist = new HTuple(), hv_Indices = new HTuple();
        HTuple hv_Values = new HTuple(), hv_K = new HTuple(), hv_Key = new HTuple();
        HTuple hv_Tuple = new HTuple();
        HTuple   hv_EvaluationComparisonKeys_COPY_INP_TMP = new HTuple(hv_EvaluationComparisonKeys);
        HTuple   hv_EvaluationResult_COPY_INP_TMP = new HTuple(hv_EvaluationResult);

        // Initialize local and output iconic variables 
        hv_Value = new HTuple();
        hv_ValidEvaluationKeys = new HTuple();
    //
    //In order to compare a model we need to reduce the evaluation parameter/result
    //to a single float Value which is comparable via >.
    //
    //Check which keys exist in the evaluation result.
    if ((int)(new HTuple((new HTuple(hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleLength()
        )).TupleGreater(0))) != 0)
    {
      //First we need to check for a special case: detection results.
      //They have a complex structure.
      hv_KeysEvalResult.Dispose();
      HOperatorSet.GetDictParam(hv_EvaluationResult_COPY_INP_TMP, "keys", new HTuple(), 
          out hv_KeysEvalResult);
      hv_NumMatches.Dispose();
      HOperatorSet.TupleRegexpTest(hv_KeysEvalResult, "max_num_detections_.*", out hv_NumMatches);
      if ((int)(new HTuple(hv_NumMatches.TupleGreater(0))) != 0)
      {
        //We use only the first results of every level.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FirstMaxNumDetections.Dispose();
        HOperatorSet.GetDictTuple(hv_EvaluationResult_COPY_INP_TMP, hv_KeysEvalResult.TupleSelect(
            0), out hv_FirstMaxNumDetections);
        }
        hv_KeysFirstMaxNumDetections.Dispose();
        HOperatorSet.GetDictParam(hv_FirstMaxNumDetections, "keys", new HTuple(), 
            out hv_KeysFirstMaxNumDetections);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DetectionResult.Dispose();
        HOperatorSet.GetDictTuple(hv_FirstMaxNumDetections, hv_KeysFirstMaxNumDetections.TupleSelect(
            0), out hv_DetectionResult);
        }
        //We use this result here as the top level to retrieve values.
        hv_EvaluationResult_COPY_INP_TMP.Dispose();
        hv_EvaluationResult_COPY_INP_TMP = new HTuple(hv_DetectionResult);
      }
      //Reduce comparison to keys that exist.
      hv_KeysExist.Dispose();
      HOperatorSet.GetDictParam(hv_EvaluationResult_COPY_INP_TMP, "key_exists", hv_EvaluationComparisonKeys_COPY_INP_TMP, 
          out hv_KeysExist);
      hv_Indices.Dispose();
      HOperatorSet.TupleFind(hv_KeysExist, 1, out hv_Indices);
      if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
      {
        hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
        hv_EvaluationComparisonKeys_COPY_INP_TMP = new HTuple();
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_EvaluationComparisonKeys = hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleSelect(
            hv_Indices);
        hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
        hv_EvaluationComparisonKeys_COPY_INP_TMP = ExpTmpLocalVar_EvaluationComparisonKeys;
        }
        }
      }
    }
    hv_ValidEvaluationKeys.Dispose();
    hv_ValidEvaluationKeys = new HTuple(hv_EvaluationComparisonKeys_COPY_INP_TMP);
    //
    hv_Value.Dispose();
    hv_Value = 0.0;
    hv_Values.Dispose();
    hv_Values = new HTuple();
    for (hv_K=0; (int)hv_K<=(int)((new HTuple(hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleLength()
        ))-1); hv_K = (int)hv_K + 1)
    {
      hv_Key.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Key = hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleSelect(
          hv_K);
      }
      hv_Tuple.Dispose();
      HOperatorSet.GetDictTuple(hv_EvaluationResult_COPY_INP_TMP, hv_Key, out hv_Tuple);
      //Use the mean in order to reduce tuples with length > 1.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Values = hv_Values.TupleConcat(
          hv_Tuple.TupleMean());
      hv_Values.Dispose();
      hv_Values = ExpTmpLocalVar_Values;
      }
      }
    }
    if ((int)(new HTuple((new HTuple(hv_Values.TupleLength())).TupleGreater(0))) != 0)
    {
      hv_Value.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Value = hv_Values.TupleMean()
          ;
      }
    }

    hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
    hv_EvaluationResult_COPY_INP_TMP.Dispose();
    hv_KeysEvalResult.Dispose();
    hv_NumMatches.Dispose();
    hv_FirstMaxNumDetections.Dispose();
    hv_KeysFirstMaxNumDetections.Dispose();
    hv_DetectionResult.Dispose();
    hv_KeysExist.Dispose();
    hv_Indices.Dispose();
    hv_Values.Dispose();
    hv_K.Dispose();
    hv_Key.Dispose();
    hv_Tuple.Dispose();

    return;
  }

  // Chapter: File / Misc
  // Short Description: This procedure removes a directory recursively. 
  public void remove_dir_recursively (HTuple hv_DirName)
  {



    // Local control variables 

    HTuple hv_Dirs = new HTuple(), hv_I = new HTuple();
    HTuple hv_Files = new HTuple();
    // Initialize local and output iconic variables 
    //Recursively delete all subdirectories.
    hv_Dirs.Dispose();
    HOperatorSet.ListFiles(hv_DirName, "directories", out hv_Dirs);
    for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Dirs.TupleLength()))-1); hv_I = (int)hv_I + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      remove_dir_recursively(hv_Dirs.TupleSelect(hv_I));
      }
    }
    //Delete all files.
    hv_Files.Dispose();
    HOperatorSet.ListFiles(hv_DirName, "files", out hv_Files);
    for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Files.TupleLength()))-1); hv_I = (int)hv_I + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.DeleteFile(hv_Files.TupleSelect(hv_I));
      }
    }
    //Remove empty directory.
    HOperatorSet.RemoveDir(hv_DirName);

    hv_Dirs.Dispose();
    hv_I.Dispose();
    hv_Files.Dispose();

    return;
  }

  // Chapter: Filters / Arithmetic
  // Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
  public void scale_image_range (HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min, 
      HTuple hv_Max)
  {




      // Stack for temporary objects 
      HObject[] OTemp = new HObject[20];

      // Local iconic variables 

      HObject ho_ImageSelected=null, ho_SelectedChannel=null;
      HObject ho_LowerRegion=null, ho_UpperRegion=null, ho_ImageSelectedScaled=null;

      // Local copy input parameter variables 
      HObject ho_Image_COPY_INP_TMP;
      ho_Image_COPY_INP_TMP = new HObject(ho_Image);



      // Local control variables 

      HTuple hv_LowerLimit = new HTuple(), hv_UpperLimit = new HTuple();
      HTuple hv_Mult = new HTuple(), hv_Add = new HTuple(), hv_NumImages = new HTuple();
      HTuple hv_ImageIndex = new HTuple(), hv_Channels = new HTuple();
      HTuple hv_ChannelIndex = new HTuple(), hv_MinGray = new HTuple();
      HTuple hv_MaxGray = new HTuple(), hv_Range = new HTuple();
      HTuple   hv_Max_COPY_INP_TMP = new HTuple(hv_Max);
      HTuple   hv_Min_COPY_INP_TMP = new HTuple(hv_Min);

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_ImageScaled);
      HOperatorSet.GenEmptyObj(out ho_ImageSelected);
      HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
      HOperatorSet.GenEmptyObj(out ho_LowerRegion);
      HOperatorSet.GenEmptyObj(out ho_UpperRegion);
      HOperatorSet.GenEmptyObj(out ho_ImageSelectedScaled);
    //Convenience procedure to scale the gray values of the
    //input image Image from the interval [Min,Max]
    //to the interval [0,255] (default).
    //Gray values < 0 or > 255 (after scaling) are clipped.
    //
    //If the image shall be scaled to an interval different from [0,255],
    //this can be achieved by passing tuples with 2 values [From, To]
    //as Min and Max.
    //Example:
    //scale_image_range(Image:ImageScaled:[100,50],[200,250])
    //maps the gray values of Image from the interval [100,200] to [50,250].
    //All other gray values will be clipped.
    //
    //input parameters:
    //Image: the input image
    //Min: the minimum gray value which will be mapped to 0
    //     If a tuple with two values is given, the first value will
    //     be mapped to the second value.
    //Max: The maximum gray value which will be mapped to 255
    //     If a tuple with two values is given, the first value will
    //     be mapped to the second value.
    //
    //Output parameter:
    //ImageScale: the resulting scaled image.
    //
    if ((int)(new HTuple((new HTuple(hv_Min_COPY_INP_TMP.TupleLength())).TupleEqual(
        2))) != 0)
    {
      hv_LowerLimit.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LowerLimit = hv_Min_COPY_INP_TMP.TupleSelect(
          1);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Min = hv_Min_COPY_INP_TMP.TupleSelect(
          0);
      hv_Min_COPY_INP_TMP.Dispose();
      hv_Min_COPY_INP_TMP = ExpTmpLocalVar_Min;
      }
      }
    }
    else
    {
      hv_LowerLimit.Dispose();
      hv_LowerLimit = 0.0;
    }
    if ((int)(new HTuple((new HTuple(hv_Max_COPY_INP_TMP.TupleLength())).TupleEqual(
        2))) != 0)
    {
      hv_UpperLimit.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_UpperLimit = hv_Max_COPY_INP_TMP.TupleSelect(
          1);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Max = hv_Max_COPY_INP_TMP.TupleSelect(
          0);
      hv_Max_COPY_INP_TMP.Dispose();
      hv_Max_COPY_INP_TMP = ExpTmpLocalVar_Max;
      }
      }
    }
    else
    {
      hv_UpperLimit.Dispose();
      hv_UpperLimit = 255.0;
    }
    //
    //Calculate scaling parameters.
    hv_Mult.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Mult = (((hv_UpperLimit-hv_LowerLimit)).TupleReal()
        )/(hv_Max_COPY_INP_TMP-hv_Min_COPY_INP_TMP);
    }
    hv_Add.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Add = ((-hv_Mult)*hv_Min_COPY_INP_TMP)+hv_LowerLimit;
    }
    //
    //Scale image.
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.ScaleImage(ho_Image_COPY_INP_TMP, out ExpTmpOutVar_0, hv_Mult, hv_Add);
    ho_Image_COPY_INP_TMP.Dispose();
    ho_Image_COPY_INP_TMP = ExpTmpOutVar_0;
    }
    //
    //Clip gray values if necessary.
    //This must be done for each image and channel separately.
    ho_ImageScaled.Dispose();
    HOperatorSet.GenEmptyObj(out ho_ImageScaled);
    hv_NumImages.Dispose();
    HOperatorSet.CountObj(ho_Image_COPY_INP_TMP, out hv_NumImages);
    HTuple end_val49 = hv_NumImages;
    HTuple step_val49 = 1;
    for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val49, step_val49); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val49))
    {
      ho_ImageSelected.Dispose();
      HOperatorSet.SelectObj(ho_Image_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
      hv_Channels.Dispose();
      HOperatorSet.CountChannels(ho_ImageSelected, out hv_Channels);
      HTuple end_val52 = hv_Channels;
      HTuple step_val52 = 1;
      for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val52, step_val52); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val52))
      {
        ho_SelectedChannel.Dispose();
        HOperatorSet.AccessChannel(ho_ImageSelected, out ho_SelectedChannel, hv_ChannelIndex);
        hv_MinGray.Dispose();hv_MaxGray.Dispose();hv_Range.Dispose();
        HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray, 
            out hv_MaxGray, out hv_Range);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_LowerRegion.Dispose();
        HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(
            hv_LowerLimit))).TupleMin(), hv_LowerLimit);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_UpperRegion.Dispose();
        HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit, 
            ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.PaintRegion(ho_LowerRegion, ho_SelectedChannel, out ExpTmpOutVar_0, 
            hv_LowerLimit, "fill");
        ho_SelectedChannel.Dispose();
        ho_SelectedChannel = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.PaintRegion(ho_UpperRegion, ho_SelectedChannel, out ExpTmpOutVar_0, 
            hv_UpperLimit, "fill");
        ho_SelectedChannel.Dispose();
        ho_SelectedChannel = ExpTmpOutVar_0;
        }
        if ((int)(new HTuple(hv_ChannelIndex.TupleEqual(1))) != 0)
        {
          ho_ImageSelectedScaled.Dispose();
          HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageSelectedScaled, 1, 
              1);
        }
        else
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.AppendChannel(ho_ImageSelectedScaled, ho_SelectedChannel, 
              out ExpTmpOutVar_0);
          ho_ImageSelectedScaled.Dispose();
          ho_ImageSelectedScaled = ExpTmpOutVar_0;
          }
        }
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_ImageScaled, ho_ImageSelectedScaled, out ExpTmpOutVar_0
          );
      ho_ImageScaled.Dispose();
      ho_ImageScaled = ExpTmpOutVar_0;
      }
    }
    ho_Image_COPY_INP_TMP.Dispose();
    ho_ImageSelected.Dispose();
    ho_SelectedChannel.Dispose();
    ho_LowerRegion.Dispose();
    ho_UpperRegion.Dispose();
    ho_ImageSelectedScaled.Dispose();

    hv_Max_COPY_INP_TMP.Dispose();
    hv_Min_COPY_INP_TMP.Dispose();
    hv_LowerLimit.Dispose();
    hv_UpperLimit.Dispose();
    hv_Mult.Dispose();
    hv_Add.Dispose();
    hv_NumImages.Dispose();
    hv_ImageIndex.Dispose();
    hv_Channels.Dispose();
    hv_ChannelIndex.Dispose();
    hv_MinGray.Dispose();
    hv_MaxGray.Dispose();
    hv_Range.Dispose();

    return;
  }

  public void select_case (HObject ho_MenuRegions, HTuple hv_WindowHandleMenu, HTuple hv_MenuTexts, 
      out HTuple hv_SelectedCase)
  {




    // Local iconic variables 

    HObject ho_ObjectSelected=null;

    // Local control variables 

    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Button = new HTuple(), hv_Number = new HTuple();
    HTuple hv_Index = new HTuple(), hv_IsInside = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
    hv_SelectedCase = new HTuple();
    while ((int)(1) != 0)
    {
      try
      {
        hv_Row.Dispose();hv_Column.Dispose();hv_Button.Dispose();
        HOperatorSet.GetMposition(hv_WindowHandleMenu, out hv_Row, out hv_Column, 
            out hv_Button);
        if ((int)(new HTuple(hv_Button.TupleEqual(1))) != 0)
        {
          hv_Number.Dispose();
          HOperatorSet.CountObj(ho_MenuRegions, out hv_Number);
          HTuple end_val5 = hv_Number.TupleMin2(
              new HTuple(hv_MenuTexts.TupleLength()));
          HTuple step_val5 = 1;
          for (hv_Index=1; hv_Index.Continue(end_val5, step_val5); hv_Index = hv_Index.TupleAdd(step_val5))
          {
            ho_ObjectSelected.Dispose();
            HOperatorSet.SelectObj(ho_MenuRegions, out ho_ObjectSelected, hv_Index);
            hv_IsInside.Dispose();
            HOperatorSet.TestRegionPoint(ho_ObjectSelected, hv_Row, hv_Column, out hv_IsInside);
            if ((int)(hv_IsInside) != 0)
            {
              hv_SelectedCase.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SelectedCase = hv_Index-1;
              }
              ho_ObjectSelected.Dispose();

              hv_Row.Dispose();
              hv_Column.Dispose();
              hv_Button.Dispose();
              hv_Number.Dispose();
              hv_Index.Dispose();
              hv_IsInside.Dispose();
              hv_Exception.Dispose();

              return;
            }
          }
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(2454))).TupleOr(
            new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(5100)))) != 0)
        {
          //Handle was already cleared -> indicates that the window was closed (by the user)
          //Abort gracefully.
          hv_SelectedCase.Dispose();
          hv_SelectedCase = -1;
          ho_ObjectSelected.Dispose();

          hv_Row.Dispose();
          hv_Column.Dispose();
          hv_Button.Dispose();
          hv_Number.Dispose();
          hv_Index.Dispose();
          hv_IsInside.Dispose();
          hv_Exception.Dispose();

          return;
        }
        else if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
            5))) != 0)
        {
          //Ignore -> mouse outside of window
        }
        else
        {
          //Unknown / Unexpected exception
          //Ignore for now
        }
      }
    }
    ho_ObjectSelected.Dispose();

    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Button.Dispose();
    hv_Number.Dispose();
    hv_Index.Dispose();
    hv_IsInside.Dispose();
    hv_Exception.Dispose();

    return;
  }

  // Chapter: Object / Manipulation
  // Short Description: Select elements from object arrays using a mask. 
  public void select_mask_obj (HObject ho_Objects, out HObject ho_SelectedObjects, 
      HTuple hv_Mask)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_Number = new HTuple(), hv_AllNumbers = new HTuple();
    HTuple hv_Indices = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SelectedObjects);
    //select_mask_obj selects one or more single elements of the object array
    //Objects and returns them in SelectedObjects.
    //The elements of Mask determine if the corresponding elements of Objects are selected.
    //If the value is greater than 0, the corresponding element is selected.
    //
    //Check number of elements
    hv_Number.Dispose();
    HOperatorSet.CountObj(ho_Objects, out hv_Number);
    if ((int)(new HTuple(hv_Number.TupleNotEqual(new HTuple(hv_Mask.TupleLength()
        )))) != 0)
    {
      throw new HalconException("Number of elements in Objects and Mask do not match.");
    }
    //
    //Check type of mask elements
    hv_AllNumbers.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_AllNumbers = new HTuple((((((hv_Mask.TupleIsRealElem()
        )).TupleSum())+(((hv_Mask.TupleIsIntElem())).TupleSum()))).TupleEqual(new HTuple(hv_Mask.TupleLength()
        )));
    }
    if ((int)((new HTuple(hv_AllNumbers.TupleNot())).TupleAnd(new HTuple(hv_Mask.TupleNotEqual(
        new HTuple())))) != 0)
    {
      throw new HalconException("Invalid type: Elements of Mask must be integer or real numbers.");
    }
    //
    //Use select_mask for tuples to generate a list of object indices.
    hv_Indices.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Indices = (HTuple.TupleGenSequence(
        1,new HTuple(hv_Mask.TupleLength()),1)).TupleSelectMask(hv_Mask);
    }
    ho_SelectedObjects.Dispose();
    HOperatorSet.SelectObj(ho_Objects, out ho_SelectedObjects, hv_Indices);

    hv_Number.Dispose();
    hv_AllNumbers.Dispose();
    hv_Indices.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Select a percentage of the given data. 
  public void select_percentage_dl_classifier_data (HTuple hv_ImageFiles, HTuple hv_GroundTruthLabels, 
      HTuple hv_SelectPercentage, out HTuple hv_ImageFilesOut, out HTuple hv_LabelsOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_UniqueClasses = new HTuple(), hv_Ratio = new HTuple();
    HTuple hv_ClassIndex = new HTuple(), hv_Label = new HTuple();
    HTuple hv_LabelIndices = new HTuple(), hv_ImageFilesLabel = new HTuple();
    HTuple hv_IndexEnd = new HTuple();
    // Initialize local and output iconic variables 
    hv_ImageFilesOut = new HTuple();
    hv_LabelsOut = new HTuple();
    //This procedure selects SelectPercentage percentages
    //of the input data set ImageFiles and GroundTruthLabels and returns
    //the result in ImageFilesOut and LabelsOut.
    //The original ratio of class sizes is kept
    //when applying this percentage.
    //
    //Check the input parameters.
    if ((int)(new HTuple((new HTuple(hv_ImageFiles.TupleLength())).TupleLess(1))) != 0)
    {
      throw new HalconException("ImageFiles must not be empty.");
    }
    if ((int)(new HTuple((new HTuple(hv_ImageFiles.TupleLength())).TupleNotEqual(
        new HTuple(hv_GroundTruthLabels.TupleLength())))) != 0)
    {
      throw new HalconException("Please provide a label for every image.");
    }
    if ((int)((new HTuple(hv_SelectPercentage.TupleLess(0))).TupleOr(new HTuple(hv_SelectPercentage.TupleGreater(
        100)))) != 0)
    {
      throw new HalconException("UsedPercentage must be between 0 and 100.");
    }
    hv_UniqueClasses.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_UniqueClasses = ((hv_GroundTruthLabels.TupleSort()
        )).TupleUniq();
    }
    //
    //Select the user-defined percentage of every class.
    if ((int)(new HTuple(hv_SelectPercentage.TupleEqual(100))) != 0)
    {
      hv_ImageFilesOut.Dispose();
      hv_ImageFilesOut = new HTuple(hv_ImageFiles);
      hv_LabelsOut.Dispose();
      hv_LabelsOut = new HTuple(hv_GroundTruthLabels);
    }
    else
    {
      hv_Ratio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ratio = hv_SelectPercentage*0.01;
      }
      hv_ImageFilesOut.Dispose();
      hv_ImageFilesOut = new HTuple();
      hv_LabelsOut.Dispose();
      hv_LabelsOut = new HTuple();
      for (hv_ClassIndex=0; (int)hv_ClassIndex<=(int)((new HTuple(hv_UniqueClasses.TupleLength()
          ))-1); hv_ClassIndex = (int)hv_ClassIndex + 1)
      {
        //For each class, find the images with this label.
        hv_Label.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Label = hv_UniqueClasses.TupleSelect(
            hv_ClassIndex);
        }
        hv_LabelIndices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LabelIndices = hv_GroundTruthLabels.TupleFind(
            hv_Label);
        }
        hv_ImageFilesLabel.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageFilesLabel = hv_ImageFiles.TupleSelect(
            hv_LabelIndices);
        }
        //Shuffle the images with this label.
        {
        HTuple ExpTmpOutVar_0;
        tuple_shuffle(hv_ImageFilesLabel, out ExpTmpOutVar_0);
        hv_ImageFilesLabel.Dispose();
        hv_ImageFilesLabel = ExpTmpOutVar_0;
        }
        //Select images from the class according to the given percentage.
        hv_IndexEnd.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_IndexEnd = (new HTuple(0)).TupleMax2(
            ((((((new HTuple(hv_ImageFilesLabel.TupleLength()))*hv_Ratio)).TupleFloor()
            )).TupleInt())-1);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ImageFilesOut = hv_ImageFilesOut.TupleConcat(
            hv_ImageFilesLabel.TupleSelectRange(0,hv_IndexEnd));
        hv_ImageFilesOut.Dispose();
        hv_ImageFilesOut = ExpTmpLocalVar_ImageFilesOut;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_LabelsOut = hv_LabelsOut.TupleConcat(
            HTuple.TupleGenConst(hv_IndexEnd+1,hv_Label));
        hv_LabelsOut.Dispose();
        hv_LabelsOut = ExpTmpLocalVar_LabelsOut;
        }
        }
      }
    }

    hv_UniqueClasses.Dispose();
    hv_Ratio.Dispose();
    hv_ClassIndex.Dispose();
    hv_Label.Dispose();
    hv_LabelIndices.Dispose();
    hv_ImageFilesLabel.Dispose();
    hv_IndexEnd.Dispose();

    return;
  }

  public void send_pose_update (HTuple hv_Parameters, HTuple hv_Poses)
  {



    // Local control variables 

    HTuple hv_MessageQueue = new HTuple(), hv_MessageHandle = new HTuple();
    // Initialize local and output iconic variables 
    hv_MessageQueue.Dispose();
    HOperatorSet.GetMessageTuple(hv_Parameters, "MessageQueue", out hv_MessageQueue);
    if ((int)(new HTuple(hv_MessageQueue.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_MessageHandle.Dispose();
      HOperatorSet.CreateMessage(out hv_MessageHandle);
      HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "redraw");
      HOperatorSet.SetMessageTuple(hv_MessageHandle, "poses", hv_Poses);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.EnqueueMessage(hv_MessageQueue.TupleSelect(2), hv_MessageHandle, 
          new HTuple(), new HTuple());
      }
      HOperatorSet.ClearMessage(hv_MessageHandle);
    }

    hv_MessageQueue.Dispose();
    hv_MessageHandle.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Serialize a DLModelHandle with current meta information. 
  public void serialize_train_dl_model_intermediate (HTuple hv_DLModelHandle, HTuple hv_Epoch, 
      HTuple hv_Strategy, HTuple hv_TrainInfos, HTuple hv_EvaluationInfos, out HTuple hv_FilenameModel, 
      out HTuple hv_FilenameMetaData)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Type = new HTuple(), hv_Basename = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_MetaData = new HTuple();
    // Initialize local and output iconic variables 
    hv_FilenameModel = new HTuple();
    hv_FilenameMetaData = new HTuple();
    //
    //Serialize the model DLModelHandle with current meta information.
    //
    //We need the type of strategy used.
    hv_Type.Dispose();
    HOperatorSet.GetDictTuple(hv_Strategy, "type", out hv_Type);

    //Get basename/default.
    try
    {
      hv_Basename.Dispose();
      HOperatorSet.GetDictTuple(hv_Strategy, "basename", out hv_Basename);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_Basename.Dispose();
      hv_Basename = new HTuple(hv_Type);
    }
    //
    //If we serialize epochs we will add the epoch to the basename.
    if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
    {
      hv_Basename.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Basename = "model_at_epoch_"+(hv_Epoch.TupleString(
          ".2f"));
      }
    }
    //
    //Filenames.
    hv_FilenameModel.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_FilenameModel = hv_Basename+".hdl";
    }
    hv_FilenameMetaData.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_FilenameMetaData = hv_Basename+"_info.hdict";
    }
    //
    //Metadata.
    hv_MetaData.Dispose();
    HOperatorSet.CreateDict(out hv_MetaData);
    HOperatorSet.SetDictTuple(hv_MetaData, "train_infos", hv_TrainInfos);
    HOperatorSet.SetDictTuple(hv_MetaData, "evaluation_infos", hv_EvaluationInfos);
    HOperatorSet.SetDictTuple(hv_MetaData, "epoch", hv_Epoch);
    //
    //Write files.
    HOperatorSet.WriteDlModel(hv_DLModelHandle, hv_FilenameModel);
    HOperatorSet.WriteDict(hv_MetaData, hv_FilenameMetaData, new HTuple(), new HTuple());

    hv_Type.Dispose();
    hv_Basename.Dispose();
    hv_Exception.Dispose();
    hv_MetaData.Dispose();

    return;
  }

  // Chapter: Calibration / Camera Parameters
  // Short Description: Set the value of a specified camera parameter in the camera parameter tuple. 
  public void set_cam_par_data (HTuple hv_CameraParamIn, HTuple hv_ParamName, HTuple hv_ParamValue, 
      out HTuple hv_CameraParamOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Index = new HTuple(), hv_ParamNameInd = new HTuple();
    HTuple hv_CameraParamNames = new HTuple(), hv_I = new HTuple();
    HTuple hv_CameraType = new HTuple(), hv_IsTelecentric = new HTuple();
    // Initialize local and output iconic variables 
    hv_CameraParamOut = new HTuple();
    //set_cam_par_data sets the value of the parameter that
    //is given in ParamName in the tuple of camera parameters
    //given in CameraParamIn. The modified camera parameters
    //are returned in CameraParamOut.
    //
    //Check for consistent length of input parameters
    if ((int)(new HTuple((new HTuple(hv_ParamName.TupleLength())).TupleNotEqual(new HTuple(hv_ParamValue.TupleLength()
        )))) != 0)
    {
      throw new HalconException("Different number of values in ParamName and ParamValue");
    }
    //First, get the parameter names that correspond to the
    //elements in the input camera parameter tuple.
    hv_CameraType.Dispose();hv_CameraParamNames.Dispose();
    get_cam_par_names(hv_CameraParamIn, out hv_CameraType, out hv_CameraParamNames);
    //
    //Find the index of the requested camera data and return
    //the corresponding value.
    hv_CameraParamOut.Dispose();
    hv_CameraParamOut = new HTuple(hv_CameraParamIn);
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ParamName.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_ParamNameInd.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ParamNameInd = hv_ParamName.TupleSelect(
          hv_Index);
      }
      hv_I.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_I = hv_CameraParamNames.TupleFind(
          hv_ParamNameInd);
      }
      if ((int)(new HTuple(hv_I.TupleNotEqual(-1))) != 0)
      {
        if (hv_CameraParamOut == null)
          hv_CameraParamOut = new HTuple();
        hv_CameraParamOut[hv_I] = hv_ParamValue.TupleSelect(hv_Index);
      }
      else
      {
        throw new HalconException("Wrong ParamName "+hv_ParamNameInd);
      }
      //Check the consistency of focus and telecentricity
      if ((int)(new HTuple(hv_ParamNameInd.TupleEqual("focus"))) != 0)
      {
        hv_IsTelecentric.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_IsTelecentric = (new HTuple(((hv_CameraType.TupleStrstr(
            "telecentric"))).TupleNotEqual(-1))).TupleAnd(new HTuple(((hv_CameraType.TupleStrstr(
            "image_side_telecentric"))).TupleEqual(-1)));
        }
        if ((int)(hv_IsTelecentric) != 0)
        {
          throw new HalconException(new HTuple("Focus for telecentric lenses is always 0, and hence, cannot be changed."));
        }
        if ((int)((new HTuple(hv_IsTelecentric.TupleNot())).TupleAnd(new HTuple(((hv_ParamValue.TupleSelect(
            hv_Index))).TupleEqual(0.0)))) != 0)
        {
          throw new HalconException("Focus for non-telecentric lenses must not be 0.");
        }
      }
    }

    hv_Index.Dispose();
    hv_ParamNameInd.Dispose();
    hv_CameraParamNames.Dispose();
    hv_I.Dispose();
    hv_CameraType.Dispose();
    hv_IsTelecentric.Dispose();

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: Set font independent of OS 
  public void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
      HTuple hv_Bold, HTuple hv_Slant)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OS = new HTuple(), hv_Fonts = new HTuple();
    HTuple hv_Style = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_AvailableFonts = new HTuple(), hv_Fdx = new HTuple();
    HTuple hv_Indices = new HTuple();
    HTuple   hv_Font_COPY_INP_TMP = new HTuple(hv_Font);
    HTuple   hv_Size_COPY_INP_TMP = new HTuple(hv_Size);

    // Initialize local and output iconic variables 
    //This procedure sets the text font of the current window with
    //the specified attributes.
    //
    //Input parameters:
    //WindowHandle: The graphics window for which the font will be set
    //Size: The font size. If Size=-1, the default of 16 is used.
    //Bold: If set to 'true', a bold font is used
    //Slant: If set to 'true', a slanted font is used
    //
    hv_OS.Dispose();
    HOperatorSet.GetSystem("operating_system", out hv_OS);
    if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
        new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
    {
      hv_Size_COPY_INP_TMP.Dispose();
      hv_Size_COPY_INP_TMP = 16;
    }
    if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
    {
      //Restore previous behaviour
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Size = ((1.13677*hv_Size_COPY_INP_TMP)).TupleInt()
          ;
      hv_Size_COPY_INP_TMP.Dispose();
      hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
      }
      }
    }
    else
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Size = hv_Size_COPY_INP_TMP.TupleInt()
          ;
      hv_Size_COPY_INP_TMP.Dispose();
      hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
      }
      }
    }
    if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
    {
      hv_Fonts.Dispose();
      hv_Fonts = new HTuple();
      hv_Fonts[0] = "Courier";
      hv_Fonts[1] = "Courier 10 Pitch";
      hv_Fonts[2] = "Courier New";
      hv_Fonts[3] = "CourierNew";
      hv_Fonts[4] = "Liberation Mono";
    }
    else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
    {
      hv_Fonts.Dispose();
      hv_Fonts = new HTuple();
      hv_Fonts[0] = "Consolas";
      hv_Fonts[1] = "Menlo";
      hv_Fonts[2] = "Courier";
      hv_Fonts[3] = "Courier 10 Pitch";
      hv_Fonts[4] = "FreeMono";
      hv_Fonts[5] = "Liberation Mono";
    }
    else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
    {
      hv_Fonts.Dispose();
      hv_Fonts = new HTuple();
      hv_Fonts[0] = "Luxi Sans";
      hv_Fonts[1] = "DejaVu Sans";
      hv_Fonts[2] = "FreeSans";
      hv_Fonts[3] = "Arial";
      hv_Fonts[4] = "Liberation Sans";
    }
    else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
    {
      hv_Fonts.Dispose();
      hv_Fonts = new HTuple();
      hv_Fonts[0] = "Times New Roman";
      hv_Fonts[1] = "Luxi Serif";
      hv_Fonts[2] = "DejaVu Serif";
      hv_Fonts[3] = "FreeSerif";
      hv_Fonts[4] = "Utopia";
      hv_Fonts[5] = "Liberation Serif";
    }
    else
    {
      hv_Fonts.Dispose();
      hv_Fonts = new HTuple(hv_Font_COPY_INP_TMP);
    }
    hv_Style.Dispose();
    hv_Style = "";
    if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Style = hv_Style+"Bold";
      hv_Style.Dispose();
      hv_Style = ExpTmpLocalVar_Style;
      }
      }
    }
    else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
    {
      hv_Exception.Dispose();
      hv_Exception = "Wrong value of control parameter Bold";
      throw new HalconException(hv_Exception);
    }
    if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Style = hv_Style+"Italic";
      hv_Style.Dispose();
      hv_Style = ExpTmpLocalVar_Style;
      }
      }
    }
    else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
    {
      hv_Exception.Dispose();
      hv_Exception = "Wrong value of control parameter Slant";
      throw new HalconException(hv_Exception);
    }
    if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
    {
      hv_Style.Dispose();
      hv_Style = "Normal";
    }
    hv_AvailableFonts.Dispose();
    HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
    hv_Font_COPY_INP_TMP.Dispose();
    hv_Font_COPY_INP_TMP = "";
    for (hv_Fdx=0; (int)hv_Fdx<=(int)((new HTuple(hv_Fonts.TupleLength()))-1); hv_Fdx = (int)hv_Fdx + 1)
    {
      hv_Indices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices = hv_AvailableFonts.TupleFind(
          hv_Fonts.TupleSelect(hv_Fdx));
      }
      if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(0))) != 0)
      {
        if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
        {
          hv_Font_COPY_INP_TMP.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(
              hv_Fdx);
          }
          break;
        }
      }
    }
    if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
    {
      throw new HalconException("Wrong value of control parameter Font");
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_Font = (((hv_Font_COPY_INP_TMP+"-")+hv_Style)+"-")+hv_Size_COPY_INP_TMP;
    hv_Font_COPY_INP_TMP.Dispose();
    hv_Font_COPY_INP_TMP = ExpTmpLocalVar_Font;
    }
    }
    HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);

    hv_Font_COPY_INP_TMP.Dispose();
    hv_Size_COPY_INP_TMP.Dispose();
    hv_OS.Dispose();
    hv_Fonts.Dispose();
    hv_Style.Dispose();
    hv_Exception.Dispose();
    hv_AvailableFonts.Dispose();
    hv_Fdx.Dispose();
    hv_Indices.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Set the model parameters based on preprocessing parameters. 
  public void set_dl_model_param_based_on_preprocessing (HTuple hv_DLModelHandle, 
      HTuple hv_DLPreprocessParam, HTuple hv_ClassIDs)
  {



          // Local iconic variables 

          // Local control variables 

          HTuple hv_ModelType = new HTuple(), hv_ImageWidth = new HTuple();
          HTuple hv_ImageHeight = new HTuple(), hv_ImageNumChannels = new HTuple();
          HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
          HTuple hv_ImageRangeMinModel = new HTuple(), hv_ImageRangeMaxModel = new HTuple();
          HTuple hv_ClassIDsBackground = new HTuple(), hv_IgnoreClassIDs = new HTuple();
          HTuple hv_RemoveClassIDs = new HTuple(), hv_Index = new HTuple();
          HTuple hv_ClassID = new HTuple(), hv_IndexFind = new HTuple();
          HTuple   hv_ClassIDs_COPY_INP_TMP = new HTuple(hv_ClassIDs);

          // Initialize local and output iconic variables 
    //
    //This procedure sets the model parameters based on preprocessing parameters.
    //Thereby, the deep-learning-based model has to be of type segmentation.
    //
    hv_ModelType.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
    //
    if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
    {
      //Get image dimensions from preprocessing.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_ImageNumChannels.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
      //
      //Set the image dimensions in the model.
      HOperatorSet.SetDlModelParam(hv_DLModelHandle, "image_width", hv_ImageWidth);
      HOperatorSet.SetDlModelParam(hv_DLModelHandle, "image_height", hv_ImageHeight);
      HOperatorSet.SetDlModelParam(hv_DLModelHandle, "image_num_channels", hv_ImageNumChannels);
      //
      //Check that image range is the same as in the model.
      hv_ImageRangeMin.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
      hv_ImageRangeMax.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
      hv_ImageRangeMinModel.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_range_min", out hv_ImageRangeMinModel);
      hv_ImageRangeMaxModel.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_range_max", out hv_ImageRangeMaxModel);
      if ((int)((new HTuple(hv_ImageRangeMin.TupleNotEqual(hv_ImageRangeMinModel))).TupleOr(
          new HTuple(hv_ImageRangeMax.TupleNotEqual(hv_ImageRangeMaxModel)))) != 0)
      {
        throw new HalconException("Warning: The preprocessed image range should be equal to the model range.");
      }
      //
      //Remove all background and ignore class IDs.
      hv_ClassIDsBackground.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_background", out hv_ClassIDsBackground);
      hv_IgnoreClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
      hv_RemoveClassIDs.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RemoveClassIDs = new HTuple();
      hv_RemoveClassIDs = hv_RemoveClassIDs.TupleConcat(hv_ClassIDsBackground, hv_IgnoreClassIDs);
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_RemoveClassIDs.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        hv_ClassID.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassID = hv_RemoveClassIDs.TupleSelect(
            hv_Index);
        }
        hv_IndexFind.Dispose();
        HOperatorSet.TupleFindFirst(hv_ClassIDs_COPY_INP_TMP, hv_ClassID, out hv_IndexFind);
        if ((int)((new HTuple((new HTuple(hv_IndexFind.TupleLength())).TupleGreater(
            0))).TupleAnd(new HTuple(hv_IndexFind.TupleNotEqual(-1)))) != 0)
        {
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_ClassIDs_COPY_INP_TMP, hv_IndexFind, out ExpTmpOutVar_0);
          hv_ClassIDs_COPY_INP_TMP.Dispose();
          hv_ClassIDs_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
      }
      //Set class IDs.
      HOperatorSet.SetDlModelParam(hv_DLModelHandle, "class_ids", hv_ClassIDs_COPY_INP_TMP);
      //Set ignore class IDs.
      HOperatorSet.SetDlModelParam(hv_DLModelHandle, "ignore_class_ids", hv_IgnoreClassIDs);
    }
    else
    {
      throw new HalconException("Procedure is only applicable for models of type 'segmentation'.");
    }
    //

    hv_ClassIDs_COPY_INP_TMP.Dispose();
    hv_ModelType.Dispose();
    hv_ImageWidth.Dispose();
    hv_ImageHeight.Dispose();
    hv_ImageNumChannels.Dispose();
    hv_ImageRangeMin.Dispose();
    hv_ImageRangeMax.Dispose();
    hv_ImageRangeMinModel.Dispose();
    hv_ImageRangeMaxModel.Dispose();
    hv_ClassIDsBackground.Dispose();
    hv_IgnoreClassIDs.Dispose();
    hv_RemoveClassIDs.Dispose();
    hv_Index.Dispose();
    hv_ClassID.Dispose();
    hv_IndexFind.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Set the maximum batch size for a given DLModelHandle and GPU. 
  public void set_dl_model_param_max_gpu_batch_size (HTuple hv_DLModelHandle, HTuple hv_BatchSizeUpperBound)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ModelType = new HTuple(), hv_OriginalRuntime = new HTuple();
    HTuple hv_GpuID = new HTuple(), hv_SerializedItemHandle = new HTuple();
    HTuple hv_OriginalModel = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_BatchSizeTestL = new HTuple(), hv_BatchSizeTestR = new HTuple();
    HTuple hv_BatchSizeTest = new HTuple(), hv_ErrorHint = new HTuple();
    HTuple hv_ExceptionThrown = new HTuple(), hv_TrainSamples = new HTuple();
    HTuple hv_TrainResult = new HTuple(), hv_BatchSize = new HTuple();
    HTuple   hv_DLModelHandle_COPY_INP_TMP = new HTuple(hv_DLModelHandle);

    // Initialize local and output iconic variables 
    //
    //This procedure sets the batch size of the deep-learning-based model DLModelHandle
    //to the maximum possible value given the current GPU memory.
    //
    hv_ModelType.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "type", out hv_ModelType);
    if ((int)((new HTuple(hv_ModelType.TupleNotEqual("segmentation"))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
        "detection")))) != 0)
    {
      throw new HalconException(new HTuple("Not implemented. Currently, this procedure only works for ")+"segmentation and detection models.");
    }
    //Get the current GPU ID.
    hv_OriginalRuntime.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "runtime", out hv_OriginalRuntime);
    hv_GpuID.Dispose();
    HOperatorSet.GetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "gpu", out hv_GpuID);
    try
    {
      //First we free the GPU memory completely to get a clean model.
      //Note, this only works for hardware where 'cpu' is available.
      HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "runtime", "cpu");
      HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "batch_size", 1);
      //
      //Create a copy which we want to use so that we do not modify the original model.
      hv_SerializedItemHandle.Dispose();
      HOperatorSet.SerializeDlModel(hv_DLModelHandle_COPY_INP_TMP, out hv_SerializedItemHandle);
      hv_OriginalModel.Dispose();
      hv_OriginalModel = new HTuple(hv_DLModelHandle_COPY_INP_TMP);
      hv_DLModelHandle_COPY_INP_TMP.Dispose();
      HOperatorSet.DeserializeDlModel(hv_SerializedItemHandle, out hv_DLModelHandle_COPY_INP_TMP);
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      //In case no CPU hardware is available we try to find maximum batch size
      //directly.
      hv_OriginalModel.Dispose();
      hv_OriginalModel = new HTuple();
    }
    //
    //Initialize the bounds.
    hv_BatchSizeTestL.Dispose();
    hv_BatchSizeTestL = 1;
    hv_BatchSizeTestR.Dispose();
    hv_BatchSizeTestR = new HTuple(hv_BatchSizeUpperBound);
    hv_BatchSizeTest.Dispose();
    hv_BatchSizeTest = new HTuple(hv_BatchSizeUpperBound);
    try
    {
      //Set initial batch size to 1. This has to work. Otherwise an exception is thrown.
      HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "batch_size", hv_BatchSizeTestL);
      HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "gpu", hv_GpuID);
      HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "runtime", "gpu");
      HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "runtime_init", 
          "immediately");
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(4104))).TupleAnd(
          new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(4201)))) != 0)
      {
        //Not an out of CUDA memory or cuDNN error. Hence, throw.
        throw new HalconException(hv_Exception);
      }
      if ((int)((new HTuple((new HTuple(hv_ModelType.TupleEqual("segmentation"))).TupleOr(
          new HTuple(hv_ModelType.TupleEqual("detection"))))).TupleOr(new HTuple(hv_ModelType.TupleEqual(
          "classification")))) != 0)
      {
        hv_ErrorHint.Dispose();
        hv_ErrorHint = "Try to reduce image_dimension or use a GPU with more RAM.";
      }
      else
      {
        hv_ErrorHint.Dispose();
        hv_ErrorHint = "Try to use a GPU with more RAM.";
      }
      throw new HalconException("Error while trying to find the maximum batch size. Even the minimum (1) does not fit into memory. "+hv_ErrorHint);

      hv_DLModelHandle_COPY_INP_TMP.Dispose();
      hv_ModelType.Dispose();
      hv_OriginalRuntime.Dispose();
      hv_GpuID.Dispose();
      hv_SerializedItemHandle.Dispose();
      hv_OriginalModel.Dispose();
      hv_Exception.Dispose();
      hv_BatchSizeTestL.Dispose();
      hv_BatchSizeTestR.Dispose();
      hv_BatchSizeTest.Dispose();
      hv_ErrorHint.Dispose();
      hv_ExceptionThrown.Dispose();
      hv_TrainSamples.Dispose();
      hv_TrainResult.Dispose();
      hv_BatchSize.Dispose();

      return;
    }
    //
    //Loop as long as we have not found the maximum batch size for the available GPU memory.
    while ((int)(new HTuple(((hv_BatchSizeTestR-hv_BatchSizeTestL)).TupleGreater(
        1))) != 0)
    {
      //
      //Check if an exception is thrown due to out of memory errors.
      hv_ExceptionThrown.Dispose();
      hv_ExceptionThrown = 0;
      try
      {
        //Try to set the batch size.
        HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "batch_size", 
            hv_BatchSizeTest);
        //
        //Even if the batch size setting works it might be that a train step fails
        //because during training more data is needed.
        //
        //Hence, generate blank train samples here.
        hv_TrainSamples.Dispose();
        gen_blank_dl_train_samples(hv_DLModelHandle_COPY_INP_TMP, out hv_TrainSamples);
        //
        //Do a few train steps to get the training data initialized.
        hv_TrainResult.Dispose();
        HOperatorSet.TrainDlModelBatch(hv_DLModelHandle_COPY_INP_TMP, hv_TrainSamples, 
            out hv_TrainResult);
        hv_TrainResult.Dispose();
        HOperatorSet.TrainDlModelBatch(hv_DLModelHandle_COPY_INP_TMP, hv_TrainSamples, 
            out hv_TrainResult);
        hv_TrainResult.Dispose();
        HOperatorSet.TrainDlModelBatch(hv_DLModelHandle_COPY_INP_TMP, hv_TrainSamples, 
            out hv_TrainResult);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(4104))).TupleAnd(
            new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(4201)))) != 0)
        {
          //Not an out of CUDA memory or cuDNN error. Hence, throw.
          throw new HalconException(hv_Exception);
        }
        //Update the upper bound.
        hv_BatchSizeTestR.Dispose();
        hv_BatchSizeTestR = new HTuple(hv_BatchSizeTest);
        hv_ExceptionThrown.Dispose();
        hv_ExceptionThrown = 1;
      }
      if ((int)(hv_ExceptionThrown.TupleNot()) != 0)
      {
        //Update the lower bound.
        hv_BatchSizeTestL.Dispose();
        hv_BatchSizeTestL = new HTuple(hv_BatchSizeTest);
      }
      //Continue with next test.
      hv_BatchSizeTest.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BatchSizeTest = hv_BatchSizeTestL+((hv_BatchSizeTestR-hv_BatchSizeTestL)/2);
      }
    }
    hv_BatchSize.Dispose();
    hv_BatchSize = new HTuple(hv_BatchSizeTest);
    //In case we used a copy we clear it.
    if ((int)(new HTuple((new HTuple(hv_OriginalModel.TupleLength())).TupleGreater(
        0))) != 0)
    {
      HOperatorSet.ClearDlModel(hv_DLModelHandle_COPY_INP_TMP);
      //Use the original model again.
      hv_DLModelHandle_COPY_INP_TMP.Dispose();
      hv_DLModelHandle_COPY_INP_TMP = new HTuple(hv_OriginalModel);
    }
    HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "runtime", hv_OriginalRuntime);
    HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "batch_size", hv_BatchSize);

    hv_DLModelHandle_COPY_INP_TMP.Dispose();
    hv_ModelType.Dispose();
    hv_OriginalRuntime.Dispose();
    hv_GpuID.Dispose();
    hv_SerializedItemHandle.Dispose();
    hv_OriginalModel.Dispose();
    hv_Exception.Dispose();
    hv_BatchSizeTestL.Dispose();
    hv_BatchSizeTestR.Dispose();
    hv_BatchSizeTest.Dispose();
    hv_ErrorHint.Dispose();
    hv_ExceptionThrown.Dispose();
    hv_TrainSamples.Dispose();
    hv_TrainResult.Dispose();
    hv_BatchSize.Dispose();

    return;
  }

  public void set_edge_parameter_sliders (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
      HTuple hv_MessageQueues, HTuple hv_MessageQueueOut, HTuple hv_ModelDiameter, 
      HTuple hv_AmplitudeRange, HTuple hv_MaxGapRange, HTuple hv_Viewpoint, out HTuple hv_MinAmplitude, 
      out HTuple hv_MaxGap)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_X=null, ho_Y=null, ho_Z=null, ho_ZZoomed=null;
    HObject ho_XEdges=null, ho_YEdges=null, ho_ZEdges=null;
    HObject ho_EdgesDomain=null, ho_EdgesDomainZoomed=null;

    // Local control variables 

    HTuple hv_ViewpointStr = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_WindowHandleBuffer = new HTuple();
    HTuple hv_SliderHeight = new HTuple(), hv_RowSlider1 = new HTuple();
    HTuple hv_RowSlider2 = new HTuple(), hv_ColSliderLabel = new HTuple();
    HTuple hv_ColSliderValue = new HTuple(), hv_ColSliderStart = new HTuple();
    HTuple hv_ColSliderEnd = new HTuple(), hv_ImgWidth = new HTuple();
    HTuple hv_ImgHeight = new HTuple(), hv_Factor = new HTuple();
    HTuple hv_CurrentSliderActive = new HTuple(), hv_ObjectModel3DEdges = new HTuple();
    HTuple hv_PoseEstimated = new HTuple(), hv_MessageHandle = new HTuple();
    HTuple hv_ValuesUpdated = new HTuple(), hv_Slider = new HTuple();
    HTuple hv_MouseRow = new HTuple(), hv_MouseColumn = new HTuple();
    HTuple hv_UpdateSlider = new HTuple(), hv_MouseButton = new HTuple();
    HTuple hv_ValueRel = new HTuple(), hv_MessageType = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_X);
    HOperatorSet.GenEmptyObj(out ho_Y);
    HOperatorSet.GenEmptyObj(out ho_Z);
    HOperatorSet.GenEmptyObj(out ho_ZZoomed);
    HOperatorSet.GenEmptyObj(out ho_XEdges);
    HOperatorSet.GenEmptyObj(out ho_YEdges);
    HOperatorSet.GenEmptyObj(out ho_ZEdges);
    HOperatorSet.GenEmptyObj(out ho_EdgesDomain);
    HOperatorSet.GenEmptyObj(out ho_EdgesDomainZoomed);
    hv_MinAmplitude = new HTuple();
    hv_MaxGap = new HTuple();
    try
    {
      hv_MaxGap.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxGap = hv_MaxGapRange.TupleSelect(
          2);
      }
      hv_MinAmplitude.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinAmplitude = hv_AmplitudeRange.TupleSelect(
          2);
      }
      hv_ViewpointStr.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ViewpointStr = ((hv_Viewpoint+" ")).TupleSum()
          ;
      }

      //Open (invisible) buffer window to avoid flickering
      hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width, 
          out hv_Height);
      hv_WindowHandleBuffer.Dispose();
      HOperatorSet.OpenWindow(0, 0, hv_Width, hv_Height, 0, "buffer", "", out hv_WindowHandleBuffer);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(hv_WindowHandleBuffer, 0, 0, hv_Height-1, hv_Width-1);
      }

      //Estimate a good visualization pose
      hv_PoseEstimated.Dispose();
      estimate_visualization_pose_simple(hv_ObjectModel3D, hv_WindowHandleBuffer, 
          out hv_PoseEstimated);

      hv_SliderHeight.Dispose();
      hv_SliderHeight = 25;
      hv_RowSlider1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RowSlider1 = (hv_Height-10)-(2*hv_SliderHeight);
      }
      hv_RowSlider2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RowSlider2 = (hv_Height-10)-(1*hv_SliderHeight);
      }
      hv_ColSliderLabel.Dispose();
      hv_ColSliderLabel = 10;
      hv_ColSliderValue.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColSliderValue = hv_Width-50;
      }
      hv_ColSliderStart.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColSliderStart = hv_ColSliderLabel+130;
      }
      hv_ColSliderEnd.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColSliderEnd = hv_ColSliderValue-10;
      }

      set_display_font(hv_WindowHandle, 12, "mono", "true", "false");
      set_display_font(hv_WindowHandleBuffer, 12, "mono", "true", "false");

      ho_X.Dispose();ho_Y.Dispose();ho_Z.Dispose();
      HOperatorSet.ObjectModel3dToXyz(out ho_X, out ho_Y, out ho_Z, hv_ObjectModel3D, 
          "from_xyz_map", new HTuple(), new HTuple());
      hv_ImgWidth.Dispose();hv_ImgHeight.Dispose();
      HOperatorSet.GetImageSize(ho_X, out hv_ImgWidth, out hv_ImgHeight);
      hv_Factor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Factor = (((1.0*hv_Width)/hv_ImgWidth)).TupleMin2(
          (((1.0*hv_Height)-10)-(2*hv_SliderHeight))/hv_ImgHeight);
      }
      ho_ZZoomed.Dispose();
      HOperatorSet.ZoomImageFactor(ho_Z, out ho_ZZoomed, hv_Factor, hv_Factor, "nearest_neighbor");
      HOperatorSet.DispObj(ho_ZZoomed, hv_WindowHandle);

      hv_CurrentSliderActive.Dispose();
      hv_CurrentSliderActive = new HTuple();

      try
      {
        while ((int)(1) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ObjectModel3DEdges.Dispose();
          HOperatorSet.EdgesObjectModel3d(hv_ObjectModel3D, hv_MinAmplitude*hv_ModelDiameter, 
              (new HTuple("max_gap")).TupleConcat("viewpoint"), hv_MaxGap.TupleConcat(
              hv_ViewpointStr), out hv_ObjectModel3DEdges);
          }
          //
          //disp_object_model_3d (WindowHandleBuffer, ObjectModel3DEdges, [], PoseEstimated, 'color', 'blue')
          HOperatorSet.ClearWindow(hv_WindowHandleBuffer);
          HOperatorSet.DispObj(ho_ZZoomed, hv_WindowHandleBuffer);
          HOperatorSet.SetColor(hv_WindowHandleBuffer, "red");
          ho_XEdges.Dispose();ho_YEdges.Dispose();ho_ZEdges.Dispose();
          HOperatorSet.ObjectModel3dToXyz(out ho_XEdges, out ho_YEdges, out ho_ZEdges, 
              hv_ObjectModel3DEdges, "from_xyz_map", new HTuple(), new HTuple());
          ho_EdgesDomain.Dispose();
          HOperatorSet.GetDomain(ho_ZEdges, out ho_EdgesDomain);
          ho_EdgesDomainZoomed.Dispose();
          HOperatorSet.ZoomRegion(ho_EdgesDomain, out ho_EdgesDomainZoomed, hv_Factor, 
              hv_Factor);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.DilationCircle(ho_EdgesDomainZoomed, out ExpTmpOutVar_0, 1.5);
          ho_EdgesDomainZoomed.Dispose();
          ho_EdgesDomainZoomed = ExpTmpOutVar_0;
          }
          HOperatorSet.DispObj(ho_EdgesDomainZoomed, hv_WindowHandleBuffer);
          //
          //Update the 3D object model with the edges in the 3D visualization window
          hv_MessageHandle.Dispose();
          HOperatorSet.CreateMessage(out hv_MessageHandle);
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "replace_object_model");
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "index", 1);
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "model", hv_ObjectModel3DEdges);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.EnqueueMessage(hv_MessageQueueOut.TupleSelect(1), hv_MessageHandle, 
              new HTuple(), new HTuple());
          }
          //
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          disp_slider(hv_WindowHandleBuffer, hv_RowSlider1, hv_SliderHeight, hv_ColSliderLabel, 
              hv_ColSliderValue, hv_ColSliderStart, hv_ColSliderEnd, "MinAmplitudeRel: ", 
              hv_AmplitudeRange.TupleSelect(0), hv_AmplitudeRange.TupleSelect(1), 
              hv_MinAmplitude, "2.3f");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          disp_slider(hv_WindowHandleBuffer, hv_RowSlider2, hv_SliderHeight, hv_ColSliderLabel, 
              hv_ColSliderValue, hv_ColSliderStart, hv_ColSliderEnd, "MaxGap: ", 
              hv_MaxGapRange.TupleSelect(0), hv_MaxGapRange.TupleSelect(1), hv_MaxGap, 
              "d");
          }
          //
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.CopyRectangle(hv_WindowHandleBuffer, hv_WindowHandle, 0, 0, 
              hv_Height-1, hv_Width-1, 0, 0);
          }
          //
          hv_ValuesUpdated.Dispose();
          hv_ValuesUpdated = 0;
          while ((int)(hv_ValuesUpdated.TupleNot()) != 0)
          {
            hv_MouseRow.Dispose();hv_MouseColumn.Dispose();hv_MouseButton.Dispose();
            get_mouse_info(hv_WindowHandle, hv_MessageQueues, 0.01, out hv_MouseRow, 
                out hv_MouseColumn, out hv_MouseButton);
            //
            //Find the slider the mouse is in
            hv_Slider.Dispose();
            hv_Slider = new HTuple();
            if ((int)((new HTuple((new HTuple((new HTuple(hv_MouseRow.TupleGreater(
                hv_RowSlider1))).TupleAnd(new HTuple(hv_MouseRow.TupleLess(hv_RowSlider1+hv_SliderHeight))))).TupleAnd(
                new HTuple(hv_MouseColumn.TupleGreaterEqual(hv_ColSliderStart))))).TupleAnd(
                new HTuple(hv_MouseColumn.TupleLessEqual(hv_ColSliderEnd)))) != 0)
            {
              hv_Slider.Dispose();
              hv_Slider = 1;
            }
            else if ((int)((new HTuple((new HTuple((new HTuple(hv_MouseRow.TupleGreater(
                hv_RowSlider2))).TupleAnd(new HTuple(hv_MouseRow.TupleLess(hv_RowSlider2+hv_SliderHeight))))).TupleAnd(
                new HTuple(hv_MouseColumn.TupleGreaterEqual(hv_ColSliderStart))))).TupleAnd(
                new HTuple(hv_MouseColumn.TupleLessEqual(hv_ColSliderEnd)))) != 0)
            {
              hv_Slider.Dispose();
              hv_Slider = 2;
            }
            //
            hv_UpdateSlider.Dispose();
            hv_UpdateSlider = 0;
            if ((int)(new HTuple(hv_MouseButton.TupleEqual(1))) != 0)
            {
              if ((int)(new HTuple(hv_CurrentSliderActive.TupleEqual(new HTuple()))) != 0)
              {
                if ((int)(new HTuple(hv_Slider.TupleNotEqual(new HTuple()))) != 0)
                {
                  //Clicked into a slider -> start sliding
                  hv_CurrentSliderActive.Dispose();
                  hv_CurrentSliderActive = new HTuple(hv_Slider);
                  hv_UpdateSlider.Dispose();
                  hv_UpdateSlider = 1;
                }
              }
              else
              {
                //Continue sliding the current slider
                hv_UpdateSlider.Dispose();
                hv_UpdateSlider = 1;
              }
            }
            else if ((int)(new HTuple(hv_MouseButton.TupleEqual(0))) != 0)
            {
              if ((int)(new HTuple(hv_CurrentSliderActive.TupleNotEqual(new HTuple()))) != 0)
              {
                //mouse button released -> stop sliding
                hv_CurrentSliderActive.Dispose();
                hv_CurrentSliderActive = new HTuple();
              }
            }
            //
            if ((int)(hv_UpdateSlider) != 0)
            {
              hv_ValueRel.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ValueRel = (hv_MouseColumn-hv_ColSliderStart)/(hv_ColSliderEnd-hv_ColSliderStart);
              }
              if ((int)(new HTuple(hv_ValueRel.TupleLess(0))) != 0)
              {
                hv_ValueRel.Dispose();
                hv_ValueRel = 0;
              }
              else if ((int)(new HTuple(hv_ValueRel.TupleGreater(
                  1))) != 0)
              {
                hv_ValueRel.Dispose();
                hv_ValueRel = 1;
              }

              if ((int)(new HTuple((new HTuple(1)).TupleEqual(hv_CurrentSliderActive))) != 0)
              {
                hv_MinAmplitude.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_MinAmplitude = (hv_AmplitudeRange.TupleSelect(
                    0))+(hv_ValueRel*((hv_AmplitudeRange.TupleSelect(1))-(hv_AmplitudeRange.TupleSelect(
                    0))));
                }
              }
              else if ((int)(new HTuple((new HTuple(2)).TupleEqual(
                  hv_CurrentSliderActive))) != 0)
              {
                hv_MaxGap.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_MaxGap = (((hv_MaxGapRange.TupleSelect(
                    0))+(hv_ValueRel*((hv_MaxGapRange.TupleSelect(1))-(hv_MaxGapRange.TupleSelect(
                    0)))))).TupleInt();
                }
                //rounding might push it out of range
                if ((int)(new HTuple(hv_MaxGap.TupleLess(hv_MaxGapRange.TupleSelect(
                    0)))) != 0)
                {
                  hv_MaxGap.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_MaxGap = hv_MaxGapRange.TupleSelect(
                      0);
                  }
                }
                else if ((int)(new HTuple(hv_MaxGap.TupleGreater(
                    hv_MaxGapRange.TupleSelect(1)))) != 0)
                {
                  hv_MaxGap.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_MaxGap = hv_MaxGapRange.TupleSelect(
                      1);
                  }
                }
              }
              hv_ValuesUpdated.Dispose();
              hv_ValuesUpdated = 1;
            }
            //
            try
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_MessageHandle.Dispose();
              HOperatorSet.DequeueMessage(hv_MessageQueues.TupleSelect(1), "timeout", 
                  0, out hv_MessageHandle);
              }
              hv_MessageType.Dispose();
              HOperatorSet.GetMessageTuple(hv_MessageHandle, "type", out hv_MessageType);
              if ((int)(new HTuple(hv_MessageType.TupleEqual("exit"))) != 0)
              {
                ho_X.Dispose();
                ho_Y.Dispose();
                ho_Z.Dispose();
                ho_ZZoomed.Dispose();
                ho_XEdges.Dispose();
                ho_YEdges.Dispose();
                ho_ZEdges.Dispose();
                ho_EdgesDomain.Dispose();
                ho_EdgesDomainZoomed.Dispose();

                hv_ViewpointStr.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WindowHandleBuffer.Dispose();
                hv_SliderHeight.Dispose();
                hv_RowSlider1.Dispose();
                hv_RowSlider2.Dispose();
                hv_ColSliderLabel.Dispose();
                hv_ColSliderValue.Dispose();
                hv_ColSliderStart.Dispose();
                hv_ColSliderEnd.Dispose();
                hv_ImgWidth.Dispose();
                hv_ImgHeight.Dispose();
                hv_Factor.Dispose();
                hv_CurrentSliderActive.Dispose();
                hv_ObjectModel3DEdges.Dispose();
                hv_PoseEstimated.Dispose();
                hv_MessageHandle.Dispose();
                hv_ValuesUpdated.Dispose();
                hv_Slider.Dispose();
                hv_MouseRow.Dispose();
                hv_MouseColumn.Dispose();
                hv_UpdateSlider.Dispose();
                hv_MouseButton.Dispose();
                hv_ValueRel.Dispose();
                hv_MessageType.Dispose();
                hv_Exception.Dispose();

                return;
              }
              else
              {
                throw new HalconException((((new HTuple("Unknown message type")).TupleConcat(
                    hv_MessageType))).TupleConcat(hv_MessageHandle));
              }
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException3)
            {
              HDevExpDefaultException3.ToHTuple(out hv_Exception);
              if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(
                  9400))) != 0)
              {
                //Ignore timeout (no message in queue)
                throw new HalconException(hv_Exception);
              }
            }
          }
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException2)
      {
        HDevExpDefaultException2.ToHTuple(out hv_Exception);
        if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(2454))).TupleOr(
            new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(5100)))) != 0)
        {
          //Handle was already cleared -> indicates that the window was closed (by the user)
          //Abort gracefully.
          ho_X.Dispose();
          ho_Y.Dispose();
          ho_Z.Dispose();
          ho_ZZoomed.Dispose();
          ho_XEdges.Dispose();
          ho_YEdges.Dispose();
          ho_ZEdges.Dispose();
          ho_EdgesDomain.Dispose();
          ho_EdgesDomainZoomed.Dispose();

          hv_ViewpointStr.Dispose();
          hv_Row.Dispose();
          hv_Column.Dispose();
          hv_Width.Dispose();
          hv_Height.Dispose();
          hv_WindowHandleBuffer.Dispose();
          hv_SliderHeight.Dispose();
          hv_RowSlider1.Dispose();
          hv_RowSlider2.Dispose();
          hv_ColSliderLabel.Dispose();
          hv_ColSliderValue.Dispose();
          hv_ColSliderStart.Dispose();
          hv_ColSliderEnd.Dispose();
          hv_ImgWidth.Dispose();
          hv_ImgHeight.Dispose();
          hv_Factor.Dispose();
          hv_CurrentSliderActive.Dispose();
          hv_ObjectModel3DEdges.Dispose();
          hv_PoseEstimated.Dispose();
          hv_MessageHandle.Dispose();
          hv_ValuesUpdated.Dispose();
          hv_Slider.Dispose();
          hv_MouseRow.Dispose();
          hv_MouseColumn.Dispose();
          hv_UpdateSlider.Dispose();
          hv_MouseButton.Dispose();
          hv_ValueRel.Dispose();
          hv_MessageType.Dispose();
          hv_Exception.Dispose();

          return;
        }
        else
        {
          //Unknown / Unexpected exception
          throw new HalconException(hv_Exception);
        }
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_MessageHandle.Dispose();
      HOperatorSet.CreateMessage(out hv_MessageHandle);
      HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "exception");
      HOperatorSet.SetMessageTuple(hv_MessageHandle, "exception", hv_Exception);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.EnqueueMessage(hv_MessageQueues.TupleSelect(2), hv_MessageHandle, 
          new HTuple(), new HTuple());
      }
    }
    ho_X.Dispose();
    ho_Y.Dispose();
    ho_Z.Dispose();
    ho_ZZoomed.Dispose();
    ho_XEdges.Dispose();
    ho_YEdges.Dispose();
    ho_ZEdges.Dispose();
    ho_EdgesDomain.Dispose();
    ho_EdgesDomainZoomed.Dispose();

    hv_ViewpointStr.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_WindowHandleBuffer.Dispose();
    hv_SliderHeight.Dispose();
    hv_RowSlider1.Dispose();
    hv_RowSlider2.Dispose();
    hv_ColSliderLabel.Dispose();
    hv_ColSliderValue.Dispose();
    hv_ColSliderStart.Dispose();
    hv_ColSliderEnd.Dispose();
    hv_ImgWidth.Dispose();
    hv_ImgHeight.Dispose();
    hv_Factor.Dispose();
    hv_CurrentSliderActive.Dispose();
    hv_ObjectModel3DEdges.Dispose();
    hv_PoseEstimated.Dispose();
    hv_MessageHandle.Dispose();
    hv_ValuesUpdated.Dispose();
    hv_Slider.Dispose();
    hv_MouseRow.Dispose();
    hv_MouseColumn.Dispose();
    hv_UpdateSlider.Dispose();
    hv_MouseButton.Dispose();
    hv_ValueRel.Dispose();
    hv_MessageType.Dispose();
    hv_Exception.Dispose();

    return;
  }

  // Chapter: Tools / Geometry
  // Short Description: Sort tuple pairs. 
  public void sort_pairs (HTuple hv_T1, HTuple hv_T2, HTuple hv_SortMode, out HTuple hv_Sorted1, 
      out HTuple hv_Sorted2)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Indices1 = new HTuple(), hv_Indices2 = new HTuple();
    // Initialize local and output iconic variables 
    hv_Sorted1 = new HTuple();
    hv_Sorted2 = new HTuple();
    //Sort tuple pairs.
    //
    //input parameters:
    //T1: first tuple
    //T2: second tuple
    //SortMode: if set to '1', sort by the first tuple,
    //   if set to '2', sort by the second tuple
    //
    if ((int)((new HTuple(hv_SortMode.TupleEqual("1"))).TupleOr(new HTuple(hv_SortMode.TupleEqual(
        1)))) != 0)
    {
      hv_Indices1.Dispose();
      HOperatorSet.TupleSortIndex(hv_T1, out hv_Indices1);
      hv_Sorted1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Sorted1 = hv_T1.TupleSelect(
          hv_Indices1);
      }
      hv_Sorted2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Sorted2 = hv_T2.TupleSelect(
          hv_Indices1);
      }
    }
    else if ((int)((new HTuple((new HTuple(hv_SortMode.TupleEqual("column"))).TupleOr(
        new HTuple(hv_SortMode.TupleEqual("2"))))).TupleOr(new HTuple(hv_SortMode.TupleEqual(
        2)))) != 0)
    {
      hv_Indices2.Dispose();
      HOperatorSet.TupleSortIndex(hv_T2, out hv_Indices2);
      hv_Sorted1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Sorted1 = hv_T1.TupleSelect(
          hv_Indices2);
      }
      hv_Sorted2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Sorted2 = hv_T2.TupleSelect(
          hv_Indices2);
      }
    }

    hv_Indices1.Dispose();
    hv_Indices2.Dispose();

    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Split and shuffle the images and ground truth labels into training, validation and test subsets. 
  public void split_dl_classifier_data_set (HTuple hv_ImageFiles, HTuple hv_GroundTruthLabels, 
      HTuple hv_TrainingPercent, HTuple hv_ValidationPercent, out HTuple hv_TrainingImages, 
      out HTuple hv_TrainingLabels, out HTuple hv_ValidationImages, out HTuple hv_ValidationLabels, 
      out HTuple hv_TestImages, out HTuple hv_TestLabels)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_TrainingRatio = new HTuple(), hv_ValidationRatio = new HTuple();
    HTuple hv_UniqueClasses = new HTuple(), hv_ClassIndex = new HTuple();
    HTuple hv_Class = new HTuple(), hv_ClassIndices = new HTuple();
    HTuple hv_ImageFilesClass = new HTuple(), hv_LabelsClass = new HTuple();
    HTuple hv_IndexTrainingEnd = new HTuple(), hv_IndexValidationEnd = new HTuple();
    HTuple hv_TrainingSequence = new HTuple(), hv_ValidationSequence = new HTuple();
    HTuple hv_TestSequence = new HTuple();
    // Initialize local and output iconic variables 
    hv_TrainingImages = new HTuple();
    hv_TrainingLabels = new HTuple();
    hv_ValidationImages = new HTuple();
    hv_ValidationLabels = new HTuple();
    hv_TestImages = new HTuple();
    hv_TestLabels = new HTuple();
    //This procedure divides the data set (images and ground truth labels)
    //into three disjoint subsets: training, validation, and test.
    //The number of images and labels in each subset is defined
    //by the given percentages TrainingPercent and ValidationPercent.
    //Each subset contains randomly distributed data,
    //whereby the original ratio of class sizes is kept.
    //
    //Check the input parameters.
    if ((int)(new HTuple((new HTuple(hv_ImageFiles.TupleLength())).TupleNotEqual(
        new HTuple(hv_GroundTruthLabels.TupleLength())))) != 0)
    {
      throw new HalconException("Please provide a label for every image file.");
    }
    if ((int)(new HTuple(hv_TrainingPercent.TupleLess(0))) != 0)
    {
      throw new HalconException("TrainingPercent must not be smaller than zero.");
    }
    if ((int)(new HTuple(hv_ValidationPercent.TupleLess(0))) != 0)
    {
      throw new HalconException("ValidationPercent must not be smaller than zero.");
    }
    if ((int)(new HTuple((new HTuple(hv_ImageFiles.TupleLength())).TupleLess(1))) != 0)
    {
      throw new HalconException("ImageFiles must not be empty.");
    }
    if ((int)(new HTuple(((hv_TrainingPercent+hv_ValidationPercent)).TupleGreater(
        100))) != 0)
    {
      throw new HalconException("The sum of TrainingPercent and ValidationPercent must not be greater than 100.");
    }
    //
    //Set classes and data ratios.
    hv_TrainingRatio.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TrainingRatio = hv_TrainingPercent*0.01;
    }
    hv_ValidationRatio.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ValidationRatio = hv_ValidationPercent*0.01;
    }
    //
    //Prepare output tuples.
    hv_TrainingImages.Dispose();
    hv_TrainingImages = new HTuple();
    hv_TrainingLabels.Dispose();
    hv_TrainingLabels = new HTuple();
    hv_ValidationImages.Dispose();
    hv_ValidationImages = new HTuple();
    hv_ValidationLabels.Dispose();
    hv_ValidationLabels = new HTuple();
    hv_TestImages.Dispose();
    hv_TestImages = new HTuple();
    hv_TestLabels.Dispose();
    hv_TestLabels = new HTuple();
    //
    //Loop through all unique classes and add data
    //according to the specified percentages.
    hv_UniqueClasses.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_UniqueClasses = ((hv_GroundTruthLabels.TupleSort()
        )).TupleUniq();
    }
    for (hv_ClassIndex=0; (int)hv_ClassIndex<=(int)((new HTuple(hv_UniqueClasses.TupleLength()
        ))-1); hv_ClassIndex = (int)hv_ClassIndex + 1)
    {
      //Select all images and ground truth labels with the class.
      hv_Class.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Class = hv_UniqueClasses.TupleSelect(
          hv_ClassIndex);
      }
      hv_ClassIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassIndices = hv_GroundTruthLabels.TupleFind(
          hv_Class);
      }
      hv_ImageFilesClass.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageFilesClass = hv_ImageFiles.TupleSelect(
          hv_ClassIndices);
      }
      hv_LabelsClass.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LabelsClass = HTuple.TupleGenConst(
          new HTuple(hv_ImageFilesClass.TupleLength()),hv_Class);
      }
      //Shuffle the images in this class.
      {
      HTuple ExpTmpOutVar_0;
      tuple_shuffle(hv_ImageFilesClass, out ExpTmpOutVar_0);
      hv_ImageFilesClass.Dispose();
      hv_ImageFilesClass = ExpTmpOutVar_0;
      }
      //Determine the boundaries of the respective selection.
      hv_IndexTrainingEnd.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IndexTrainingEnd = ((((((new HTuple(hv_ImageFilesClass.TupleLength()
          ))*hv_TrainingRatio)).TupleFloor())).TupleInt())-1;
      }
      hv_IndexValidationEnd.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IndexValidationEnd = ((((((new HTuple(hv_ImageFilesClass.TupleLength()
          ))*(hv_ValidationRatio+hv_TrainingRatio))).TupleFloor())).TupleInt())-1;
      }
      //Add the respective images and labels.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TrainingImages = hv_TrainingImages.TupleConcat(
          hv_ImageFilesClass.TupleSelectRange(0,hv_IndexTrainingEnd));
      hv_TrainingImages.Dispose();
      hv_TrainingImages = ExpTmpLocalVar_TrainingImages;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TrainingLabels = hv_TrainingLabels.TupleConcat(
          hv_LabelsClass.TupleSelectRange(0,hv_IndexTrainingEnd));
      hv_TrainingLabels.Dispose();
      hv_TrainingLabels = ExpTmpLocalVar_TrainingLabels;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ValidationImages = hv_ValidationImages.TupleConcat(
          hv_ImageFilesClass.TupleSelectRange(hv_IndexTrainingEnd+1,hv_IndexValidationEnd));
      hv_ValidationImages.Dispose();
      hv_ValidationImages = ExpTmpLocalVar_ValidationImages;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ValidationLabels = hv_ValidationLabels.TupleConcat(
          hv_LabelsClass.TupleSelectRange(hv_IndexTrainingEnd+1,hv_IndexValidationEnd));
      hv_ValidationLabels.Dispose();
      hv_ValidationLabels = ExpTmpLocalVar_ValidationLabels;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TestImages = hv_TestImages.TupleConcat(
          hv_ImageFilesClass.TupleSelectRange(hv_IndexValidationEnd+1,(new HTuple(hv_ImageFilesClass.TupleLength()
          ))-1));
      hv_TestImages.Dispose();
      hv_TestImages = ExpTmpLocalVar_TestImages;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TestLabels = hv_TestLabels.TupleConcat(
          hv_LabelsClass.TupleSelectRange(hv_IndexValidationEnd+1,(new HTuple(hv_ImageFilesClass.TupleLength()
          ))-1));
      hv_TestLabels.Dispose();
      hv_TestLabels = ExpTmpLocalVar_TestLabels;
      }
      }
    }
    //
    //Shuffle the output.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TrainingSequence.Dispose();
    tuple_shuffle(HTuple.TupleGenSequence(0,(new HTuple(hv_TrainingImages.TupleLength()
        ))-1,1), out hv_TrainingSequence);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_TrainingImages = hv_TrainingImages.TupleSelect(
        hv_TrainingSequence);
    hv_TrainingImages.Dispose();
    hv_TrainingImages = ExpTmpLocalVar_TrainingImages;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_TrainingLabels = hv_TrainingLabels.TupleSelect(
        hv_TrainingSequence);
    hv_TrainingLabels.Dispose();
    hv_TrainingLabels = ExpTmpLocalVar_TrainingLabels;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ValidationSequence.Dispose();
    tuple_shuffle(HTuple.TupleGenSequence(0,(new HTuple(hv_ValidationImages.TupleLength()
        ))-1,1), out hv_ValidationSequence);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_ValidationImages = hv_ValidationImages.TupleSelect(
        hv_ValidationSequence);
    hv_ValidationImages.Dispose();
    hv_ValidationImages = ExpTmpLocalVar_ValidationImages;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_ValidationLabels = hv_ValidationLabels.TupleSelect(
        hv_ValidationSequence);
    hv_ValidationLabels.Dispose();
    hv_ValidationLabels = ExpTmpLocalVar_ValidationLabels;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TestSequence.Dispose();
    tuple_shuffle(HTuple.TupleGenSequence(0,(new HTuple(hv_TestImages.TupleLength()
        ))-1,1), out hv_TestSequence);
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_TestImages = hv_TestImages.TupleSelect(
        hv_TestSequence);
    hv_TestImages.Dispose();
    hv_TestImages = ExpTmpLocalVar_TestImages;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_TestLabels = hv_TestLabels.TupleSelect(
        hv_TestSequence);
    hv_TestLabels.Dispose();
    hv_TestLabels = ExpTmpLocalVar_TestLabels;
    }
    }

    hv_TrainingRatio.Dispose();
    hv_ValidationRatio.Dispose();
    hv_UniqueClasses.Dispose();
    hv_ClassIndex.Dispose();
    hv_Class.Dispose();
    hv_ClassIndices.Dispose();
    hv_ImageFilesClass.Dispose();
    hv_LabelsClass.Dispose();
    hv_IndexTrainingEnd.Dispose();
    hv_IndexValidationEnd.Dispose();
    hv_TrainingSequence.Dispose();
    hv_ValidationSequence.Dispose();
    hv_TestSequence.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Split the samples into training, validation, and test subsets. 
  public void split_dl_dataset (HTuple hv_DLDataset, HTuple hv_TrainingPercent, HTuple hv_ValidationPercent, 
      HTuple hv_GenParam)
  {



    // Local iconic variables 

    HObject ho_SegmImage=null;

    // Local control variables 

    HTuple hv_OverwriteSplit = new HTuple(), hv_SplitNames = new HTuple();
    HTuple hv_SegmDirExists = new HTuple(), hv_ModelType = new HTuple();
    HTuple hv_GenParamName = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_DLSamples = new HTuple(), hv_ClassIDs = new HTuple();
    HTuple hv_ClassNames = new HTuple(), hv_ClassIDToClassIndex = new HTuple();
    HTuple hv_TrainingRatio = new HTuple(), hv_ValidationRatio = new HTuple();
    HTuple hv_SplitRatios = new HTuple(), hv_SplitKeys = new HTuple();
    HTuple hv_IndexSample = new HTuple(), hv_SplitExists = new HTuple();
    HTuple hv_SampleSplit = new HTuple(), hv_NotYetSplit = new HTuple();
    HTuple hv_ImageIDsPerClass = new HTuple(), hv_ClassIndex = new HTuple();
    HTuple hv_NumImagesPerClass = new HTuple(), hv_ImageIDList = new HTuple();
    HTuple hv_DLSample = new HTuple(), hv_ImageID = new HTuple();
    HTuple hv_BboxLabels = new HTuple(), hv_Labels = new HTuple();
    HTuple hv_SegmDir = new HTuple(), hv_SegmFileName = new HTuple();
    HTuple hv_AbsoluteHisto = new HTuple(), hv_LabelIndices = new HTuple();
    HTuple hv_Index = new HTuple(), hv_ImgIDsClass = new HTuple();
    HTuple hv_SplitImageIDs = new HTuple(), hv_AssignedImageIDs = new HTuple();
    HTuple hv_ClassSortIndices = new HTuple(), hv_ImageIDsClass = new HTuple();
    HTuple hv_ImageIDsClassToBeAssigned = new HTuple(), hv_SplitIndex = new HTuple();
    HTuple hv_AssignedImageIDsToThisSplit = new HTuple(), hv_NumToBeAssignedToThisSplit = new HTuple();
    HTuple hv_NumAlreadyAssignedToThisSplit = new HTuple();
    HTuple hv_NumStillToBeAssigned = new HTuple(), hv_SplitRatiosInvSortIndices = new HTuple();
    HTuple hv_ImageIndex = new HTuple(), hv_Rand = new HTuple();
    HTuple hv_RatioIndex = new HTuple(), hv_CurrentSplitIndex = new HTuple();
    HTuple hv_CurrentSplitRatio = new HTuple(), hv_ImageIDsWithoutLabel = new HTuple();
    HTuple hv_NumImageIDsWithoutLabel = new HTuple(), hv_NumToBeAssigned = new HTuple();
    HTuple hv_MaxRatioIndex = new HTuple(), hv_SplitNameIndex = new HTuple();
    HTuple hv_SplitName = new HTuple(), hv_SplitIDs = new HTuple();
    HTuple hv_SplitIDIndex = new HTuple(), hv_SampleSplitIDs = new HTuple();
    HTuple hv_DLSampleIndex = new HTuple(), hv_ErrorDict = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmImage);
    //
    //This procedure divides the samples in DLDataset
    //into three disjoint subsets: train, validation, and test.
    //The number of samples in each subset is defined
    //by the given percentages TrainingPercent and ValidationPercent.
    //As a result, every sample has a new key named 'split'
    //with an associated value 'train', 'validation', or 'test'.
    //Thereby the classes of every image are taken
    //into consideration, in order to avoid accidental predominance
    //of certain classes in one of the subsets.
    //
    //Check input data.
    if ((int)(new HTuple(hv_TrainingPercent.TupleLess(0))) != 0)
    {
      throw new HalconException("TrainingPercent must not be smaller than zero.");
    }
    if ((int)(new HTuple(hv_ValidationPercent.TupleLess(0))) != 0)
    {
      throw new HalconException("ValidationPercent must not be smaller than zero.");
    }
    if ((int)(new HTuple(((hv_TrainingPercent+hv_ValidationPercent)).TupleGreater(
        100))) != 0)
    {
      throw new HalconException("The sum of TrainingPercent and ValidationPercent must not be greater than 100.");
    }
    //
    //** Set the default values ***
    //
    //Overwrite an existing split?
    hv_OverwriteSplit.Dispose();
    hv_OverwriteSplit = 0;
    //Names for split subsets.
    hv_SplitNames.Dispose();
    hv_SplitNames = new HTuple();
    hv_SplitNames[0] = "train";
    hv_SplitNames[1] = "validation";
    hv_SplitNames[2] = "test";
    //Try to guess the ModelType.
    hv_SegmDirExists.Dispose();
    HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "segmentation_dir", out hv_SegmDirExists);
    if ((int)(hv_SegmDirExists) != 0)
    {
      hv_ModelType.Dispose();
      hv_ModelType = "segmentation";
    }
    else
    {
      hv_ModelType.Dispose();
      hv_ModelType = "detection";
    }
    //
    //Get input for generic parameters.
    if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
    {
      hv_GenParamName.Dispose();
      HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamName);
      for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
          ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
      {
        if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "overwrite_split"))) != 0)
        {
          hv_OverwriteSplit.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "overwrite_split", out hv_OverwriteSplit);
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "model_type"))) != 0)
        {
          hv_ModelType.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "model_type", out hv_ModelType);
        }
        else
        {
          throw new HalconException("Unknown GenParam entry: "+(hv_GenParamName.TupleSelect(
              hv_GenParamIndex)));
        }
      }
    }
    //
    //Get data from DLDataset.
    hv_DLSamples.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
    hv_ClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
    hv_ClassNames.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "class_names", out hv_ClassNames);
    hv_ClassIDToClassIndex.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ClassIDToClassIndex = HTuple.TupleGenConst(
        (hv_ClassIDs.TupleMax())+1,-1);
    }
    if (hv_ClassIDToClassIndex == null)
      hv_ClassIDToClassIndex = new HTuple();
    hv_ClassIDToClassIndex[hv_ClassIDs] = HTuple.TupleGenSequence(0,(new HTuple(hv_ClassIDs.TupleLength()
        ))-1,1);
    //
    //Calculate ratios of training and validation datasets.
    hv_TrainingRatio.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TrainingRatio = hv_TrainingPercent*0.01;
    }
    hv_ValidationRatio.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ValidationRatio = hv_ValidationPercent*0.01;
    }
    hv_SplitRatios.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SplitRatios = new HTuple();
    hv_SplitRatios = hv_SplitRatios.TupleConcat(hv_TrainingRatio, hv_ValidationRatio);
    hv_SplitRatios = hv_SplitRatios.TupleConcat((1.0-hv_TrainingRatio)-hv_ValidationRatio);
    }
    //
    //Test whether the dataset is already split.
    hv_SplitKeys.Dispose();
    hv_SplitKeys = new HTuple();
    for (hv_IndexSample=0; (int)hv_IndexSample<=(int)((new HTuple(hv_DLSamples.TupleLength()
        ))-1); hv_IndexSample = (int)hv_IndexSample + 1)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SplitExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(hv_IndexSample), "key_exists", 
          "split", out hv_SplitExists);
      }
      if ((int)(hv_SplitExists) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SampleSplit.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_IndexSample), "split", 
            out hv_SampleSplit);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_SplitKeys = hv_SplitKeys.TupleConcat(
            hv_SampleSplit);
        hv_SplitKeys.Dispose();
        hv_SplitKeys = ExpTmpLocalVar_SplitKeys;
        }
        }
      }
    }
    hv_NotYetSplit.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NotYetSplit = new HTuple(hv_SplitKeys.TupleEqual(
        new HTuple()));
    }
    //
    //Split the dataset if no split is present
    //or split should be overwritten.
    if ((int)(hv_NotYetSplit.TupleOr(hv_OverwriteSplit)) != 0)
    {
      //
      //Initialize a dictionary to collect the IDs
      //of images that contain the class.
      hv_ImageIDsPerClass.Dispose();
      HOperatorSet.CreateDict(out hv_ImageIDsPerClass);
      for (hv_ClassIndex=0; (int)hv_ClassIndex<=(int)((new HTuple(hv_ClassNames.TupleLength()
          ))-1); hv_ClassIndex = (int)hv_ClassIndex + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_ImageIDsPerClass, hv_ClassNames.TupleSelect(
            hv_ClassIndex), new HTuple());
        }
      }
      //
      //Get labels of every sample image
      //and count how many images per class there are.
      //
      hv_NumImagesPerClass.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumImagesPerClass = HTuple.TupleGenConst(
          new HTuple(hv_ClassIDs.TupleLength()),0);
      }
      hv_ImageIDList.Dispose();
      hv_ImageIDList = new HTuple();
      for (hv_IndexSample=0; (int)hv_IndexSample<=(int)((new HTuple(hv_DLSamples.TupleLength()
          ))-1); hv_IndexSample = (int)hv_IndexSample + 1)
      {
        hv_DLSample.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DLSample = hv_DLSamples.TupleSelect(
            hv_IndexSample);
        }
        hv_ImageID.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageID);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ImageIDList = hv_ImageIDList.TupleConcat(
            hv_ImageID);
        hv_ImageIDList.Dispose();
        hv_ImageIDList = ExpTmpLocalVar_ImageIDList;
        }
        }
        if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
        {
          //Get labels - object detection.
          hv_BboxLabels.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
          hv_Labels.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Labels = ((hv_BboxLabels.TupleUniq()
              )).TupleSort();
          }
        }
        else
        {
          //Get labels - semantic segmentation.
          hv_SegmDir.Dispose();
          HOperatorSet.GetDictTuple(hv_DLDataset, "segmentation_dir", out hv_SegmDir);
          hv_SegmFileName.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSample, "segmentation_file_name", out hv_SegmFileName);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_SegmImage.Dispose();
          HOperatorSet.ReadImage(out ho_SegmImage, (hv_SegmDir+"/")+hv_SegmFileName);
          }
          //
          hv_AbsoluteHisto.Dispose();
          HOperatorSet.GrayHistoAbs(ho_SegmImage, ho_SegmImage, 1, out hv_AbsoluteHisto);
          hv_Labels.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Labels = ((hv_AbsoluteHisto.TupleGreaterElem(
              0))).TupleFind(1);
          }
        }
        //
        //Add up images per class.
        hv_LabelIndices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LabelIndices = hv_ClassIDToClassIndex.TupleSelect(
            hv_Labels);
        }
        if (hv_NumImagesPerClass == null)
          hv_NumImagesPerClass = new HTuple();
        hv_NumImagesPerClass[hv_LabelIndices] = (hv_NumImagesPerClass.TupleSelect(
            hv_LabelIndices))+1;
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Labels.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          //Add ImageIDs to ImageIDsPerClass.
          hv_ClassIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassIndex = hv_LabelIndices.TupleSelect(
              hv_Index);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImgIDsClass.Dispose();
          HOperatorSet.GetDictTuple(hv_ImageIDsPerClass, hv_ClassNames.TupleSelect(
              hv_ClassIndex), out hv_ImgIDsClass);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ImgIDsClass = hv_ImgIDsClass.TupleConcat(
              hv_ImageID);
          hv_ImgIDsClass.Dispose();
          hv_ImgIDsClass = ExpTmpLocalVar_ImgIDsClass;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_ImageIDsPerClass, hv_ClassNames.TupleSelect(
              hv_ClassIndex), hv_ImgIDsClass);
          }
        }
      }
      //
      //** Start splitting. ***
      //
      //Create a dictionary where the ImageIDs
      //for the three subsets are saved.
      hv_SplitImageIDs.Dispose();
      HOperatorSet.CreateDict(out hv_SplitImageIDs);
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_SplitNames.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(hv_Index), 
            new HTuple());
        }
      }
      //We split based on classes,
      //starting with the smallest class.
      hv_AssignedImageIDs.Dispose();
      hv_AssignedImageIDs = new HTuple();
      hv_ClassSortIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassSortIndices = hv_NumImagesPerClass.TupleSortIndex()
          ;
      }
      for (hv_ClassIndex=0; (int)hv_ClassIndex<=(int)((new HTuple(hv_NumImagesPerClass.TupleLength()
          ))-1); hv_ClassIndex = (int)hv_ClassIndex + 1)
      {
        //Get all ImageIDs where this class is present.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageIDsClass.Dispose();
        HOperatorSet.GetDictTuple(hv_ImageIDsPerClass, hv_ClassNames.TupleSelect(
            hv_ClassSortIndices.TupleSelect(hv_ClassIndex)), out hv_ImageIDsClass);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ImageIDsClass = hv_ImageIDsClass.TupleUniq()
            ;
        hv_ImageIDsClass.Dispose();
        hv_ImageIDsClass = ExpTmpLocalVar_ImageIDsClass;
        }
        }
        //Remove ImageIDs that have already been assigned.
        hv_ImageIDsClassToBeAssigned.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageIDsClassToBeAssigned = hv_ImageIDsClass.TupleDifference(
            hv_AssignedImageIDs);
        }
        {
        HTuple ExpTmpOutVar_0;
        tuple_shuffle(hv_ImageIDsClassToBeAssigned, out ExpTmpOutVar_0);
        hv_ImageIDsClassToBeAssigned.Dispose();
        hv_ImageIDsClassToBeAssigned = ExpTmpOutVar_0;
        }
        //
        for (hv_SplitIndex=0; (int)hv_SplitIndex<=(int)((new HTuple(hv_SplitNames.TupleLength()
            ))-1); hv_SplitIndex = (int)hv_SplitIndex + 1)
        {
          //Check how many of the IDs have already been assigned
          //and how many should be assigned.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AssignedImageIDsToThisSplit.Dispose();
          HOperatorSet.GetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(hv_SplitIndex), 
              out hv_AssignedImageIDsToThisSplit);
          }
          hv_NumToBeAssignedToThisSplit.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_NumToBeAssignedToThisSplit = (((((hv_SplitRatios.TupleSelect(
              hv_SplitIndex))*(new HTuple(hv_ImageIDsClass.TupleLength())))).TupleFloor()
              )).TupleInt();
          }
          hv_NumAlreadyAssignedToThisSplit.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_NumAlreadyAssignedToThisSplit = new HTuple(((hv_ImageIDsClass.TupleIntersection(
              hv_AssignedImageIDsToThisSplit))).TupleLength());
          }
          hv_NumStillToBeAssigned.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_NumStillToBeAssigned = hv_NumToBeAssignedToThisSplit-hv_NumAlreadyAssignedToThisSplit;
          }
          //
          if ((int)(new HTuple(hv_NumStillToBeAssigned.TupleGreater(0))) != 0)
          {
            if ((int)(new HTuple(hv_NumStillToBeAssigned.TupleGreater(new HTuple(hv_ImageIDsClassToBeAssigned.TupleLength()
                )))) != 0)
            {
              hv_NumStillToBeAssigned.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_NumStillToBeAssigned = new HTuple(hv_ImageIDsClassToBeAssigned.TupleLength()
                  );
              }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_AssignedImageIDsToThisSplit = hv_AssignedImageIDsToThisSplit.TupleConcat(
                hv_ImageIDsClassToBeAssigned.TupleSelectRange(0,hv_NumStillToBeAssigned-1));
            hv_AssignedImageIDsToThisSplit.Dispose();
            hv_AssignedImageIDsToThisSplit = ExpTmpLocalVar_AssignedImageIDsToThisSplit;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                hv_SplitIndex), hv_AssignedImageIDsToThisSplit);
            }
            //Update the remaining ImageIDs of this class.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ImageIDsClassToBeAssigned = hv_ImageIDsClassToBeAssigned.TupleSelectRange(
                hv_NumStillToBeAssigned,(new HTuple(hv_ImageIDsClassToBeAssigned.TupleLength()
                ))-1);
            hv_ImageIDsClassToBeAssigned.Dispose();
            hv_ImageIDsClassToBeAssigned = ExpTmpLocalVar_ImageIDsClassToBeAssigned;
            }
            }
          }
        }
        //The remaining ImageIDs are assigned to random subsets
        //according to the defined ratios.
        if ((int)(new HTuple((new HTuple(hv_ImageIDsClassToBeAssigned.TupleLength()
            )).TupleGreater(0))) != 0)
        {
          hv_SplitRatiosInvSortIndices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SplitRatiosInvSortIndices = (new HTuple(hv_SplitRatios.TupleSortIndex()
              )).TupleInverse();
          }
          for (hv_ImageIndex=0; (int)hv_ImageIndex<=(int)((new HTuple(hv_ImageIDsClassToBeAssigned.TupleLength()
              ))-1); hv_ImageIndex = (int)hv_ImageIndex + 1)
          {
            hv_Rand.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Rand = HTuple.TupleRand(
                1);
            }
            for (hv_RatioIndex=0; (int)hv_RatioIndex<=(int)((new HTuple(hv_SplitRatios.TupleLength()
                ))-1); hv_RatioIndex = (int)hv_RatioIndex + 1)
            {
              hv_CurrentSplitIndex.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_CurrentSplitIndex = hv_SplitRatiosInvSortIndices.TupleSelect(
                  hv_RatioIndex);
              }
              hv_CurrentSplitRatio.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_CurrentSplitRatio = hv_SplitRatios.TupleSelect(
                  hv_CurrentSplitIndex);
              }
              if ((int)(new HTuple(hv_Rand.TupleLessEqual(hv_CurrentSplitRatio))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_AssignedImageIDsToThisSplit.Dispose();
                HOperatorSet.GetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                    hv_CurrentSplitIndex), out hv_AssignedImageIDsToThisSplit);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_AssignedImageIDsToThisSplit = hv_AssignedImageIDsToThisSplit.TupleConcat(
                    hv_ImageIDsClassToBeAssigned.TupleSelect(hv_ImageIndex));
                hv_AssignedImageIDsToThisSplit.Dispose();
                hv_AssignedImageIDsToThisSplit = ExpTmpLocalVar_AssignedImageIDsToThisSplit;
                }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                    hv_CurrentSplitIndex), hv_AssignedImageIDsToThisSplit);
                }
                break;
              }
              else
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_Rand = hv_Rand-hv_CurrentSplitRatio;
                hv_Rand.Dispose();
                hv_Rand = ExpTmpLocalVar_Rand;
                }
                }
              }
            }
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_AssignedImageIDs = ((((hv_AssignedImageIDs.TupleConcat(
            hv_ImageIDsClass))).TupleUniq())).TupleSort();
        hv_AssignedImageIDs.Dispose();
        hv_AssignedImageIDs = ExpTmpLocalVar_AssignedImageIDs;
        }
        }
      }
      //
      //There might be images not having any labels:
      //Assign them based on the ratio.
      hv_ImageIDsWithoutLabel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageIDsWithoutLabel = hv_ImageIDList.TupleDifference(
          hv_AssignedImageIDs);
      }
      hv_NumImageIDsWithoutLabel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumImageIDsWithoutLabel = new HTuple(hv_ImageIDsWithoutLabel.TupleLength()
          );
      }
      if ((int)(new HTuple(hv_NumImageIDsWithoutLabel.TupleGreater(0))) != 0)
      {
        {
        HTuple ExpTmpOutVar_0;
        tuple_shuffle(hv_ImageIDsWithoutLabel, out ExpTmpOutVar_0);
        hv_ImageIDsWithoutLabel.Dispose();
        hv_ImageIDsWithoutLabel = ExpTmpOutVar_0;
        }
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_SplitRatios.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          hv_NumToBeAssigned.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_NumToBeAssigned = (((hv_SplitRatios.TupleSelect(
              hv_Index))*hv_NumImageIDsWithoutLabel)).TupleInt();
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AssignedImageIDsToThisSplit.Dispose();
          HOperatorSet.GetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(hv_Index), 
              out hv_AssignedImageIDsToThisSplit);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_AssignedImageIDsToThisSplit = hv_AssignedImageIDsToThisSplit.TupleConcat(
              hv_ImageIDsWithoutLabel.TupleSelectRange(0,hv_NumToBeAssigned-1));
          hv_AssignedImageIDsToThisSplit.Dispose();
          hv_AssignedImageIDsToThisSplit = ExpTmpLocalVar_AssignedImageIDsToThisSplit;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(hv_Index), 
              hv_AssignedImageIDsToThisSplit.TupleSort());
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ImageIDsWithoutLabel = hv_ImageIDsWithoutLabel.TupleSelectRange(
              hv_NumToBeAssigned,(new HTuple(hv_ImageIDsWithoutLabel.TupleLength()
              ))-1);
          hv_ImageIDsWithoutLabel.Dispose();
          hv_ImageIDsWithoutLabel = ExpTmpLocalVar_ImageIDsWithoutLabel;
          }
          }
        }
        //If there are still ImageIDs, assign them to split with highest ratio.
        hv_MaxRatioIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxRatioIndex = hv_SplitRatiosInvSortIndices.TupleFind(
            0);
        }
        if ((int)(new HTuple((new HTuple(hv_ImageIDsWithoutLabel.TupleLength())).TupleGreater(
            0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AssignedImageIDsToThisSplit.Dispose();
          HOperatorSet.GetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(hv_MaxRatioIndex), 
              out hv_AssignedImageIDsToThisSplit);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_AssignedImageIDsToThisSplit = hv_AssignedImageIDsToThisSplit.TupleConcat(
              hv_ImageIDsWithoutLabel);
          hv_AssignedImageIDsToThisSplit.Dispose();
          hv_AssignedImageIDsToThisSplit = ExpTmpLocalVar_AssignedImageIDsToThisSplit;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(hv_MaxRatioIndex), 
              hv_AssignedImageIDsToThisSplit.TupleSort());
          }
        }
      }
      //
      //Assign 'split' entries to samples.
      for (hv_SplitNameIndex=0; (int)hv_SplitNameIndex<=(int)((new HTuple(hv_SplitNames.TupleLength()
          ))-1); hv_SplitNameIndex = (int)hv_SplitNameIndex + 1)
      {
        hv_SplitName.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SplitName = hv_SplitNames.TupleSelect(
            hv_SplitNameIndex);
        }
        hv_SplitIDs.Dispose();
        HOperatorSet.GetDictTuple(hv_SplitImageIDs, hv_SplitName, out hv_SplitIDs);
        for (hv_SplitIDIndex=0; (int)hv_SplitIDIndex<=(int)((new HTuple(hv_SplitIDs.TupleLength()
            ))-1); hv_SplitIDIndex = (int)hv_SplitIDIndex + 1)
        {
          hv_SampleSplitIDs.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SampleSplitIDs = hv_SplitIDs.TupleSelect(
              hv_SplitIDIndex);
          }
          hv_DLSampleIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DLSampleIndex = hv_ImageIDList.TupleFind(
              hv_SampleSplitIDs);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_DLSamples.TupleSelect(hv_DLSampleIndex), "split", 
              hv_SplitName);
          }
        }
      }
    }
    else
    {
      hv_ErrorDict.Dispose();
      hv_ErrorDict = "The dataset is already split. You can overwrite the existing split using the generic parameter 'overwrite_split'.";
      throw new HalconException(hv_ErrorDict);
    }
    ho_SegmImage.Dispose();

    hv_OverwriteSplit.Dispose();
    hv_SplitNames.Dispose();
    hv_SegmDirExists.Dispose();
    hv_ModelType.Dispose();
    hv_GenParamName.Dispose();
    hv_GenParamIndex.Dispose();
    hv_DLSamples.Dispose();
    hv_ClassIDs.Dispose();
    hv_ClassNames.Dispose();
    hv_ClassIDToClassIndex.Dispose();
    hv_TrainingRatio.Dispose();
    hv_ValidationRatio.Dispose();
    hv_SplitRatios.Dispose();
    hv_SplitKeys.Dispose();
    hv_IndexSample.Dispose();
    hv_SplitExists.Dispose();
    hv_SampleSplit.Dispose();
    hv_NotYetSplit.Dispose();
    hv_ImageIDsPerClass.Dispose();
    hv_ClassIndex.Dispose();
    hv_NumImagesPerClass.Dispose();
    hv_ImageIDList.Dispose();
    hv_DLSample.Dispose();
    hv_ImageID.Dispose();
    hv_BboxLabels.Dispose();
    hv_Labels.Dispose();
    hv_SegmDir.Dispose();
    hv_SegmFileName.Dispose();
    hv_AbsoluteHisto.Dispose();
    hv_LabelIndices.Dispose();
    hv_Index.Dispose();
    hv_ImgIDsClass.Dispose();
    hv_SplitImageIDs.Dispose();
    hv_AssignedImageIDs.Dispose();
    hv_ClassSortIndices.Dispose();
    hv_ImageIDsClass.Dispose();
    hv_ImageIDsClassToBeAssigned.Dispose();
    hv_SplitIndex.Dispose();
    hv_AssignedImageIDsToThisSplit.Dispose();
    hv_NumToBeAssignedToThisSplit.Dispose();
    hv_NumAlreadyAssignedToThisSplit.Dispose();
    hv_NumStillToBeAssigned.Dispose();
    hv_SplitRatiosInvSortIndices.Dispose();
    hv_ImageIndex.Dispose();
    hv_Rand.Dispose();
    hv_RatioIndex.Dispose();
    hv_CurrentSplitIndex.Dispose();
    hv_CurrentSplitRatio.Dispose();
    hv_ImageIDsWithoutLabel.Dispose();
    hv_NumImageIDsWithoutLabel.Dispose();
    hv_NumToBeAssigned.Dispose();
    hv_MaxRatioIndex.Dispose();
    hv_SplitNameIndex.Dispose();
    hv_SplitName.Dispose();
    hv_SplitIDs.Dispose();
    hv_SplitIDIndex.Dispose();
    hv_SampleSplitIDs.Dispose();
    hv_DLSampleIndex.Dispose();
    hv_ErrorDict.Dispose();

    return;
  }

  // Chapter: Inspection / Structured Light
  // Short Description: Acquire images for the synchronization between the screen and the camera in a structured light setup. 
  public void structured_light_camera_screen_sync (out HObject ho_CameraImages, HTuple hv_AcqHandle, 
      HTuple hv_WindowHandle, HTuple hv_WindowWidth, HTuple hv_WindowHeight, HTuple hv_WaitSeconds, 
      out HTuple hv_ImagesPerSecond)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_VerticalStripes, ho_ScreenDomain;
    HObject ho_HorizontalStripes, ho_Image=null;

    // Local control variables 

    HTuple hv_NumLoops = new HTuple(), hv_ScrRows = new HTuple();
    HTuple hv_ScrColumns = new HTuple(), hv_Begin = new HTuple();
    HTuple hv_Index = new HTuple(), hv_End = new HTuple();
    HTuple hv_Time = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_CameraImages);
    HOperatorSet.GenEmptyObj(out ho_VerticalStripes);
    HOperatorSet.GenEmptyObj(out ho_ScreenDomain);
    HOperatorSet.GenEmptyObj(out ho_HorizontalStripes);
    HOperatorSet.GenEmptyObj(out ho_Image);
    hv_ImagesPerSecond = new HTuple();
    //This procedure helps to establish a synchonization between
    //the screen and the camera in a particular structured light setup.
    //An in-sync setup ensures accurate camera images that are captured
    //at exactly the right time.
    //These camera images show exactly one pattern image
    //each, rather than overlapping pattern images. If on the other
    //hand the camera and screen are not in sync, the captured camera
    //images will show overlap between two pattern images.
    //
    //Define the number of loops for the acquisition.
    hv_NumLoops.Dispose();
    hv_NumLoops = 10;
    //Generate test images:
    //Vertical stripe image.
    ho_VerticalStripes.Dispose();
    HOperatorSet.GenImageConst(out ho_VerticalStripes, "byte", hv_WindowWidth, hv_WindowHeight);
    ho_ScreenDomain.Dispose();
    HOperatorSet.GetDomain(ho_VerticalStripes, out ho_ScreenDomain);
    hv_ScrRows.Dispose();hv_ScrColumns.Dispose();
    HOperatorSet.GetRegionPoints(ho_ScreenDomain, out hv_ScrRows, out hv_ScrColumns);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetGrayval(ho_VerticalStripes, hv_ScrRows, hv_ScrColumns, ((hv_ScrColumns/80)%2)*255);
    }
    //Horizontal stripe image.
    ho_HorizontalStripes.Dispose();
    HOperatorSet.GenImageConst(out ho_HorizontalStripes, "byte", hv_WindowWidth, 
        hv_WindowHeight);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    HOperatorSet.SetGrayval(ho_HorizontalStripes, hv_ScrRows, hv_ScrColumns, ((hv_ScrRows/80)%2)*255);
    }
    //
    ho_CameraImages.Dispose();
    HOperatorSet.GenEmptyObj(out ho_CameraImages);
    hv_Begin.Dispose();
    HOperatorSet.CountSeconds(out hv_Begin);
    HTuple end_val23 = hv_NumLoops;
    HTuple step_val23 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val23, step_val23); hv_Index = hv_Index.TupleAdd(step_val23))
    {
      //Display the vertical stripes image.
      HOperatorSet.DispImage(ho_VerticalStripes, hv_WindowHandle);
      //Wait the specified time before acquiring the camera image.
      HOperatorSet.WaitSeconds(hv_WaitSeconds);
      ho_Image.Dispose();
      HOperatorSet.GrabImage(out ho_Image, hv_AcqHandle);
      //Add the acquired vertical image to the output.
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_CameraImages, ho_Image, out ExpTmpOutVar_0);
      ho_CameraImages.Dispose();
      ho_CameraImages = ExpTmpOutVar_0;
      }
      //
      //Display the horizontal stripe image.
      HOperatorSet.DispImage(ho_HorizontalStripes, hv_WindowHandle);
      //Wait the specified time before acquiring the camera image.
      HOperatorSet.WaitSeconds(hv_WaitSeconds);
      ho_Image.Dispose();
      HOperatorSet.GrabImage(out ho_Image, hv_AcqHandle);
      //Add the acquired horizontal image to the output.
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_CameraImages, ho_Image, out ExpTmpOutVar_0);
      ho_CameraImages.Dispose();
      ho_CameraImages = ExpTmpOutVar_0;
      }
    }
    hv_End.Dispose();
    HOperatorSet.CountSeconds(out hv_End);
    //
    //Acquisition time and acquired images per second.
    hv_Time.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Time = hv_End-hv_Begin;
    }
    hv_ImagesPerSecond.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ImagesPerSecond = (2*hv_NumLoops)/hv_Time;
    }
    //
    ho_VerticalStripes.Dispose();
    ho_ScreenDomain.Dispose();
    ho_HorizontalStripes.Dispose();
    ho_Image.Dispose();

    hv_NumLoops.Dispose();
    hv_ScrRows.Dispose();
    hv_ScrColumns.Dispose();
    hv_Begin.Dispose();
    hv_Index.Dispose();
    hv_End.Dispose();
    hv_Time.Dispose();

    return;
  }

  // Chapter: Inspection / Structured Light
  // Short Description: Visually inspect the Gray code images of a structured light model. 
  public void structured_light_inspect_segmentation (HObject ho_CameraImages, HObject ho_BinarizedImages, 
      HTuple hv_WindowHandle)
  {




    // Local iconic variables 

    HObject ho_CamImage=null, ho_BinImage=null;
    HObject ho_BrightRegion=null;

    // Local control variables 

    HTuple hv_NumCamera = new HTuple(), hv_NumBinarized = new HTuple();
    HTuple hv_Index = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_CamImage);
    HOperatorSet.GenEmptyObj(out ho_BinImage);
    HOperatorSet.GenEmptyObj(out ho_BrightRegion);
    //This procedure helps to validate the decoded bright/dark areas
    //in the Gray code images of a structured light model, in comparison
    //to the bright/dark areas in the camera images.
    //
    //The procedure can be thus used to find a suitable value for the
    //parameter min_gray_difference. Please note that being unable to
    //find a suitable value indicates that the actual decoding was wrong
    //since the decision whether a pixel is bright or dark was often
    //incorrect. In that sense, the procedure can also be used to decide
    //whether the surface is partially specular and the pattern_type
    //'single_stripe' should be used.
    //
    HDevWindowStack.SetActive(hv_WindowHandle);
    //Check that CameraImages and BinarizedImages have equal lengths.
    hv_NumCamera.Dispose();
    HOperatorSet.CountObj(ho_CameraImages, out hv_NumCamera);
    hv_NumBinarized.Dispose();
    HOperatorSet.CountObj(ho_BinarizedImages, out hv_NumBinarized);
    if ((int)(new HTuple(hv_NumCamera.TupleNotEqual(hv_NumBinarized))) != 0)
    {
      throw new HalconException("CameraImages and BinarizedImages do not have equal lengths.");
    }
    //
    //Visualize the decoded bright region(s) on each camera image.
    HTuple end_val21 = hv_NumCamera;
    HTuple step_val21 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val21, step_val21); hv_Index = hv_Index.TupleAdd(step_val21))
    {
      ho_CamImage.Dispose();
      HOperatorSet.SelectObj(ho_CameraImages, out ho_CamImage, hv_Index);
      ho_BinImage.Dispose();
      HOperatorSet.SelectObj(ho_BinarizedImages, out ho_BinImage, hv_Index);
      //The bright region in the binarized image is that with gray
      //value = 255.
      ho_BrightRegion.Dispose();
      HOperatorSet.Threshold(ho_BinImage, out ho_BrightRegion, 254, 255);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_CamImage, HDevWindowStack.GetActive());
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "#ff000010");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_BrightRegion, HDevWindowStack.GetActive());
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 1);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "#ff0000");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_BrightRegion, HDevWindowStack.GetActive());
      }
      //If the decoded bright region does not match the visible bright
      //areas on the camera image, try calling the procedure after
      //decoding with a different min_gray_difference value.
      //If no appropriate min_gray_difference value can be found, the
      //actual decode might be incorrect and not the segmentation.
      //In that case, the surface might be partially specular and
      //decoding with the pattern_type 'single_stripe' might correct
      //this effect.
      // stop(...); only in hdevelop
    }
    ho_CamImage.Dispose();
    ho_BinImage.Dispose();
    ho_BrightRegion.Dispose();

    hv_NumCamera.Dispose();
    hv_NumBinarized.Dispose();
    hv_Index.Dispose();

    return;
  }

  // Chapter: Classification / Misc
  // Short Description: Test procedure for custom features. 
  public void test_features (HTuple hv_FeatureNames)
  {



    // Local iconic variables 

    HObject ho_Image, ho_Region, ho_TestRegion=null;
    HObject ho_TestRegionSelected, ho_ObjectSelected=null;

    // Local control variables 

    HTuple hv_TestSuccessful = new HTuple(), hv_TestString = new HTuple();
    HTuple hv_Test = new HTuple(), hv_NumRegions = new HTuple();
    HTuple hv_AllFeatures = new HTuple(), hv_Index = new HTuple();
    HTuple hv_CurName = new HTuple(), hv_Lengths = new HTuple();
    HTuple hv_CurLength = new HTuple(), hv_Features = new HTuple();
    HTuple hv_SumLengths = new HTuple(), hv_Total = new HTuple();
    HTuple hv_I = new HTuple(), hv_Features2 = new HTuple();
    HTuple hv_J = new HTuple(), hv_Features1 = new HTuple();
    HTuple hv_CorrectOrder = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_TestRegion);
    HOperatorSet.GenEmptyObj(out ho_TestRegionSelected);
    HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
    //
    //Test procedure for custom features
    //
    //This procedure can be used to test, if custom features
    //implemented in get_custom_features comply with the
    //specifications of the calculate_feature_set library.
    //
    //In particular, the feature vector Feature, that is
    //calculated with calculate_feature must fulfil
    //following conditions:
    //
    //- For a single input region the result of
    //  get_feature_length has to be equal to the length
    //  of the featue vector: |Feature| == Length
    //
    //- For an empty input region array, the feature
    //  vector has to be empty:
    //  Feature == []
    //
    //- For input region arrays with multiple regions, the
    //  following condition must be met:
    //  |Feature| == NumRegions * Length
    //
    //- Additionally, the feature vector has to be sorted
    //  according to the 'feature_column' order of
    //  add_sample_class_train_data.
    //
    hv_TestSuccessful.Dispose();
    hv_TestSuccessful = 0;
    ho_Image.Dispose();
    HOperatorSet.ReadImage(out ho_Image, "patras");
    ho_Region.Dispose();
    HOperatorSet.Threshold(ho_Image, out ho_Region, 128, 255);
    hv_Lengths.Dispose();
    get_feature_lengths(hv_FeatureNames, out hv_Lengths);
    //
    if (hv_TestString == null)
      hv_TestString = new HTuple();
    hv_TestString[0] = "Empty region array test (no region)";
    if (hv_TestString == null)
      hv_TestString = new HTuple();
    hv_TestString[1] = "Empty region test";
    if (hv_TestString == null)
      hv_TestString = new HTuple();
    hv_TestString[2] = "Single region test";
    for (hv_Test=0; (int)hv_Test<=2; hv_Test = (int)hv_Test + 1)
    {
      switch (hv_Test.I)
      {
      case 0:
        ho_TestRegion.Dispose();
        HOperatorSet.SelectShape(ho_Region, out ho_TestRegion, "area", "and", 0, 
            0);
        break;
      case 1:
        ho_TestRegion.Dispose();
        HOperatorSet.GenEmptyRegion(out ho_TestRegion);
        break;
      case 2:
        ho_TestRegion.Dispose();
        HOperatorSet.CopyObj(ho_Region, out ho_TestRegion, 1, 1);
        break;
      default:
        break;
      }
      hv_NumRegions.Dispose();
      HOperatorSet.CountObj(ho_TestRegion, out hv_NumRegions);
      hv_AllFeatures.Dispose();
      hv_AllFeatures = new HTuple();
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_FeatureNames.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        hv_CurName.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurName = hv_FeatureNames.TupleSelect(
            hv_Index);
        }
        hv_CurLength.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurLength = hv_Lengths.TupleSelect(
            hv_Index);
        }
        hv_Features.Dispose();
        calculate_features(ho_TestRegion, ho_Image, hv_CurName, out hv_Features);
        if ((int)(new HTuple(((hv_NumRegions*hv_CurLength)).TupleNotEqual(new HTuple(hv_Features.TupleLength()
            )))) != 0)
        {
          throw new HalconException((((hv_TestString.TupleSelect(
              hv_Test))+" failed for feature '")+hv_CurName)+"'");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_AllFeatures = hv_AllFeatures.TupleConcat(
            hv_Features);
        hv_AllFeatures.Dispose();
        hv_AllFeatures = ExpTmpLocalVar_AllFeatures;
        }
        }
      }
      hv_SumLengths.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SumLengths = hv_Lengths.TupleSum()
          ;
      }
      hv_Total.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Total = hv_SumLengths*hv_NumRegions;
      }
      if ((int)(new HTuple(hv_Total.TupleNotEqual(new HTuple(hv_AllFeatures.TupleLength()
          )))) != 0)
      {
        throw new HalconException(((("Test "+hv_Test)+" failed")).TupleConcat(
            hv_TestString.TupleSelect(hv_Test)));
      }
    }
    //
    //Test multiple input regions
    ho_TestRegion.Dispose();
    HOperatorSet.Connection(ho_Region, out ho_TestRegion);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    ho_TestRegionSelected.Dispose();
    HOperatorSet.SelectObj(ho_TestRegion, out ho_TestRegionSelected, HTuple.TupleGenSequence(
        1,3,1));
    }
    for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_FeatureNames.TupleLength()))-1); hv_I = (int)hv_I + 1)
    {
      hv_CurName.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurName = hv_FeatureNames.TupleSelect(
          hv_I);
      }
      hv_Features1.Dispose();
      calculate_features(ho_TestRegionSelected, ho_Image, hv_CurName, out hv_Features1);
      hv_Features2.Dispose();
      hv_Features2 = new HTuple();
      hv_NumRegions.Dispose();
      HOperatorSet.CountObj(ho_TestRegionSelected, out hv_NumRegions);
      HTuple end_val74 = hv_NumRegions;
      HTuple step_val74 = 1;
      for (hv_J=1; hv_J.Continue(end_val74, step_val74); hv_J = hv_J.TupleAdd(step_val74))
      {
        ho_ObjectSelected.Dispose();
        HOperatorSet.SelectObj(ho_TestRegionSelected, out ho_ObjectSelected, hv_J);
        hv_Features.Dispose();
        calculate_features(ho_ObjectSelected, ho_Image, hv_CurName, out hv_Features);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Features2 = hv_Features2.TupleConcat(
            hv_Features);
        hv_Features2.Dispose();
        hv_Features2 = ExpTmpLocalVar_Features2;
        }
        }
      }
      hv_CorrectOrder.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CorrectOrder = new HTuple(hv_Features1.TupleEqual(
          hv_Features2));
      }
      if ((int)(hv_CorrectOrder.TupleNot()) != 0)
      {
        throw new HalconException(("Multiple region test failed for feature '"+hv_CurName)+"'");
      }
    }
    hv_TestSuccessful.Dispose();
    hv_TestSuccessful = 1;
    ho_Image.Dispose();
    ho_Region.Dispose();
    ho_TestRegion.Dispose();
    ho_TestRegionSelected.Dispose();
    ho_ObjectSelected.Dispose();

    hv_TestSuccessful.Dispose();
    hv_TestString.Dispose();
    hv_Test.Dispose();
    hv_NumRegions.Dispose();
    hv_AllFeatures.Dispose();
    hv_Index.Dispose();
    hv_CurName.Dispose();
    hv_Lengths.Dispose();
    hv_CurLength.Dispose();
    hv_Features.Dispose();
    hv_SumLengths.Dispose();
    hv_Total.Dispose();
    hv_I.Dispose();
    hv_Features2.Dispose();
    hv_J.Dispose();
    hv_Features1.Dispose();
    hv_CorrectOrder.Dispose();

    return;
  }

  // Chapter: Time
  // Short Description: Create a formatted string of a time span. 
  public void timespan_string (HTuple hv_TotalSeconds, HTuple hv_Format, out HTuple hv_TimeString)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Seconds = new HTuple(), hv_TotalMinutes = new HTuple();
    HTuple hv_Minutes = new HTuple(), hv_TotalHours = new HTuple();
    HTuple hv_Hours = new HTuple(), hv_Days = new HTuple();
    HTuple   hv_TotalSeconds_COPY_INP_TMP = new HTuple(hv_TotalSeconds);

    // Initialize local and output iconic variables 
    hv_TimeString = new HTuple();
    //
    //This procedure creates a readable representation of a time span
    //given the elapsed time in seconds.
    //
    //Ensure that the input is an integer.
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_TotalSeconds = hv_TotalSeconds_COPY_INP_TMP.TupleInt()
        ;
    hv_TotalSeconds_COPY_INP_TMP.Dispose();
    hv_TotalSeconds_COPY_INP_TMP = ExpTmpLocalVar_TotalSeconds;
    }
    }
    //
    hv_Seconds.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Seconds = hv_TotalSeconds_COPY_INP_TMP%60;
    }
    //
    hv_TotalMinutes.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TotalMinutes = hv_TotalSeconds_COPY_INP_TMP/60;
    }
    hv_Minutes.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Minutes = hv_TotalMinutes%60;
    }
    //
    hv_TotalHours.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_TotalHours = hv_TotalSeconds_COPY_INP_TMP/3600;
    }
    hv_Hours.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Hours = hv_TotalHours%24;
    }
    //
    hv_Days.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Days = hv_TotalSeconds_COPY_INP_TMP/86400;
    }
    //
    if ((int)(new HTuple(hv_Format.TupleEqual("auto"))) != 0)
    {
      //Print the highest non-zero unit and all remaining sub-units.
      if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (((((((hv_Days.TupleString(
            "d"))+"d ")+(hv_Hours.TupleString("d")))+"h ")+(hv_Minutes.TupleString(
            "d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
        }
      }
      else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (((((hv_Hours.TupleString(
            "d"))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString(
            "d")))+"s";
        }
      }
      else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (((hv_Minutes.TupleString(
            "d"))+"m ")+(hv_Seconds.TupleString("d")))+"s";
        }
      }
      else
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (hv_Seconds.TupleString(
            "d"))+"s";
        }
      }
    }
    else if ((int)(new HTuple(hv_Format.TupleEqual("top1"))) != 0)
    {
      //Print the highest non-zero unit.
      if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (hv_Days.TupleString(
            "d"))+"d";
        }
      }
      else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (hv_Hours.TupleString(
            "d"))+"h";
        }
      }
      else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (hv_Minutes.TupleString(
            "d"))+"m";
        }
      }
      else
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (hv_Seconds.TupleString(
            "d"))+"s";
        }
      }
    }
    else if ((int)(new HTuple(hv_Format.TupleEqual("top2"))) != 0)
    {
      //Print the highest non-zero unit and the following sub-unit.
      if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (((hv_Days.TupleString(
            "d"))+"d ")+(hv_Hours.TupleString("d")))+"h";
        }
      }
      else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (((hv_Hours.TupleString(
            "d"))+"h ")+(hv_Minutes.TupleString("d")))+"m";
        }
      }
      else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (((hv_Minutes.TupleString(
            "d"))+"m ")+(hv_Seconds.TupleString("d")))+"s";
        }
      }
      else
      {
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (hv_Seconds.TupleString(
            "d"))+"s";
        }
      }
    }
    else if ((int)(new HTuple(hv_Format.TupleEqual("dhms"))) != 0)
    {
      //Print a Days-Hours-Minutes-Seconds string.
      hv_TimeString.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TimeString = (((((((hv_Days.TupleString(
          "d"))+"d ")+(hv_Hours.TupleString("d")))+"h ")+(hv_Minutes.TupleString(
          "d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
      }
    }
    else if ((int)(new HTuple(hv_Format.TupleEqual("hms"))) != 0)
    {
      //Print a Hours-Minutes-Seconds string, where hours can be >= 24.
      hv_TimeString.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TimeString = (((((hv_TotalHours.TupleString(
          "d"))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString(
          "d")))+"s";
      }
    }
    else
    {
      throw new HalconException("Unknown format string.");
    }
    //

    hv_TotalSeconds_COPY_INP_TMP.Dispose();
    hv_Seconds.Dispose();
    hv_TotalMinutes.Dispose();
    hv_Minutes.Dispose();
    hv_TotalHours.Dispose();
    hv_Hours.Dispose();
    hv_Days.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Compute the 3D rotation from the mouse movement 
  public void trackball (HTuple hv_MX1, HTuple hv_MY1, HTuple hv_MX2, HTuple hv_MY2, 
      HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SensFactor, out HTuple hv_QuatRotation)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_P1 = new HTuple(), hv_P2 = new HTuple();
    HTuple hv_RotAxis = new HTuple(), hv_D = new HTuple();
    HTuple hv_T = new HTuple(), hv_RotAngle = new HTuple();
    HTuple hv_Len = new HTuple();
    // Initialize local and output iconic variables 
    hv_QuatRotation = new HTuple();
    //
    //Compute the 3D rotation from the mouse movement
    //
    if ((int)((new HTuple(hv_MX1.TupleEqual(hv_MX2))).TupleAnd(new HTuple(hv_MY1.TupleEqual(
        hv_MY2)))) != 0)
    {
      hv_QuatRotation.Dispose();
      hv_QuatRotation = new HTuple();
      hv_QuatRotation[0] = 1;
      hv_QuatRotation[1] = 0;
      hv_QuatRotation[2] = 0;
      hv_QuatRotation[3] = 0;

      hv_P1.Dispose();
      hv_P2.Dispose();
      hv_RotAxis.Dispose();
      hv_D.Dispose();
      hv_T.Dispose();
      hv_RotAngle.Dispose();
      hv_Len.Dispose();

      return;
    }
    //Project the image point onto the trackball
    hv_P1.Dispose();
    project_point_on_trackball(hv_MX1, hv_MY1, hv_VirtualTrackball, hv_TrackballSize, 
        out hv_P1);
    hv_P2.Dispose();
    project_point_on_trackball(hv_MX2, hv_MY2, hv_VirtualTrackball, hv_TrackballSize, 
        out hv_P2);
    //The cross product of the projected points defines the rotation axis
    hv_RotAxis.Dispose();
    tuple_vector_cross_product(hv_P1, hv_P2, out hv_RotAxis);
    //Compute the rotation angle
    hv_D.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_D = hv_P2-hv_P1;
    }
    hv_T.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_T = (((((hv_D*hv_D)).TupleSum()
        )).TupleSqrt())/(2.0*hv_TrackballSize);
    }
    if ((int)(new HTuple(hv_T.TupleGreater(1.0))) != 0)
    {
      hv_T.Dispose();
      hv_T = 1.0;
    }
    if ((int)(new HTuple(hv_T.TupleLess(-1.0))) != 0)
    {
      hv_T.Dispose();
      hv_T = -1.0;
    }
    hv_RotAngle.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RotAngle = (2.0*(hv_T.TupleAsin()
        ))*hv_SensFactor;
    }
    hv_Len.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Len = ((((hv_RotAxis*hv_RotAxis)).TupleSum()
        )).TupleSqrt();
    }
    if ((int)(new HTuple(hv_Len.TupleGreater(0.0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_RotAxis = hv_RotAxis/hv_Len;
      hv_RotAxis.Dispose();
      hv_RotAxis = ExpTmpLocalVar_RotAxis;
      }
      }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QuatRotation.Dispose();
    HOperatorSet.AxisAngleToQuat(hv_RotAxis.TupleSelect(0), hv_RotAxis.TupleSelect(
        1), hv_RotAxis.TupleSelect(2), hv_RotAngle, out hv_QuatRotation);
    }

    hv_P1.Dispose();
    hv_P2.Dispose();
    hv_RotAxis.Dispose();
    hv_D.Dispose();
    hv_T.Dispose();
    hv_RotAngle.Dispose();
    hv_Len.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Compute the 3D rotation from the mouse movement 
  public void trackball_visualize_object_model_3d (HTuple hv_MX1, HTuple hv_MY1, 
      HTuple hv_MX2, HTuple hv_MY2, HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, 
      HTuple hv_SensFactor, out HTuple hv_QuatRotation)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_P1 = new HTuple(), hv_P2 = new HTuple();
    HTuple hv_RotAxis = new HTuple(), hv_D = new HTuple();
    HTuple hv_T = new HTuple(), hv_RotAngle = new HTuple();
    HTuple hv_Len = new HTuple();
    // Initialize local and output iconic variables 
    hv_QuatRotation = new HTuple();
    //
    //Compute the 3D rotation from the mouse movement
    //
    if ((int)((new HTuple(hv_MX1.TupleEqual(hv_MX2))).TupleAnd(new HTuple(hv_MY1.TupleEqual(
        hv_MY2)))) != 0)
    {
      hv_QuatRotation.Dispose();
      hv_QuatRotation = new HTuple();
      hv_QuatRotation[0] = 1;
      hv_QuatRotation[1] = 0;
      hv_QuatRotation[2] = 0;
      hv_QuatRotation[3] = 0;

      hv_P1.Dispose();
      hv_P2.Dispose();
      hv_RotAxis.Dispose();
      hv_D.Dispose();
      hv_T.Dispose();
      hv_RotAngle.Dispose();
      hv_Len.Dispose();

      return;
    }
    //Project the image point onto the trackball
    hv_P1.Dispose();
    project_point_on_trackball_visualize_object_model_3d(hv_MX1, hv_MY1, hv_VirtualTrackball, 
        hv_TrackballSize, out hv_P1);
    hv_P2.Dispose();
    project_point_on_trackball_visualize_object_model_3d(hv_MX2, hv_MY2, hv_VirtualTrackball, 
        hv_TrackballSize, out hv_P2);
    //The cross product of the projected points defines the rotation axis
    hv_RotAxis.Dispose();
    tuple_vector_cross_product(hv_P1, hv_P2, out hv_RotAxis);
    //Compute the rotation angle
    hv_D.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_D = hv_P2-hv_P1;
    }
    hv_T.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_T = (((((hv_D*hv_D)).TupleSum()
        )).TupleSqrt())/(2.0*hv_TrackballSize);
    }
    if ((int)(new HTuple(hv_T.TupleGreater(1.0))) != 0)
    {
      hv_T.Dispose();
      hv_T = 1.0;
    }
    if ((int)(new HTuple(hv_T.TupleLess(-1.0))) != 0)
    {
      hv_T.Dispose();
      hv_T = -1.0;
    }
    hv_RotAngle.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_RotAngle = (2.0*(hv_T.TupleAsin()
        ))*hv_SensFactor;
    }
    hv_Len.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_Len = ((((hv_RotAxis*hv_RotAxis)).TupleSum()
        )).TupleSqrt();
    }
    if ((int)(new HTuple(hv_Len.TupleGreater(0.0))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_RotAxis = hv_RotAxis/hv_Len;
      hv_RotAxis.Dispose();
      hv_RotAxis = ExpTmpLocalVar_RotAxis;
      }
      }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_QuatRotation.Dispose();
    HOperatorSet.AxisAngleToQuat(hv_RotAxis.TupleSelect(0), hv_RotAxis.TupleSelect(
        1), hv_RotAxis.TupleSelect(2), hv_RotAngle, out hv_QuatRotation);
    }

    hv_P1.Dispose();
    hv_P2.Dispose();
    hv_RotAxis.Dispose();
    hv_D.Dispose();
    hv_T.Dispose();
    hv_RotAngle.Dispose();
    hv_Len.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Train a deep-learning-based model on a dataset. 
  public void train_dl_model (HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_TrainParam, 
      HTuple hv_StartEpoch, out HTuple hv_TrainResults, out HTuple hv_TrainInfos, 
      out HTuple hv_EvaluationInfos)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DLSamples = new HTuple(), hv_SampleIndices = new HTuple();
    HTuple hv_NumTrainSamples = new HTuple(), hv_SeedRand = new HTuple();
    HTuple hv_NumEpochs = new HTuple(), hv_SampleIndicesTrainRaw = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Shuffled = new HTuple();
    HTuple hv_SampleSeedsTrainRaw = new HTuple(), hv_BatchSize = new HTuple();
    HTuple hv_ChangeStrategyData = new HTuple(), hv_SerializationData = new HTuple();
    HTuple hv_DisplayData = new HTuple(), hv_DisplayEnabled = new HTuple();
    HTuple hv_DisplayLossEpochs = new HTuple(), hv_DisplayLoss = new HTuple();
    HTuple hv_DisplayEvaluationEpochs = new HTuple(), hv_DisplayEvaluationValues = new HTuple();
    HTuple hv_DisplayPreviewInitialized = new HTuple(), hv_StartTime = new HTuple();
    HTuple hv_FirstIteration = new HTuple(), hv_Epoch = new HTuple();
    HTuple hv_Iteration = new HTuple(), hv_NumIterationsPerEpoch = new HTuple();
    HTuple hv_BatchSizeModel = new HTuple(), hv_NumIterations = new HTuple();
    HTuple hv_SampleIndicesTrain = new HTuple(), hv_BatchStart = new HTuple();
    HTuple hv_BatchEnd = new HTuple(), hv_BatchIndices = new HTuple();
    HTuple hv_AugmentationParam = new HTuple(), hv_TrainResult = new HTuple();
    HTuple hv_DisplayParam = new HTuple(), hv_TrainInfoUpdateIntervalSeconds = new HTuple();
    HTuple hv_LastUpdate = new HTuple(), hv_Seconds = new HTuple();
    HTuple hv_EvaluationComparisonKeys = new HTuple(), hv_NumSamplesMeanLoss = new HTuple();
    HTuple hv_TrainInfo = new HTuple(), hv_EpochsStatus = new HTuple();
    HTuple hv_MeanLoss = new HTuple(), hv_UpdateImagesIntervalEpochs = new HTuple();
    HTuple hv_UpdateImagesInterval = new HTuple(), hv_WindowImages = new HTuple();
    HTuple hv_FirstCall = new HTuple(), hv_NumImages = new HTuple();
    HTuple hv_GenParam = new HTuple(), hv_EvaluationIntervalEpochs = new HTuple();
    HTuple hv_EvaluationInterval = new HTuple(), hv_EvaluationResult = new HTuple();
    HTuple hv_EvaluationParam = new HTuple(), hv_GeneratedEvaluationParam = new HTuple();
    HTuple hv_EvaluationInfo = new HTuple(), hv_Value = new HTuple();
    HTuple hv_ValidEvaluationKeys = new HTuple();
    // Initialize local and output iconic variables 
    hv_TrainResults = new HTuple();
    hv_TrainInfos = new HTuple();
    hv_EvaluationInfos = new HTuple();
    //
    //This procedure contains all steps for training a model given through DLModelHandle
    //on a dataset DLDataset.
    //The required training parameters are provided through the dictionary TrainParam,
    //which can be created by create_dl_train_param.
    //The training is started at StartEpoch, which allows resuming the training of a model.
    //
    //The procedure returns three dictionaries:
    //- TrainResults: Collected results returned by train_dl_model_batch of every iteration.
    //- TrainInfo: Collected information of the training progress.
    //- EvaluationInfos: Evaluation results collected during training.
    //
    //Get the samples for training.
    hv_DLSamples.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
    hv_SampleIndices.Dispose();
    find_dl_samples(hv_DLSamples, "split", "train", "match", out hv_SampleIndices);
    hv_NumTrainSamples.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumTrainSamples = new HTuple(hv_SampleIndices.TupleLength()
        );
    }
    //
    //Check inconsistent training parameters.
    check_train_dl_model_params(hv_DLDataset, hv_DLModelHandle, hv_NumTrainSamples, 
        hv_StartEpoch, hv_TrainParam);
    //
    //Set random seed according to parameter value.
    hv_SeedRand.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainParam, "seed_rand", out hv_SeedRand);
    if ((int)(new HTuple((new HTuple(hv_SeedRand.TupleLength())).TupleGreater(0))) != 0)
    {
      //Note, that setting this random seed will not enforce every training to
      //result in the exact same model because the cuDNN library uses approximate
      //algorithms on some architectures.
      //If you want to enforce bit-wise reproducibility, you should also set:
      //   'set_system('cudnn_deterministic', 'true')'
      //However, this can slow down computations on some architectures.
      HOperatorSet.SetSystem("seed_rand", hv_SeedRand);
    }
    //
    //Generate a random sample index for the whole training independent of batch size.
    hv_NumEpochs.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainParam, "num_epochs", out hv_NumEpochs);
    hv_SampleIndicesTrainRaw.Dispose();
    hv_SampleIndicesTrainRaw = new HTuple();
    HTuple end_val35 = (hv_NumEpochs.TupleCeil()
        )-1;
    HTuple step_val35 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val35, step_val35); hv_Index = hv_Index.TupleAdd(step_val35))
    {
      hv_Shuffled.Dispose();
      tuple_shuffle(hv_SampleIndices, out hv_Shuffled);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_SampleIndicesTrainRaw = hv_SampleIndicesTrainRaw.TupleConcat(
          hv_Shuffled);
      hv_SampleIndicesTrainRaw.Dispose();
      hv_SampleIndicesTrainRaw = ExpTmpLocalVar_SampleIndicesTrainRaw;
      }
      }
    }
    //
    //Generate a random seed pool for the whole training independent of batch size.
    hv_SampleSeedsTrainRaw.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SampleSeedsTrainRaw = (new HTuple((((new HTuple(2)).TuplePow(
        31))-1)*HTuple.TupleRand(new HTuple(hv_SampleIndicesTrainRaw.TupleLength()
        )))).TupleInt();
    }
    //
    //Initialize the variables for the training.
    //
    //Initialize the batch size with an invalid value so that
    //the while loop will initialize all values directly.
    hv_BatchSize.Dispose();
    hv_BatchSize = -1;
    //
    //Initialize the variable to collect all training results during training.
    hv_TrainResults.Dispose();
    hv_TrainResults = new HTuple();
    //
    //Initialize the variable to collect the evaluation information during training.
    hv_EvaluationInfos.Dispose();
    hv_EvaluationInfos = new HTuple();
    //
    //Initialize the variable to collect the train status information during training.
    hv_TrainInfos.Dispose();
    hv_TrainInfos = new HTuple();
    //
    //Initialize change strategies.
    hv_ChangeStrategyData.Dispose();
    init_train_dl_model_change_strategies(hv_TrainParam, out hv_ChangeStrategyData);
    //
    //Initialize serialization strategies.
    hv_SerializationData.Dispose();
    init_train_dl_model_serialization_strategies(hv_TrainParam, out hv_SerializationData);
    //
    //Initialize visualizations if enabled.
    hv_DisplayData.Dispose();
    dev_display_init_train_dl_model(hv_DLModelHandle, hv_TrainParam, out hv_DisplayData);
    hv_DisplayEnabled.Dispose();
    HOperatorSet.GetDictTuple(hv_DisplayData, "enabled", out hv_DisplayEnabled);
    //The following variables are also used for visualization during training.
    if ((int)(hv_DisplayEnabled) != 0)
    {
      hv_DisplayLossEpochs.Dispose();
      hv_DisplayLossEpochs = new HTuple();
      hv_DisplayLoss.Dispose();
      hv_DisplayLoss = new HTuple();
      hv_DisplayEvaluationEpochs.Dispose();
      hv_DisplayEvaluationEpochs = new HTuple();
      hv_DisplayEvaluationValues.Dispose();
      hv_DisplayEvaluationValues = new HTuple();
      hv_DisplayPreviewInitialized.Dispose();
      hv_DisplayPreviewInitialized = 0;
    }
    //
    //Start time for measurement of elapsed training time.
    hv_StartTime.Dispose();
    HOperatorSet.CountSeconds(out hv_StartTime);
    //
    //The while loop needs to know if it is the very first iteration.
    hv_FirstIteration.Dispose();
    hv_FirstIteration = 1;
    while ((int)(1) != 0)
    {
      //Do some initializations only for the very first iteration.
      if ((int)(hv_FirstIteration) != 0)
      {
        //Jump to StartEpoch (Default: 0 but it could be used to resume training at given StartIteration).
        hv_Epoch.Dispose();
        hv_Epoch = new HTuple(hv_StartEpoch);
      }
      else
      {
        hv_Epoch.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Epoch = (hv_Iteration+1)/(hv_NumIterationsPerEpoch.TupleReal()
            );
        }
      }
      //
      //Update any parameters based on strategies.
      update_train_dl_model_change_strategies(hv_DLModelHandle, hv_ChangeStrategyData, 
          hv_Epoch);
      //
      //Check if the current batch size and model batch size differ.
      hv_BatchSizeModel.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSizeModel);
      //
      if ((int)((new HTuple(hv_BatchSize.TupleNotEqual(hv_BatchSizeModel))).TupleOr(
          hv_FirstIteration)) != 0)
      {
        //Set the current value.
        hv_BatchSize.Dispose();
        hv_BatchSize = new HTuple(hv_BatchSizeModel);
        //Now, we compute all values which are related to the batch size of the model.
        //That way, the batch_size can be changed during the training without issues.
        //All inputs/outputs/visualizations are based on epochs.
        //
        //Calculate total number of iterations.
        hv_NumIterationsPerEpoch.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumIterationsPerEpoch = ((((hv_NumTrainSamples/(hv_BatchSize.TupleReal()
            ))).TupleFloor())).TupleInt();
        }
        hv_NumIterations.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumIterations = ((hv_NumIterationsPerEpoch*hv_NumEpochs)).TupleInt()
            ;
        }
        //Select those indices that fit into the batch size.
        hv_SampleIndicesTrain.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SampleIndicesTrain = hv_SampleIndicesTrainRaw.TupleSelectRange(
            0,(hv_NumIterations*hv_BatchSize)-1);
        }
        //The TrainResults tuple will be updated every iteration.
        //Hence, we initialize it as a constant tuple for speedup.
        //It is based on the iterations and hence cannot be reused if the batch size changes.
        hv_TrainResults.Dispose();
        HOperatorSet.TupleGenConst(hv_NumIterations, -1, out hv_TrainResults);
        if ((int)(hv_FirstIteration.TupleNot()) != 0)
        {
          hv_Iteration.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Iteration = (((((hv_Epoch.TupleReal()
              )*hv_NumIterationsPerEpoch)).TupleFloor())).TupleInt();
          }
          hv_Epoch.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Epoch = (hv_Iteration+1)/(hv_NumIterationsPerEpoch.TupleReal()
              );
          }
        }
      }
      //
      //In the first iteration do some initializations.
      if ((int)(hv_FirstIteration) != 0)
      {
        //Jump to StartEpoch (Default: 0 but it could be used to resume training at given StartIteration).
        hv_Iteration.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Iteration = (((((hv_StartEpoch.TupleReal()
            )*hv_NumIterationsPerEpoch)).TupleFloor())).TupleInt();
        }
        hv_FirstIteration.Dispose();
        hv_FirstIteration = 0;
        if ((int)(new HTuple((((hv_Iteration*hv_BatchSize)+hv_BatchSize)).TupleGreater(
            new HTuple(hv_SampleIndicesTrain.TupleLength())))) != 0)
        {
          hv_Iteration.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Iteration = hv_NumIterations-1;
          }
          break;
        }
      }
      //
      //Generate the sample batch indices.
      hv_BatchStart.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BatchStart = hv_Iteration*hv_BatchSize;
      }
      hv_BatchEnd.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BatchEnd = (hv_BatchStart+hv_BatchSize)-1;
      }
      hv_BatchIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BatchIndices = hv_SampleIndicesTrain.TupleSelectRange(
          hv_BatchStart,hv_BatchEnd);
      }
      //
      //Set a random seed for the sample batch.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetSystem("seed_rand", hv_SampleSeedsTrainRaw.TupleSelect(hv_BatchEnd));
      }
      //
      //Read preprocessed samples.
      hv_DLSamples.Dispose();
      read_dl_samples(hv_DLDataset, hv_BatchIndices, out hv_DLSamples);
      //
      //Augment samples based on train parameter.
      hv_AugmentationParam.Dispose();
      HOperatorSet.GetDictTuple(hv_TrainParam, "augmentation_param", out hv_AugmentationParam);
      augment_dl_samples(hv_DLSamples, hv_AugmentationParam);
      //
      //Train the model on current batch.
      hv_TrainResult.Dispose();
      HOperatorSet.TrainDlModelBatch(hv_DLModelHandle, hv_DLSamples, out hv_TrainResult);
      //
      //We store each train result.
      if (hv_TrainResults == null)
        hv_TrainResults = new HTuple();
      hv_TrainResults[hv_Iteration] = hv_TrainResult;
      //
      //Check if an update is needed.
      hv_DisplayParam.Dispose();
      HOperatorSet.GetDictTuple(hv_DisplayData, "display_param", out hv_DisplayParam);
      hv_TrainInfoUpdateIntervalSeconds.Dispose();
      HOperatorSet.GetDictTuple(hv_TrainParam, "update_interval_seconds", out hv_TrainInfoUpdateIntervalSeconds);
      hv_LastUpdate.Dispose();
      HOperatorSet.GetDictTuple(hv_DisplayData, "last_update", out hv_LastUpdate);
      hv_Seconds.Dispose();
      HOperatorSet.CountSeconds(out hv_Seconds);
      //Check if enough time has elapsed for the next update.
      if ((int)(new HTuple(((((hv_LastUpdate-hv_Seconds)).TupleAbs())).TupleGreater(
          hv_TrainInfoUpdateIntervalSeconds))) != 0)
      {
        HOperatorSet.SetDictTuple(hv_DisplayData, "last_update", hv_Seconds);
        hv_EvaluationComparisonKeys.Dispose();
        HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys", out hv_EvaluationComparisonKeys);
        hv_NumSamplesMeanLoss.Dispose();
        HOperatorSet.GetDictTuple(hv_TrainParam, "num_samples_mean_loss", out hv_NumSamplesMeanLoss);
        hv_TrainInfo.Dispose();
        collect_train_dl_model_info(hv_DLModelHandle, hv_TrainResults, hv_EvaluationInfos, 
            hv_EvaluationComparisonKeys, hv_Iteration, hv_NumIterations, hv_NumIterationsPerEpoch, 
            hv_NumSamplesMeanLoss, out hv_TrainInfo);
        HOperatorSet.SetDictTuple(hv_TrainInfo, "start_epoch", hv_StartEpoch);
        HOperatorSet.SetDictTuple(hv_TrainInfo, "start_time", hv_StartTime);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_TrainInfos = hv_TrainInfos.TupleConcat(
            hv_TrainInfo);
        hv_TrainInfos.Dispose();
        hv_TrainInfos = ExpTmpLocalVar_TrainInfos;
        }
        }
        //
        //Display handling.
        if ((int)(hv_DisplayEnabled) != 0)
        {
          hv_EpochsStatus.Dispose();
          HOperatorSet.GetDictTuple(hv_TrainInfo, "epoch", out hv_EpochsStatus);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_DisplayLossEpochs = hv_DisplayLossEpochs.TupleConcat(
              hv_EpochsStatus);
          hv_DisplayLossEpochs.Dispose();
          hv_DisplayLossEpochs = ExpTmpLocalVar_DisplayLossEpochs;
          }
          }
          hv_MeanLoss.Dispose();
          HOperatorSet.GetDictTuple(hv_TrainInfo, "mean_loss", out hv_MeanLoss);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_DisplayLoss = hv_DisplayLoss.TupleConcat(
              hv_MeanLoss);
          hv_DisplayLoss.Dispose();
          hv_DisplayLoss = ExpTmpLocalVar_DisplayLoss;
          }
          }
          dev_display_update_train_dl_model(hv_TrainParam, hv_DisplayData, hv_DLDataset, 
              hv_DLModelHandle, hv_TrainInfo, hv_EvaluationInfos, hv_DisplayLossEpochs, 
              hv_DisplayLoss, hv_DisplayEvaluationEpochs, hv_DisplayEvaluationValues);
        }
      }
      //Image result preview handling.
      if ((int)(hv_DisplayEnabled) != 0)
      {
        //Check if the image preview has to be updated.
        hv_UpdateImagesIntervalEpochs.Dispose();
        HOperatorSet.GetDictTuple(hv_DisplayParam, "update_images_interval_epochs", 
            out hv_UpdateImagesIntervalEpochs);
        hv_UpdateImagesInterval.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_UpdateImagesInterval = (((((hv_UpdateImagesIntervalEpochs.TupleReal()
            )*hv_NumIterationsPerEpoch)).TupleFloor())).TupleInt();
        }
        if ((int)(new HTuple(hv_UpdateImagesInterval.TupleEqual(0))) != 0)
        {
          hv_UpdateImagesInterval.Dispose();
          hv_UpdateImagesInterval = 1;
        }
        if ((int)((new HTuple(((hv_Iteration%hv_UpdateImagesInterval)).TupleEqual(
            0))).TupleOr(hv_DisplayPreviewInitialized.TupleNot())) != 0)
        {
          hv_WindowImages.Dispose();
          HOperatorSet.GetDictTuple(hv_DisplayData, "window_images", out hv_WindowImages);
          hv_FirstCall.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_FirstCall = new HTuple((new HTuple(hv_WindowImages.TupleLength()
              )).TupleEqual(0));
          }
          hv_NumImages.Dispose();
          HOperatorSet.GetDictTuple(hv_DisplayParam, "num_images", out hv_NumImages);
          hv_GenParam.Dispose();
          HOperatorSet.GetDictTuple(hv_DisplayData, "window_images_genparam", out hv_GenParam);
          {
          HTuple ExpTmpOutVar_0;
          dev_display_dl_data_tiled(hv_DLDataset, hv_DLModelHandle, hv_NumImages, 
              "validation", hv_GenParam, hv_WindowImages, out ExpTmpOutVar_0);
          hv_WindowImages.Dispose();
          hv_WindowImages = ExpTmpOutVar_0;
          }
          if ((int)(hv_FirstCall) != 0)
          {
            HOperatorSet.SetDictTuple(hv_DisplayData, "window_images", hv_WindowImages);
            set_display_font(hv_WindowImages, 12, "mono", "true", "false");
          }
          dev_display_tiled_legend(hv_WindowImages, hv_GenParam);
          hv_DisplayPreviewInitialized.Dispose();
          hv_DisplayPreviewInitialized = 1;
        }
      }
      //
      //Evaluation handling.
      hv_EvaluationIntervalEpochs.Dispose();
      HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_interval_epochs", out hv_EvaluationIntervalEpochs);
      hv_EvaluationInterval.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EvaluationInterval = ((((hv_EvaluationIntervalEpochs*hv_NumIterationsPerEpoch)).TupleFloor()
          )).TupleInt();
      }
      hv_EvaluationResult.Dispose();
      hv_EvaluationResult = new HTuple();
      if ((int)(new HTuple(hv_EvaluationInterval.TupleGreater(0))) != 0)
      {
        //Evaluate the model at given intervals.
        if ((int)((new HTuple((new HTuple((((hv_Iteration+1)%hv_EvaluationInterval)).TupleEqual(
            0))).TupleAnd(new HTuple(hv_Iteration.TupleNotEqual(0))))).TupleOr(new HTuple(hv_Iteration.TupleEqual(
            hv_NumIterations-1)))) != 0)
        {
          hv_EvaluationParam.Dispose();
          HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_param", out hv_EvaluationParam);
          hv_EvaluationResult.Dispose();hv_GeneratedEvaluationParam.Dispose();
          evaluate_dl_model(hv_DLDataset, hv_DLModelHandle, "split", "validation", 
              hv_EvaluationParam, out hv_EvaluationResult, out hv_GeneratedEvaluationParam);
          hv_EvaluationInfo.Dispose();
          HOperatorSet.CreateDict(out hv_EvaluationInfo);
          HOperatorSet.SetDictTuple(hv_EvaluationInfo, "epoch", hv_Epoch);
          HOperatorSet.SetDictTuple(hv_EvaluationInfo, "result", hv_EvaluationResult);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_EvaluationInfos = hv_EvaluationInfos.TupleConcat(
              hv_EvaluationInfo);
          hv_EvaluationInfos.Dispose();
          hv_EvaluationInfos = ExpTmpLocalVar_EvaluationInfos;
          }
          }
          if ((int)(hv_DisplayEnabled) != 0)
          {
            hv_EvaluationComparisonKeys.Dispose();
            HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys", 
                out hv_EvaluationComparisonKeys);
            hv_Value.Dispose();hv_ValidEvaluationKeys.Dispose();
            reduce_dl_evaluation_result(hv_EvaluationResult, hv_EvaluationComparisonKeys, 
                out hv_Value, out hv_ValidEvaluationKeys);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_DisplayEvaluationValues = hv_DisplayEvaluationValues.TupleConcat(
                hv_Value);
            hv_DisplayEvaluationValues.Dispose();
            hv_DisplayEvaluationValues = ExpTmpLocalVar_DisplayEvaluationValues;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_DisplayEvaluationEpochs = hv_DisplayEvaluationEpochs.TupleConcat(
                hv_Epoch);
            hv_DisplayEvaluationEpochs.Dispose();
            hv_DisplayEvaluationEpochs = ExpTmpLocalVar_DisplayEvaluationEpochs;
            }
            }
          }
        }
      }
      //
      //Serialization handling.
      update_train_dl_model_serialization(hv_TrainParam, hv_SerializationData, hv_Iteration, 
          hv_NumIterations, hv_Epoch, hv_EvaluationResult, hv_DLModelHandle, hv_TrainInfos, 
          hv_EvaluationInfos);
      //
      //Check for end of training.
      if ((int)(new HTuple(hv_Iteration.TupleGreaterEqual(hv_NumIterations-1))) != 0)
      {
        break;
      }
      //
      //Continue with next iteration.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Iteration = hv_Iteration+1;
      hv_Iteration.Dispose();
      hv_Iteration = ExpTmpLocalVar_Iteration;
      }
      }
    }
    //
    //Calculate a final train info.
    hv_EvaluationComparisonKeys.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys", out hv_EvaluationComparisonKeys);
    hv_NumSamplesMeanLoss.Dispose();
    HOperatorSet.GetDictTuple(hv_TrainParam, "num_samples_mean_loss", out hv_NumSamplesMeanLoss);
    hv_TrainInfo.Dispose();
    collect_train_dl_model_info(hv_DLModelHandle, hv_TrainResults, hv_EvaluationInfos, 
        hv_EvaluationComparisonKeys, hv_Iteration, hv_NumIterations, hv_NumIterationsPerEpoch, 
        hv_NumSamplesMeanLoss, out hv_TrainInfo);
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_TrainInfos = hv_TrainInfos.TupleConcat(
        hv_TrainInfo);
    hv_TrainInfos.Dispose();
    hv_TrainInfos = ExpTmpLocalVar_TrainInfos;
    }
    }
    //

    hv_DLSamples.Dispose();
    hv_SampleIndices.Dispose();
    hv_NumTrainSamples.Dispose();
    hv_SeedRand.Dispose();
    hv_NumEpochs.Dispose();
    hv_SampleIndicesTrainRaw.Dispose();
    hv_Index.Dispose();
    hv_Shuffled.Dispose();
    hv_SampleSeedsTrainRaw.Dispose();
    hv_BatchSize.Dispose();
    hv_ChangeStrategyData.Dispose();
    hv_SerializationData.Dispose();
    hv_DisplayData.Dispose();
    hv_DisplayEnabled.Dispose();
    hv_DisplayLossEpochs.Dispose();
    hv_DisplayLoss.Dispose();
    hv_DisplayEvaluationEpochs.Dispose();
    hv_DisplayEvaluationValues.Dispose();
    hv_DisplayPreviewInitialized.Dispose();
    hv_StartTime.Dispose();
    hv_FirstIteration.Dispose();
    hv_Epoch.Dispose();
    hv_Iteration.Dispose();
    hv_NumIterationsPerEpoch.Dispose();
    hv_BatchSizeModel.Dispose();
    hv_NumIterations.Dispose();
    hv_SampleIndicesTrain.Dispose();
    hv_BatchStart.Dispose();
    hv_BatchEnd.Dispose();
    hv_BatchIndices.Dispose();
    hv_AugmentationParam.Dispose();
    hv_TrainResult.Dispose();
    hv_DisplayParam.Dispose();
    hv_TrainInfoUpdateIntervalSeconds.Dispose();
    hv_LastUpdate.Dispose();
    hv_Seconds.Dispose();
    hv_EvaluationComparisonKeys.Dispose();
    hv_NumSamplesMeanLoss.Dispose();
    hv_TrainInfo.Dispose();
    hv_EpochsStatus.Dispose();
    hv_MeanLoss.Dispose();
    hv_UpdateImagesIntervalEpochs.Dispose();
    hv_UpdateImagesInterval.Dispose();
    hv_WindowImages.Dispose();
    hv_FirstCall.Dispose();
    hv_NumImages.Dispose();
    hv_GenParam.Dispose();
    hv_EvaluationIntervalEpochs.Dispose();
    hv_EvaluationInterval.Dispose();
    hv_EvaluationResult.Dispose();
    hv_EvaluationParam.Dispose();
    hv_GeneratedEvaluationParam.Dispose();
    hv_EvaluationInfo.Dispose();
    hv_Value.Dispose();
    hv_ValidEvaluationKeys.Dispose();

    return;
  }

  // Chapter: Tuple / Element Order
  // Short Description: Sort the elements of a tuple randomly. 
  public void tuple_shuffle (HTuple hv_Tuple, out HTuple hv_Shuffled)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShuffleIndices = new HTuple();
    // Initialize local and output iconic variables 
    hv_Shuffled = new HTuple();
    //This procedure sorts the input tuple randomly.
    //
    if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleGreater(0))) != 0)
    {
      //Create a tuple of random numbers,
      //sort this tuple, and return the indices
      //of this sorted tuple.
      hv_ShuffleIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ShuffleIndices = (HTuple.TupleRand(
          new HTuple(hv_Tuple.TupleLength()))).TupleSortIndex();
      }
      //Assign the elements of Tuple
      //to these random positions.
      hv_Shuffled.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Shuffled = hv_Tuple.TupleSelect(
          hv_ShuffleIndices);
      }
    }
    else
    {
      //If the input tuple is empty,
      //an empty tuple should be returned.
      hv_Shuffled.Dispose();
      hv_Shuffled = new HTuple();
    }

    hv_ShuffleIndices.Dispose();

    return;
  }

  // Chapter: Tuple / Arithmetic
  // Short Description: Calculates the cross product of two vectors of length 3. 
  public void tuple_vector_cross_product (HTuple hv_V1, HTuple hv_V2, out HTuple hv_VC)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_VC = new HTuple();
    //The caller must ensure that the length of both input vectors is 3
    hv_VC.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_VC = ((hv_V1.TupleSelect(
        1))*(hv_V2.TupleSelect(2)))-((hv_V1.TupleSelect(2))*(hv_V2.TupleSelect(1)));
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_VC = hv_VC.TupleConcat(
        ((hv_V1.TupleSelect(2))*(hv_V2.TupleSelect(0)))-((hv_V1.TupleSelect(0))*(hv_V2.TupleSelect(
        2))));
    hv_VC.Dispose();
    hv_VC = ExpTmpLocalVar_VC;
    }
    }
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_VC = hv_VC.TupleConcat(
        ((hv_V1.TupleSelect(0))*(hv_V2.TupleSelect(1)))-((hv_V1.TupleSelect(1))*(hv_V2.TupleSelect(
        0))));
    hv_VC.Dispose();
    hv_VC = ExpTmpLocalVar_VC;
    }
    }


    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Update RunningMeasures by evaluating Samples and corresponding Results. 
  public void update_running_evaluation_measures (HTuple hv_Samples, HTuple hv_Results, 
      HTuple hv_EvalParams, HTuple hv_RunningMeasures)
  {



    // Local control variables 

    HTuple hv_EvalInstances = new HTuple();
    // Initialize local and output iconic variables 
    //
    //This procedure updates the running measures depending on the evaluation type.
    hv_EvalInstances.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "evaluate_instances", out hv_EvalInstances);
    if ((int)(hv_EvalInstances) != 0)
    {
      update_running_instance_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
    }
    else
    {
      update_running_pixel_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
    }
    //

    hv_EvalInstances.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Update running measures for an instance-based evaluation. 
  public void update_running_instance_measures (HTuple hv_Samples, HTuple hv_Results, 
      HTuple hv_EvalParams, HTuple hv_RunningMeasures)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MaxNumDetections = new HTuple();
    HTuple hv_AreaRanges = new HTuple(), hv_IoUThresholds = new HTuple();
    HTuple hv_InstanceType = new HTuple(), hv_ClassIDs = new HTuple();
    HTuple hv_NumClasses = new HTuple(), hv_AreaNames = new HTuple();
    HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
    HTuple hv_NumAreaRanges = new HTuple(), hv_AllocationBlockLength = new HTuple();
    HTuple hv_DetailedEvaluation = new HTuple(), hv_KeyExists = new HTuple();
    HTuple hv_ClassIDToClassIdx = new HTuple(), hv_SIdx = new HTuple();
    HTuple hv_CurrentSample = new HTuple(), hv_CurrentResult = new HTuple();
    HTuple hv_GtClassIDs = new HTuple(), hv_ResClassIDs = new HTuple();
    HTuple hv_NumGT = new HTuple(), hv_NumRes = new HTuple();
    HTuple hv_Confidences = new HTuple(), hv_ResSortIndices = new HTuple();
    HTuple hv_GtAreas = new HTuple(), hv_ResAreas = new HTuple();
    HTuple hv_IoUs = new HTuple(), hv_MDIdx = new HTuple();
    HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
    HTuple hv_CurrentRunningMeasures = new HTuple(), hv_AreaIdx = new HTuple();
    HTuple hv_MinArea = new HTuple(), hv_MaxArea = new HTuple();
    HTuple hv_AreaName = new HTuple(), hv_AreaRunningMeasures = new HTuple();
    HTuple hv_GtIgnore = new HTuple(), hv_GtIgnoreInds = new HTuple();
    HTuple hv_PerClassNumGt = new HTuple(), hv_PerClassNumPred = new HTuple();
    HTuple hv_PerClassConfidences = new HTuple(), hv_PerClassNumGtIgnore = new HTuple();
    HTuple hv_SampleHasFP = new HTuple(), hv_SampleHasFN = new HTuple();
    HTuple hv_ClsIdx = new HTuple(), hv_CurrentClassID = new HTuple();
    HTuple hv_CurrentGtIdxs = new HTuple(), hv_CurrentNumGt = new HTuple();
    HTuple hv_CurrentGtIgnore = new HTuple(), hv_CurrentNumGtIgnore = new HTuple();
    HTuple hv_CurrentNumGtNoIgnore = new HTuple(), hv_CurrentResIdxs = new HTuple();
    HTuple hv_CurrentNumRes = new HTuple(), hv_CurrentResAreas = new HTuple();
    HTuple hv_OldNumPred = new HTuple(), hv_CurrentClassConfidences = new HTuple();
    HTuple hv_GtSortIdx = new HTuple(), hv_ITIdx = new HTuple();
    HTuple hv_GtMatched = new HTuple(), hv_ResMatched = new HTuple();
    HTuple hv_ResIgnore = new HTuple(), hv_ResIdx = new HTuple();
    HTuple hv_CurrentIoU = new HTuple(), hv_MatchIdx = new HTuple();
    HTuple hv_GtIdx = new HTuple(), hv_AreaIgnore = new HTuple();
    HTuple hv_PerIoUMeasure = new HTuple(), hv_PerClassMeasures = new HTuple();
    HTuple hv_CurrentIsTP = new HTuple(), hv_CurrentIgnore = new HTuple();
    HTuple hv_GtMatchedNoIgnore = new HTuple(), hv_ResIsFPClass = new HTuple();
    HTuple hv_ResIsFPBackground = new HTuple(), hv_ResIsFPLocalization = new HTuple();
    HTuple hv_ResIsFPDuplicate = new HTuple(), hv_ResIsFPMultiple = new HTuple();
    HTuple hv_FPResIdxsThisClass = new HTuple(), hv_FPResIdxsAllResults = new HTuple();
    HTuple hv_GTIdxsNotToIgnore = new HTuple(), hv_MaxIoU = new HTuple();
    HTuple hv_IoUsWithGT = new HTuple(), hv_MaxIdx = new HTuple();
    HTuple hv_GTClassIDMaxIoU = new HTuple(), hv_IsFPClass = new HTuple();
    HTuple hv_IsFPBackground = new HTuple(), hv_IsFPLocalization = new HTuple();
    HTuple hv_IsFPDuplicate = new HTuple(), hv_IsFPMultiple = new HTuple();
    HTuple hv_CurrentImageID = new HTuple(), hv_ImageIDsWithFN = new HTuple();
    HTuple hv_NumImageIDsWithFN = new HTuple(), hv_ImageIDsWithFP = new HTuple();
    HTuple hv_NumImageIDsWithFP = new HTuple();
    // Initialize local and output iconic variables 
    //This procedure updates the RunningMeasures
    //for an instance-based evaluation.
    //These measures are stored in the dictionary RunningMeasures and
    //updated by incorporating the Results the model obtained for the Samples.
    //
    dev_update_off();
    //Get the necessary evaluation parameters.
    hv_MaxNumDetections.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
    hv_AreaRanges.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
    hv_IoUThresholds.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
    hv_InstanceType.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
    hv_ClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
    hv_NumClasses.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
    //
    //Get the area parameters: name, min, and max.
    hv_AreaNames.Dispose();
    HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
    hv_MinAreas.Dispose();
    HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
    hv_MaxAreas.Dispose();
    HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
    hv_NumAreaRanges.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumAreaRanges = (new HTuple(hv_AreaNames.TupleLength()
        ))-1;
    }
    //
    //Get the allocation length for extending tuples.
    hv_AllocationBlockLength.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
    //
    //Check if a detailed evaluation should be done.
    hv_DetailedEvaluation.Dispose();
    hv_DetailedEvaluation = 0;
    hv_KeyExists.Dispose();
    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation", 
        out hv_KeyExists);
    if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
    {
      hv_DetailedEvaluation.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
    }
    if ((int)(hv_DetailedEvaluation) != 0)
    {
      //We need a mapping from class IDs to class indices
      hv_ClassIDToClassIdx.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassIDToClassIdx = HTuple.TupleGenConst(
          (hv_ClassIDs.TupleMax())+1,-1);
      }
      if (hv_ClassIDToClassIdx == null)
        hv_ClassIDToClassIdx = new HTuple();
      hv_ClassIDToClassIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0,hv_NumClasses-1,1);
    }
    //
    //Go through samples.
    for (hv_SIdx=0; (int)hv_SIdx<=(int)((new HTuple(hv_Samples.TupleLength()))-1); hv_SIdx = (int)hv_SIdx + 1)
    {
      //
      hv_CurrentSample.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentSample = hv_Samples.TupleSelect(
          hv_SIdx);
      }
      hv_CurrentResult.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CurrentResult = hv_Results.TupleSelect(
          hv_SIdx);
      }
      //
      //* Get classes.
      hv_GtClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_label_id", out hv_GtClassIDs);
      hv_ResClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_class_id", out hv_ResClassIDs);
      hv_NumGT.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumGT = new HTuple(hv_GtClassIDs.TupleLength()
          );
      }
      hv_NumRes.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumRes = new HTuple(hv_ResClassIDs.TupleLength()
          );
      }
      //
      //* Get result confidences and sort them in descending order.
      hv_Confidences.Dispose();
      HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_confidence", out hv_Confidences);
      hv_ResSortIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ResSortIndices = ((-hv_Confidences)).TupleSortIndex()
          ;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
          hv_ResSortIndices);
      hv_Confidences.Dispose();
      hv_Confidences = ExpTmpLocalVar_Confidences;
      }
      }
      //Sort the result class IDs.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ResClassIDs = hv_ResClassIDs.TupleSelect(
          hv_ResSortIndices);
      hv_ResClassIDs.Dispose();
      hv_ResClassIDs = ExpTmpLocalVar_ResClassIDs;
      }
      }
      //
      //Compute the IoUs of the instances.
      hv_GtAreas.Dispose();hv_ResAreas.Dispose();hv_IoUs.Dispose();
      area_iou(hv_CurrentSample, hv_CurrentResult, hv_InstanceType, hv_ResSortIndices, 
          out hv_GtAreas, out hv_ResAreas, out hv_IoUs);
      //
      //Loop over the maximal number of detections.
      for (hv_MDIdx=0; (int)hv_MDIdx<=(int)((new HTuple(hv_MaxNumDetections.TupleLength()
          ))-1); hv_MDIdx = (int)hv_MDIdx + 1)
      {
        hv_MaxNum.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxNum = hv_MaxNumDetections.TupleSelect(
            hv_MDIdx);
        }
        hv_MaxNumStr.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxNumStr = ""+hv_MaxNum;
        }
        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
        {
          hv_MaxNumStr.Dispose();
          hv_MaxNumStr = "all";
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentRunningMeasures.Dispose();
        HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_"+hv_MaxNumStr, 
            out hv_CurrentRunningMeasures);
        }
        //
        //Loop over the area ranges.
        for (hv_AreaIdx=0; (int)hv_AreaIdx<=(int)((new HTuple(hv_AreaNames.TupleLength()
            ))-1); hv_AreaIdx = (int)hv_AreaIdx + 1)
        {
          //
          //Get information about the current area range.
          hv_MinArea.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MinArea = hv_MinAreas.TupleSelect(
              hv_AreaIdx);
          }
          hv_MaxArea.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MaxArea = hv_MaxAreas.TupleSelect(
              hv_AreaIdx);
          }
          hv_AreaName.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AreaName = hv_AreaNames.TupleSelect(
              hv_AreaIdx);
          }
          //
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AreaRunningMeasures.Dispose();
          HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_"+hv_AreaName, 
              out hv_AreaRunningMeasures);
          }
          //
          //Set ignore-flag for ground truth instances.
          hv_GtIgnore.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_GtIgnore = HTuple.TupleGenConst(
              hv_NumGT,0);
          }
          //
          //Ignore ground truth instances with area outside the area range.
          if ((int)(new HTuple(hv_NumGT.TupleGreater(0))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_GtIgnoreInds.Dispose();
            HOperatorSet.TupleFind(((hv_GtAreas.TupleLessElem(hv_MinArea))).TupleOr(
                hv_GtAreas.TupleGreaterElem(hv_MaxArea)), 1, out hv_GtIgnoreInds);
            }
            if ((int)(new HTuple(hv_GtIgnoreInds.TupleGreater(-1))) != 0)
            {
              if (hv_GtIgnore == null)
                hv_GtIgnore = new HTuple();
              hv_GtIgnore[hv_GtIgnoreInds] = 1;
            }
          }
          //
          hv_PerClassNumGt.Dispose();
          HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
          hv_PerClassNumPred.Dispose();
          HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
          hv_PerClassConfidences.Dispose();
          HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidences);
          hv_PerClassNumGtIgnore.Dispose();
          HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
          //
          if ((int)(hv_DetailedEvaluation) != 0)
          {
            //Store if a sample has at least one false positive or false negative (for each IoU threshold).
            hv_SampleHasFP.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_SampleHasFP = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),0);
            }
            hv_SampleHasFN.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_SampleHasFN = HTuple.TupleGenConst(
                new HTuple(hv_IoUThresholds.TupleLength()),0);
            }
          }
          //
          //Loop over the classes.
          HTuple end_val99 = hv_NumClasses-1;
          HTuple step_val99 = 1;
          for (hv_ClsIdx=0; hv_ClsIdx.Continue(end_val99, step_val99); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val99))
          {
            hv_CurrentClassID.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentClassID = hv_ClassIDs.TupleSelect(
                hv_ClsIdx);
            }
            //
            //Get the ground truth for this class.
            hv_CurrentGtIdxs.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentGtIdxs = hv_GtClassIDs.TupleFind(
                hv_CurrentClassID);
            }
            if ((int)(new HTuple(hv_CurrentGtIdxs.TupleEqual(-1))) != 0)
            {
              hv_CurrentGtIdxs.Dispose();
              hv_CurrentGtIdxs = new HTuple();
            }
            hv_CurrentNumGt.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentNumGt = new HTuple(hv_CurrentGtIdxs.TupleLength()
                );
            }
            //
            //Get ground truth ignore for this class.
            hv_CurrentGtIgnore.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentGtIgnore = hv_GtIgnore.TupleSelect(
                hv_CurrentGtIdxs);
            }
            if ((int)(new HTuple((new HTuple(hv_CurrentGtIgnore.TupleLength())).TupleEqual(
                0))) != 0)
            {
              hv_CurrentNumGtIgnore.Dispose();
              hv_CurrentNumGtIgnore = 0;
            }
            else
            {
              hv_CurrentNumGtIgnore.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_CurrentNumGtIgnore = hv_CurrentGtIgnore.TupleSum()
                  ;
              }
            }
            //
            //Number of gt for this class and without ignore.
            hv_CurrentNumGtNoIgnore.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentNumGtNoIgnore = hv_CurrentNumGt-hv_CurrentNumGtIgnore;
            }
            //
            //Get results for this class.
            hv_CurrentResIdxs.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentResIdxs = hv_ResClassIDs.TupleFind(
                hv_CurrentClassID);
            }
            if ((int)(new HTuple(hv_CurrentResIdxs.TupleEqual(-1))) != 0)
            {
              hv_CurrentResIdxs.Dispose();
              hv_CurrentResIdxs = new HTuple();
            }
            hv_CurrentNumRes.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentNumRes = hv_MaxNum.TupleMin2(
                new HTuple(hv_CurrentResIdxs.TupleLength()));
            }
            //MaxNum -1 corresponds to taking all results.
            if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
            {
              hv_CurrentNumRes.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_CurrentNumRes = new HTuple(hv_CurrentResIdxs.TupleLength()
                  );
              }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_CurrentResIdxs = hv_CurrentResIdxs.TupleSelectRange(
                0,hv_CurrentNumRes-1);
            hv_CurrentResIdxs.Dispose();
            hv_CurrentResIdxs = ExpTmpLocalVar_CurrentResIdxs;
            }
            }
            //
            //Get areas of the current results.
            hv_CurrentResAreas.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentResAreas = hv_ResAreas.TupleSelect(
                hv_CurrentResIdxs);
            }
            //
            //Update the confidences, num_gt and num_pred for this class.
            hv_OldNumPred.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_OldNumPred = hv_PerClassNumPred.TupleSelect(
                hv_ClsIdx);
            }
            if (hv_PerClassNumGt == null)
              hv_PerClassNumGt = new HTuple();
            hv_PerClassNumGt[hv_ClsIdx] = (hv_PerClassNumGt.TupleSelect(hv_ClsIdx))+hv_CurrentNumGt;
            if (hv_PerClassNumGtIgnore == null)
              hv_PerClassNumGtIgnore = new HTuple();
            hv_PerClassNumGtIgnore[hv_ClsIdx] = (hv_PerClassNumGtIgnore.TupleSelect(
                hv_ClsIdx))+hv_CurrentNumGtIgnore;
            if (hv_PerClassNumPred == null)
              hv_PerClassNumPred = new HTuple();
            hv_PerClassNumPred[hv_ClsIdx] = (hv_PerClassNumPred.TupleSelect(hv_ClsIdx))+hv_CurrentNumRes;
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentClassConfidences.Dispose();
            HOperatorSet.GetDictTuple(hv_PerClassConfidences, "class_"+(hv_ClassIDs.TupleSelect(
                hv_ClsIdx)), out hv_CurrentClassConfidences);
            }
            //Confidences are allocated in blocks of AllocationBlockLength. Therefore, we have to check
            //if the allocated block is long enough, otherwise allocate a new block.
            if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                new HTuple(hv_CurrentClassConfidences.TupleLength())))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_CurrentClassConfidences = hv_CurrentClassConfidences.TupleConcat(
                  HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
              hv_CurrentClassConfidences.Dispose();
              hv_CurrentClassConfidences = ExpTmpLocalVar_CurrentClassConfidences;
              }
              }
            }
            if (hv_CurrentClassConfidences == null)
              hv_CurrentClassConfidences = new HTuple();
            hv_CurrentClassConfidences[HTuple.TupleGenSequence(hv_OldNumPred,(hv_PerClassNumPred.TupleSelect(
                hv_ClsIdx))-1,1)] = hv_Confidences.TupleSelect(hv_CurrentResIdxs);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_PerClassConfidences, "class_"+(hv_ClassIDs.TupleSelect(
                hv_ClsIdx)), hv_CurrentClassConfidences);
            }
            //
            //Sort the ground truth: Non-ignored instances first.
            hv_GtSortIdx.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_GtSortIdx = hv_CurrentGtIgnore.TupleSortIndex()
                ;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_CurrentGtIgnore = hv_CurrentGtIgnore.TupleSelect(
                hv_GtSortIdx);
            hv_CurrentGtIgnore.Dispose();
            hv_CurrentGtIgnore = ExpTmpLocalVar_CurrentGtIgnore;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_CurrentGtIdxs = hv_CurrentGtIdxs.TupleSelect(
                hv_GtSortIdx);
            hv_CurrentGtIdxs.Dispose();
            hv_CurrentGtIdxs = ExpTmpLocalVar_CurrentGtIdxs;
            }
            }
            //
            //
            if ((int)(new HTuple(hv_CurrentNumRes.TupleGreater(0))) != 0)
            {
              //Loop over IoU thresholds.
              for (hv_ITIdx=0; (int)hv_ITIdx<=(int)((new HTuple(hv_IoUThresholds.TupleLength()
                  ))-1); hv_ITIdx = (int)hv_ITIdx + 1)
              {
                //We check which ground truth and
                //result instance can be matched.
                hv_GtMatched.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_GtMatched = HTuple.TupleGenConst(
                    hv_CurrentNumGt,0);
                }
                hv_ResMatched.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_ResMatched = HTuple.TupleGenConst(
                    hv_CurrentNumRes,0);
                }
                //Store which detections should be ignored.
                hv_ResIgnore.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_ResIgnore = HTuple.TupleGenConst(
                    hv_CurrentNumRes,0);
                }
                HTuple end_val164 = hv_CurrentNumRes-1;
                HTuple step_val164 = 1;
                for (hv_ResIdx=0; hv_ResIdx.Continue(end_val164, step_val164); hv_ResIdx = hv_ResIdx.TupleAdd(step_val164))
                {
                  //Set the currently best achieved IoU to the IoU threshold and
                  //initialize the matching index.
                  hv_CurrentIoU.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_CurrentIoU = ((hv_IoUThresholds.TupleSelect(
                      hv_ITIdx))).TupleMin2(1-1.0e-10);
                  }
                  hv_MatchIdx.Dispose();
                  hv_MatchIdx = -1;
                  //Loop over ground truth.
                  HTuple end_val170 = hv_CurrentNumGt-1;
                  HTuple step_val170 = 1;
                  for (hv_GtIdx=0; hv_GtIdx.Continue(end_val170, step_val170); hv_GtIdx = hv_GtIdx.TupleAdd(step_val170))
                  {
                    //Continue if this ground truth has already been matched.
                    if ((int)(hv_GtMatched.TupleSelect(hv_GtIdx)) != 0)
                    {
                      continue;
                    }
                    //Stop if matched with non-ignored ground truth and current ground truth is on ignore.
                    if ((int)(new HTuple(hv_MatchIdx.TupleGreater(-1))) != 0)
                    {
                      if ((int)((new HTuple(((hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx))).TupleEqual(
                          0))).TupleAnd(new HTuple(((hv_CurrentGtIgnore.TupleSelect(
                          hv_GtIdx))).TupleEqual(1)))) != 0)
                      {
                        break;
                      }
                    }
                    //Continue if IoU is not better than a previous match.
                    if ((int)(new HTuple(((hv_IoUs.TupleSelect(((hv_CurrentGtIdxs.TupleSelect(
                        hv_GtIdx))*hv_NumRes)+(hv_CurrentResIdxs.TupleSelect(hv_ResIdx))))).TupleLess(
                        hv_CurrentIoU))) != 0)
                    {
                      continue;
                    }
                    //We got a new best match, store it.
                    hv_CurrentIoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_CurrentIoU = hv_IoUs.TupleSelect(
                        ((hv_CurrentGtIdxs.TupleSelect(hv_GtIdx))*hv_NumRes)+(hv_CurrentResIdxs.TupleSelect(
                        hv_ResIdx)));
                    }
                    hv_MatchIdx.Dispose();
                    hv_MatchIdx = new HTuple(hv_GtIdx);
                  }
                  //If a match has been made we store it for both ground truth and result.
                  if ((int)(new HTuple(hv_MatchIdx.TupleNotEqual(-1))) != 0)
                  {
                    //In COCO they use the IDs of GT and Res, we just use 1
                    //to indicate the matching, but don't store which one has been matched.
                    if (hv_ResMatched == null)
                      hv_ResMatched = new HTuple();
                    hv_ResMatched[hv_ResIdx] = 1;
                    if (hv_GtMatched == null)
                      hv_GtMatched = new HTuple();
                    hv_GtMatched[hv_MatchIdx] = 1;
                    if (hv_ResIgnore == null)
                      hv_ResIgnore = new HTuple();
                    hv_ResIgnore[hv_ResIdx] = hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx);
                  }
                }
                //Ignore the unmatched results that are outside of the current area range.
                hv_AreaIgnore.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_AreaIgnore = ((hv_CurrentResAreas.TupleLessElem(
                    hv_MinArea))).TupleOr(hv_CurrentResAreas.TupleGreaterElem(hv_MaxArea));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_ResIgnore = (new HTuple(((hv_ResMatched.TupleEqualElem(
                    -1))).TupleAnd(hv_AreaIgnore.TupleEqualElem(1)))).TupleOr(hv_ResIgnore);
                hv_ResIgnore.Dispose();
                hv_ResIgnore = ExpTmpLocalVar_ResIgnore;
                }
                }
                //True positives are the merged results.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_PerIoUMeasure.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_"+(((""+(hv_IoUThresholds.TupleSelect(
                    hv_ITIdx)))).TupleRegexpReplace("\\.","")), out hv_PerIoUMeasure);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_PerClassMeasures.Dispose();
                HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_"+(hv_ClassIDs.TupleSelect(
                    hv_ClsIdx)), out hv_PerClassMeasures);
                }
                hv_CurrentIsTP.Dispose();
                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_tp", out hv_CurrentIsTP);
                //As for confidences, check if we have to allocate a new block.
                if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                    new HTuple(hv_CurrentIsTP.TupleLength())))) != 0)
                {
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  {
                  HTuple 
                    ExpTmpLocalVar_CurrentIsTP = hv_CurrentIsTP.TupleConcat(
                      HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                  hv_CurrentIsTP.Dispose();
                  hv_CurrentIsTP = ExpTmpLocalVar_CurrentIsTP;
                  }
                  }
                }
                if (hv_CurrentIsTP == null)
                  hv_CurrentIsTP = new HTuple();
                hv_CurrentIsTP[HTuple.TupleGenSequence(hv_OldNumPred,(hv_PerClassNumPred.TupleSelect(
                    hv_ClsIdx))-1,1)] = hv_ResMatched;
                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_tp", hv_CurrentIsTP);
                //Set the ignored results.
                hv_CurrentIgnore.Dispose();
                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "ignore", out hv_CurrentIgnore);
                if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                    new HTuple(hv_CurrentIgnore.TupleLength())))) != 0)
                {
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  {
                  HTuple 
                    ExpTmpLocalVar_CurrentIgnore = hv_CurrentIgnore.TupleConcat(
                      HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                  hv_CurrentIgnore.Dispose();
                  hv_CurrentIgnore = ExpTmpLocalVar_CurrentIgnore;
                  }
                  }
                }
                if (hv_CurrentIgnore == null)
                  hv_CurrentIgnore = new HTuple();
                hv_CurrentIgnore[HTuple.TupleGenSequence(hv_OldNumPred,(hv_PerClassNumPred.TupleSelect(
                    hv_ClsIdx))-1,1)] = hv_ResIgnore;
                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "ignore", hv_CurrentIgnore);
                //
                //Beginning of detailed evaluation processing (optional).
                //
                if ((int)(hv_DetailedEvaluation) != 0)
                {
                  //Check if there have been false negatives.
                  if ((int)(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(0))) != 0)
                  {
                    hv_GtMatchedNoIgnore.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_GtMatchedNoIgnore = hv_GtMatched.TupleAnd(
                        hv_CurrentGtIgnore.TupleNot());
                    }
                    if ((int)(new HTuple(((hv_GtMatchedNoIgnore.TupleSum())).TupleLess(
                        hv_CurrentNumGtNoIgnore))) != 0)
                    {
                      if (hv_SampleHasFN == null)
                        hv_SampleHasFN = new HTuple();
                      hv_SampleHasFN[hv_ITIdx] = 1;
                    }
                  }
                  //
                  //Initialize the detailed running measures.
                  hv_ResIsFPClass.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_ResIsFPClass = HTuple.TupleGenConst(
                      hv_CurrentNumRes,-1);
                  }
                  hv_ResIsFPBackground.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_ResIsFPBackground = HTuple.TupleGenConst(
                      hv_CurrentNumRes,0);
                  }
                  hv_ResIsFPLocalization.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_ResIsFPLocalization = HTuple.TupleGenConst(
                      hv_CurrentNumRes,0);
                  }
                  hv_ResIsFPDuplicate.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_ResIsFPDuplicate = HTuple.TupleGenConst(
                      hv_CurrentNumRes,0);
                  }
                  hv_ResIsFPMultiple.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_ResIsFPMultiple = HTuple.TupleGenConst(
                      hv_CurrentNumRes,0);
                  }
                  //Check if there have been false positives.
                  if ((int)(new HTuple(((hv_ResMatched.TupleSum())).TupleLess(hv_CurrentNumRes))) != 0)
                  {
                    if (hv_SampleHasFP == null)
                      hv_SampleHasFP = new HTuple();
                    hv_SampleHasFP[hv_ITIdx] = 1;
                    //
                    //For each false positive, find out what was the reason for being false positive:
                    hv_FPResIdxsThisClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_FPResIdxsThisClass = hv_ResMatched.TupleFind(
                        0);
                    }
                    hv_FPResIdxsAllResults.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_FPResIdxsAllResults = hv_CurrentResIdxs.TupleSelect(
                        hv_FPResIdxsThisClass);
                    }
                    hv_GTIdxsNotToIgnore.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_GTIdxsNotToIgnore = hv_GtIgnore.TupleFind(
                        0);
                    }
                    for (hv_ResIdx=0; (int)hv_ResIdx<=(int)((new HTuple(hv_FPResIdxsThisClass.TupleLength()
                        ))-1); hv_ResIdx = (int)hv_ResIdx + 1)
                    {
                      if ((int)(((hv_ResIgnore.TupleSelect(hv_FPResIdxsThisClass.TupleSelect(
                          hv_ResIdx)))).TupleNot()) != 0)
                      {
                        if ((int)((new HTuple((new HTuple(hv_GTIdxsNotToIgnore.TupleLength()
                            )).TupleEqual(0))).TupleOr(new HTuple(hv_GTIdxsNotToIgnore.TupleEqual(
                            -1)))) != 0)
                        {
                          //No GT instances or all GT instances are ignored.
                          //Thus, any detection is a background detection
                          hv_MaxIoU.Dispose();
                          hv_MaxIoU = 0.0;
                        }
                        else
                        {
                          //We have GT instances to consider.
                          hv_IoUsWithGT.Dispose();
                          using (HDevDisposeHelper dh = new HDevDisposeHelper())
                          {
                          hv_IoUsWithGT = hv_IoUs.TupleSelect(
                              (hv_GTIdxsNotToIgnore*hv_NumRes)+(hv_FPResIdxsAllResults.TupleSelect(
                              hv_ResIdx)));
                          }
                          hv_MaxIoU.Dispose();
                          using (HDevDisposeHelper dh = new HDevDisposeHelper())
                          {
                          hv_MaxIoU = hv_IoUsWithGT.TupleMax()
                              ;
                          }
                          //It is enough to look for the first occurrence because the IoUs to ground truth should be different.
                          hv_MaxIdx.Dispose();
                          using (HDevDisposeHelper dh = new HDevDisposeHelper())
                          {
                          hv_MaxIdx = hv_IoUsWithGT.TupleFindFirst(
                              hv_MaxIoU);
                          }
                          hv_GTClassIDMaxIoU.Dispose();
                          using (HDevDisposeHelper dh = new HDevDisposeHelper())
                          {
                          hv_GTClassIDMaxIoU = hv_GtClassIDs.TupleSelect(
                              hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx));
                          }
                        }
                        //Determine false positive type.
                        if ((int)(new HTuple(hv_MaxIoU.TupleEqual(0.0))) != 0)
                        {
                          //Background detection. This detection does not overlap to any ground truth (that is not ignored).
                          if (hv_ResIsFPBackground == null)
                            hv_ResIsFPBackground = new HTuple();
                          hv_ResIsFPBackground[hv_FPResIdxsThisClass.TupleSelect(
                              hv_ResIdx)] = 1;
                        }
                        else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(new HTuple(hv_CurrentClassID.TupleNotEqual(
                            hv_GTClassIDMaxIoU)))) != 0)
                        {
                          //False class.
                          //Note that this does not necessarily mean that this detection
                          //would be a true positive if the class was changed. It could still be a duplicate.
                          if (hv_ResIsFPClass == null)
                            hv_ResIsFPClass = new HTuple();
                          hv_ResIsFPClass[hv_FPResIdxsThisClass.TupleSelect(hv_ResIdx)] = hv_ClassIDToClassIdx.TupleSelect(
                              hv_GTClassIDMaxIoU);
                        }
                        else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(new HTuple(hv_CurrentClassID.TupleEqual(
                            hv_GTClassIDMaxIoU)))) != 0)
                        {
                          //Duplicate detection. There must exist another detection with a higher confidence with the same ground truth.
                          if (hv_ResIsFPDuplicate == null)
                            hv_ResIsFPDuplicate = new HTuple();
                          hv_ResIsFPDuplicate[hv_FPResIdxsThisClass.TupleSelect(hv_ResIdx)] = 1;
                        }
                        else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(new HTuple(hv_CurrentClassID.TupleEqual(
                            hv_GTClassIDMaxIoU)))) != 0)
                        {
                          //Bad localization. Class is correct, but the IoU is too low.
                          if (hv_ResIsFPLocalization == null)
                            hv_ResIsFPLocalization = new HTuple();
                          hv_ResIsFPLocalization[hv_FPResIdxsThisClass.TupleSelect(
                              hv_ResIdx)] = 1;
                        }
                        else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(new HTuple(hv_CurrentClassID.TupleNotEqual(
                            hv_GTClassIDMaxIoU)))) != 0)
                        {
                          //Wrong class and bad localization.
                          if (hv_ResIsFPMultiple == null)
                            hv_ResIsFPMultiple = new HTuple();
                          hv_ResIsFPMultiple[hv_FPResIdxsThisClass.TupleSelect(hv_ResIdx)] = 1;
                        }
                        else
                        {
                          //This case should never occur.
                          throw new HalconException("Fatal error during detailed evaluation.");
                        }
                      }
                    }
                  }
                  //
                  //Overwrite the detailed running measures.
                  hv_IsFPClass.Dispose();
                  HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_class", out hv_IsFPClass);
                  hv_IsFPBackground.Dispose();
                  HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_background", 
                      out hv_IsFPBackground);
                  hv_IsFPLocalization.Dispose();
                  HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_localization", 
                      out hv_IsFPLocalization);
                  hv_IsFPDuplicate.Dispose();
                  HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_duplicate", 
                      out hv_IsFPDuplicate);
                  hv_IsFPMultiple.Dispose();
                  HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_multiple", 
                      out hv_IsFPMultiple);
                  //Allocate new blocks if necessary (all have the same length).
                  if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                      new HTuple(hv_IsFPClass.TupleLength())))) != 0)
                  {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    {
                    HTuple 
                      ExpTmpLocalVar_IsFPClass = hv_IsFPClass.TupleConcat(
                        HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                    hv_IsFPClass.Dispose();
                    hv_IsFPClass = ExpTmpLocalVar_IsFPClass;
                    }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    {
                    HTuple 
                      ExpTmpLocalVar_IsFPBackground = hv_IsFPBackground.TupleConcat(
                        HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                    hv_IsFPBackground.Dispose();
                    hv_IsFPBackground = ExpTmpLocalVar_IsFPBackground;
                    }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    {
                    HTuple 
                      ExpTmpLocalVar_IsFPLocalization = hv_IsFPLocalization.TupleConcat(
                        HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                    hv_IsFPLocalization.Dispose();
                    hv_IsFPLocalization = ExpTmpLocalVar_IsFPLocalization;
                    }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    {
                    HTuple 
                      ExpTmpLocalVar_IsFPDuplicate = hv_IsFPDuplicate.TupleConcat(
                        HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                    hv_IsFPDuplicate.Dispose();
                    hv_IsFPDuplicate = ExpTmpLocalVar_IsFPDuplicate;
                    }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    {
                    HTuple 
                      ExpTmpLocalVar_IsFPMultiple = hv_IsFPMultiple.TupleConcat(
                        HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                    hv_IsFPMultiple.Dispose();
                    hv_IsFPMultiple = ExpTmpLocalVar_IsFPMultiple;
                    }
                    }
                  }
                  if (hv_IsFPClass == null)
                    hv_IsFPClass = new HTuple();
                  hv_IsFPClass[HTuple.TupleGenSequence(hv_OldNumPred,(hv_PerClassNumPred.TupleSelect(
                      hv_ClsIdx))-1,1)] = hv_ResIsFPClass;
                  if (hv_IsFPBackground == null)
                    hv_IsFPBackground = new HTuple();
                  hv_IsFPBackground[HTuple.TupleGenSequence(hv_OldNumPred,(hv_PerClassNumPred.TupleSelect(
                      hv_ClsIdx))-1,1)] = hv_ResIsFPBackground;
                  if (hv_IsFPLocalization == null)
                    hv_IsFPLocalization = new HTuple();
                  hv_IsFPLocalization[HTuple.TupleGenSequence(hv_OldNumPred,(hv_PerClassNumPred.TupleSelect(
                      hv_ClsIdx))-1,1)] = hv_ResIsFPLocalization;
                  if (hv_IsFPDuplicate == null)
                    hv_IsFPDuplicate = new HTuple();
                  hv_IsFPDuplicate[HTuple.TupleGenSequence(hv_OldNumPred,(hv_PerClassNumPred.TupleSelect(
                      hv_ClsIdx))-1,1)] = hv_ResIsFPDuplicate;
                  if (hv_IsFPMultiple == null)
                    hv_IsFPMultiple = new HTuple();
                  hv_IsFPMultiple[HTuple.TupleGenSequence(hv_OldNumPred,(hv_PerClassNumPred.TupleSelect(
                      hv_ClsIdx))-1,1)] = hv_ResIsFPMultiple;
                  HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_class", hv_IsFPClass);
                  HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_background", 
                      hv_IsFPBackground);
                  HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_localization", 
                      hv_IsFPLocalization);
                  HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_duplicate", 
                      hv_IsFPDuplicate);
                  HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_multiple", 
                      hv_IsFPMultiple);
                }
                //
                //End of detailed evaluation processing.
                //
              }
            }
            else
            {
              if ((int)(hv_DetailedEvaluation.TupleAnd(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(
                  0)))) != 0)
              {
                //There are false negatives for this class.
                //Loop over IoU thresholds.
                for (hv_ITIdx=0; (int)hv_ITIdx<=(int)((new HTuple(hv_IoUThresholds.TupleLength()
                    ))-1); hv_ITIdx = (int)hv_ITIdx + 1)
                {
                  if (hv_SampleHasFN == null)
                    hv_SampleHasFN = new HTuple();
                  hv_SampleHasFN[hv_ITIdx] = 1;
                }
              }
            }
          }
          //Update the confidences, num_gt and num_pred.
          HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt", hv_PerClassNumGt);
          HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_pred", hv_PerClassNumPred);
          HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "confidence", hv_PerClassConfidences);
          HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", hv_PerClassNumGtIgnore);
          //
          if ((int)(hv_DetailedEvaluation) != 0)
          {
            //Set values that are calculated over all classes (for each IoU threshold).
            for (hv_ITIdx=0; (int)hv_ITIdx<=(int)((new HTuple(hv_IoUThresholds.TupleLength()
                ))-1); hv_ITIdx = (int)hv_ITIdx + 1)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_PerIoUMeasure.Dispose();
              HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_"+(((""+(hv_IoUThresholds.TupleSelect(
                  hv_ITIdx)))).TupleRegexpReplace("\\.","")), out hv_PerIoUMeasure);
              }
              //Set image IDs with false negatives
              if ((int)(hv_SampleHasFN.TupleSelect(hv_ITIdx)) != 0)
              {
                hv_CurrentImageID.Dispose();
                HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                hv_ImageIDsWithFN.Dispose();
                HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives", 
                    out hv_ImageIDsWithFN);
                hv_NumImageIDsWithFN.Dispose();
                HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives", 
                    out hv_NumImageIDsWithFN);
                //Allocate a new block if necessary.
                if ((int)(new HTuple(((hv_NumImageIDsWithFN+1)).TupleGreater(new HTuple(hv_ImageIDsWithFN.TupleLength()
                    )))) != 0)
                {
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  {
                  HTuple 
                    ExpTmpLocalVar_ImageIDsWithFN = hv_ImageIDsWithFN.TupleConcat(
                      HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                  hv_ImageIDsWithFN.Dispose();
                  hv_ImageIDsWithFN = ExpTmpLocalVar_ImageIDsWithFN;
                  }
                  }
                }
                if (hv_ImageIDsWithFN == null)
                  hv_ImageIDsWithFN = new HTuple();
                hv_ImageIDsWithFN[hv_NumImageIDsWithFN] = hv_CurrentImageID;
                HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives", 
                    hv_ImageIDsWithFN);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives", 
                    hv_NumImageIDsWithFN+1);
                }
              }
              if ((int)(hv_SampleHasFP.TupleSelect(hv_ITIdx)) != 0)
              {
                hv_CurrentImageID.Dispose();
                HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                hv_ImageIDsWithFP.Dispose();
                HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives", 
                    out hv_ImageIDsWithFP);
                hv_NumImageIDsWithFP.Dispose();
                HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives", 
                    out hv_NumImageIDsWithFP);
                //Allocate a new block if necessary.
                if ((int)(new HTuple(((hv_NumImageIDsWithFP+1)).TupleGreater(new HTuple(hv_ImageIDsWithFP.TupleLength()
                    )))) != 0)
                {
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  {
                  HTuple 
                    ExpTmpLocalVar_ImageIDsWithFP = hv_ImageIDsWithFP.TupleConcat(
                      HTuple.TupleGenConst(hv_AllocationBlockLength,-1));
                  hv_ImageIDsWithFP.Dispose();
                  hv_ImageIDsWithFP = ExpTmpLocalVar_ImageIDsWithFP;
                  }
                  }
                }
                if (hv_ImageIDsWithFP == null)
                  hv_ImageIDsWithFP = new HTuple();
                hv_ImageIDsWithFP[hv_NumImageIDsWithFP] = hv_CurrentImageID;
                HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives", 
                    hv_ImageIDsWithFP);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives", 
                    hv_NumImageIDsWithFP+1);
                }
              }
            }
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_CurrentRunningMeasures, "area_"+hv_AreaName, 
            hv_AreaRunningMeasures);
        }
      }
    }
    //

    hv_MaxNumDetections.Dispose();
    hv_AreaRanges.Dispose();
    hv_IoUThresholds.Dispose();
    hv_InstanceType.Dispose();
    hv_ClassIDs.Dispose();
    hv_NumClasses.Dispose();
    hv_AreaNames.Dispose();
    hv_MinAreas.Dispose();
    hv_MaxAreas.Dispose();
    hv_NumAreaRanges.Dispose();
    hv_AllocationBlockLength.Dispose();
    hv_DetailedEvaluation.Dispose();
    hv_KeyExists.Dispose();
    hv_ClassIDToClassIdx.Dispose();
    hv_SIdx.Dispose();
    hv_CurrentSample.Dispose();
    hv_CurrentResult.Dispose();
    hv_GtClassIDs.Dispose();
    hv_ResClassIDs.Dispose();
    hv_NumGT.Dispose();
    hv_NumRes.Dispose();
    hv_Confidences.Dispose();
    hv_ResSortIndices.Dispose();
    hv_GtAreas.Dispose();
    hv_ResAreas.Dispose();
    hv_IoUs.Dispose();
    hv_MDIdx.Dispose();
    hv_MaxNum.Dispose();
    hv_MaxNumStr.Dispose();
    hv_CurrentRunningMeasures.Dispose();
    hv_AreaIdx.Dispose();
    hv_MinArea.Dispose();
    hv_MaxArea.Dispose();
    hv_AreaName.Dispose();
    hv_AreaRunningMeasures.Dispose();
    hv_GtIgnore.Dispose();
    hv_GtIgnoreInds.Dispose();
    hv_PerClassNumGt.Dispose();
    hv_PerClassNumPred.Dispose();
    hv_PerClassConfidences.Dispose();
    hv_PerClassNumGtIgnore.Dispose();
    hv_SampleHasFP.Dispose();
    hv_SampleHasFN.Dispose();
    hv_ClsIdx.Dispose();
    hv_CurrentClassID.Dispose();
    hv_CurrentGtIdxs.Dispose();
    hv_CurrentNumGt.Dispose();
    hv_CurrentGtIgnore.Dispose();
    hv_CurrentNumGtIgnore.Dispose();
    hv_CurrentNumGtNoIgnore.Dispose();
    hv_CurrentResIdxs.Dispose();
    hv_CurrentNumRes.Dispose();
    hv_CurrentResAreas.Dispose();
    hv_OldNumPred.Dispose();
    hv_CurrentClassConfidences.Dispose();
    hv_GtSortIdx.Dispose();
    hv_ITIdx.Dispose();
    hv_GtMatched.Dispose();
    hv_ResMatched.Dispose();
    hv_ResIgnore.Dispose();
    hv_ResIdx.Dispose();
    hv_CurrentIoU.Dispose();
    hv_MatchIdx.Dispose();
    hv_GtIdx.Dispose();
    hv_AreaIgnore.Dispose();
    hv_PerIoUMeasure.Dispose();
    hv_PerClassMeasures.Dispose();
    hv_CurrentIsTP.Dispose();
    hv_CurrentIgnore.Dispose();
    hv_GtMatchedNoIgnore.Dispose();
    hv_ResIsFPClass.Dispose();
    hv_ResIsFPBackground.Dispose();
    hv_ResIsFPLocalization.Dispose();
    hv_ResIsFPDuplicate.Dispose();
    hv_ResIsFPMultiple.Dispose();
    hv_FPResIdxsThisClass.Dispose();
    hv_FPResIdxsAllResults.Dispose();
    hv_GTIdxsNotToIgnore.Dispose();
    hv_MaxIoU.Dispose();
    hv_IoUsWithGT.Dispose();
    hv_MaxIdx.Dispose();
    hv_GTClassIDMaxIoU.Dispose();
    hv_IsFPClass.Dispose();
    hv_IsFPBackground.Dispose();
    hv_IsFPLocalization.Dispose();
    hv_IsFPDuplicate.Dispose();
    hv_IsFPMultiple.Dispose();
    hv_CurrentImageID.Dispose();
    hv_ImageIDsWithFN.Dispose();
    hv_NumImageIDsWithFN.Dispose();
    hv_ImageIDsWithFP.Dispose();
    hv_NumImageIDsWithFP.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Update running measures for a pixel-based evaluation. 
  public void update_running_pixel_measures (HTuple hv_Samples, HTuple hv_Results, 
      HTuple hv_EvalParams, HTuple hv_RunningMeasures)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Annot=null, ho_Result=null, ho_ClsIgnore=null;
    HObject ho_ClsIgnoreTmp=null, ho_ClsAnnot=null, ho_ClsResult=null;
    HObject ho_TPReg=null, ho_FPReg=null, ho_FNReg=null;

    // Local control variables 

    HTuple hv_ClassIDs = new HTuple(), hv_IgnoreClassIDs = new HTuple();
    HTuple hv_Measures = new HTuple(), hv_CalcConfMatrix = new HTuple();
    HTuple hv_NumClasses = new HTuple(), hv_MaxId = new HTuple();
    HTuple hv_ConfMatrix = new HTuple(), hv_MapClassIDs = new HTuple();
    HTuple hv_ClsIdToClsIdx = new HTuple(), hv_TP = new HTuple();
    HTuple hv_FP = new HTuple(), hv_FN = new HTuple(), hv_SampleIndex = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
    HTuple hv_AnnotVals = new HTuple(), hv_ResultVals = new HTuple();
    HTuple hv_ConfTuple = new HTuple(), hv_ConfHist = new HTuple();
    HTuple hv_BinSize = new HTuple(), hv_ConfMatrixTmp = new HTuple();
    HTuple hv_IgnoreIndex = new HTuple(), hv_ClsIndex = new HTuple();
    HTuple hv_ClsId = new HTuple(), hv_ClsTP = new HTuple();
    HTuple hv_ClsFP = new HTuple(), hv_ClsFN = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Annot);
    HOperatorSet.GenEmptyObj(out ho_Result);
    HOperatorSet.GenEmptyObj(out ho_ClsIgnore);
    HOperatorSet.GenEmptyObj(out ho_ClsIgnoreTmp);
    HOperatorSet.GenEmptyObj(out ho_ClsAnnot);
    HOperatorSet.GenEmptyObj(out ho_ClsResult);
    HOperatorSet.GenEmptyObj(out ho_TPReg);
    HOperatorSet.GenEmptyObj(out ho_FPReg);
    HOperatorSet.GenEmptyObj(out ho_FNReg);
    //This procedure updates the RunningMeasures
    //for a pixel-based evaluation.
    //These measures are stored in the dictionary RunningMeasures and
    //updated by incorporating the Results the model obtained for the Samples.
    //
    //Get the class IDs.
    hv_ClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
    //Get the ignore class IDs.
    hv_IgnoreClassIDs.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
    //Check if we need to compute/update the confusion matrix.
    hv_Measures.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
    hv_CalcConfMatrix.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_CalcConfMatrix = (new HTuple(((hv_Measures.TupleFind(
        "pixel_confusion_matrix"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
        "all"))).TupleGreater(-1)));
    }
    //Get the number of classes.
    hv_NumClasses.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
    //Get the maximum class ID plus a possible ignore-class.
    hv_MaxId.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_MaxId = (hv_ClassIDs.TupleMax()
        )+(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
        0)));
    }
    //
    if ((int)(hv_CalcConfMatrix) != 0)
    {
      //Get the current confusion matrix.
      hv_ConfMatrix.Dispose();
      HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
      //Check if we need to map the class IDs.
      hv_MapClassIDs.Dispose();
      HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_id_mapping", 
          out hv_MapClassIDs);
      if ((int)(hv_MapClassIDs) != 0)
      {
        hv_ClsIdToClsIdx.Dispose();
        HOperatorSet.GetDictTuple(hv_EvalParams, "class_id_mapping", out hv_ClsIdToClsIdx);
        hv_NumClasses.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumClasses = (hv_ClsIdToClsIdx.TupleMax()
            )+1;
        }
      }
    }
    else
    {
      //Get the tuples for TP/FP/FN
      hv_TP.Dispose();
      HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
      hv_FP.Dispose();
      HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
      hv_FN.Dispose();
      HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
    }
    //
    //Loop over images, i.e. sample dicts.
    for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_Samples.TupleLength()
        ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
    {
      //Get annotation.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_Annot.Dispose();
      HOperatorSet.GetDictObject(out ho_Annot, hv_Samples.TupleSelect(hv_SampleIndex), 
          "segmentation_image");
      }
      //Get result.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_Result.Dispose();
      HOperatorSet.GetDictObject(out ho_Result, hv_Results.TupleSelect(hv_SampleIndex), 
          "segmentation_image");
      }
      //
      //Update the measures.
      if ((int)(hv_CalcConfMatrix) != 0)
      {
        //Get the ground truth and predicted class IDs of all pixels.
        hv_Rows.Dispose();hv_Columns.Dispose();
        HOperatorSet.GetRegionPoints(ho_Annot, out hv_Rows, out hv_Columns);
        hv_AnnotVals.Dispose();
        HOperatorSet.GetGrayval(ho_Annot, hv_Rows, hv_Columns, out hv_AnnotVals);
        hv_ResultVals.Dispose();
        HOperatorSet.GetGrayval(ho_Result, hv_Rows, hv_Columns, out hv_ResultVals);
        //Map the class IDs to class indices.
        if ((int)(hv_MapClassIDs) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_AnnotVals = hv_ClsIdToClsIdx.TupleSelect(
              hv_AnnotVals);
          hv_AnnotVals.Dispose();
          hv_AnnotVals = ExpTmpLocalVar_AnnotVals;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ResultVals = hv_ClsIdToClsIdx.TupleSelect(
              hv_ResultVals);
          hv_ResultVals.Dispose();
          hv_ResultVals = ExpTmpLocalVar_ResultVals;
          }
          }
        }
        //The ground truth and predicted IDs are accumulated
        //such that each confusion pair (class_i <-> class_j) gets a unique value.
        hv_ConfTuple.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ConfTuple = (hv_NumClasses*hv_AnnotVals)+hv_ResultVals;
        }
        //Compute the histogram of this confusion tuple.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ConfHist.Dispose();hv_BinSize.Dispose();
        HOperatorSet.TupleHistoRange(hv_ConfTuple, 0, (hv_NumClasses*hv_NumClasses)-1, 
            hv_NumClasses*hv_NumClasses, out hv_ConfHist, out hv_BinSize);
        }
        hv_ConfMatrixTmp.Dispose();
        HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, hv_ConfHist, out hv_ConfMatrixTmp);
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TransposeMatrix(hv_ConfMatrixTmp, out ExpTmpOutVar_0);
        hv_ConfMatrixTmp.Dispose();
        hv_ConfMatrixTmp = ExpTmpOutVar_0;
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.AddMatrix(hv_ConfMatrix, hv_ConfMatrixTmp, out ExpTmpOutVar_0);
        hv_ConfMatrix.Dispose();
        hv_ConfMatrix = ExpTmpOutVar_0;
        }
      }
      else
      {
        //Get the ignore region.
        ho_ClsIgnore.Dispose();
        HOperatorSet.GenEmptyRegion(out ho_ClsIgnore);
        for (hv_IgnoreIndex=0; (int)hv_IgnoreIndex<=(int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
            ))-1); hv_IgnoreIndex = (int)hv_IgnoreIndex + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ClsIgnoreTmp.Dispose();
          HOperatorSet.Threshold(ho_Annot, out ho_ClsIgnoreTmp, hv_IgnoreClassIDs.TupleSelect(
              hv_IgnoreIndex), hv_IgnoreClassIDs.TupleSelect(hv_IgnoreIndex));
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.Union2(ho_ClsIgnore, ho_ClsIgnoreTmp, out ExpTmpOutVar_0);
          ho_ClsIgnore.Dispose();
          ho_ClsIgnore = ExpTmpOutVar_0;
          }
        }
        //
        //Go through model classes.
        for (hv_ClsIndex=0; (int)hv_ClsIndex<=(int)((new HTuple(hv_ClassIDs.TupleLength()
            ))-1); hv_ClsIndex = (int)hv_ClsIndex + 1)
        {
          hv_ClsId.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClsId = hv_ClassIDs.TupleSelect(
              hv_ClsIndex);
          }
          //Get the annotated region for this class.
          ho_ClsAnnot.Dispose();
          HOperatorSet.Threshold(ho_Annot, out ho_ClsAnnot, hv_ClsId, hv_ClsId);
          //Get the result region for this class.
          ho_ClsResult.Dispose();
          HOperatorSet.Threshold(ho_Result, out ho_ClsResult, hv_ClsId, hv_ClsId);
          //The pixels in the ignore region should not be considered.
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.Difference(ho_ClsResult, ho_ClsIgnore, out ExpTmpOutVar_0);
          ho_ClsResult.Dispose();
          ho_ClsResult = ExpTmpOutVar_0;
          }
          //Get TP/FP/FN.
          ho_TPReg.Dispose();
          HOperatorSet.Intersection(ho_ClsAnnot, ho_ClsResult, out ho_TPReg);
          ho_FPReg.Dispose();
          HOperatorSet.Difference(ho_ClsResult, ho_ClsAnnot, out ho_FPReg);
          //We define false negatives as pixels that have been labeled as this class,
          //but not been correctly predicted.
          ho_FNReg.Dispose();
          HOperatorSet.Difference(ho_ClsAnnot, ho_ClsResult, out ho_FNReg);
          //Get corresponding pixel numbers and update.
          hv_ClsTP.Dispose();
          HOperatorSet.RegionFeatures(ho_TPReg, "area", out hv_ClsTP);
          hv_ClsFP.Dispose();
          HOperatorSet.RegionFeatures(ho_FPReg, "area", out hv_ClsFP);
          hv_ClsFN.Dispose();
          HOperatorSet.RegionFeatures(ho_FNReg, "area", out hv_ClsFN);
          if (hv_TP == null)
            hv_TP = new HTuple();
          hv_TP[hv_ClsIndex] = (hv_TP.TupleSelect(hv_ClsIndex))+hv_ClsTP;
          if (hv_FP == null)
            hv_FP = new HTuple();
          hv_FP[hv_ClsIndex] = (hv_FP.TupleSelect(hv_ClsIndex))+hv_ClsFP;
          if (hv_FN == null)
            hv_FN = new HTuple();
          hv_FN[hv_ClsIndex] = (hv_FN.TupleSelect(hv_ClsIndex))+hv_ClsFN;
        }
      }
    }
    //
    //Update running measures.
    if ((int)(hv_CalcConfMatrix) != 0)
    {
      HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", hv_ConfMatrix);
    }
    else
    {
      HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
      HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
      HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
    }
    //
    ho_Annot.Dispose();
    ho_Result.Dispose();
    ho_ClsIgnore.Dispose();
    ho_ClsIgnoreTmp.Dispose();
    ho_ClsAnnot.Dispose();
    ho_ClsResult.Dispose();
    ho_TPReg.Dispose();
    ho_FPReg.Dispose();
    ho_FNReg.Dispose();

    hv_ClassIDs.Dispose();
    hv_IgnoreClassIDs.Dispose();
    hv_Measures.Dispose();
    hv_CalcConfMatrix.Dispose();
    hv_NumClasses.Dispose();
    hv_MaxId.Dispose();
    hv_ConfMatrix.Dispose();
    hv_MapClassIDs.Dispose();
    hv_ClsIdToClsIdx.Dispose();
    hv_TP.Dispose();
    hv_FP.Dispose();
    hv_FN.Dispose();
    hv_SampleIndex.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_AnnotVals.Dispose();
    hv_ResultVals.Dispose();
    hv_ConfTuple.Dispose();
    hv_ConfHist.Dispose();
    hv_BinSize.Dispose();
    hv_ConfMatrixTmp.Dispose();
    hv_IgnoreIndex.Dispose();
    hv_ClsIndex.Dispose();
    hv_ClsId.Dispose();
    hv_ClsTP.Dispose();
    hv_ClsFP.Dispose();
    hv_ClsFN.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Update model parameters according to the change strategies. 
  public void update_train_dl_model_change_strategies (HTuple hv_DLModelHandle, HTuple hv_ChangeStrategyData, 
      HTuple hv_Epoch)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Enabled = new HTuple(), hv_ChangeStrategies = new HTuple();
    HTuple hv_Index = new HTuple(), hv_ChangeStrategy = new HTuple();
    HTuple hv_ModelParam = new HTuple(), hv_Epochs = new HTuple();
    HTuple hv_Values = new HTuple(), hv_Initial = new HTuple();
    HTuple hv_Greater = new HTuple(), hv_ValueIndex = new HTuple();
    HTuple hv_Value = new HTuple(), hv_InternalCurrent = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    //
    //This procedure updates all parameters according to the change strategies
    //with respect to the current iteration.
    //
    hv_Enabled.Dispose();
    HOperatorSet.GetDictTuple(hv_ChangeStrategyData, "enabled", out hv_Enabled);
    if ((int)(hv_Enabled.TupleNot()) != 0)
    {

      hv_Enabled.Dispose();
      hv_ChangeStrategies.Dispose();
      hv_Index.Dispose();
      hv_ChangeStrategy.Dispose();
      hv_ModelParam.Dispose();
      hv_Epochs.Dispose();
      hv_Values.Dispose();
      hv_Initial.Dispose();
      hv_Greater.Dispose();
      hv_ValueIndex.Dispose();
      hv_Value.Dispose();
      hv_InternalCurrent.Dispose();
      hv_Exception.Dispose();

      return;
    }
    //
    hv_ChangeStrategies.Dispose();
    HOperatorSet.GetDictTuple(hv_ChangeStrategyData, "strategies", out hv_ChangeStrategies);
    //
    //Update the parameter of each strategy.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ChangeStrategies.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_ChangeStrategy.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ChangeStrategy = hv_ChangeStrategies.TupleSelect(
          hv_Index);
      }
      hv_ModelParam.Dispose();
      HOperatorSet.GetDictTuple(hv_ChangeStrategy, "model_param", out hv_ModelParam);
      hv_Epochs.Dispose();
      HOperatorSet.GetDictTuple(hv_ChangeStrategy, "epochs", out hv_Epochs);
      hv_Values.Dispose();
      HOperatorSet.GetDictTuple(hv_ChangeStrategy, "values", out hv_Values);
      hv_Initial.Dispose();
      HOperatorSet.GetDictTuple(hv_ChangeStrategy, "initial_value", out hv_Initial);
      //Epochs defines at which epoch the change happens. Its sorting is enforced during initialization.
      hv_Greater.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Greater = hv_Epoch.TupleGreaterEqualElem(
          hv_Epochs);
      }
      hv_ValueIndex.Dispose();
      HOperatorSet.TupleFindLast(hv_Greater, 1, out hv_ValueIndex);
      if ((int)(new HTuple(hv_ValueIndex.TupleEqual(-1))) != 0)
      {
        hv_Value.Dispose();
        hv_Value = new HTuple(hv_Initial);
      }
      else
      {
        hv_Value.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Value = hv_Values.TupleSelect(
            hv_ValueIndex);
        }
      }
      //Check current value and only make changes if the value changed.
      try
      {
        hv_InternalCurrent.Dispose();
        HOperatorSet.GetDictTuple(hv_ChangeStrategy, "internal_current_value", out hv_InternalCurrent);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_InternalCurrent.Dispose();
        HOperatorSet.GetDlModelParam(hv_DLModelHandle, hv_ModelParam, out hv_InternalCurrent);
      }
      //If the current value differs from the new value we change it.
      if ((int)(new HTuple(((((hv_InternalCurrent.TupleNotEqualElem(hv_Value))).TupleSum()
          )).TupleGreater(0))) != 0)
      {
        HOperatorSet.SetDlModelParam(hv_DLModelHandle, hv_ModelParam, hv_Value);
      }
      //Store the new internal current value.
      HOperatorSet.SetDictTuple(hv_ChangeStrategy, "internal_current_value", hv_Value);
    }

    hv_Enabled.Dispose();
    hv_ChangeStrategies.Dispose();
    hv_Index.Dispose();
    hv_ChangeStrategy.Dispose();
    hv_ModelParam.Dispose();
    hv_Epochs.Dispose();
    hv_Values.Dispose();
    hv_Initial.Dispose();
    hv_Greater.Dispose();
    hv_ValueIndex.Dispose();
    hv_Value.Dispose();
    hv_InternalCurrent.Dispose();
    hv_Exception.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Serialize the model if a strategy applies to the current training status. 
  public void update_train_dl_model_serialization (HTuple hv_TrainParam, HTuple hv_SerializationData, 
      HTuple hv_Iteration, HTuple hv_NumIterations, HTuple hv_Epoch, HTuple hv_EvaluationResult, 
      HTuple hv_DLModelHandle, HTuple hv_TrainInfos, HTuple hv_EvaluationInfos)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_RawData = new HTuple(), hv_Types = new HTuple();
    HTuple hv_Strategies = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Type = new HTuple(), hv_Data = new HTuple();
    HTuple hv_Strategy = new HTuple(), hv_EvaluationComparisonKeys = new HTuple();
    HTuple hv_CurrentBest = new HTuple(), hv_Value = new HTuple();
    HTuple hv_Epochs = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_LastIndex = new HTuple(), hv_ValidEvaluationKeys = new HTuple();
    HTuple hv_FilenameModel = new HTuple(), hv_FilenameMetaData = new HTuple();
    // Initialize local and output iconic variables 
    //
    //Serialize the model if a strategy applies to the current training status.
    //
    hv_RawData.Dispose();
    HOperatorSet.GetDictTuple(hv_SerializationData, "raw_data", out hv_RawData);
    hv_Types.Dispose();
    HOperatorSet.GetDictTuple(hv_SerializationData, "types", out hv_Types);
    hv_Strategies.Dispose();
    HOperatorSet.GetDictTuple(hv_SerializationData, "strategies", out hv_Strategies);
    //
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Types.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
    {
      //
      hv_Type.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Type = hv_Types.TupleSelect(
          hv_Index);
      }
      hv_Data.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Data = hv_RawData.TupleSelect(
          hv_Index);
      }
      hv_Strategy.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Strategy = hv_Strategies.TupleSelect(
          hv_Index);
      }
      //
      if ((int)(new HTuple(hv_Type.TupleEqual("best"))) != 0)
      {
        //If there is no new evaluation result, we will not serialize.
        if ((int)(new HTuple((new HTuple(hv_EvaluationResult.TupleLength())).TupleEqual(
            0))) != 0)
        {
          continue;
        }
        //Get result and check if the new result is better than the serialized old result.
        hv_EvaluationComparisonKeys.Dispose();
        HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys", out hv_EvaluationComparisonKeys);
        hv_Value.Dispose();hv_ValidEvaluationKeys.Dispose();
        reduce_dl_evaluation_result(hv_EvaluationResult, hv_EvaluationComparisonKeys, 
            out hv_Value, out hv_ValidEvaluationKeys);
        hv_CurrentBest.Dispose();
        HOperatorSet.GetDictTuple(hv_Data, "best_value", out hv_CurrentBest);
        if ((int)((new HTuple(hv_CurrentBest.TupleEqual(-1))).TupleOr(new HTuple(hv_Value.TupleGreater(
            hv_CurrentBest)))) != 0)
        {
          HOperatorSet.SetDictTuple(hv_Data, "best_value", hv_Value);
          hv_FilenameModel.Dispose();hv_FilenameMetaData.Dispose();
          serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, hv_Strategy, 
              hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel, out hv_FilenameMetaData);
        }
      }
      else if ((int)(new HTuple(hv_Type.TupleEqual("final"))) != 0)
      {
        if ((int)(new HTuple(hv_Iteration.TupleEqual(hv_NumIterations-1))) != 0)
        {
          //Serialize final model.
          hv_FilenameModel.Dispose();hv_FilenameMetaData.Dispose();
          serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, hv_Strategy, 
              hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel, out hv_FilenameMetaData);
        }
      }
      else if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
      {
        //Check if the specified epoch is reached.
        hv_Epochs.Dispose();
        HOperatorSet.GetDictTuple(hv_Data, "epochs", out hv_Epochs);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices.Dispose();
        HOperatorSet.TupleFindLast(hv_Epoch.TupleLessEqualElem(hv_Epochs), 0, out hv_Indices);
        }
        //Also check that the last saved epoch is not the same.
        hv_LastIndex.Dispose();
        HOperatorSet.GetDictTuple(hv_Data, "last_epoch_index", out hv_LastIndex);
        if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
            0))) != 0)
        {
          //
          if ((int)((new HTuple(((hv_Indices.TupleSelect(0))).TupleGreater(-1))).TupleAnd(
              new HTuple(((hv_Indices.TupleSelect(0))).TupleNotEqual(hv_LastIndex)))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_Data, "last_epoch_index", hv_Indices.TupleSelect(
                0));
            }
            //Serialize final model.
            hv_FilenameModel.Dispose();hv_FilenameMetaData.Dispose();
            serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, hv_Strategy, 
                hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel, out hv_FilenameMetaData);
          }
        }
      }
    }
    //

    hv_RawData.Dispose();
    hv_Types.Dispose();
    hv_Strategies.Dispose();
    hv_Index.Dispose();
    hv_Type.Dispose();
    hv_Data.Dispose();
    hv_Strategy.Dispose();
    hv_EvaluationComparisonKeys.Dispose();
    hv_CurrentBest.Dispose();
    hv_Value.Dispose();
    hv_Epochs.Dispose();
    hv_Indices.Dispose();
    hv_LastIndex.Dispose();
    hv_ValidEvaluationKeys.Dispose();
    hv_FilenameModel.Dispose();
    hv_FilenameMetaData.Dispose();

    return;
  }

  // Chapter: Deep Learning / Evaluation
  // Short Description: Check that all given entries in EvalParams are valid. 
  public void validate_evaluation_param (HTuple hv_EvalParams, out HTuple hv_Valid, 
      out HTuple hv_Exception)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ClassIDsExist = new HTuple(), hv_ClassIDs = new HTuple();
    HTuple hv_NumClassesExist = new HTuple(), hv_NumClasses = new HTuple();
    HTuple hv_EvalInstancesExists = new HTuple(), hv_MeasuresExists = new HTuple();
    HTuple hv_Measures = new HTuple(), hv_EvaluateInstances = new HTuple();
    HTuple hv_ValidMeasures = new HTuple(), hv_IouThreshExists = new HTuple();
    HTuple hv_IouThresholds = new HTuple(), hv_MaxNumDetectionsExists = new HTuple();
    HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRangesExist = new HTuple();
    HTuple hv_AreaRanges = new HTuple(), hv_AreaKeysExist = new HTuple();
    HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
    HTuple hv_MaxAreas = new HTuple(), hv_InstanceTypeExists = new HTuple();
    HTuple hv_InstanceType = new HTuple(), hv_ValidInstanceTypes = new HTuple();
    HTuple hv_AllocationBlockLengthExists = new HTuple(), hv_AllocationBlockLength = new HTuple();
    HTuple hv_DetailedEvaluationExists = new HTuple(), hv_DetailedEvaluation = new HTuple();
    HTuple hv_IgnoreClassIDsExist = new HTuple(), hv_ValidMeasuresString = new HTuple();
    HTuple hv_Idx = new HTuple(), hv_ValidMeasure = new HTuple();
    // Initialize local and output iconic variables 
    hv_Valid = new HTuple();
    hv_Exception = new HTuple();
    //
    //This procedure checks if the dictionary EvalParams
    //contains all necessary parameters and if they are valid (type, range, ...).
    //
    hv_Valid.Dispose();
    hv_Valid = 0;
    hv_Exception.Dispose();
    hv_Exception = "";
    //Check class IDs.
    hv_ClassIDsExist.Dispose();
    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids", out hv_ClassIDsExist);
    if ((int)(hv_ClassIDsExist.TupleNot()) != 0)
    {
      hv_Exception.Dispose();
      hv_Exception = "The evaluation parameters need a key-value pair for 'class_ids'";

      hv_ClassIDsExist.Dispose();
      hv_ClassIDs.Dispose();
      hv_NumClassesExist.Dispose();
      hv_NumClasses.Dispose();
      hv_EvalInstancesExists.Dispose();
      hv_MeasuresExists.Dispose();
      hv_Measures.Dispose();
      hv_EvaluateInstances.Dispose();
      hv_ValidMeasures.Dispose();
      hv_IouThreshExists.Dispose();
      hv_IouThresholds.Dispose();
      hv_MaxNumDetectionsExists.Dispose();
      hv_MaxNumDetections.Dispose();
      hv_AreaRangesExist.Dispose();
      hv_AreaRanges.Dispose();
      hv_AreaKeysExist.Dispose();
      hv_AreaNames.Dispose();
      hv_MinAreas.Dispose();
      hv_MaxAreas.Dispose();
      hv_InstanceTypeExists.Dispose();
      hv_InstanceType.Dispose();
      hv_ValidInstanceTypes.Dispose();
      hv_AllocationBlockLengthExists.Dispose();
      hv_AllocationBlockLength.Dispose();
      hv_DetailedEvaluationExists.Dispose();
      hv_DetailedEvaluation.Dispose();
      hv_IgnoreClassIDsExist.Dispose();
      hv_ValidMeasuresString.Dispose();
      hv_Idx.Dispose();
      hv_ValidMeasure.Dispose();

      return;
    }
    else
    {
      hv_ClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
      if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleLess(1))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "'class_ids' should have at least length 1";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
      if ((int)(new HTuple(((hv_ClassIDs.TupleIsIntElem())).TupleNotEqual(HTuple.TupleGenConst(
          new HTuple(hv_ClassIDs.TupleLength()),1)))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "'class_ids' should be of type int";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
      if ((int)(new HTuple(((((hv_ClassIDs.TupleLessElem(0))).TupleFind(1))).TupleGreater(
          -1))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "'class_ids' should be positive or zero";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
    }
    //Check the entry num_classes.
    hv_NumClassesExist.Dispose();
    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "num_classes", out hv_NumClassesExist);
    if ((int)(hv_NumClassesExist.TupleNot()) != 0)
    {
      hv_Exception.Dispose();
      hv_Exception = "The evaluation parameters need a key-value pair for 'num_classes'";

      hv_ClassIDsExist.Dispose();
      hv_ClassIDs.Dispose();
      hv_NumClassesExist.Dispose();
      hv_NumClasses.Dispose();
      hv_EvalInstancesExists.Dispose();
      hv_MeasuresExists.Dispose();
      hv_Measures.Dispose();
      hv_EvaluateInstances.Dispose();
      hv_ValidMeasures.Dispose();
      hv_IouThreshExists.Dispose();
      hv_IouThresholds.Dispose();
      hv_MaxNumDetectionsExists.Dispose();
      hv_MaxNumDetections.Dispose();
      hv_AreaRangesExist.Dispose();
      hv_AreaRanges.Dispose();
      hv_AreaKeysExist.Dispose();
      hv_AreaNames.Dispose();
      hv_MinAreas.Dispose();
      hv_MaxAreas.Dispose();
      hv_InstanceTypeExists.Dispose();
      hv_InstanceType.Dispose();
      hv_ValidInstanceTypes.Dispose();
      hv_AllocationBlockLengthExists.Dispose();
      hv_AllocationBlockLength.Dispose();
      hv_DetailedEvaluationExists.Dispose();
      hv_DetailedEvaluation.Dispose();
      hv_IgnoreClassIDsExist.Dispose();
      hv_ValidMeasuresString.Dispose();
      hv_Idx.Dispose();
      hv_ValidMeasure.Dispose();

      return;
    }
    else
    {
      hv_NumClasses.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
      if ((int)(new HTuple((new HTuple(hv_NumClasses.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "'num_classes' should have length 1";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
      if ((int)(new HTuple(((hv_NumClasses.TupleType())).TupleNotEqual((new HTuple((new HTuple(1)).TupleInt()
          )).TupleType()))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "'num_classes' should be of type int";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
      if ((int)(new HTuple(hv_NumClasses.TupleLess(1))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "'num_classes' should be at least 1";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
    }
    //Check that num_classes is equal to |class_ids|.
    if ((int)(new HTuple(hv_NumClasses.TupleNotEqual(new HTuple(hv_ClassIDs.TupleLength()
        )))) != 0)
    {
      hv_Exception.Dispose();
      hv_Exception = "'num_classes' has to be set to the number of 'class_ids'";

      hv_ClassIDsExist.Dispose();
      hv_ClassIDs.Dispose();
      hv_NumClassesExist.Dispose();
      hv_NumClasses.Dispose();
      hv_EvalInstancesExists.Dispose();
      hv_MeasuresExists.Dispose();
      hv_Measures.Dispose();
      hv_EvaluateInstances.Dispose();
      hv_ValidMeasures.Dispose();
      hv_IouThreshExists.Dispose();
      hv_IouThresholds.Dispose();
      hv_MaxNumDetectionsExists.Dispose();
      hv_MaxNumDetections.Dispose();
      hv_AreaRangesExist.Dispose();
      hv_AreaRanges.Dispose();
      hv_AreaKeysExist.Dispose();
      hv_AreaNames.Dispose();
      hv_MinAreas.Dispose();
      hv_MaxAreas.Dispose();
      hv_InstanceTypeExists.Dispose();
      hv_InstanceType.Dispose();
      hv_ValidInstanceTypes.Dispose();
      hv_AllocationBlockLengthExists.Dispose();
      hv_AllocationBlockLength.Dispose();
      hv_DetailedEvaluationExists.Dispose();
      hv_DetailedEvaluation.Dispose();
      hv_IgnoreClassIDsExist.Dispose();
      hv_ValidMeasuresString.Dispose();
      hv_Idx.Dispose();
      hv_ValidMeasure.Dispose();

      return;
    }
    //Check the entry 'evaluate_instances'.
    hv_EvalInstancesExists.Dispose();
    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluate_instances", 
        out hv_EvalInstancesExists);
    if ((int)(hv_EvalInstancesExists.TupleNot()) != 0)
    {
      hv_Exception.Dispose();
      hv_Exception = "The evaluation parameters need a key-value pair for 'evaluate_instances'";

      hv_ClassIDsExist.Dispose();
      hv_ClassIDs.Dispose();
      hv_NumClassesExist.Dispose();
      hv_NumClasses.Dispose();
      hv_EvalInstancesExists.Dispose();
      hv_MeasuresExists.Dispose();
      hv_Measures.Dispose();
      hv_EvaluateInstances.Dispose();
      hv_ValidMeasures.Dispose();
      hv_IouThreshExists.Dispose();
      hv_IouThresholds.Dispose();
      hv_MaxNumDetectionsExists.Dispose();
      hv_MaxNumDetections.Dispose();
      hv_AreaRangesExist.Dispose();
      hv_AreaRanges.Dispose();
      hv_AreaKeysExist.Dispose();
      hv_AreaNames.Dispose();
      hv_MinAreas.Dispose();
      hv_MaxAreas.Dispose();
      hv_InstanceTypeExists.Dispose();
      hv_InstanceType.Dispose();
      hv_ValidInstanceTypes.Dispose();
      hv_AllocationBlockLengthExists.Dispose();
      hv_AllocationBlockLength.Dispose();
      hv_DetailedEvaluationExists.Dispose();
      hv_DetailedEvaluation.Dispose();
      hv_IgnoreClassIDsExist.Dispose();
      hv_ValidMeasuresString.Dispose();
      hv_Idx.Dispose();
      hv_ValidMeasure.Dispose();

      return;
    }
    hv_MeasuresExists.Dispose();
    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "measures", out hv_MeasuresExists);
    if ((int)(hv_MeasuresExists.TupleNot()) != 0)
    {
      hv_Exception.Dispose();
      hv_Exception = "The evaluation parameters need a key-value pair for 'measures'";

      hv_ClassIDsExist.Dispose();
      hv_ClassIDs.Dispose();
      hv_NumClassesExist.Dispose();
      hv_NumClasses.Dispose();
      hv_EvalInstancesExists.Dispose();
      hv_MeasuresExists.Dispose();
      hv_Measures.Dispose();
      hv_EvaluateInstances.Dispose();
      hv_ValidMeasures.Dispose();
      hv_IouThreshExists.Dispose();
      hv_IouThresholds.Dispose();
      hv_MaxNumDetectionsExists.Dispose();
      hv_MaxNumDetections.Dispose();
      hv_AreaRangesExist.Dispose();
      hv_AreaRanges.Dispose();
      hv_AreaKeysExist.Dispose();
      hv_AreaNames.Dispose();
      hv_MinAreas.Dispose();
      hv_MaxAreas.Dispose();
      hv_InstanceTypeExists.Dispose();
      hv_InstanceType.Dispose();
      hv_ValidInstanceTypes.Dispose();
      hv_AllocationBlockLengthExists.Dispose();
      hv_AllocationBlockLength.Dispose();
      hv_DetailedEvaluationExists.Dispose();
      hv_DetailedEvaluation.Dispose();
      hv_IgnoreClassIDsExist.Dispose();
      hv_ValidMeasuresString.Dispose();
      hv_Idx.Dispose();
      hv_ValidMeasure.Dispose();

      return;
    }
    else
    {
      hv_Measures.Dispose();
      HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
      if ((int)(new HTuple((new HTuple(hv_Measures.TupleLength())).TupleEqual(0))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "'measures' should contain at least one entry";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
    }
    //Checks dependent on evaluation-type, encoded by 'evaluate_instances'.
    hv_EvaluateInstances.Dispose();
    HOperatorSet.GetDictTuple(hv_EvalParams, "evaluate_instances", out hv_EvaluateInstances);
    if ((int)(hv_EvaluateInstances) != 0)
    {
      //Instance-based evaluation.
      //Add instance measures.
      hv_ValidMeasures.Dispose();
      hv_ValidMeasures = new HTuple();
      hv_ValidMeasures[0] = "all";
      hv_ValidMeasures[1] = "mean_ap";
      //
      //Check if the entry 'iou_threshold' is present.
      hv_IouThreshExists.Dispose();
      HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "iou_threshold", out hv_IouThreshExists);
      if ((int)(hv_IouThreshExists.TupleNot()) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "The evaluation parameters need a key-value pair for 'iou_threshold'";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
      else
      {
        hv_IouThresholds.Dispose();
        HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IouThresholds);
        //Check the length of 'iou_threshold'.
        if ((int)(new HTuple((new HTuple(hv_IouThresholds.TupleLength())).TupleLess(
            1))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'iou_threshold' is empty";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        if ((int)(new HTuple(((hv_IouThresholds.TupleIsRealElem())).TupleNotEqual(
            HTuple.TupleGenConst(new HTuple(hv_IouThresholds.TupleLength()),1)))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'iou_threshold' should be of type real";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        //Check if the IoU thresholds are within (0.0, 1.0).
        if ((int)((new HTuple(((hv_IouThresholds.TupleMin())).TupleLessEqual(0.0))).TupleOr(
            new HTuple(((hv_IouThresholds.TupleMax())).TupleGreaterEqual(1.0)))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = new HTuple("Invalid 'iou_threshold', not in range (0.0, 1.0)");

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
      }
      //
      //Check if the entry 'max_num_detections' is present.
      hv_MaxNumDetectionsExists.Dispose();
      HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "max_num_detections", 
          out hv_MaxNumDetectionsExists);
      if ((int)(hv_MaxNumDetectionsExists.TupleNot()) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "The evaluation parameters need a key-value pair for 'max_num_detections'";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
      else
      {
        hv_MaxNumDetections.Dispose();
        HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
        //Check the length of 'max_num_detections'.
        if ((int)(new HTuple((new HTuple(hv_MaxNumDetections.TupleLength())).TupleLess(
            1))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'max_num_detections' is empty";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        if ((int)(new HTuple(((hv_MaxNumDetections.TupleIsIntElem())).TupleNotEqual(
            HTuple.TupleGenConst(new HTuple(hv_MaxNumDetections.TupleLength()),1)))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'max_num_detections' should be of type int";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        //Check if 'max_num_detections' is -1 (to use all detections) or positive.
        if ((int)((new HTuple(((hv_MaxNumDetections.TupleMin())).TupleLess(-1))).TupleOr(
            new HTuple(((hv_MaxNumDetections.TupleFind(0))).TupleGreater(-1)))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'max_num_detections' should be -1 or positive";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
      }
      //
      //Check if the entry 'area_ranges' is present.
      hv_AreaRangesExist.Dispose();
      HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "area_ranges", out hv_AreaRangesExist);
      if ((int)(hv_AreaRangesExist.TupleNot()) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "The evaluation parameters need a key-value pair for 'area_ranges'";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
      else
      {
        //Check if the entry 'area_ranges' is a dict.
        hv_AreaRanges.Dispose();
        HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
        if ((int)(new HTuple(((hv_AreaRanges.TupleSemType())).TupleNotEqual("dict"))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'area_ranges' must be a dict";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        //Check that the necessary keys exist.
        hv_AreaKeysExist.Dispose();
        HOperatorSet.GetDictParam(hv_AreaRanges, "key_exists", ((new HTuple("name")).TupleConcat(
            "min")).TupleConcat("max"), out hv_AreaKeysExist);
        if ((int)(((hv_AreaKeysExist.TupleSelect(0))).TupleNot()) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'area_ranges' need a key-value pair for 'name'";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        if ((int)(((hv_AreaKeysExist.TupleSelect(1))).TupleNot()) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'area_ranges' need a key-value pair for 'min'";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        if ((int)(((hv_AreaKeysExist.TupleSelect(2))).TupleNot()) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'area_ranges' need a key-value pair for 'max'";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        //Check the lengths of the area keys.
        hv_AreaNames.Dispose();
        HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
        if ((int)(new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleLess(1))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'area_ranges': 'name' is empty";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        hv_MinAreas.Dispose();
        HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
        if ((int)(new HTuple((new HTuple(hv_MinAreas.TupleLength())).TupleLess(1))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'area_ranges': 'min' is empty";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        hv_MaxAreas.Dispose();
        HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
        if ((int)(new HTuple((new HTuple(hv_MaxAreas.TupleLength())).TupleLess(1))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'area_ranges': 'max' is empty";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        if ((int)((new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleNotEqual(
            new HTuple(hv_MinAreas.TupleLength())))).TupleOr(new HTuple((new HTuple(hv_AreaNames.TupleLength()
            )).TupleNotEqual(new HTuple(hv_MaxAreas.TupleLength()))))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = new HTuple("'area_ranges': 'name', 'min' and 'max' must have the same length");

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        //Check values of min, max.
        if ((int)(new HTuple(((((hv_MinAreas.TupleGreaterEqualElem(hv_MaxAreas))).TupleFind(
            1))).TupleGreater(-1))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'area_ranges': 'min' must be elementwise smaller than 'max'";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
      }
      //
      //Check if instance-type is valid.
      hv_InstanceTypeExists.Dispose();
      HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "instance_type", out hv_InstanceTypeExists);
      if ((int)(hv_InstanceTypeExists.TupleNot()) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "The evaluation parameters need a key-value pair for 'instance_type'";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
      else
      {
        hv_InstanceType.Dispose();
        HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
        //At the moment we only support rectangle1-evaluation.
        hv_ValidInstanceTypes.Dispose();
        hv_ValidInstanceTypes = "rectangle1";
        if ((int)(new HTuple(((hv_ValidInstanceTypes.TupleFind(hv_InstanceType))).TupleEqual(
            -1))) != 0)
        {
          hv_Exception.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Exception = ("Invalid instance type '"+hv_InstanceType)+"'";
          }

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
      }
      //
      //Check if the entry 'allocation_block_length' is present and valid.
      hv_AllocationBlockLengthExists.Dispose();
      HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "allocation_block_length", 
          out hv_AllocationBlockLengthExists);
      if ((int)(hv_AllocationBlockLengthExists.TupleNot()) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "The evaluation parameters need a key-value pair for 'allocation_block_length'";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
      else
      {
        hv_AllocationBlockLength.Dispose();
        HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
        //Check the length of 'allocation_block_length'.
        if ((int)(new HTuple((new HTuple(hv_AllocationBlockLength.TupleLength())).TupleNotEqual(
            1))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'allocation_block_length' should have length 1";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        //Check the type of 'allocation_block_length'.
        if ((int)(new HTuple(((hv_AllocationBlockLength.TupleType())).TupleNotEqual(
            (new HTuple((new HTuple(0)).TupleInt())).TupleType()))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'allocation_block_length' should be of type int";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        //Check if 'allocation_block_length' is larger than zero.
        if ((int)(new HTuple(hv_AllocationBlockLength.TupleLess(1))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'allocation_block_length' should be positive";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
      }
      //
      //Check if the entry 'detailed_evaluation' is valid if present.
      hv_DetailedEvaluationExists.Dispose();
      HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation", 
          out hv_DetailedEvaluationExists);
      if ((int)(hv_DetailedEvaluationExists.TupleNot()) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "The evaluation parameters need a key-value pair for 'detailed_evaluation'";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
      else
      {
        hv_DetailedEvaluation.Dispose();
        HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
        //Check the length of 'detailed_evaluation'.
        if ((int)(new HTuple((new HTuple(hv_DetailedEvaluation.TupleLength())).TupleNotEqual(
            1))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'detailed_evaluation' should have length 1";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        //Check the type of 'detailed_evaluation'.
        if ((int)(new HTuple(((hv_DetailedEvaluation.TupleType())).TupleNotEqual(
            (new HTuple(1)).TupleType()))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'detailed_evaluation' should be of type int";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
        //Check if 'detailed_evaluation' is larger than zero.
        if ((int)((new HTuple(hv_DetailedEvaluation.TupleNotEqual(0))).TupleAnd(new HTuple(hv_DetailedEvaluation.TupleNotEqual(
            1)))) != 0)
        {
          hv_Exception.Dispose();
          hv_Exception = "'detailed_evaluation' should be zero or one";

          hv_ClassIDsExist.Dispose();
          hv_ClassIDs.Dispose();
          hv_NumClassesExist.Dispose();
          hv_NumClasses.Dispose();
          hv_EvalInstancesExists.Dispose();
          hv_MeasuresExists.Dispose();
          hv_Measures.Dispose();
          hv_EvaluateInstances.Dispose();
          hv_ValidMeasures.Dispose();
          hv_IouThreshExists.Dispose();
          hv_IouThresholds.Dispose();
          hv_MaxNumDetectionsExists.Dispose();
          hv_MaxNumDetections.Dispose();
          hv_AreaRangesExist.Dispose();
          hv_AreaRanges.Dispose();
          hv_AreaKeysExist.Dispose();
          hv_AreaNames.Dispose();
          hv_MinAreas.Dispose();
          hv_MaxAreas.Dispose();
          hv_InstanceTypeExists.Dispose();
          hv_InstanceType.Dispose();
          hv_ValidInstanceTypes.Dispose();
          hv_AllocationBlockLengthExists.Dispose();
          hv_AllocationBlockLength.Dispose();
          hv_DetailedEvaluationExists.Dispose();
          hv_DetailedEvaluation.Dispose();
          hv_IgnoreClassIDsExist.Dispose();
          hv_ValidMeasuresString.Dispose();
          hv_Idx.Dispose();
          hv_ValidMeasure.Dispose();

          return;
        }
      }
    }
    else
    {
      //Pixel-based evaluation.
      hv_ValidMeasures.Dispose();
      hv_ValidMeasures = new HTuple();
      hv_ValidMeasures[0] = "all";
      hv_ValidMeasures[1] = "pixel_accuracy";
      hv_ValidMeasures[2] = "mean_accuracy";
      hv_ValidMeasures[3] = "mean_iou";
      hv_ValidMeasures[4] = "class_iou";
      hv_ValidMeasures[5] = "class_pixel_accuracy";
      hv_ValidMeasures[6] = "pixel_confusion_matrix";
      hv_ValidMeasures[7] = "frequency_weighted_iou";
      //
      //Check if the entry 'ignore_class_ids' exists.
      hv_IgnoreClassIDsExist.Dispose();
      HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "ignore_class_ids", 
          out hv_IgnoreClassIDsExist);
      if ((int)(hv_IgnoreClassIDsExist.TupleNot()) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "The evaluation parameters need a key-value pair for 'ignore_class_ids'";

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
    }
    //Check measures.
    hv_ValidMeasuresString.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ValidMeasuresString = HTuple.TupleGenConst(
        ((new HTuple(hv_ValidMeasures.TupleLength()))*2)-1,new HTuple("','"));
    }
    if (hv_ValidMeasuresString == null)
      hv_ValidMeasuresString = new HTuple();
    hv_ValidMeasuresString[HTuple.TupleGenSequence(0,(new HTuple(hv_ValidMeasuresString.TupleLength()
        ))-1,2)] = hv_ValidMeasures;
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    {
    HTuple 
      ExpTmpLocalVar_ValidMeasuresString = hv_ValidMeasuresString.TupleSum()
        ;
    hv_ValidMeasuresString.Dispose();
    hv_ValidMeasuresString = ExpTmpLocalVar_ValidMeasuresString;
    }
    }
    for (hv_Idx=0; (int)hv_Idx<=(int)((new HTuple(hv_Measures.TupleLength()))-1); hv_Idx = (int)hv_Idx + 1)
    {
      hv_ValidMeasure.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ValidMeasure = ((hv_ValidMeasures.TupleFind(
          hv_Measures.TupleSelect(hv_Idx)))).TupleGreaterElem(-1);
      }
      if ((int)(hv_ValidMeasure.TupleNot()) != 0)
      {
        hv_Exception.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Exception = ((("Invalid measure '"+(hv_Measures.TupleSelect(
            hv_Idx)))+new HTuple("', choose one of ['"))+hv_ValidMeasuresString)+"']";
        }

        hv_ClassIDsExist.Dispose();
        hv_ClassIDs.Dispose();
        hv_NumClassesExist.Dispose();
        hv_NumClasses.Dispose();
        hv_EvalInstancesExists.Dispose();
        hv_MeasuresExists.Dispose();
        hv_Measures.Dispose();
        hv_EvaluateInstances.Dispose();
        hv_ValidMeasures.Dispose();
        hv_IouThreshExists.Dispose();
        hv_IouThresholds.Dispose();
        hv_MaxNumDetectionsExists.Dispose();
        hv_MaxNumDetections.Dispose();
        hv_AreaRangesExist.Dispose();
        hv_AreaRanges.Dispose();
        hv_AreaKeysExist.Dispose();
        hv_AreaNames.Dispose();
        hv_MinAreas.Dispose();
        hv_MaxAreas.Dispose();
        hv_InstanceTypeExists.Dispose();
        hv_InstanceType.Dispose();
        hv_ValidInstanceTypes.Dispose();
        hv_AllocationBlockLengthExists.Dispose();
        hv_AllocationBlockLength.Dispose();
        hv_DetailedEvaluationExists.Dispose();
        hv_DetailedEvaluation.Dispose();
        hv_IgnoreClassIDsExist.Dispose();
        hv_ValidMeasuresString.Dispose();
        hv_Idx.Dispose();
        hv_ValidMeasure.Dispose();

        return;
      }
    }
    //
    //Done with checks.
    hv_Valid.Dispose();
    hv_Valid = 1;

    hv_ClassIDsExist.Dispose();
    hv_ClassIDs.Dispose();
    hv_NumClassesExist.Dispose();
    hv_NumClasses.Dispose();
    hv_EvalInstancesExists.Dispose();
    hv_MeasuresExists.Dispose();
    hv_Measures.Dispose();
    hv_EvaluateInstances.Dispose();
    hv_ValidMeasures.Dispose();
    hv_IouThreshExists.Dispose();
    hv_IouThresholds.Dispose();
    hv_MaxNumDetectionsExists.Dispose();
    hv_MaxNumDetections.Dispose();
    hv_AreaRangesExist.Dispose();
    hv_AreaRanges.Dispose();
    hv_AreaKeysExist.Dispose();
    hv_AreaNames.Dispose();
    hv_MinAreas.Dispose();
    hv_MaxAreas.Dispose();
    hv_InstanceTypeExists.Dispose();
    hv_InstanceType.Dispose();
    hv_ValidInstanceTypes.Dispose();
    hv_AllocationBlockLengthExists.Dispose();
    hv_AllocationBlockLength.Dispose();
    hv_DetailedEvaluationExists.Dispose();
    hv_DetailedEvaluation.Dispose();
    hv_IgnoreClassIDsExist.Dispose();
    hv_ValidMeasuresString.Dispose();
    hv_Idx.Dispose();
    hv_ValidMeasure.Dispose();

    return;
  }

  // Chapter: Graphics / 3D Scene
  // Short Description: Visualize the poses that were used to calculate the touching point, and the result. 
  public void visualize_calibrated_touching_point (HTuple hv_RobotTouchingPointInToolCoordinates, 
      HTupleVector/*{eTupleVector,Dim=1}*/ hvec_ToolInBasePosesTouchingPoint, HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OM3DToolTouchingPoint = new HTuple();
    HTuple hv_Instructions = new HTuple(), hv_PoseIn = new HTuple();
    HTuple hv_GenParamName = new HTuple(), hv_GenParamValue = new HTuple();
    HTuple hv_Title = new HTuple(), hv_NumOM3D = new HTuple();
    HTuple hv_Label = new HTuple(), hv_PoseOut = new HTuple();
    // Initialize local and output iconic variables 
    //
    //Create 3D object models.
    hv_OM3DToolTouchingPoint.Dispose();
    gen_tool_to_touching_point_object_model_3d(hvec_ToolInBasePosesTouchingPoint, 
        hv_RobotTouchingPointInToolCoordinates, out hv_OM3DToolTouchingPoint);
    //
    //Prepare parameters for visualize_object_model_3d.
    //Instructions.
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[0] = "Rotate: Left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[1] = "Zoom:   Shift + left button";
    if (hv_Instructions == null)
      hv_Instructions = new HTuple();
    hv_Instructions[2] = "Move:   Ctrl  + left button";
    //3D visualization pose.
    hv_PoseIn.Dispose();
    HOperatorSet.CreatePose(0.326, 0.016, 3.137, 83.33, 341.96, 99.32, "Rp+T", "gba", 
        "point", out hv_PoseIn);
    //
    hv_GenParamName.Dispose();
    hv_GenParamName = new HTuple();
    hv_GenParamName[0] = "color_0";
    hv_GenParamName[1] = "color_1";
    hv_GenParamName[2] = "color_2";
    hv_GenParamName[3] = "color_3";
    hv_GenParamName[4] = "color_4";
    hv_GenParamName[5] = "color_5";
    hv_GenParamName[6] = "color_6";
    hv_GenParamName[7] = "color_7";
    hv_GenParamName[8] = "color_8";
    hv_GenParamName[9] = "color_9";
    hv_GenParamName[10] = "color_10";
    hv_GenParamName[11] = "color_11";
    hv_GenParamValue.Dispose();
    hv_GenParamValue = new HTuple();
    hv_GenParamValue[0] = "red";
    hv_GenParamValue[1] = "green";
    hv_GenParamValue[2] = "blue";
    hv_GenParamValue[3] = "magenta";
    hv_GenParamValue[4] = "red";
    hv_GenParamValue[5] = "green";
    hv_GenParamValue[6] = "blue";
    hv_GenParamValue[7] = "magenta";
    hv_GenParamValue[8] = "red";
    hv_GenParamValue[9] = "green";
    hv_GenParamValue[10] = "blue";
    hv_GenParamValue[11] = "magenta";
    //
    hv_Title.Dispose();
    hv_Title = "Visualization of the read poses. The magenta lines connect the";
    if (hv_Title == null)
      hv_Title = new HTuple();
    hv_Title[1] = "tool coordinate system with the touching point. They intersect";
    if (hv_Title == null)
      hv_Title = new HTuple();
    hv_Title[2] = "in the approached point in the plane. Calculated touching point";
    if (hv_Title == null)
      hv_Title = new HTuple();
    hv_Title[3] = "coordinates with respect to the robot's tool: ";
    if (hv_Title == null)
      hv_Title = new HTuple();
    hv_Title[4] = ((((("X: "+((((hv_RobotTouchingPointInToolCoordinates.TupleSelect(
        0))*1000)).TupleString(".2f")))+new HTuple(" mm, Y: "))+((((hv_RobotTouchingPointInToolCoordinates.TupleSelect(
        1))*1000)).TupleString(".2f")))+new HTuple(" mm, Z: "))+((((hv_RobotTouchingPointInToolCoordinates.TupleSelect(
        2))*1000)).TupleString(".2f")))+" mm";
    //Labels for the visualized 3D object models.
    hv_NumOM3D.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumOM3D = new HTuple(hv_OM3DToolTouchingPoint.TupleLength()
        );
    }
    hv_Label.Dispose();
    HOperatorSet.TupleGenConst(hv_NumOM3D, "", out hv_Label);
    if (hv_Label == null)
      hv_Label = new HTuple();
    hv_Label[2] = "ToolInBasePosesTouchingPoint 1";
    if (hv_Label == null)
      hv_Label = new HTuple();
    hv_Label[6] = "ToolInBasePosesTouchingPoint 2";
    if (hv_Label == null)
      hv_Label = new HTuple();
    hv_Label[10] = "ToolInBasePosesTouchingPoint 3";
    //
    hv_PoseOut.Dispose();
    visualize_object_model_3d(hv_WindowHandle, hv_OM3DToolTouchingPoint, new HTuple(), 
        hv_PoseIn, hv_GenParamName, hv_GenParamValue, hv_Title, hv_Label, hv_Instructions, 
        out hv_PoseOut);
    //
    //Clean up.
    HOperatorSet.ClearObjectModel3d(hv_OM3DToolTouchingPoint);

    hv_OM3DToolTouchingPoint.Dispose();
    hv_Instructions.Dispose();
    hv_PoseIn.Dispose();
    hv_GenParamName.Dispose();
    hv_GenParamValue.Dispose();
    hv_Title.Dispose();
    hv_NumOM3D.Dispose();
    hv_Label.Dispose();
    hv_PoseOut.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Interactively display 3D object models 
  public void visualize_object_model_3d (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
      HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue, 
      HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, out HTuple hv_PoseOut)
  {



    // Local iconic variables 

    HObject ho_Image=null, ho_ImageDump=null;

    // Local control variables 

    HTuple ExpTmpLocalVar_gDispObjOffset = new HTuple();
    HTuple ExpTmpLocalVar_gLabelsDecor = new HTuple(), ExpTmpLocalVar_gInfoDecor = new HTuple();
    HTuple ExpTmpLocalVar_gInfoPos = new HTuple(), ExpTmpLocalVar_gTitlePos = new HTuple();
    HTuple ExpTmpLocalVar_gTitleDecor = new HTuple(), ExpTmpLocalVar_gTerminationButtonLabel = new HTuple();
    HTuple ExpTmpLocalVar_gAlphaDeselected = new HTuple();
    HTuple ExpTmpLocalVar_gIsSinglePose = new HTuple(), ExpTmpLocalVar_gUsesOpenGL = new HTuple();
    HTuple hv_Scene3DTest = new HTuple(), hv_Scene3D = new HTuple();
    HTuple hv_WindowHandleBuffer = new HTuple(), hv_TrackballSize = new HTuple();
    HTuple hv_VirtualTrackball = new HTuple(), hv_MouseMapping = new HTuple();
    HTuple hv_WaitForButtonRelease = new HTuple(), hv_MaxNumModels = new HTuple();
    HTuple hv_WindowCenteredRotation = new HTuple(), hv_NumModels = new HTuple();
    HTuple hv_SelectedObject = new HTuple(), hv_ClipRegion = new HTuple();
    HTuple hv_CPLength = new HTuple(), hv_RowNotUsed = new HTuple();
    HTuple hv_ColumnNotUsed = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_WPRow1 = new HTuple();
    HTuple hv_WPColumn1 = new HTuple(), hv_WPRow2 = new HTuple();
    HTuple hv_WPColumn2 = new HTuple(), hv_CamParamValue = new HTuple();
    HTuple hv_CamWidth = new HTuple(), hv_CamHeight = new HTuple();
    HTuple hv_Scale = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_DispBackground = new HTuple(), hv_Mask = new HTuple();
    HTuple hv_Center = new HTuple(), hv_Poses = new HTuple();
    HTuple hv_HomMat3Ds = new HTuple(), hv_Sequence = new HTuple();
    HTuple hv_PoseEstimated = new HTuple(), hv_Font = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_OpenGLInfo = new HTuple();
    HTuple hv_DummyObjectModel3D = new HTuple(), hv_CameraIndexTest = new HTuple();
    HTuple hv_PoseTest = new HTuple(), hv_InstanceIndexTest = new HTuple();
    HTuple hv_MinImageSize = new HTuple(), hv_TrackballRadiusPixel = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv_TextWidth = new HTuple(), hv_TextHeight = new HTuple();
    HTuple hv_NumChannels = new HTuple(), hv_ColorImage = new HTuple();
    HTuple hv_CameraIndex = new HTuple(), hv_AllInstances = new HTuple();
    HTuple hv_SetLight = new HTuple(), hv_LightParam = new HTuple();
    HTuple hv_LightPosition = new HTuple(), hv_LightKind = new HTuple();
    HTuple hv_LightIndex = new HTuple(), hv_PersistenceParamName = new HTuple();
    HTuple hv_PersistenceParamValue = new HTuple(), hv_AlphaOrig = new HTuple();
    HTuple hv_I = new HTuple(), hv_ParamName = new HTuple();
    HTuple hv_ParamValue = new HTuple(), hv_ParamNameTrunk = new HTuple();
    HTuple hv_Instance = new HTuple(), hv_HomMat3D = new HTuple();
    HTuple hv_Qx = new HTuple(), hv_Qy = new HTuple(), hv_Qz = new HTuple();
    HTuple hv_TBCenter = new HTuple(), hv_TBSize = new HTuple();
    HTuple hv_ButtonHold = new HTuple(), hv_VisualizeTB = new HTuple();
    HTuple hv_MaxIndex = new HTuple(), hv_TrackballCenterRow = new HTuple();
    HTuple hv_TrackballCenterCol = new HTuple(), hv_GraphEvent = new HTuple();
    HTuple hv_Exit = new HTuple(), hv_GraphButtonRow = new HTuple();
    HTuple hv_GraphButtonColumn = new HTuple(), hv_GraphButton = new HTuple();
    HTuple hv_ButtonReleased = new HTuple(), hv_e = new HTuple();
    HTuple   hv_CamParam_COPY_INP_TMP = new HTuple(hv_CamParam);
    HTuple   hv_GenParamName_COPY_INP_TMP = new HTuple(hv_GenParamName);
    HTuple   hv_GenParamValue_COPY_INP_TMP = new HTuple(hv_GenParamValue);
    HTuple   hv_Label_COPY_INP_TMP = new HTuple(hv_Label);
    HTuple   hv_PoseIn_COPY_INP_TMP = new HTuple(hv_PoseIn);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ImageDump);
    hv_PoseOut = new HTuple();
    //The procedure visualize_object_model_3d can be used to display
    //one or more 3d object models and to interactively modify
    //the object poses by using the mouse.
    //
    //The pose can be modified by moving the mouse while
    //pressing a mouse button. The default settings are:
    //
    // Rotate: Left mouse button
    // Zoom: Shift + Left mouse button (or Center mouse button)
    // Pan: Ctrl + Left mouse button
    //
    //Furthermore, it is possible to select and deselect objects,
    //to decrease the mouse sensitivity, and to toggle the
    //inspection mode (see the description of the generic parameter
    //'inspection_mode' below):
    //
    // (De-)select object(s): Right mouse button
    // Low mouse sensitivity: Alt + Mouse button
    // Toggle inspection mode: Ctrl + Alt + Left mouse button
    //
    //In GenParamName and GenParamValue all generic Parameters
    //of disp_object_model_3d are supported.
    //
    //**********************************************************
    //Define global variables
    //**********************************************************
    //
    //global def tuple gDispObjOffset
    //global def tuple gLabelsDecor
    //global def tuple gInfoDecor
    //global def tuple gInfoPos
    //global def tuple gTitlePos
    //global def tuple gTitleDecor
    //global def tuple gTerminationButtonLabel
    //global def tuple gAlphaDeselected
    //global def tuple gIsSinglePose
    //global def tuple gUsesOpenGL
    //
    //**********************************************************
    //Initialize Handles to enable correct handling in error case
    //**********************************************************
    hv_Scene3DTest.Dispose();
    hv_Scene3DTest = new HTuple();
    hv_Scene3D.Dispose();
    hv_Scene3D = new HTuple();
    hv_WindowHandleBuffer.Dispose();
    hv_WindowHandleBuffer = new HTuple();

    //**********************************************************
    //Some user defines that may be adapted if desired
    //**********************************************************
    //
    //TrackballSize defines the diameter of the trackball in
    //the image with respect to the smaller image dimension.
    hv_TrackballSize.Dispose();
    hv_TrackballSize = 0.8;
    //
    //VirtualTrackball defines the type of virtual trackball that
    //shall be used ('shoemake' or 'bell').
    hv_VirtualTrackball.Dispose();
    hv_VirtualTrackball = "shoemake";
    //VirtualTrackball := 'bell'
    //
    //Functionality of mouse buttons
    //    1: Left Button
    //    2: Middle Button
    //    4: Right Button
    //    5: Left+Right Mousebutton
    //  8+x: Shift + Mousebutton
    // 16+x: Ctrl + Mousebutton
    // 48+x: Ctrl + Alt + Mousebutton
    //in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]
    hv_MouseMapping.Dispose();
    hv_MouseMapping = new HTuple();
    hv_MouseMapping[0] = 17;
    hv_MouseMapping[1] = 1;
    hv_MouseMapping[2] = 2;
    hv_MouseMapping[3] = 5;
    hv_MouseMapping[4] = 9;
    hv_MouseMapping[5] = 4;
    hv_MouseMapping[6] = 49;
    //
    //The labels of the objects appear next to their projected
    //center. With gDispObjOffset a fixed offset is added
    //                  R,  C
    ExpTmpLocalVar_gDispObjOffset = new HTuple();
    ExpTmpLocalVar_gDispObjOffset[0] = -30;
    ExpTmpLocalVar_gDispObjOffset[1] = 0;
    ExpSetGlobalVar_gDispObjOffset(ExpTmpLocalVar_gDispObjOffset);
    //
    //Customize the decoration of the different text elements
    //              Color,   Box
    ExpTmpLocalVar_gInfoDecor = new HTuple();
    ExpTmpLocalVar_gInfoDecor[0] = "white";
    ExpTmpLocalVar_gInfoDecor[1] = "false";
    ExpSetGlobalVar_gInfoDecor(ExpTmpLocalVar_gInfoDecor);
    ExpTmpLocalVar_gLabelsDecor = new HTuple();
    ExpTmpLocalVar_gLabelsDecor[0] = "white";
    ExpTmpLocalVar_gLabelsDecor[1] = "false";
    ExpSetGlobalVar_gLabelsDecor(ExpTmpLocalVar_gLabelsDecor);
    ExpTmpLocalVar_gTitleDecor = new HTuple();
    ExpTmpLocalVar_gTitleDecor[0] = "black";
    ExpTmpLocalVar_gTitleDecor[1] = "true";
    ExpSetGlobalVar_gTitleDecor(ExpTmpLocalVar_gTitleDecor);
    //
    //Customize the position of some text elements
    //  gInfoPos has one of the values
    //  {'UpperLeft', 'LowerLeft', 'UpperRight'}
    ExpTmpLocalVar_gInfoPos = "LowerLeft";
    ExpSetGlobalVar_gInfoPos(ExpTmpLocalVar_gInfoPos);
    //  gTitlePos has one of the values
    //  {'UpperLeft', 'UpperCenter', 'UpperRight'}
    ExpTmpLocalVar_gTitlePos = "UpperLeft";
    ExpSetGlobalVar_gTitlePos(ExpTmpLocalVar_gTitlePos);
    //Alpha value (=1-transparency) that is used for visualizing
    //the objects that are not selected
    ExpTmpLocalVar_gAlphaDeselected = 0.3;
    ExpSetGlobalVar_gAlphaDeselected(ExpTmpLocalVar_gAlphaDeselected);
    //Customize the label of the continue button
    ExpTmpLocalVar_gTerminationButtonLabel = " Continue ";
    ExpSetGlobalVar_gTerminationButtonLabel(ExpTmpLocalVar_gTerminationButtonLabel);
    //Define if the continue button responds to a single click event or
    //if it responds only if the mouse button is released while being placed
    //over the continue button.
    //'true':  Wait until the continue button has been released.
    //         This should be used to avoid unwanted continuations of
    //         subsequent calls of visualize_object_model_3d, which can
    //         otherwise occur if the mouse button remains pressed while the
    //         next visualization is active.
    //'false': Continue the execution already if the continue button is
    //         pressed. This option allows a fast forwarding through
    //         subsequent calls of visualize_object_model_3d.
    hv_WaitForButtonRelease.Dispose();
    hv_WaitForButtonRelease = "true";
    //Number of 3D Object models that can be selected and handled individually.
    //If there are more models passed then this number, some calculations
    //are performed differently and the individual selection and handling
    //of models is not supported anymore. Note that the value of MaxNumModels
    //can be overwritten with the generic parameter max_num_selectable_models.
    hv_MaxNumModels.Dispose();
    hv_MaxNumModels = 1000;
    //Defines the default for the initial state of the rotation center:
    //(1) The rotation center is fixed in the center of the image and lies
    //    on the surface of the object.
    //(2) The rotation center lies in the center of the object.
    hv_WindowCenteredRotation.Dispose();
    hv_WindowCenteredRotation = 2;
    //
    //**********************************************************
    //
    //Initialize some values
    hv_NumModels.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_NumModels = new HTuple(hv_ObjectModel3D.TupleLength()
        );
    }
    hv_SelectedObject.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_SelectedObject = HTuple.TupleGenConst(
        hv_NumModels,1);
    }
    //
    //Apply some system settings
    // dev_set_preferences(...); only in hdevelop
    // dev_get_preferences(...); only in hdevelop
    // dev_set_preferences(...); only in hdevelop
    hv_ClipRegion.Dispose();
    HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
    HOperatorSet.SetSystem("clip_region", "false");
    dev_update_off();
    //
    //Check if GenParamName matches GenParamValue
    if ((int)(new HTuple((new HTuple(hv_GenParamName_COPY_INP_TMP.TupleLength())).TupleNotEqual(
        new HTuple(hv_GenParamValue_COPY_INP_TMP.TupleLength())))) != 0)
    {
      throw new HalconException("Number of generic parameters does not match number of generic parameter values");
    }
    //
    try
    {
      //
      //Refactor camera parameters to fit to window size
      //
      hv_CPLength.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CPLength = new HTuple(hv_CamParam_COPY_INP_TMP.TupleLength()
          );
      }
      hv_RowNotUsed.Dispose();hv_ColumnNotUsed.Dispose();hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowNotUsed, out hv_ColumnNotUsed, 
          out hv_Width, out hv_Height);
      hv_WPRow1.Dispose();hv_WPColumn1.Dispose();hv_WPRow2.Dispose();hv_WPColumn2.Dispose();
      HOperatorSet.GetPart(hv_WindowHandle, out hv_WPRow1, out hv_WPColumn1, out hv_WPRow2, 
          out hv_WPColumn2);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_Height-1, hv_Width-1);
      }
      if ((int)(new HTuple(hv_CPLength.TupleEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamParam_COPY_INP_TMP.Dispose();
        gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width/2, hv_Height/2, 
            hv_Width, hv_Height, out hv_CamParam_COPY_INP_TMP);
        }
      }
      else
      {
        hv_CamParamValue.Dispose();
        get_cam_par_data(hv_CamParam_COPY_INP_TMP, (((((new HTuple("sx")).TupleConcat(
            "sy")).TupleConcat("cx")).TupleConcat("cy")).TupleConcat("image_width")).TupleConcat(
            "image_height"), out hv_CamParamValue);
        hv_CamWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamWidth = ((hv_CamParamValue.TupleSelect(
            4))).TupleReal();
        }
        hv_CamHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamHeight = ((hv_CamParamValue.TupleSelect(
            5))).TupleReal();
        }
        hv_Scale.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Scale = ((((hv_Width/hv_CamWidth)).TupleConcat(
            hv_Height/hv_CamHeight))).TupleMin();
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "sx", (hv_CamParamValue.TupleSelect(
            0))/hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "sy", (hv_CamParamValue.TupleSelect(
            1))/hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "cx", (hv_CamParamValue.TupleSelect(
            2))*hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "cy", (hv_CamParamValue.TupleSelect(
            3))*hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "image_width", (((hv_CamParamValue.TupleSelect(
            4))*hv_Scale)).TupleInt(), out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "image_height", (((hv_CamParamValue.TupleSelect(
            5))*hv_Scale)).TupleInt(), out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Check the generic parameters for max_num_selectable_models
      //(Note that the default is set above to MaxNumModels := 1000)
      hv_Indices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
          "max_num_selectable_models");
      }
      if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
          new HTuple())))) != 0)
      {
        if ((int)(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(hv_Indices.TupleSelect(
            0)))).TupleIsNumber()) != 0)
        {
          if ((int)(new HTuple(((((((hv_GenParamValue_COPY_INP_TMP.TupleSelect(hv_Indices.TupleSelect(
              0)))).TupleNumber())).TupleInt())).TupleLess(1))) != 0)
          {
            //Wrong parameter value: Only integer values greater than 0 are allowed
            throw new HalconException("Wrong value for parameter 'max_num_selectable_models' (must be an integer value greater than 0)");
          }
        }
        else
        {
          //Wrong parameter value: Only integer values greater than 0 are allowed
          throw new HalconException("Wrong value for parameter 'max_num_selectable_models' (must be an integer value greater than 0)");
        }
        hv_MaxNumModels.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxNumModels = ((((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_Indices.TupleSelect(0)))).TupleNumber())).TupleInt();
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      //
      //Check the generic parameters for window_centered_rotation
      //(Note that the default is set above to WindowCenteredRotation := 2)
      hv_Indices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
          "inspection_mode");
      }
      if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
          new HTuple())))) != 0)
      {
        if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(hv_Indices.TupleSelect(
            0)))).TupleEqual("surface"))) != 0)
        {
          hv_WindowCenteredRotation.Dispose();
          hv_WindowCenteredRotation = 1;
        }
        else if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_Indices.TupleSelect(0)))).TupleEqual("standard"))) != 0)
        {
          hv_WindowCenteredRotation.Dispose();
          hv_WindowCenteredRotation = 2;
        }
        else
        {
          //Wrong parameter value, use default value
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      //
      //Check the generic parameters for disp_background
      //(The former parameter name 'use_background' is still supported
      // for compatibility reasons)
      hv_DispBackground.Dispose();
      hv_DispBackground = "false";
      if ((int)(new HTuple((new HTuple(hv_GenParamName_COPY_INP_TMP.TupleLength()
          )).TupleGreater(0))) != 0)
      {
        hv_Mask.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Mask = ((hv_GenParamName_COPY_INP_TMP.TupleEqualElem(
            "disp_background"))).TupleOr(hv_GenParamName_COPY_INP_TMP.TupleEqualElem(
            "use_background"));
        }
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = hv_Mask.TupleFind(
            1);
        }
      }
      else
      {
        hv_Indices.Dispose();
        hv_Indices = -1;
      }
      if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
          new HTuple())))) != 0)
      {
        hv_DispBackground.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DispBackground = hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_Indices.TupleSelect(0));
        }
        if ((int)((new HTuple(hv_DispBackground.TupleNotEqual("true"))).TupleAnd(
            new HTuple(hv_DispBackground.TupleNotEqual("false")))) != 0)
        {
          //Wrong parameter value: Only 'true' and 'false' are allowed
          throw new HalconException("Wrong value for parameter 'disp_background' (must be either 'true' or 'false')");
        }
        //Note the the background is handled explicitly in this procedure
        //and therefore, the parameter is removed from the list of
        //parameters and disp_background is always set to true (see below)
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      //
      //Read and check the parameter Label for each object
      if ((int)(new HTuple((new HTuple(hv_Label_COPY_INP_TMP.TupleLength())).TupleEqual(
          0))) != 0)
      {
        hv_Label_COPY_INP_TMP.Dispose();
        hv_Label_COPY_INP_TMP = 0;
      }
      else if ((int)(new HTuple((new HTuple(hv_Label_COPY_INP_TMP.TupleLength()
          )).TupleEqual(1))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Label = HTuple.TupleGenConst(
            hv_NumModels,hv_Label_COPY_INP_TMP);
        hv_Label_COPY_INP_TMP.Dispose();
        hv_Label_COPY_INP_TMP = ExpTmpLocalVar_Label;
        }
        }
      }
      else
      {
        if ((int)(new HTuple((new HTuple(hv_Label_COPY_INP_TMP.TupleLength())).TupleNotEqual(
            hv_NumModels))) != 0)
        {
          //Number of elements in Label does not match
          //the number of object models.
          throw new HalconException(((new HTuple(new HTuple("Number of elements in Label (")+(new HTuple(hv_Label_COPY_INP_TMP.TupleLength()
              )))+") does not match the number of object models(")+hv_NumModels)+").");
        }
      }
      //
      //Read and check the parameter PoseIn for each object
      hv_Center.Dispose();
      get_object_models_center(hv_ObjectModel3D, out hv_Center);
      if ((int)(new HTuple(hv_Center.TupleEqual(new HTuple()))) != 0)
      {
        hv_Center.Dispose();
        hv_Center = new HTuple();
        hv_Center[0] = 0;
        hv_Center[1] = 0;
        hv_Center[2] = 0;
      }
      if ((int)(new HTuple((new HTuple(hv_PoseIn_COPY_INP_TMP.TupleLength())).TupleEqual(
          0))) != 0)
      {
        //If no pose was specified by the caller, automatically calculate
        //a pose that is appropriate for the visualization.
        //Set the initial model reference pose. The orientation is parallel
        //to the object coordinate system, the position is at the center
        //of gravity of all models.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PoseIn_COPY_INP_TMP.Dispose();
        HOperatorSet.CreatePose(-(hv_Center.TupleSelect(0)), -(hv_Center.TupleSelect(
            1)), -(hv_Center.TupleSelect(2)), 0, 0, 0, "Rp+T", "gba", "point", out hv_PoseIn_COPY_INP_TMP);
        }
        hv_PoseEstimated.Dispose();
        determine_optimum_pose_distance(hv_ObjectModel3D, hv_CamParam_COPY_INP_TMP, 
            0.9, hv_PoseIn_COPY_INP_TMP, out hv_PoseEstimated);
        hv_Poses.Dispose();
        hv_Poses = new HTuple();
        hv_HomMat3Ds.Dispose();
        hv_HomMat3Ds = new HTuple();
        hv_Sequence.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Sequence = HTuple.TupleGenSequence(
            0,(hv_NumModels*7)-1,1);
        }
        hv_Poses.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Poses = hv_PoseEstimated.TupleSelect(
            hv_Sequence%7);
        }
        ExpTmpLocalVar_gIsSinglePose = 1;
        ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
      }
      else if ((int)(new HTuple((new HTuple(hv_PoseIn_COPY_INP_TMP.TupleLength()
          )).TupleEqual(7))) != 0)
      {
        hv_Poses.Dispose();
        hv_Poses = new HTuple();
        hv_HomMat3Ds.Dispose();
        hv_HomMat3Ds = new HTuple();
        hv_Sequence.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Sequence = HTuple.TupleGenSequence(
            0,(hv_NumModels*7)-1,1);
        }
        hv_Poses.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Poses = hv_PoseIn_COPY_INP_TMP.TupleSelect(
            hv_Sequence%7);
        }
        ExpTmpLocalVar_gIsSinglePose = 1;
        ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
      }
      else
      {
        if ((int)(new HTuple((new HTuple(hv_PoseIn_COPY_INP_TMP.TupleLength())).TupleNotEqual(
            (new HTuple(hv_ObjectModel3D.TupleLength()))*7))) != 0)
        {
          //Wrong number of values of input control parameter 'PoseIn'
          throw new HalconException("Wrong number of values of input control parameter 'PoseIn'.");
        }
        else
        {
          hv_Poses.Dispose();
          hv_Poses = new HTuple(hv_PoseIn_COPY_INP_TMP);
        }
        ExpTmpLocalVar_gIsSinglePose = 0;
        ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
      }

      //
      //Open (invisible) buffer window to avoid flickering
      hv_WindowHandleBuffer.Dispose();
      HOperatorSet.OpenWindow(0, 0, hv_Width, hv_Height, 0, "buffer", "", out hv_WindowHandleBuffer);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(hv_WindowHandleBuffer, 0, 0, hv_Height-1, hv_Width-1);
      }
      hv_Font.Dispose();
      HOperatorSet.GetFont(hv_WindowHandle, out hv_Font);
      try
      {
        HOperatorSet.SetFont(hv_WindowHandleBuffer, hv_Font);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException2)
      {
        HDevExpDefaultException2.ToHTuple(out hv_Exception);
      }
      //
      // Is OpenGL available and should it be used?
      ExpTmpLocalVar_gUsesOpenGL = "true";
      ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
      hv_Indices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
          "opengl");
      }
      if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
          new HTuple())))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ExpTmpLocalVar_gUsesOpenGL = hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_Indices.TupleSelect(0));
        }
        ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = ExpTmpLocalVar_GenParamValue;
        }
        }
        if ((int)((new HTuple(ExpGetGlobalVar_gUsesOpenGL().TupleNotEqual("true"))).TupleAnd(
            new HTuple(ExpGetGlobalVar_gUsesOpenGL().TupleNotEqual("false")))) != 0)
        {
          //Wrong parameter value: Only 'true' and 'false' are allowed
          throw new HalconException("Wrong value for parameter 'opengl' (must be either 'true' or 'false')");
        }
      }
      if ((int)(new HTuple(ExpGetGlobalVar_gUsesOpenGL().TupleEqual("true"))) != 0)
      {
        hv_OpenGLInfo.Dispose();
        HOperatorSet.GetSystem("opengl_info", out hv_OpenGLInfo);
        if ((int)(new HTuple(hv_OpenGLInfo.TupleEqual("No OpenGL support included."))) != 0)
        {
          ExpTmpLocalVar_gUsesOpenGL = "false";
          ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
        }
        else
        {
          hv_DummyObjectModel3D.Dispose();
          HOperatorSet.GenObjectModel3dFromPoints(0, 0, 0, out hv_DummyObjectModel3D);
          hv_Scene3DTest.Dispose();
          HOperatorSet.CreateScene3d(out hv_Scene3DTest);
          hv_CameraIndexTest.Dispose();
          HOperatorSet.AddScene3dCamera(hv_Scene3DTest, hv_CamParam_COPY_INP_TMP, 
              out hv_CameraIndexTest);
          hv_PoseTest.Dispose();
          determine_optimum_pose_distance(hv_DummyObjectModel3D, hv_CamParam_COPY_INP_TMP, 
              0.9, ((((((new HTuple(0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(
              0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(0), out hv_PoseTest);
          hv_InstanceIndexTest.Dispose();
          HOperatorSet.AddScene3dInstance(hv_Scene3DTest, hv_DummyObjectModel3D, 
              hv_PoseTest, out hv_InstanceIndexTest);
          try
          {
            HOperatorSet.DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3DTest, hv_InstanceIndexTest);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException2)
          {
            HDevExpDefaultException2.ToHTuple(out hv_Exception);
            ExpTmpLocalVar_gUsesOpenGL = "false";
            ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
          }
          HOperatorSet.ClearScene3d(hv_Scene3DTest);
          hv_Scene3DTest.Dispose();
          hv_Scene3DTest = new HTuple();
          HOperatorSet.ClearObjectModel3d(hv_DummyObjectModel3D);
        }
      }
      //
      //Compute the trackball
      hv_MinImageSize.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinImageSize = ((hv_Width.TupleConcat(
          hv_Height))).TupleMin();
      }
      hv_TrackballRadiusPixel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize)/2.0;
      }
      //
      //Measure the text extents for the continue button in the
      //graphics window
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandleBuffer, ExpGetGlobalVar_gTerminationButtonLabel()+"  ", 
          out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
      }
      //
      //Store background image
      if ((int)(new HTuple(hv_DispBackground.TupleEqual("false"))) != 0)
      {
        HOperatorSet.ClearWindow(hv_WindowHandle);
      }
      ho_Image.Dispose();
      HOperatorSet.DumpWindowImage(out ho_Image, hv_WindowHandle);
      //Special treatment for color background images necessary
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_Image, out hv_NumChannels);
      hv_ColorImage.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColorImage = new HTuple(hv_NumChannels.TupleEqual(
          3));
      }
      //
      hv_Scene3D.Dispose();
      HOperatorSet.CreateScene3d(out hv_Scene3D);
      hv_CameraIndex.Dispose();
      HOperatorSet.AddScene3dCamera(hv_Scene3D, hv_CamParam_COPY_INP_TMP, out hv_CameraIndex);
      hv_AllInstances.Dispose();
      HOperatorSet.AddScene3dInstance(hv_Scene3D, hv_ObjectModel3D, hv_Poses, out hv_AllInstances);
      //Always set 'disp_background' to true,  because it is handled explicitly
      //in this procedure (see above)
      HOperatorSet.SetScene3dParam(hv_Scene3D, "disp_background", "true");
      //Check if we have to set light specific parameters
      hv_SetLight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SetLight = new HTuple(hv_GenParamName_COPY_INP_TMP.TupleRegexpTest(
          "light_"));
      }
      if ((int)(hv_SetLight) != 0)
      {
        //set position of light source
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
            "light_position");
        }
        if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
            new HTuple())))) != 0)
        {
          //If multiple light positions are given, use the last one
          hv_LightParam.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LightParam = ((((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
              hv_Indices.TupleSelect((new HTuple(hv_Indices.TupleLength()))-1)))).TupleSplit(
              new HTuple(", ")))).TupleNumber();
          }
          if ((int)(new HTuple((new HTuple(hv_LightParam.TupleLength())).TupleNotEqual(
              4))) != 0)
          {
            throw new HalconException("light_position must be given as a string that contains four space separated floating point numbers");
          }
          hv_LightPosition.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LightPosition = hv_LightParam.TupleSelectRange(
              0,2);
          }
          hv_LightKind.Dispose();
          hv_LightKind = "point_light";
          if ((int)(new HTuple(((hv_LightParam.TupleSelect(3))).TupleEqual(0))) != 0)
          {
            hv_LightKind.Dispose();
            hv_LightKind = "directional_light";
          }
          //Currently, only one light source is supported
          HOperatorSet.RemoveScene3dLight(hv_Scene3D, 0);
          hv_LightIndex.Dispose();
          HOperatorSet.AddScene3dLight(hv_Scene3D, hv_LightPosition, hv_LightKind, 
              out hv_LightIndex);
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_GenParamName_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
          hv_GenParamName_COPY_INP_TMP.Dispose();
          hv_GenParamName_COPY_INP_TMP = ExpTmpOutVar_0;
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_GenParamValue_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
          hv_GenParamValue_COPY_INP_TMP.Dispose();
          hv_GenParamValue_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        //set ambient part of light source
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
            "light_ambient");
        }
        if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
            new HTuple())))) != 0)
        {
          //If the ambient part is set multiple times, use the last setting
          hv_LightParam.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LightParam = ((((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
              hv_Indices.TupleSelect((new HTuple(hv_Indices.TupleLength()))-1)))).TupleSplit(
              new HTuple(", ")))).TupleNumber();
          }
          if ((int)(new HTuple((new HTuple(hv_LightParam.TupleLength())).TupleLess(
              3))) != 0)
          {
            throw new HalconException("light_ambient must be given as a string that contains three space separated floating point numbers");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetScene3dLightParam(hv_Scene3D, 0, "ambient", hv_LightParam.TupleSelectRange(
              0,2));
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_GenParamName_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
          hv_GenParamName_COPY_INP_TMP.Dispose();
          hv_GenParamName_COPY_INP_TMP = ExpTmpOutVar_0;
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_GenParamValue_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
          hv_GenParamValue_COPY_INP_TMP.Dispose();
          hv_GenParamValue_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        //Set diffuse part of light source
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
            "light_diffuse");
        }
        if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
            new HTuple())))) != 0)
        {
          //If the diffuse part is set multiple times, use the last setting
          hv_LightParam.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LightParam = ((((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
              hv_Indices.TupleSelect((new HTuple(hv_Indices.TupleLength()))-1)))).TupleSplit(
              new HTuple(", ")))).TupleNumber();
          }
          if ((int)(new HTuple((new HTuple(hv_LightParam.TupleLength())).TupleLess(
              3))) != 0)
          {
            throw new HalconException("light_diffuse must be given as a string that contains three space separated floating point numbers");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetScene3dLightParam(hv_Scene3D, 0, "diffuse", hv_LightParam.TupleSelectRange(
              0,2));
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_GenParamName_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
          hv_GenParamName_COPY_INP_TMP.Dispose();
          hv_GenParamName_COPY_INP_TMP = ExpTmpOutVar_0;
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_GenParamValue_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
          hv_GenParamValue_COPY_INP_TMP.Dispose();
          hv_GenParamValue_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
      }
      //
      //Handle persistence parameters separately because persistence will
      //only be activated immediately before leaving the visualization
      //procedure
      hv_PersistenceParamName.Dispose();
      hv_PersistenceParamName = new HTuple();
      hv_PersistenceParamValue.Dispose();
      hv_PersistenceParamValue = new HTuple();
      //Set position of light source
      hv_Indices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
          "object_index_persistence");
      }
      if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
          new HTuple())))) != 0)
      {
        if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(hv_Indices.TupleSelect(
            (new HTuple(hv_Indices.TupleLength()))-1)))).TupleEqual("true"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_PersistenceParamName = hv_PersistenceParamName.TupleConcat(
              "object_index_persistence");
          hv_PersistenceParamName.Dispose();
          hv_PersistenceParamName = ExpTmpLocalVar_PersistenceParamName;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat(
              "true");
          hv_PersistenceParamValue.Dispose();
          hv_PersistenceParamValue = ExpTmpLocalVar_PersistenceParamValue;
          }
          }
        }
        else if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_Indices.TupleSelect((new HTuple(hv_Indices.TupleLength()))-1)))).TupleEqual(
            "false"))) != 0)
        {
        }
        else
        {
          throw new HalconException("Wrong value for parameter 'object_index_persistence' (must be either 'true' or 'false')");
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleRemove(hv_GenParamName_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleRemove(hv_GenParamValue_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      hv_Indices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
          "depth_persistence");
      }
      if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
          new HTuple())))) != 0)
      {
        if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(hv_Indices.TupleSelect(
            (new HTuple(hv_Indices.TupleLength()))-1)))).TupleEqual("true"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_PersistenceParamName = hv_PersistenceParamName.TupleConcat(
              "depth_persistence");
          hv_PersistenceParamName.Dispose();
          hv_PersistenceParamName = ExpTmpLocalVar_PersistenceParamName;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat(
              "true");
          hv_PersistenceParamValue.Dispose();
          hv_PersistenceParamValue = ExpTmpLocalVar_PersistenceParamValue;
          }
          }
        }
        else if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_Indices.TupleSelect((new HTuple(hv_Indices.TupleLength()))-1)))).TupleEqual(
            "false"))) != 0)
        {
        }
        else
        {
          throw new HalconException("Wrong value for parameter 'depth_persistence' (must be either 'true' or 'false')");
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleRemove(hv_GenParamName_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleRemove(hv_GenParamValue_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Parse the generic parameters
      //- First, all parameters that are understood by set_scene_3d_instance_param
      hv_AlphaOrig.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_AlphaOrig = HTuple.TupleGenConst(
          hv_NumModels,1);
      }
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_GenParamName_COPY_INP_TMP.TupleLength()
          ))-1); hv_I = (int)hv_I + 1)
      {
        hv_ParamName.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamName = hv_GenParamName_COPY_INP_TMP.TupleSelect(
            hv_I);
        }
        hv_ParamValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamValue = hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_I);
        }
        //Check if this parameter is understood by set_scene_3d_param
        if ((int)(new HTuple(hv_ParamName.TupleEqual("alpha"))) != 0)
        {
          hv_AlphaOrig.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AlphaOrig = HTuple.TupleGenConst(
              hv_NumModels,hv_ParamValue);
          }
        }
        try
        {
          HOperatorSet.SetScene3dParam(hv_Scene3D, hv_ParamName, hv_ParamValue);
          continue;
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException2)
        {
          HDevExpDefaultException2.ToHTuple(out hv_Exception);
          if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1203))).TupleOr(
              new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1303)))) != 0)
          {
            throw new HalconException((("Wrong type or value for parameter "+hv_ParamName)+": ")+hv_ParamValue);
          }
        }
        //Check if it is a parameter that is valid for only one instance
        //and therefore can be set only with set_scene_3d_instance_param
        hv_ParamNameTrunk.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParamNameTrunk = hv_ParamName.TupleRegexpReplace(
            "_\\d+$","");
        }
        if ((int)(new HTuple(hv_ParamName.TupleEqual(hv_ParamNameTrunk))) != 0)
        {
          hv_Instance.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Instance = HTuple.TupleGenSequence(
              0,hv_NumModels-1,1);
          }
        }
        else
        {
          hv_Instance.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Instance = ((hv_ParamName.TupleRegexpReplace(
              ("^"+hv_ParamNameTrunk)+"_(\\d+)$","$1"))).TupleNumber();
          }
          if ((int)((new HTuple(hv_Instance.TupleLess(0))).TupleOr(new HTuple(hv_Instance.TupleGreater(
              hv_NumModels-1)))) != 0)
          {
            throw new HalconException(("Parameter "+hv_ParamName)+" refers to a non existing 3D object model");
          }
        }
        try
        {
          HOperatorSet.SetScene3dInstanceParam(hv_Scene3D, hv_Instance, hv_ParamNameTrunk, 
              hv_ParamValue);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException2)
        {
          HDevExpDefaultException2.ToHTuple(out hv_Exception);
          if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1204))).TupleOr(
              new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1304)))) != 0)
          {
            throw new HalconException((("Wrong type or value for parameter "+hv_ParamName)+": ")+hv_ParamValue);
          }
          else if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
              1203))).TupleOr(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
              1303)))) != 0)
          {
            throw new HalconException("Wrong parameter name "+hv_ParamName);
          }
          else
          {
            throw new HalconException(hv_Exception);
          }
        }
        if ((int)(new HTuple(hv_ParamNameTrunk.TupleEqual("alpha"))) != 0)
        {
          if (hv_AlphaOrig == null)
            hv_AlphaOrig = new HTuple();
          hv_AlphaOrig[hv_Instance] = hv_ParamValue;
        }
      }
      //
      //Start the visualization loop
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HomMat3D.Dispose();
      HOperatorSet.PoseToHomMat3d(hv_Poses.TupleSelectRange(0,6), out hv_HomMat3D);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Qx.Dispose();hv_Qy.Dispose();hv_Qz.Dispose();
      HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_Center.TupleSelect(0), hv_Center.TupleSelect(
          1), hv_Center.TupleSelect(2), out hv_Qx, out hv_Qy, out hv_Qz);
      }
      hv_TBCenter.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TBCenter = new HTuple();
      hv_TBCenter = hv_TBCenter.TupleConcat(hv_Qx, hv_Qy, hv_Qz);
      }
      hv_TBSize.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TBSize = (0.5+((0.5*(hv_SelectedObject.TupleSum()
          ))/hv_NumModels))*hv_TrackballRadiusPixel;
      }
      hv_ButtonHold.Dispose();
      hv_ButtonHold = 0;
      while ((int)(1) != 0)
      {
        hv_VisualizeTB.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_VisualizeTB = new HTuple(((hv_SelectedObject.TupleMax()
            )).TupleNotEqual(0));
        }
        hv_MaxIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxIndex = ((((new HTuple(hv_ObjectModel3D.TupleLength()
            )).TupleConcat(hv_MaxNumModels))).TupleMin())-1;
        }
        //Set trackball fixed in the center of the window
        hv_TrackballCenterRow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TrackballCenterRow = hv_Height/2;
        }
        hv_TrackballCenterCol.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TrackballCenterCol = hv_Width/2;
        }
        if ((int)(new HTuple(hv_WindowCenteredRotation.TupleEqual(1))) != 0)
        {
          try
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TBCenter.Dispose();hv_TBSize.Dispose();
            get_trackball_center_fixed_visualize_object_model_3d(hv_SelectedObject.TupleSelectRange(
                0,hv_MaxIndex), hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TrackballRadiusPixel, 
                hv_Scene3D, hv_ObjectModel3D.TupleSelectRange(0,hv_MaxIndex), hv_Poses.TupleSelectRange(
                0,((hv_MaxIndex+1)*7)-1), hv_WindowHandleBuffer, hv_CamParam_COPY_INP_TMP, 
                hv_GenParamName_COPY_INP_TMP, hv_GenParamValue_COPY_INP_TMP, out hv_TBCenter, 
                out hv_TBSize);
            }
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException2)
          {
            HDevExpDefaultException2.ToHTuple(out hv_Exception);
            disp_message(hv_WindowHandle, "Surface inspection mode is not available.", 
                "image", 5, 20, "red", "true");
            hv_WindowCenteredRotation.Dispose();
            hv_WindowCenteredRotation = 2;
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TBCenter.Dispose();hv_TBSize.Dispose();
            get_trackball_center_visualize_object_model_3d(hv_SelectedObject.TupleSelectRange(
                0,hv_MaxIndex), hv_TrackballRadiusPixel, hv_ObjectModel3D.TupleSelectRange(
                0,hv_MaxIndex), hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), 
                out hv_TBCenter, out hv_TBSize);
            }
            HOperatorSet.WaitSeconds(1);
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TBCenter.Dispose();hv_TBSize.Dispose();
          get_trackball_center_visualize_object_model_3d(hv_SelectedObject.TupleSelectRange(
              0,hv_MaxIndex), hv_TrackballRadiusPixel, hv_ObjectModel3D.TupleSelectRange(
              0,hv_MaxIndex), hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), 
              out hv_TBCenter, out hv_TBSize);
          }
        }
        dump_image_output_visualize_object_model_3d(ho_Image, hv_WindowHandleBuffer, 
            hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3D, hv_GenParamName_COPY_INP_TMP, 
            hv_GenParamValue_COPY_INP_TMP, hv_CamParam_COPY_INP_TMP, hv_Poses, hv_ColorImage, 
            hv_Title, hv_Information, hv_Label_COPY_INP_TMP, hv_VisualizeTB, "true", 
            hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TBSize, hv_SelectedObject, 
            hv_WindowCenteredRotation, hv_TBCenter);
        ho_ImageDump.Dispose();
        HOperatorSet.DumpWindowImage(out ho_ImageDump, hv_WindowHandleBuffer);
        HDevWindowStack.SetActive(hv_WindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_ImageDump, HDevWindowStack.GetActive());
        }
        //
        //Check for mouse events
        hv_GraphEvent.Dispose();
        hv_GraphEvent = 0;
        hv_Exit.Dispose();
        hv_Exit = 0;
        while ((int)(1) != 0)
        {
          //
          //Check graphic event
          try
          {
            hv_GraphButtonRow.Dispose();hv_GraphButtonColumn.Dispose();hv_GraphButton.Dispose();
            HOperatorSet.GetMpositionSubPix(hv_WindowHandle, out hv_GraphButtonRow, 
                out hv_GraphButtonColumn, out hv_GraphButton);
            if ((int)(new HTuple(hv_GraphButton.TupleNotEqual(0))) != 0)
            {
              if ((int)((new HTuple((new HTuple((new HTuple(hv_GraphButtonRow.TupleGreater(
                  (hv_Height-hv_TextHeight)-25))).TupleAnd(new HTuple(hv_GraphButtonRow.TupleLess(
                  hv_Height))))).TupleAnd(new HTuple(hv_GraphButtonColumn.TupleGreater(
                  (hv_Width-hv_TextWidth)-15))))).TupleAnd(new HTuple(hv_GraphButtonColumn.TupleLess(
                  hv_Width)))) != 0)
              {
                //Wait until the continue button has been released
                if ((int)(new HTuple(hv_WaitForButtonRelease.TupleEqual("true"))) != 0)
                {
                  while ((int)(1) != 0)
                  {
                    hv_GraphButtonRow.Dispose();hv_GraphButtonColumn.Dispose();hv_GraphButton.Dispose();
                    HOperatorSet.GetMpositionSubPix(hv_WindowHandle, out hv_GraphButtonRow, 
                        out hv_GraphButtonColumn, out hv_GraphButton);
                    if ((int)((new HTuple(hv_GraphButton.TupleEqual(0))).TupleOr(
                        new HTuple(hv_GraphButton.TupleEqual(new HTuple())))) != 0)
                    {
                      if ((int)((new HTuple((new HTuple((new HTuple(hv_GraphButtonRow.TupleGreater(
                          (hv_Height-hv_TextHeight)-25))).TupleAnd(new HTuple(hv_GraphButtonRow.TupleLess(
                          hv_Height))))).TupleAnd(new HTuple(hv_GraphButtonColumn.TupleGreater(
                          (hv_Width-hv_TextWidth)-15))))).TupleAnd(new HTuple(hv_GraphButtonColumn.TupleLess(
                          hv_Width)))) != 0)
                      {
                        hv_ButtonReleased.Dispose();
                        hv_ButtonReleased = 1;
                      }
                      else
                      {
                        hv_ButtonReleased.Dispose();
                        hv_ButtonReleased = 0;
                      }
                      //
                      break;
                    }
                    //Keep waiting until mouse button is released or moved out of the window
                  }
                }
                else
                {
                  hv_ButtonReleased.Dispose();
                  hv_ButtonReleased = 1;
                }
                //Exit the visualization loop
                if ((int)(hv_ButtonReleased) != 0)
                {
                  hv_Exit.Dispose();
                  hv_Exit = 1;
                  break;
                }
              }
              hv_GraphEvent.Dispose();
              hv_GraphEvent = 1;
              break;
            }
            else
            {
              hv_ButtonHold.Dispose();
              hv_ButtonHold = 0;
            }
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException2)
          {
            HDevExpDefaultException2.ToHTuple(out hv_Exception);
            //Keep waiting
          }
        }
        if ((int)(hv_GraphEvent) != 0)
        {
          {
          HTuple ExpTmpOutVar_0;HTuple ExpTmpOutVar_1;HTuple ExpTmpOutVar_2;HTuple ExpTmpOutVar_3;
          analyze_graph_event_visualize_object_model_3d(ho_Image, hv_MouseMapping, 
              hv_GraphButton, hv_GraphButtonRow, hv_GraphButtonColumn, hv_WindowHandle, 
              hv_WindowHandleBuffer, hv_VirtualTrackball, hv_TrackballSize, hv_SelectedObject, 
              hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3D, hv_CamParam_COPY_INP_TMP, 
              hv_Label_COPY_INP_TMP, hv_Title, hv_Information, hv_GenParamName_COPY_INP_TMP, 
              hv_GenParamValue_COPY_INP_TMP, hv_Poses, hv_ButtonHold, hv_TBCenter, 
              hv_TBSize, hv_WindowCenteredRotation, hv_MaxNumModels, out ExpTmpOutVar_0, 
              out ExpTmpOutVar_1, out ExpTmpOutVar_2, out ExpTmpOutVar_3);
          hv_Poses.Dispose();
          hv_Poses = ExpTmpOutVar_0;
          hv_SelectedObject.Dispose();
          hv_SelectedObject = ExpTmpOutVar_1;
          hv_ButtonHold.Dispose();
          hv_ButtonHold = ExpTmpOutVar_2;
          hv_WindowCenteredRotation.Dispose();
          hv_WindowCenteredRotation = ExpTmpOutVar_3;
          }
        }
        if ((int)(hv_Exit) != 0)
        {
          break;
        }
      }
      //
      //Display final state with persistence, if requested
      //Note that disp_object_model_3d must be used instead of the 3D scene
      if ((int)(new HTuple((new HTuple(hv_PersistenceParamName.TupleLength())).TupleGreater(
          0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispObjectModel3d(hv_WindowHandle, hv_ObjectModel3D, hv_CamParam_COPY_INP_TMP, 
            hv_Poses, ((new HTuple("disp_background")).TupleConcat("alpha")).TupleConcat(
            hv_PersistenceParamName), ((new HTuple("true")).TupleConcat(0.0)).TupleConcat(
            hv_PersistenceParamValue));
        }
      }
      //
      //Compute the output pose
      if ((int)(ExpGetGlobalVar_gIsSinglePose()) != 0)
      {
        hv_PoseOut.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PoseOut = hv_Poses.TupleSelectRange(
            0,6);
        }
      }
      else
      {
        hv_PoseOut.Dispose();
        hv_PoseOut = new HTuple(hv_Poses);
      }
      //
      //Clean up
      HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
      // dev_set_preferences(...); only in hdevelop
      // dev_set_preferences(...); only in hdevelop
      dump_image_output_visualize_object_model_3d(ho_Image, hv_WindowHandleBuffer, 
          hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3D, hv_GenParamName_COPY_INP_TMP, 
          hv_GenParamValue_COPY_INP_TMP, hv_CamParam_COPY_INP_TMP, hv_Poses, hv_ColorImage, 
          hv_Title, new HTuple(), hv_Label_COPY_INP_TMP, 0, "false", hv_TrackballCenterRow, 
          hv_TrackballCenterCol, hv_TBSize, hv_SelectedObject, hv_WindowCenteredRotation, 
          hv_TBCenter);
      ho_ImageDump.Dispose();
      HOperatorSet.DumpWindowImage(out ho_ImageDump, hv_WindowHandleBuffer);
      HDevWindowStack.SetActive(hv_WindowHandle);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_ImageDump, HDevWindowStack.GetActive());
      }
      HOperatorSet.CloseWindow(hv_WindowHandleBuffer);
      HOperatorSet.SetPart(hv_WindowHandle, hv_WPRow1, hv_WPColumn1, hv_WPRow2, hv_WPColumn2);
      HOperatorSet.ClearScene3d(hv_Scene3D);
      hv_Scene3D.Dispose();
      hv_Scene3D = new HTuple();
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      try
      {
        if ((int)(new HTuple((new HTuple(0)).TupleLess(new HTuple(hv_Scene3DTest.TupleLength()
            )))) != 0)
        {
          HOperatorSet.ClearScene3d(hv_Scene3DTest);
          hv_Scene3DTest.Dispose();
          hv_Scene3DTest = new HTuple();
        }
        if ((int)(new HTuple((new HTuple(0)).TupleLess(new HTuple(hv_Scene3D.TupleLength()
            )))) != 0)
        {
          HOperatorSet.ClearScene3d(hv_Scene3D);
          hv_Scene3D.Dispose();
          hv_Scene3D = new HTuple();
        }
        if ((int)(new HTuple((new HTuple(0)).TupleLess(new HTuple(hv_WindowHandleBuffer.TupleLength()
            )))) != 0)
        {
          HOperatorSet.CloseWindow(hv_WindowHandleBuffer);
          hv_WindowHandleBuffer.Dispose();
          hv_WindowHandleBuffer = new HTuple();
        }
      }
      // catch (e) 
      catch (HalconException HDevExpDefaultException2)
      {
        HDevExpDefaultException2.ToHTuple(out hv_e);
        //suppress all further exceptions to return the original exception
      }

      throw new HalconException(hv_Exception);
    }
    ho_Image.Dispose();
    ho_ImageDump.Dispose();

    hv_CamParam_COPY_INP_TMP.Dispose();
    hv_GenParamName_COPY_INP_TMP.Dispose();
    hv_GenParamValue_COPY_INP_TMP.Dispose();
    hv_Label_COPY_INP_TMP.Dispose();
    hv_PoseIn_COPY_INP_TMP.Dispose();
    hv_Scene3DTest.Dispose();
    hv_Scene3D.Dispose();
    hv_WindowHandleBuffer.Dispose();
    hv_TrackballSize.Dispose();
    hv_VirtualTrackball.Dispose();
    hv_MouseMapping.Dispose();
    hv_WaitForButtonRelease.Dispose();
    hv_MaxNumModels.Dispose();
    hv_WindowCenteredRotation.Dispose();
    hv_NumModels.Dispose();
    hv_SelectedObject.Dispose();
    hv_ClipRegion.Dispose();
    hv_CPLength.Dispose();
    hv_RowNotUsed.Dispose();
    hv_ColumnNotUsed.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_WPRow1.Dispose();
    hv_WPColumn1.Dispose();
    hv_WPRow2.Dispose();
    hv_WPColumn2.Dispose();
    hv_CamParamValue.Dispose();
    hv_CamWidth.Dispose();
    hv_CamHeight.Dispose();
    hv_Scale.Dispose();
    hv_Indices.Dispose();
    hv_DispBackground.Dispose();
    hv_Mask.Dispose();
    hv_Center.Dispose();
    hv_Poses.Dispose();
    hv_HomMat3Ds.Dispose();
    hv_Sequence.Dispose();
    hv_PoseEstimated.Dispose();
    hv_Font.Dispose();
    hv_Exception.Dispose();
    hv_OpenGLInfo.Dispose();
    hv_DummyObjectModel3D.Dispose();
    hv_CameraIndexTest.Dispose();
    hv_PoseTest.Dispose();
    hv_InstanceIndexTest.Dispose();
    hv_MinImageSize.Dispose();
    hv_TrackballRadiusPixel.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_TextWidth.Dispose();
    hv_TextHeight.Dispose();
    hv_NumChannels.Dispose();
    hv_ColorImage.Dispose();
    hv_CameraIndex.Dispose();
    hv_AllInstances.Dispose();
    hv_SetLight.Dispose();
    hv_LightParam.Dispose();
    hv_LightPosition.Dispose();
    hv_LightKind.Dispose();
    hv_LightIndex.Dispose();
    hv_PersistenceParamName.Dispose();
    hv_PersistenceParamValue.Dispose();
    hv_AlphaOrig.Dispose();
    hv_I.Dispose();
    hv_ParamName.Dispose();
    hv_ParamValue.Dispose();
    hv_ParamNameTrunk.Dispose();
    hv_Instance.Dispose();
    hv_HomMat3D.Dispose();
    hv_Qx.Dispose();
    hv_Qy.Dispose();
    hv_Qz.Dispose();
    hv_TBCenter.Dispose();
    hv_TBSize.Dispose();
    hv_ButtonHold.Dispose();
    hv_VisualizeTB.Dispose();
    hv_MaxIndex.Dispose();
    hv_TrackballCenterRow.Dispose();
    hv_TrackballCenterCol.Dispose();
    hv_GraphEvent.Dispose();
    hv_Exit.Dispose();
    hv_GraphButtonRow.Dispose();
    hv_GraphButtonColumn.Dispose();
    hv_GraphButton.Dispose();
    hv_ButtonReleased.Dispose();
    hv_e.Dispose();

    return;
  }

  // Chapter: Graphics / Output
  // Short Description: Interactively display 3D object models 
  public void visualize_object_model_3d_ext (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
      HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue, 
      HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, HTuple hv_MessageQueue, 
      HTuple hv_Buttons, HTuple hv_Type, HTuple hv_Message, HTuple hv_DispViewPoint, 
      HTuple hv_ViewPoint)
  {



    // Local iconic variables 

    HObject ho_Image=null, ho_ImageDump=null;

    // Local control variables 

    HTuple hv_Parameters = new HTuple(), hv_Scene3DTest = new HTuple();
    HTuple hv_Scene3D = new HTuple(), hv_WindowHandleBuffer = new HTuple();
    HTuple hv_TrackballSize = new HTuple(), hv_VirtualTrackball = new HTuple();
    HTuple hv_MouseMapping = new HTuple(), hv_gDispObjOffset = new HTuple();
    HTuple hv_gInfoDecor = new HTuple(), hv_gLabelsDecor = new HTuple();
    HTuple hv_gTitleDecor = new HTuple(), hv_gInfoPos = new HTuple();
    HTuple hv_gTitlePos = new HTuple(), hv_gAlphaDeselected = new HTuple();
    HTuple hv_ExitButton = new HTuple(), hv_MaxNumModels = new HTuple();
    HTuple hv_WindowCenteredRotation = new HTuple(), hv_NumModels = new HTuple();
    HTuple hv_SelectedObject = new HTuple(), hv_ButtonPressStatus = new HTuple();
    HTuple hv_ClipRegion = new HTuple(), hv_CPLength = new HTuple();
    HTuple hv_RowNotUsed = new HTuple(), hv_ColumnNotUsed = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_WPRow1 = new HTuple(), hv_WPColumn1 = new HTuple();
    HTuple hv_WPRow2 = new HTuple(), hv_WPColumn2 = new HTuple();
    HTuple hv_CamParamValue = new HTuple(), hv_CamWidth = new HTuple();
    HTuple hv_CamHeight = new HTuple(), hv_Scale = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_DispBackground = new HTuple();
    HTuple hv_Mask = new HTuple(), hv_Center = new HTuple();
    HTuple hv_PoseEstimated = new HTuple(), hv_Poses = new HTuple();
    HTuple hv_HomMat3Ds = new HTuple(), hv_Sequence = new HTuple();
    HTuple hv_gIsSinglePose = new HTuple(), hv_Font = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_gUsesOpenGL = new HTuple();
    HTuple hv_OpenGLInfo = new HTuple(), hv_DummyObjectModel3D = new HTuple();
    HTuple hv_CameraIndexTest = new HTuple(), hv_PoseTest = new HTuple();
    HTuple hv_InstanceIndexTest = new HTuple(), hv_MinImageSize = new HTuple();
    HTuple hv_TrackballRadiusPixel = new HTuple(), hv_idx = new HTuple();
    HTuple hv_MaxAscent = new HTuple(), hv_MaxDescent = new HTuple();
    HTuple hv_MaxWidth = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv_TextWidth = new HTuple(), hv_TextHeight = new HTuple();
    HTuple hv_ButtonWidth = new HTuple(), hv_ButtonHeight = new HTuple();
    HTuple hv_gButtons = new HTuple(), hv_NumChannels = new HTuple();
    HTuple hv_ColorImage = new HTuple(), hv_OriginalGenParamName = new HTuple();
    HTuple hv_OriginalGenParamValue = new HTuple(), hv_Exit = new HTuple();
    HTuple hv_PreviousSentPose = new HTuple(), hv_CameraIndex = new HTuple();
    HTuple hv_AllInstances = new HTuple(), hv_SetLight = new HTuple();
    HTuple hv_LightParam = new HTuple(), hv_LightPosition = new HTuple();
    HTuple hv_LightKind = new HTuple(), hv_LightIndex = new HTuple();
    HTuple hv_PersistenceParamName = new HTuple(), hv_PersistenceParamValue = new HTuple();
    HTuple hv_AlphaOrig = new HTuple(), hv_I = new HTuple();
    HTuple hv_ParamName = new HTuple(), hv_ParamValue = new HTuple();
    HTuple hv_ParamNameTrunk = new HTuple(), hv_Instance = new HTuple();
    HTuple hv_HomMat3D = new HTuple(), hv_Qx = new HTuple();
    HTuple hv_Qy = new HTuple(), hv_Qz = new HTuple(), hv_TBCenter = new HTuple();
    HTuple hv_TBSize = new HTuple(), hv_ButtonHold = new HTuple();
    HTuple hv_SupressUpdateMessage = new HTuple(), hv_VisualizeTB = new HTuple();
    HTuple hv_MaxIndex = new HTuple(), hv_TrackballCenterRow = new HTuple();
    HTuple hv_TrackballCenterCol = new HTuple(), hv_GraphEvent = new HTuple();
    HTuple hv_Redraw = new HTuple(), hv_RecreateScene3D = new HTuple();
    HTuple hv_GraphButtonRow = new HTuple(), hv_GraphButtonColumn = new HTuple();
    HTuple hv_GraphButton = new HTuple(), hv_MessageHandle = new HTuple();
    HTuple hv_MessageType = new HTuple(), hv_Pos = new HTuple();
    HTuple hv_Angle = new HTuple(), hv_Pose = new HTuple();
    HTuple hv_NewPoses = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Model = new HTuple(), hv_ButtonIndex = new HTuple();
    HTuple hv_ButtonText = new HTuple(), hv_FoundButton = new HTuple();
    HTuple hv_ButtonPressed = new HTuple(), hv_FoundButton2 = new HTuple();
    HTuple hv_PoseOut = new HTuple();
    HTuple   hv_Buttons_COPY_INP_TMP = new HTuple(hv_Buttons);
    HTuple   hv_CamParam_COPY_INP_TMP = new HTuple(hv_CamParam);
    HTuple   hv_GenParamName_COPY_INP_TMP = new HTuple(hv_GenParamName);
    HTuple   hv_GenParamValue_COPY_INP_TMP = new HTuple(hv_GenParamValue);
    HTuple   hv_Label_COPY_INP_TMP = new HTuple(hv_Label);
    HTuple   hv_ObjectModel3D_COPY_INP_TMP = new HTuple(hv_ObjectModel3D);
    HTuple   hv_PoseIn_COPY_INP_TMP = new HTuple(hv_PoseIn);
    HTuple   hv_Title_COPY_INP_TMP = new HTuple(hv_Title);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ImageDump);
    //The procedure visualize_object_model_3d can be used to display
    //one or more 3d object models and to interactively modify
    //the object poses by using the mouse.
    //
    //The pose can be modified by moving the mouse while
    //pressing a mouse button. The default settings are:
    //
    // Rotate: Left mouse button
    // Zoom: Shift + Left mouse button (or Center mouse button)
    // Pan: Ctrl + Left mouse button
    //
    //Furthermore, it is possible to select and deselect objects,
    //to decrease the mouse sensitivity, and to toggle the
    //inspection mode (see the description of the generic parameter
    //'inspection_mode' below):
    //
    // (De-)select object(s): Right mouse button
    // Low mouse sensitivity: Alt + Mouse button
    // Toggle inspection mode: Ctrl + Alt + Left mouse button
    //
    //In GenParamName and GenParamValue all generic Parameters
    //of disp_object_model_3d are supported.
    try
    {
      //
      //**********************************************************
      //Define parameter variables
      //**********************************************************
      //
      hv_Parameters.Dispose();
      HOperatorSet.CreateMessage(out hv_Parameters);
      HOperatorSet.SetMessageTuple(hv_Parameters, "MessageQueue", hv_MessageQueue);

      //
      //**********************************************************
      //Initialize Handles to enable correct handling in error case
      //**********************************************************
      hv_Scene3DTest.Dispose();
      hv_Scene3DTest = new HTuple();
      hv_Scene3D.Dispose();
      hv_Scene3D = new HTuple();
      hv_WindowHandleBuffer.Dispose();
      hv_WindowHandleBuffer = new HTuple();

      //**********************************************************
      //Some user defines that may be adapted if desired
      //**********************************************************
      //
      //TrackballSize defines the diameter of the trackball in
      //the image with respect to the smaller image dimension.
      hv_TrackballSize.Dispose();
      hv_TrackballSize = 0.8;
      //
      //VirtualTrackball defines the type of virtual trackball that
      //shall be used ('shoemake' or 'bell').
      hv_VirtualTrackball.Dispose();
      hv_VirtualTrackball = "shoemake";
      //VirtualTrackball := 'bell'
      //
      //Functionality of mouse buttons
      //    1: Left Button
      //    2: Middle Button
      //    4: Right Button
      //    5: Left+Right Mousebutton
      //  8+x: Shift + Mousebutton
      // 16+x: Ctrl + Mousebutton
      // 48+x: Ctrl + Alt + Mousebutton
      //in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]
      hv_MouseMapping.Dispose();
      hv_MouseMapping = new HTuple();
      hv_MouseMapping[0] = 17;
      hv_MouseMapping[1] = 1;
      hv_MouseMapping[2] = 2;
      hv_MouseMapping[3] = 5;
      hv_MouseMapping[4] = 9;
      hv_MouseMapping[5] = 4;
      hv_MouseMapping[6] = 49;
      //
      //The labels of the objects appear next to their projected
      //center. With gDispObjOffset a fixed offset is added
      //                  R,  C
      hv_gDispObjOffset.Dispose();
      hv_gDispObjOffset = new HTuple();
      hv_gDispObjOffset[0] = -30;
      hv_gDispObjOffset[1] = 0;
      HOperatorSet.SetMessageTuple(hv_Parameters, "gDispObjOffset", hv_gDispObjOffset);
      //
      //Customize the decoration of the different text elements
      //              Color,   Box
      hv_gInfoDecor.Dispose();
      hv_gInfoDecor = new HTuple();
      hv_gInfoDecor[0] = "white";
      hv_gInfoDecor[1] = "false";
      HOperatorSet.SetMessageTuple(hv_Parameters, "gInfoDecor", hv_gInfoDecor);
      hv_gLabelsDecor.Dispose();
      hv_gLabelsDecor = new HTuple();
      hv_gLabelsDecor[0] = "white";
      hv_gLabelsDecor[1] = "false";
      HOperatorSet.SetMessageTuple(hv_Parameters, "gLabelsDecor", hv_gLabelsDecor);
      hv_gTitleDecor.Dispose();
      hv_gTitleDecor = new HTuple();
      hv_gTitleDecor[0] = "black";
      hv_gTitleDecor[1] = "true";
      HOperatorSet.SetMessageTuple(hv_Parameters, "gTitleDecor", hv_gTitleDecor);
      //
      //Customize the position of some text elements
      //  gInfoPos has one of the values
      //  {'UpperLeft', 'LowerLeft', 'UpperRight'}
      hv_gInfoPos.Dispose();
      hv_gInfoPos = "LowerLeft";
      HOperatorSet.SetMessageTuple(hv_Parameters, "gInfoPos", hv_gInfoPos);
      //  gTitlePos has one of the values
      //  {'UpperLeft', 'UpperCenter', 'UpperRight'}
      hv_gTitlePos.Dispose();
      hv_gTitlePos = "UpperLeft";
      HOperatorSet.SetMessageTuple(hv_Parameters, "gTitlePos", hv_gTitlePos);
      //Alpha value (=1-transparency) that is used for visualizing
      //the objects that are not selected
      hv_gAlphaDeselected.Dispose();
      hv_gAlphaDeselected = 0.3;
      HOperatorSet.SetMessageTuple(hv_Parameters, "gAlphaDeselected", hv_gAlphaDeselected);
      //BUTTONS
      hv_ExitButton.Dispose();
      hv_ExitButton = -1;
      if ((int)(new HTuple(hv_Buttons_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
      {
        //Customize the label of the continue button
        if (hv_Buttons_COPY_INP_TMP == null)
          hv_Buttons_COPY_INP_TMP = new HTuple();
        hv_Buttons_COPY_INP_TMP[0] = " Continue ";
        //Position of the button
        if (hv_Buttons_COPY_INP_TMP == null)
          hv_Buttons_COPY_INP_TMP = new HTuple();
        hv_Buttons_COPY_INP_TMP[1] = "right";
        if (hv_Buttons_COPY_INP_TMP == null)
          hv_Buttons_COPY_INP_TMP = new HTuple();
        hv_Buttons_COPY_INP_TMP[2] = "bottom";
        if (hv_Buttons_COPY_INP_TMP == null)
          hv_Buttons_COPY_INP_TMP = new HTuple();
        hv_Buttons_COPY_INP_TMP[3] = -1;
        if (hv_Buttons_COPY_INP_TMP == null)
          hv_Buttons_COPY_INP_TMP = new HTuple();
        hv_Buttons_COPY_INP_TMP[4] = -1;
        hv_ExitButton.Dispose();
        hv_ExitButton = 0;
      }
      //Number of 3D Object models that can be selected and handled individually.
      //If there are more models passed then this number, some calculations
      //are performed differently and the individual selection and handling
      //of models is not supported anymore. Note that the value of MaxNumModels
      //can be overwritten with the generic parameter max_num_selectable_models.
      hv_MaxNumModels.Dispose();
      hv_MaxNumModels = 1000;
      //Defines the default for the initial state of the rotation center:
      //(1) The rotation center is fixed in the center of the image and lies
      //    on the surface of the object.
      //(2) The rotation center lies in the center of the object.
      hv_WindowCenteredRotation.Dispose();
      hv_WindowCenteredRotation = 2;
      //
      //**********************************************************
      //
      //Initialize some values
      hv_NumModels.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumModels = new HTuple(hv_ObjectModel3D_COPY_INP_TMP.TupleLength()
          );
      }
      hv_SelectedObject.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SelectedObject = HTuple.TupleGenConst(
          hv_NumModels,1);
      }
      hv_ButtonPressStatus.Dispose();
      hv_ButtonPressStatus = 0;
      //
      //Apply some system settings
      // dev_set_preferences(...); only in hdevelop
      // dev_get_preferences(...); only in hdevelop
      // dev_set_preferences(...); only in hdevelop
      hv_ClipRegion.Dispose();
      HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
      HOperatorSet.SetSystem("clip_region", "false");
      dev_update_off();
      //
      //Check if GenParamName matches GenParamValue
      if ((int)(new HTuple((new HTuple(hv_GenParamName_COPY_INP_TMP.TupleLength()
          )).TupleNotEqual(new HTuple(hv_GenParamValue_COPY_INP_TMP.TupleLength()
          )))) != 0)
      {
        throw new HalconException("Number of generic parameters does not match number of generic parameter values");
      }
      //
      //
      //Refactor camera parameters to fit to window size
      //
      hv_CPLength.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CPLength = new HTuple(hv_CamParam_COPY_INP_TMP.TupleLength()
          );
      }
      hv_RowNotUsed.Dispose();hv_ColumnNotUsed.Dispose();hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowNotUsed, out hv_ColumnNotUsed, 
          out hv_Width, out hv_Height);
      hv_WPRow1.Dispose();hv_WPColumn1.Dispose();hv_WPRow2.Dispose();hv_WPColumn2.Dispose();
      HOperatorSet.GetPart(hv_WindowHandle, out hv_WPRow1, out hv_WPColumn1, out hv_WPRow2, 
          out hv_WPColumn2);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_Height-1, hv_Width-1);
      }
      if ((int)(new HTuple(hv_CPLength.TupleEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamParam_COPY_INP_TMP.Dispose();
        gen_cam_par_area_scan_division(0.06, 0, 8.5e-6, 8.5e-6, hv_Width/2, hv_Height/2, 
            hv_Width, hv_Height, out hv_CamParam_COPY_INP_TMP);
        }
      }
      else
      {
        hv_CamParamValue.Dispose();
        get_cam_par_data(hv_CamParam_COPY_INP_TMP, (((((new HTuple("sx")).TupleConcat(
            "sy")).TupleConcat("cx")).TupleConcat("cy")).TupleConcat("image_width")).TupleConcat(
            "image_height"), out hv_CamParamValue);
        hv_CamWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamWidth = ((hv_CamParamValue.TupleSelect(
            4))).TupleReal();
        }
        hv_CamHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CamHeight = ((hv_CamParamValue.TupleSelect(
            5))).TupleReal();
        }
        hv_Scale.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Scale = ((((hv_Width/hv_CamWidth)).TupleConcat(
            hv_Height/hv_CamHeight))).TupleMin();
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "sx", (hv_CamParamValue.TupleSelect(
            0))/hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "sy", (hv_CamParamValue.TupleSelect(
            1))/hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "cx", (hv_CamParamValue.TupleSelect(
            2))*hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "cy", (hv_CamParamValue.TupleSelect(
            3))*hv_Scale, out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "image_width", (((hv_CamParamValue.TupleSelect(
            4))*hv_Scale)).TupleInt(), out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HTuple ExpTmpOutVar_0;
        set_cam_par_data(hv_CamParam_COPY_INP_TMP, "image_height", (((hv_CamParamValue.TupleSelect(
            5))*hv_Scale)).TupleInt(), out ExpTmpOutVar_0);
        hv_CamParam_COPY_INP_TMP.Dispose();
        hv_CamParam_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Check the generic parameters for max_num_selectable_models
      //(Note that the default is set above to MaxNumModels := 1000)
      hv_Indices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
          "max_num_selectable_models");
      }
      if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
          new HTuple())))) != 0)
      {
        if ((int)(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(hv_Indices.TupleSelect(
            0)))).TupleIsNumber()) != 0)
        {
          if ((int)(new HTuple(((((((hv_GenParamValue_COPY_INP_TMP.TupleSelect(hv_Indices.TupleSelect(
              0)))).TupleNumber())).TupleInt())).TupleLess(1))) != 0)
          {
            //Wrong parameter value: Only integer values greater than 0 are allowed
            throw new HalconException("Wrong value for parameter 'max_num_selectable_models' (must be an integer value greater than 0)");
          }
        }
        else
        {
          //Wrong parameter value: Only integer values greater than 0 are allowed
          throw new HalconException("Wrong value for parameter 'max_num_selectable_models' (must be an integer value greater than 0)");
        }
        hv_MaxNumModels.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxNumModels = ((((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_Indices.TupleSelect(0)))).TupleNumber())).TupleInt();
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      //
      //Check the generic parameters for window_centered_rotation
      //(Note that the default is set above to WindowCenteredRotation := 2)
      hv_Indices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
          "inspection_mode");
      }
      if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
          new HTuple())))) != 0)
      {
        if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(hv_Indices.TupleSelect(
            0)))).TupleEqual("surface"))) != 0)
        {
          hv_WindowCenteredRotation.Dispose();
          hv_WindowCenteredRotation = 1;
        }
        else if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_Indices.TupleSelect(0)))).TupleEqual("standard"))) != 0)
        {
          hv_WindowCenteredRotation.Dispose();
          hv_WindowCenteredRotation = 2;
        }
        else
        {
          //Wrong parameter value, use default value
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      //
      //Check the generic parameters for disp_background
      //(The former parameter name 'use_background' is still supported
      // for compatibility reasons)
      hv_DispBackground.Dispose();
      hv_DispBackground = "false";
      if ((int)(new HTuple((new HTuple(hv_GenParamName_COPY_INP_TMP.TupleLength()
          )).TupleGreater(0))) != 0)
      {
        hv_Mask.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Mask = ((hv_GenParamName_COPY_INP_TMP.TupleEqualElem(
            "disp_background"))).TupleOr(hv_GenParamName_COPY_INP_TMP.TupleEqualElem(
            "use_background"));
        }
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = hv_Mask.TupleFind(
            1);
        }
      }
      else
      {
        hv_Indices.Dispose();
        hv_Indices = -1;
      }
      if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
          new HTuple())))) != 0)
      {
        hv_DispBackground.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DispBackground = hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_Indices.TupleSelect(0));
        }
        if ((int)((new HTuple(hv_DispBackground.TupleNotEqual("true"))).TupleAnd(
            new HTuple(hv_DispBackground.TupleNotEqual("false")))) != 0)
        {
          //Wrong parameter value: Only 'true' and 'false' are allowed
          throw new HalconException("Wrong value for parameter 'disp_background' (must be either 'true' or 'false')");
        }
        //Note the the background is handled explicitly in this procedure
        //and therefore, the parameter is removed from the list of
        //parameters and disp_background is always set to true (see below)
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = ExpTmpLocalVar_GenParamValue;
        }
        }
      }
      //
      //Read and check the parameter Label for each object
      if ((int)(new HTuple((new HTuple(hv_Label_COPY_INP_TMP.TupleLength())).TupleEqual(
          0))) != 0)
      {
        hv_Label_COPY_INP_TMP.Dispose();
        hv_Label_COPY_INP_TMP = 0;
      }
      else if ((int)(new HTuple((new HTuple(hv_Label_COPY_INP_TMP.TupleLength()
          )).TupleEqual(1))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Label = HTuple.TupleGenConst(
            hv_NumModels,hv_Label_COPY_INP_TMP);
        hv_Label_COPY_INP_TMP.Dispose();
        hv_Label_COPY_INP_TMP = ExpTmpLocalVar_Label;
        }
        }
      }
      else
      {
        if ((int)(new HTuple((new HTuple(hv_Label_COPY_INP_TMP.TupleLength())).TupleNotEqual(
            hv_NumModels))) != 0)
        {
          //Error: Number of elements in Label does not match the
          //number of object models
          // stop(...); only in hdevelop
        }
      }
      //
      //Read and check the parameter PoseIn for each object
      hv_Center.Dispose();
      get_object_models_center(hv_ObjectModel3D_COPY_INP_TMP, out hv_Center);
      if ((int)(new HTuple(hv_Center.TupleEqual(new HTuple()))) != 0)
      {
        hv_Center.Dispose();
        hv_Center = new HTuple();
        hv_Center[0] = 0;
        hv_Center[1] = 0;
        hv_Center[2] = 0;
      }
      if ((int)(new HTuple((new HTuple(hv_PoseIn_COPY_INP_TMP.TupleLength())).TupleEqual(
          0))) != 0)
      {
        //If no pose was specified by the caller, automatically calculate
        //a pose that is appropriate for the visualization.
        //Set the initial model reference pose. The orientation is parallel
        //to the object coordinate system, the position is at the center
        //of gravity of all models.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PoseIn_COPY_INP_TMP.Dispose();
        HOperatorSet.CreatePose(-(hv_Center.TupleSelect(0)), -(hv_Center.TupleSelect(
            1)), -(hv_Center.TupleSelect(2)), 0, 0, 0, "Rp+T", "gba", "point", out hv_PoseIn_COPY_INP_TMP);
        }
        hv_PoseEstimated.Dispose();
        determine_optimum_pose_distance(hv_ObjectModel3D_COPY_INP_TMP, hv_CamParam_COPY_INP_TMP, 
            0.9, hv_PoseIn_COPY_INP_TMP, out hv_PoseEstimated);
        hv_Poses.Dispose();
        hv_Poses = new HTuple();
        hv_HomMat3Ds.Dispose();
        hv_HomMat3Ds = new HTuple();
        hv_Sequence.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Sequence = HTuple.TupleGenSequence(
            0,(hv_NumModels*7)-1,1);
        }
        hv_Poses.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Poses = hv_PoseEstimated.TupleSelect(
            hv_Sequence%7);
        }
        hv_gIsSinglePose.Dispose();
        hv_gIsSinglePose = 1;
        HOperatorSet.SetMessageTuple(hv_Parameters, "gIsSinglePose", hv_gIsSinglePose);
      }
      else if ((int)(new HTuple((new HTuple(hv_PoseIn_COPY_INP_TMP.TupleLength()
          )).TupleEqual(7))) != 0)
      {
        hv_Poses.Dispose();
        hv_Poses = new HTuple();
        hv_HomMat3Ds.Dispose();
        hv_HomMat3Ds = new HTuple();
        hv_Sequence.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Sequence = HTuple.TupleGenSequence(
            0,(hv_NumModels*7)-1,1);
        }
        hv_Poses.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Poses = hv_PoseIn_COPY_INP_TMP.TupleSelect(
            hv_Sequence%7);
        }
        hv_gIsSinglePose.Dispose();
        hv_gIsSinglePose = 1;
        HOperatorSet.SetMessageTuple(hv_Parameters, "gIsSinglePose", hv_gIsSinglePose);
      }
      else
      {
        if ((int)(new HTuple((new HTuple(hv_PoseIn_COPY_INP_TMP.TupleLength())).TupleNotEqual(
            (new HTuple(hv_ObjectModel3D_COPY_INP_TMP.TupleLength()))*7))) != 0)
        {
          //Error: Wrong number of values of input control parameter 'PoseIn'
          // stop(...); only in hdevelop
        }
        else
        {
          hv_Poses.Dispose();
          hv_Poses = new HTuple(hv_PoseIn_COPY_INP_TMP);
        }
        hv_gIsSinglePose.Dispose();
        hv_gIsSinglePose = 0;
        HOperatorSet.SetMessageTuple(hv_Parameters, "gIsSinglePose", hv_gIsSinglePose);
      }

      //
      //Open (invisible) buffer window to avoid flickering
      hv_WindowHandleBuffer.Dispose();
      HOperatorSet.OpenWindow(0, 0, hv_Width, hv_Height, 0, "buffer", "", out hv_WindowHandleBuffer);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetPart(hv_WindowHandleBuffer, 0, 0, hv_Height-1, hv_Width-1);
      }
      hv_Font.Dispose();
      HOperatorSet.GetFont(hv_WindowHandle, out hv_Font);
      try
      {
        HOperatorSet.SetFont(hv_WindowHandleBuffer, hv_Font);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException2)
      {
        HDevExpDefaultException2.ToHTuple(out hv_Exception);
      }
      //
      // Is OpenGL available and should it be used?
      hv_gUsesOpenGL.Dispose();
      hv_gUsesOpenGL = "true";
      HOperatorSet.SetMessageTuple(hv_Parameters, "gUsesOpenGL", hv_gUsesOpenGL);
      hv_Indices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
          "opengl");
      }
      if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
          new HTuple())))) != 0)
      {
        hv_gUsesOpenGL.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_gUsesOpenGL = hv_GenParamValue_COPY_INP_TMP.TupleSelect(
            hv_Indices.TupleSelect(0));
        }
        HOperatorSet.SetMessageTuple(hv_Parameters, "gUsesOpenGL", hv_gUsesOpenGL);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamName = hv_GenParamName_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = ExpTmpLocalVar_GenParamName;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GenParamValue = hv_GenParamValue_COPY_INP_TMP.TupleRemove(
            hv_Indices);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = ExpTmpLocalVar_GenParamValue;
        }
        }
        if ((int)((new HTuple(hv_gUsesOpenGL.TupleNotEqual("true"))).TupleAnd(new HTuple(hv_gUsesOpenGL.TupleNotEqual(
            "false")))) != 0)
        {
          //Wrong parameter value: Only 'true' and 'false' are allowed
          throw new HalconException("Wrong value for parameter 'opengl' (must be either 'true' or 'false')");
        }
      }
      if ((int)(new HTuple(hv_gUsesOpenGL.TupleEqual("true"))) != 0)
      {
        hv_OpenGLInfo.Dispose();
        HOperatorSet.GetSystem("opengl_info", out hv_OpenGLInfo);
        if ((int)(new HTuple(hv_OpenGLInfo.TupleEqual("No OpenGL support included."))) != 0)
        {
          hv_gUsesOpenGL.Dispose();
          hv_gUsesOpenGL = "false";
          HOperatorSet.SetMessageTuple(hv_Parameters, "gUsesOpenGL", hv_gUsesOpenGL);
        }
        else
        {
          hv_DummyObjectModel3D.Dispose();
          HOperatorSet.GenObjectModel3dFromPoints(0, 0, 0, out hv_DummyObjectModel3D);
          hv_Scene3DTest.Dispose();
          HOperatorSet.CreateScene3d(out hv_Scene3DTest);
          hv_CameraIndexTest.Dispose();
          HOperatorSet.AddScene3dCamera(hv_Scene3DTest, hv_CamParam_COPY_INP_TMP, 
              out hv_CameraIndexTest);
          hv_PoseTest.Dispose();
          determine_optimum_pose_distance(hv_DummyObjectModel3D, hv_CamParam_COPY_INP_TMP, 
              0.9, ((((((new HTuple(0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(
              0)).TupleConcat(0)).TupleConcat(0)).TupleConcat(0), out hv_PoseTest);
          hv_InstanceIndexTest.Dispose();
          HOperatorSet.AddScene3dInstance(hv_Scene3DTest, hv_DummyObjectModel3D, 
              hv_PoseTest, out hv_InstanceIndexTest);
          try
          {
            HOperatorSet.DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3DTest, hv_InstanceIndexTest);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException2)
          {
            HDevExpDefaultException2.ToHTuple(out hv_Exception);
            hv_gUsesOpenGL.Dispose();
            hv_gUsesOpenGL = "false";
            HOperatorSet.SetMessageTuple(hv_Parameters, "gUsesOpenGL", hv_gUsesOpenGL);
          }
          hv_Scene3DTest.Dispose();
          hv_Scene3DTest = new HTuple();
          hv_DummyObjectModel3D.Dispose();
          hv_DummyObjectModel3D = new HTuple();
        }
      }
      //
      //Compute the trackball
      hv_MinImageSize.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinImageSize = ((hv_Width.TupleConcat(
          hv_Height))).TupleMin();
      }
      hv_TrackballRadiusPixel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize)/2.0;
      }
      //
      //Measure the text extents for the continue button in the
      //graphics window
      //Finalize Buttons
      for (hv_idx=0; (int)hv_idx<=(int)((new HTuple(hv_Buttons_COPY_INP_TMP.TupleLength()
          ))-1); hv_idx = (int)hv_idx + 5)
      {
        hv_MaxAscent.Dispose();hv_MaxDescent.Dispose();hv_MaxWidth.Dispose();hv_MaxHeight.Dispose();
        HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent, 
            out hv_MaxWidth, out hv_MaxHeight);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandleBuffer, (hv_Buttons_COPY_INP_TMP.TupleSelect(
            hv_idx+0))+"  ", out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
        }
        hv_ButtonWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ButtonWidth = hv_Buttons_COPY_INP_TMP.TupleSelect(
            hv_idx+3);
        }
        if ((int)(new HTuple(hv_ButtonWidth.TupleEqual(-1))) != 0)
        {
          hv_ButtonWidth.Dispose();
          hv_ButtonWidth = new HTuple(hv_TextWidth);
        }
        hv_ButtonHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ButtonHeight = hv_Buttons_COPY_INP_TMP.TupleSelect(
            hv_idx+4);
        }
        if ((int)(new HTuple(hv_ButtonHeight.TupleEqual(-1))) != 0)
        {
          //Button border is of size 2
          hv_ButtonHeight.Dispose();
          hv_ButtonHeight = new HTuple(hv_MaxHeight);
        }
        //X position
        if ((int)(new HTuple(((hv_Buttons_COPY_INP_TMP.TupleSelect(hv_idx+1))).TupleEqual(
            "right"))) != 0)
        {
          if (hv_Buttons_COPY_INP_TMP == null)
            hv_Buttons_COPY_INP_TMP = new HTuple();
          hv_Buttons_COPY_INP_TMP[hv_idx+1] = (hv_Width-15)-hv_ButtonWidth;
        }
        else if ((int)(new HTuple(((hv_Buttons_COPY_INP_TMP.TupleSelect(
            hv_idx+1))).TupleEqual("left"))) != 0)
        {
          if (hv_Buttons_COPY_INP_TMP == null)
            hv_Buttons_COPY_INP_TMP = new HTuple();
          hv_Buttons_COPY_INP_TMP[hv_idx+1] = 15;
        }
        else if ((int)(new HTuple(((hv_Buttons_COPY_INP_TMP.TupleSelect(
            hv_idx+1))).TupleEqual("center"))) != 0)
        {
          if (hv_Buttons_COPY_INP_TMP == null)
            hv_Buttons_COPY_INP_TMP = new HTuple();
          hv_Buttons_COPY_INP_TMP[hv_idx+1] = (hv_Width/2)-(hv_ButtonWidth/2);
        }
        else
        {
          throw new HalconException("Invalid button horizontal position: "+(hv_Buttons_COPY_INP_TMP.TupleSelect(
              hv_idx+1)));
        }
        if (hv_Buttons_COPY_INP_TMP == null)
          hv_Buttons_COPY_INP_TMP = new HTuple();
        hv_Buttons_COPY_INP_TMP[hv_idx+3] = (hv_Buttons_COPY_INP_TMP.TupleSelect(
            hv_idx+1))+hv_ButtonWidth;
        //Y position
        if ((int)(new HTuple(((hv_Buttons_COPY_INP_TMP.TupleSelect(hv_idx+2))).TupleEqual(
            "bottom"))) != 0)
        {
          if (hv_Buttons_COPY_INP_TMP == null)
            hv_Buttons_COPY_INP_TMP = new HTuple();
          hv_Buttons_COPY_INP_TMP[hv_idx+2] = (hv_Height-25)-hv_ButtonHeight;
        }
        else if ((int)(new HTuple(((hv_Buttons_COPY_INP_TMP.TupleSelect(
            hv_idx+2))).TupleEqual("top"))) != 0)
        {
          if (hv_Buttons_COPY_INP_TMP == null)
            hv_Buttons_COPY_INP_TMP = new HTuple();
          hv_Buttons_COPY_INP_TMP[hv_idx+2] = 25;
        }
        else if ((int)(new HTuple(((hv_Buttons_COPY_INP_TMP.TupleSelect(
            hv_idx+2))).TupleEqual("center"))) != 0)
        {
          if (hv_Buttons_COPY_INP_TMP == null)
            hv_Buttons_COPY_INP_TMP = new HTuple();
          hv_Buttons_COPY_INP_TMP[hv_idx+2] = (hv_Height/2)-(hv_ButtonHeight/2);
        }
        else
        {
          throw new HalconException("Invalid button vertical position: "+(hv_Buttons_COPY_INP_TMP.TupleSelect(
              hv_idx+2)));
        }
        if (hv_Buttons_COPY_INP_TMP == null)
          hv_Buttons_COPY_INP_TMP = new HTuple();
        hv_Buttons_COPY_INP_TMP[hv_idx+4] = (hv_Buttons_COPY_INP_TMP.TupleSelect(
            hv_idx+2))+hv_ButtonHeight;
      }
      hv_gButtons.Dispose();
      hv_gButtons = new HTuple(hv_Buttons_COPY_INP_TMP);
      HOperatorSet.SetMessageTuple(hv_Parameters, "gButtons", hv_gButtons);
      //
      //Store background image
      if ((int)(new HTuple(hv_DispBackground.TupleEqual("false"))) != 0)
      {
        HOperatorSet.ClearWindow(hv_WindowHandle);
      }
      ho_Image.Dispose();
      HOperatorSet.DumpWindowImage(out ho_Image, hv_WindowHandle);
      //Special treatment for color background images necessary
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_Image, out hv_NumChannels);
      hv_ColorImage.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColorImage = new HTuple(hv_NumChannels.TupleEqual(
          3));
      }
      //
      hv_OriginalGenParamName.Dispose();
      hv_OriginalGenParamName = new HTuple(hv_GenParamName_COPY_INP_TMP);
      hv_OriginalGenParamValue.Dispose();
      hv_OriginalGenParamValue = new HTuple(hv_GenParamValue_COPY_INP_TMP);

      hv_Exit.Dispose();
      hv_Exit = 0;
      hv_PreviousSentPose.Dispose();
      hv_PreviousSentPose = new HTuple();
      while ((int)(hv_Exit.TupleNot()) != 0)
      {
        hv_GenParamName_COPY_INP_TMP.Dispose();
        hv_GenParamName_COPY_INP_TMP = new HTuple(hv_OriginalGenParamName);
        hv_GenParamValue_COPY_INP_TMP.Dispose();
        hv_GenParamValue_COPY_INP_TMP = new HTuple(hv_OriginalGenParamValue);

        hv_Scene3D.Dispose();
        HOperatorSet.CreateScene3d(out hv_Scene3D);
        hv_CameraIndex.Dispose();
        HOperatorSet.AddScene3dCamera(hv_Scene3D, hv_CamParam_COPY_INP_TMP, out hv_CameraIndex);
        hv_AllInstances.Dispose();
        HOperatorSet.AddScene3dInstance(hv_Scene3D, hv_ObjectModel3D_COPY_INP_TMP, 
            hv_Poses, out hv_AllInstances);
        //Always set 'disp_background' to true,  because it is handled explicitly
        //in this procedure (see above)
        HOperatorSet.SetScene3dParam(hv_Scene3D, "disp_background", "true");
        //Check if we have to set light specific parameters
        hv_SetLight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SetLight = new HTuple(hv_GenParamName_COPY_INP_TMP.TupleRegexpTest(
            "light_"));
        }
        if ((int)(hv_SetLight) != 0)
        {
          //set position of light source
          hv_Indices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
              "light_position");
          }
          if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
              new HTuple())))) != 0)
          {
            //If multiple light positions are given, use the last one
            hv_LightParam.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LightParam = ((((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
                hv_Indices.TupleSelect((new HTuple(hv_Indices.TupleLength()))-1)))).TupleSplit(
                new HTuple(", ")))).TupleNumber();
            }
            if ((int)(new HTuple((new HTuple(hv_LightParam.TupleLength())).TupleNotEqual(
                4))) != 0)
            {
              throw new HalconException("light_position must be given as a string that contains four space separated floating point numbers");
            }
            hv_LightPosition.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LightPosition = hv_LightParam.TupleSelectRange(
                0,2);
            }
            hv_LightKind.Dispose();
            hv_LightKind = "point_light";
            if ((int)(new HTuple(((hv_LightParam.TupleSelect(3))).TupleEqual(0))) != 0)
            {
              hv_LightKind.Dispose();
              hv_LightKind = "directional_light";
            }
            //Currently, only one light source is supported
            HOperatorSet.RemoveScene3dLight(hv_Scene3D, 0);
            hv_LightIndex.Dispose();
            HOperatorSet.AddScene3dLight(hv_Scene3D, hv_LightPosition, hv_LightKind, 
                out hv_LightIndex);
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.TupleRemove(hv_GenParamName_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
            hv_GenParamName_COPY_INP_TMP.Dispose();
            hv_GenParamName_COPY_INP_TMP = ExpTmpOutVar_0;
            }
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.TupleRemove(hv_GenParamValue_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
            hv_GenParamValue_COPY_INP_TMP.Dispose();
            hv_GenParamValue_COPY_INP_TMP = ExpTmpOutVar_0;
            }
          }
          //set ambient part of light source
          hv_Indices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
              "light_ambient");
          }
          if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
              new HTuple())))) != 0)
          {
            //If the ambient part is set multiple times, use the last setting
            hv_LightParam.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LightParam = ((((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
                hv_Indices.TupleSelect((new HTuple(hv_Indices.TupleLength()))-1)))).TupleSplit(
                new HTuple(", ")))).TupleNumber();
            }
            if ((int)(new HTuple((new HTuple(hv_LightParam.TupleLength())).TupleLess(
                3))) != 0)
            {
              throw new HalconException("light_ambient must be given as a string that contains three space separated floating point numbers");
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetScene3dLightParam(hv_Scene3D, 0, "ambient", hv_LightParam.TupleSelectRange(
                0,2));
            }
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.TupleRemove(hv_GenParamName_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
            hv_GenParamName_COPY_INP_TMP.Dispose();
            hv_GenParamName_COPY_INP_TMP = ExpTmpOutVar_0;
            }
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.TupleRemove(hv_GenParamValue_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
            hv_GenParamValue_COPY_INP_TMP.Dispose();
            hv_GenParamValue_COPY_INP_TMP = ExpTmpOutVar_0;
            }
          }
          //Set diffuse part of light source
          hv_Indices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
              "light_diffuse");
          }
          if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
              new HTuple())))) != 0)
          {
            //If the diffuse part is set multiple times, use the last setting
            hv_LightParam.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LightParam = ((((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
                hv_Indices.TupleSelect((new HTuple(hv_Indices.TupleLength()))-1)))).TupleSplit(
                new HTuple(", ")))).TupleNumber();
            }
            if ((int)(new HTuple((new HTuple(hv_LightParam.TupleLength())).TupleLess(
                3))) != 0)
            {
              throw new HalconException("light_diffuse must be given as a string that contains three space separated floating point numbers");
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetScene3dLightParam(hv_Scene3D, 0, "diffuse", hv_LightParam.TupleSelectRange(
                0,2));
            }
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.TupleRemove(hv_GenParamName_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
            hv_GenParamName_COPY_INP_TMP.Dispose();
            hv_GenParamName_COPY_INP_TMP = ExpTmpOutVar_0;
            }
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.TupleRemove(hv_GenParamValue_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
            hv_GenParamValue_COPY_INP_TMP.Dispose();
            hv_GenParamValue_COPY_INP_TMP = ExpTmpOutVar_0;
            }
          }
        }
        //
        //Handle persistence parameters separately because persistence will
        //only be activated immediately before leaving the visualization
        //procedure
        hv_PersistenceParamName.Dispose();
        hv_PersistenceParamName = new HTuple();
        hv_PersistenceParamValue.Dispose();
        hv_PersistenceParamValue = new HTuple();
        //Set position of light source
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
            "object_index_persistence");
        }
        if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
            new HTuple())))) != 0)
        {
          if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(hv_Indices.TupleSelect(
              (new HTuple(hv_Indices.TupleLength()))-1)))).TupleEqual("true"))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_PersistenceParamName = hv_PersistenceParamName.TupleConcat(
                "object_index_persistence");
            hv_PersistenceParamName.Dispose();
            hv_PersistenceParamName = ExpTmpLocalVar_PersistenceParamName;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat(
                "true");
            hv_PersistenceParamValue.Dispose();
            hv_PersistenceParamValue = ExpTmpLocalVar_PersistenceParamValue;
            }
            }
          }
          else if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
              hv_Indices.TupleSelect((new HTuple(hv_Indices.TupleLength()))-1)))).TupleEqual(
              "false"))) != 0)
          {
          }
          else
          {
            throw new HalconException("Wrong value for parameter 'object_index_persistence' (must be either 'true' or 'false')");
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_GenParamName_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
          hv_GenParamName_COPY_INP_TMP.Dispose();
          hv_GenParamName_COPY_INP_TMP = ExpTmpOutVar_0;
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_GenParamValue_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
          hv_GenParamValue_COPY_INP_TMP.Dispose();
          hv_GenParamValue_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = hv_GenParamName_COPY_INP_TMP.TupleFind(
            "depth_persistence");
        }
        if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
            new HTuple())))) != 0)
        {
          if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(hv_Indices.TupleSelect(
              (new HTuple(hv_Indices.TupleLength()))-1)))).TupleEqual("true"))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_PersistenceParamName = hv_PersistenceParamName.TupleConcat(
                "depth_persistence");
            hv_PersistenceParamName.Dispose();
            hv_PersistenceParamName = ExpTmpLocalVar_PersistenceParamName;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat(
                "true");
            hv_PersistenceParamValue.Dispose();
            hv_PersistenceParamValue = ExpTmpLocalVar_PersistenceParamValue;
            }
            }
          }
          else if ((int)(new HTuple(((hv_GenParamValue_COPY_INP_TMP.TupleSelect(
              hv_Indices.TupleSelect((new HTuple(hv_Indices.TupleLength()))-1)))).TupleEqual(
              "false"))) != 0)
          {
          }
          else
          {
            throw new HalconException("Wrong value for parameter 'depth_persistence' (must be either 'true' or 'false')");
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_GenParamName_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
          hv_GenParamName_COPY_INP_TMP.Dispose();
          hv_GenParamName_COPY_INP_TMP = ExpTmpOutVar_0;
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_GenParamValue_COPY_INP_TMP, hv_Indices, out ExpTmpOutVar_0);
          hv_GenParamValue_COPY_INP_TMP.Dispose();
          hv_GenParamValue_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        //
        //Parse the generic parameters
        //- First, all parameters that are understood by set_scene_3d_instance_param
        hv_AlphaOrig.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AlphaOrig = HTuple.TupleGenConst(
            hv_NumModels,1);
        }
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_GenParamName_COPY_INP_TMP.TupleLength()
            ))-1); hv_I = (int)hv_I + 1)
        {
          hv_ParamName.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ParamName = hv_GenParamName_COPY_INP_TMP.TupleSelect(
              hv_I);
          }
          hv_ParamValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ParamValue = hv_GenParamValue_COPY_INP_TMP.TupleSelect(
              hv_I);
          }
          //Check if this parameter is understood by set_scene_3d_param
          if ((int)(new HTuple(hv_ParamName.TupleEqual("alpha"))) != 0)
          {
            hv_AlphaOrig.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_AlphaOrig = HTuple.TupleGenConst(
                hv_NumModels,hv_ParamValue);
            }
          }
          try
          {
            HOperatorSet.SetScene3dParam(hv_Scene3D, hv_ParamName, hv_ParamValue);
            continue;
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException2)
          {
            HDevExpDefaultException2.ToHTuple(out hv_Exception);
            if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1203))).TupleOr(
                new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1303)))) != 0)
            {
              throw new HalconException((("Wrong type or value for parameter "+hv_ParamName)+": ")+hv_ParamValue);
            }
          }
          //Check if it is a parameter that is valid for only one instance
          //and therefore can be set only with set_scene_3d_instance_param
          hv_ParamNameTrunk.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ParamNameTrunk = hv_ParamName.TupleRegexpReplace(
              "_\\d+$","");
          }
          if ((int)(new HTuple(hv_ParamName.TupleEqual(hv_ParamNameTrunk))) != 0)
          {
            hv_Instance.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Instance = HTuple.TupleGenSequence(
                0,hv_NumModels-1,1);
            }
          }
          else
          {
            hv_Instance.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Instance = ((hv_ParamName.TupleRegexpReplace(
                ("^"+hv_ParamNameTrunk)+"_(\\d+)$","$1"))).TupleNumber();
            }
            if ((int)((new HTuple(hv_Instance.TupleLess(0))).TupleOr(new HTuple(hv_Instance.TupleGreater(
                hv_NumModels-1)))) != 0)
            {
              throw new HalconException(("Parameter "+hv_ParamName)+" refers to a non existing 3D object model");
            }
          }
          try
          {
            HOperatorSet.SetScene3dInstanceParam(hv_Scene3D, hv_Instance, hv_ParamNameTrunk, 
                hv_ParamValue);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException2)
          {
            HDevExpDefaultException2.ToHTuple(out hv_Exception);
            if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1204))).TupleOr(
                new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1304)))) != 0)
            {
              throw new HalconException((("Wrong type or value for parameter "+hv_ParamName)+": ")+hv_ParamValue);
            }
            else if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
                1203))).TupleOr(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
                1303)))) != 0)
            {
              throw new HalconException("Wrong parameter name "+hv_ParamName);
            }
            else
            {
              throw new HalconException(hv_Exception);
            }
          }
          if ((int)(new HTuple(hv_ParamNameTrunk.TupleEqual("alpha"))) != 0)
          {
            if (hv_AlphaOrig == null)
              hv_AlphaOrig = new HTuple();
            hv_AlphaOrig[hv_Instance] = hv_ParamValue;
          }
        }
        //
        //Start the visualization loop
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HomMat3D.Dispose();
        HOperatorSet.PoseToHomMat3d(hv_Poses.TupleSelectRange(0,6), out hv_HomMat3D);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Qx.Dispose();hv_Qy.Dispose();hv_Qz.Dispose();
        HOperatorSet.AffineTransPoint3d(hv_HomMat3D, hv_Center.TupleSelect(0), hv_Center.TupleSelect(
            1), hv_Center.TupleSelect(2), out hv_Qx, out hv_Qy, out hv_Qz);
        }
        hv_TBCenter.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TBCenter = new HTuple();
        hv_TBCenter = hv_TBCenter.TupleConcat(hv_Qx, hv_Qy, hv_Qz);
        }
        hv_TBSize.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TBSize = (0.5+((0.5*(hv_SelectedObject.TupleSum()
            ))/hv_NumModels))*hv_TrackballRadiusPixel;
        }
        hv_ButtonHold.Dispose();
        hv_ButtonHold = 0;
        hv_SupressUpdateMessage.Dispose();
        hv_SupressUpdateMessage = 0;
        while ((int)(hv_Exit.TupleNot()) != 0)
        {
          hv_VisualizeTB.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_VisualizeTB = new HTuple(((hv_SelectedObject.TupleMax()
              )).TupleNotEqual(0));
          }
          hv_MaxIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MaxIndex = ((((new HTuple(hv_ObjectModel3D_COPY_INP_TMP.TupleLength()
              )).TupleConcat(hv_MaxNumModels))).TupleMin())-1;
          }
          //Set trackball fixed in the center of the window
          hv_TrackballCenterRow.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TrackballCenterRow = hv_Height/2;
          }
          hv_TrackballCenterCol.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TrackballCenterCol = hv_Width/2;
          }
          if ((int)(new HTuple(hv_WindowCenteredRotation.TupleEqual(1))) != 0)
          {
            try
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TBCenter.Dispose();hv_TBSize.Dispose();
              get_trackball_center_fixed(hv_SelectedObject.TupleSelectRange(0,hv_MaxIndex), 
                  hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TrackballRadiusPixel, 
                  hv_Scene3D, hv_ObjectModel3D_COPY_INP_TMP.TupleSelectRange(0,hv_MaxIndex), 
                  hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), hv_WindowHandleBuffer, 
                  hv_CamParam_COPY_INP_TMP, hv_GenParamName_COPY_INP_TMP, hv_GenParamValue_COPY_INP_TMP, 
                  out hv_TBCenter, out hv_TBSize);
              }
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException2)
            {
              HDevExpDefaultException2.ToHTuple(out hv_Exception);
              disp_message(hv_WindowHandle, "Surface inspection mode is not available.", 
                  "image", 5, 20, "red", "true");
              hv_WindowCenteredRotation.Dispose();
              hv_WindowCenteredRotation = 2;
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TBCenter.Dispose();hv_TBSize.Dispose();
              get_trackball_center(hv_SelectedObject.TupleSelectRange(0,hv_MaxIndex), 
                  hv_TrackballRadiusPixel, hv_ObjectModel3D_COPY_INP_TMP.TupleSelectRange(
                  0,hv_MaxIndex), hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), 
                  out hv_TBCenter, out hv_TBSize);
              }
              HOperatorSet.WaitSeconds(1);
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TBCenter.Dispose();hv_TBSize.Dispose();
            get_trackball_center(hv_SelectedObject.TupleSelectRange(0,hv_MaxIndex), 
                hv_TrackballRadiusPixel, hv_ObjectModel3D_COPY_INP_TMP.TupleSelectRange(
                0,hv_MaxIndex), hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), 
                out hv_TBCenter, out hv_TBSize);
            }
          }
          dump_image_output(ho_Image, hv_Parameters, hv_WindowHandleBuffer, hv_Scene3D, 
              hv_AlphaOrig, hv_ObjectModel3D_COPY_INP_TMP, hv_GenParamName_COPY_INP_TMP, 
              hv_GenParamValue_COPY_INP_TMP, hv_CamParam_COPY_INP_TMP, hv_Poses, 
              hv_ColorImage, hv_Title_COPY_INP_TMP, hv_Information, hv_Label_COPY_INP_TMP, 
              hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
              hv_TBSize, hv_SelectedObject, hv_WindowCenteredRotation, hv_TBCenter, 
              hv_Type, hv_Message, hv_DispViewPoint, hv_ViewPoint);
          ho_ImageDump.Dispose();
          HOperatorSet.DumpWindowImage(out ho_ImageDump, hv_WindowHandleBuffer);
          if ((int)(1) != 0)
          {
            HOperatorSet.DispObj(ho_ImageDump, hv_WindowHandle);
          }
          else
          {
            HDevWindowStack.SetActive(hv_WindowHandle);
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ImageDump, HDevWindowStack.GetActive());
            }
          }

          if ((int)(new HTuple(hv_Poses.TupleNotEqual(hv_PreviousSentPose))) != 0)
          {
            send_pose_update(hv_Parameters, hv_Poses);
            hv_PreviousSentPose.Dispose();
            hv_PreviousSentPose = new HTuple(hv_Poses);
          }
          //
          //
          //Check for mouse events
          hv_GraphEvent.Dispose();
          hv_GraphEvent = 0;
          hv_Exit.Dispose();
          hv_Exit = 0;
          hv_Redraw.Dispose();
          hv_Redraw = 0;
          hv_RecreateScene3D.Dispose();
          hv_RecreateScene3D = 0;
          while ((int)(hv_Exit.TupleNot()) != 0)
          {
            //
            //Check graphic event
            try
            {
              hv_GraphButtonRow.Dispose();hv_GraphButtonColumn.Dispose();hv_GraphButton.Dispose();
              get_mouse_info(hv_WindowHandle, hv_MessageQueue, 0.01, out hv_GraphButtonRow, 
                  out hv_GraphButtonColumn, out hv_GraphButton);

              if ((int)(new HTuple(hv_GraphButton.TupleEqual(-1))) != 0)
              {
                //timeout! Check the second message queue
                try
                {
                  //Process all messages first, then perform any update
                  //This avoids message congestion, where we are too slow with the redrawing.
                  while ((int)(1) != 0)
                  {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    hv_MessageHandle.Dispose();
                    HOperatorSet.DequeueMessage(hv_MessageQueue.TupleSelect(1), "timeout", 
                        0.001, out hv_MessageHandle);
                    }
                    hv_MessageType.Dispose();
                    HOperatorSet.GetMessageTuple(hv_MessageHandle, "type", out hv_MessageType);
                    if ((int)(new HTuple(hv_MessageType.TupleEqual("exit"))) != 0)
                    {
                      //Graceful exit
                      hv_Exit.Dispose();
                      hv_Exit = 1;
                      break;
                    }
                    else if ((int)(new HTuple(hv_MessageType.TupleEqual(
                        "exit_fast"))) != 0)
                    {
                      //Fast exit - no cleanup of resources! Use only for debugging.
                      ho_Image.Dispose();
                      ho_ImageDump.Dispose();

                      hv_Buttons_COPY_INP_TMP.Dispose();
                      hv_CamParam_COPY_INP_TMP.Dispose();
                      hv_GenParamName_COPY_INP_TMP.Dispose();
                      hv_GenParamValue_COPY_INP_TMP.Dispose();
                      hv_Label_COPY_INP_TMP.Dispose();
                      hv_ObjectModel3D_COPY_INP_TMP.Dispose();
                      hv_PoseIn_COPY_INP_TMP.Dispose();
                      hv_Title_COPY_INP_TMP.Dispose();
                      hv_Parameters.Dispose();
                      hv_Scene3DTest.Dispose();
                      hv_Scene3D.Dispose();
                      hv_WindowHandleBuffer.Dispose();
                      hv_TrackballSize.Dispose();
                      hv_VirtualTrackball.Dispose();
                      hv_MouseMapping.Dispose();
                      hv_gDispObjOffset.Dispose();
                      hv_gInfoDecor.Dispose();
                      hv_gLabelsDecor.Dispose();
                      hv_gTitleDecor.Dispose();
                      hv_gInfoPos.Dispose();
                      hv_gTitlePos.Dispose();
                      hv_gAlphaDeselected.Dispose();
                      hv_ExitButton.Dispose();
                      hv_MaxNumModels.Dispose();
                      hv_WindowCenteredRotation.Dispose();
                      hv_NumModels.Dispose();
                      hv_SelectedObject.Dispose();
                      hv_ButtonPressStatus.Dispose();
                      hv_ClipRegion.Dispose();
                      hv_CPLength.Dispose();
                      hv_RowNotUsed.Dispose();
                      hv_ColumnNotUsed.Dispose();
                      hv_Width.Dispose();
                      hv_Height.Dispose();
                      hv_WPRow1.Dispose();
                      hv_WPColumn1.Dispose();
                      hv_WPRow2.Dispose();
                      hv_WPColumn2.Dispose();
                      hv_CamParamValue.Dispose();
                      hv_CamWidth.Dispose();
                      hv_CamHeight.Dispose();
                      hv_Scale.Dispose();
                      hv_Indices.Dispose();
                      hv_DispBackground.Dispose();
                      hv_Mask.Dispose();
                      hv_Center.Dispose();
                      hv_PoseEstimated.Dispose();
                      hv_Poses.Dispose();
                      hv_HomMat3Ds.Dispose();
                      hv_Sequence.Dispose();
                      hv_gIsSinglePose.Dispose();
                      hv_Font.Dispose();
                      hv_Exception.Dispose();
                      hv_gUsesOpenGL.Dispose();
                      hv_OpenGLInfo.Dispose();
                      hv_DummyObjectModel3D.Dispose();
                      hv_CameraIndexTest.Dispose();
                      hv_PoseTest.Dispose();
                      hv_InstanceIndexTest.Dispose();
                      hv_MinImageSize.Dispose();
                      hv_TrackballRadiusPixel.Dispose();
                      hv_idx.Dispose();
                      hv_MaxAscent.Dispose();
                      hv_MaxDescent.Dispose();
                      hv_MaxWidth.Dispose();
                      hv_MaxHeight.Dispose();
                      hv_Ascent.Dispose();
                      hv_Descent.Dispose();
                      hv_TextWidth.Dispose();
                      hv_TextHeight.Dispose();
                      hv_ButtonWidth.Dispose();
                      hv_ButtonHeight.Dispose();
                      hv_gButtons.Dispose();
                      hv_NumChannels.Dispose();
                      hv_ColorImage.Dispose();
                      hv_OriginalGenParamName.Dispose();
                      hv_OriginalGenParamValue.Dispose();
                      hv_Exit.Dispose();
                      hv_PreviousSentPose.Dispose();
                      hv_CameraIndex.Dispose();
                      hv_AllInstances.Dispose();
                      hv_SetLight.Dispose();
                      hv_LightParam.Dispose();
                      hv_LightPosition.Dispose();
                      hv_LightKind.Dispose();
                      hv_LightIndex.Dispose();
                      hv_PersistenceParamName.Dispose();
                      hv_PersistenceParamValue.Dispose();
                      hv_AlphaOrig.Dispose();
                      hv_I.Dispose();
                      hv_ParamName.Dispose();
                      hv_ParamValue.Dispose();
                      hv_ParamNameTrunk.Dispose();
                      hv_Instance.Dispose();
                      hv_HomMat3D.Dispose();
                      hv_Qx.Dispose();
                      hv_Qy.Dispose();
                      hv_Qz.Dispose();
                      hv_TBCenter.Dispose();
                      hv_TBSize.Dispose();
                      hv_ButtonHold.Dispose();
                      hv_SupressUpdateMessage.Dispose();
                      hv_VisualizeTB.Dispose();
                      hv_MaxIndex.Dispose();
                      hv_TrackballCenterRow.Dispose();
                      hv_TrackballCenterCol.Dispose();
                      hv_GraphEvent.Dispose();
                      hv_Redraw.Dispose();
                      hv_RecreateScene3D.Dispose();
                      hv_GraphButtonRow.Dispose();
                      hv_GraphButtonColumn.Dispose();
                      hv_GraphButton.Dispose();
                      hv_MessageHandle.Dispose();
                      hv_MessageType.Dispose();
                      hv_Pos.Dispose();
                      hv_Angle.Dispose();
                      hv_Pose.Dispose();
                      hv_NewPoses.Dispose();
                      hv_Index.Dispose();
                      hv_Model.Dispose();
                      hv_ButtonIndex.Dispose();
                      hv_ButtonText.Dispose();
                      hv_FoundButton.Dispose();
                      hv_ButtonPressed.Dispose();
                      hv_FoundButton2.Dispose();
                      hv_PoseOut.Dispose();

                      return;
                    }
                    else if ((int)(new HTuple(hv_MessageType.TupleEqual(
                        "toggle_param"))) != 0)
                    {
                      hv_ParamName.Dispose();
                      HOperatorSet.GetMessageTuple(hv_MessageHandle, "param", out hv_ParamName);
                      hv_Pos.Dispose();
                      using (HDevDisposeHelper dh = new HDevDisposeHelper())
                      {
                      hv_Pos = hv_OriginalGenParamName.TupleFind(
                          hv_ParamName);
                      }
                      if ((int)((new HTuple(hv_Pos.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Pos.TupleNotEqual(
                          new HTuple())))) != 0)
                      {
                        if ((int)(new HTuple(((hv_OriginalGenParamValue.TupleSelect(
                            hv_Pos))).TupleEqual("true"))) != 0)
                        {
                          if (hv_OriginalGenParamValue == null)
                            hv_OriginalGenParamValue = new HTuple();
                          hv_OriginalGenParamValue[hv_Pos] = "false";
                        }
                        else
                        {
                          if (hv_OriginalGenParamValue == null)
                            hv_OriginalGenParamValue = new HTuple();
                          hv_OriginalGenParamValue[hv_Pos] = "true";
                        }
                      }
                      else
                      {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                        {
                        HTuple 
                          ExpTmpLocalVar_OriginalGenParamName = hv_OriginalGenParamName.TupleConcat(
                            hv_ParamName);
                        hv_OriginalGenParamName.Dispose();
                        hv_OriginalGenParamName = ExpTmpLocalVar_OriginalGenParamName;
                        }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                        {
                        HTuple 
                          ExpTmpLocalVar_OriginalGenParamValue = hv_OriginalGenParamValue.TupleConcat(
                            "true");
                        hv_OriginalGenParamValue.Dispose();
                        hv_OriginalGenParamValue = ExpTmpLocalVar_OriginalGenParamValue;
                        }
                        }
                        hv_Pos.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                        hv_Pos = (new HTuple(hv_OriginalGenParamName.TupleLength()
                            ))-1;
                        }
                      }
                      //try
                        //set_scene_3d_param (Scene3D, GenParamName[Pos], GenParamValue[Pos])
                      //catch (Exception)
                        //If the parameter cannot be set directly, recreate the scene
                        //completely
                        hv_RecreateScene3D.Dispose();
                        hv_RecreateScene3D = 1;
                      //endtry
                      hv_Redraw.Dispose();
                      hv_Redraw = 1;
                    }
                    else if ((int)(new HTuple(hv_MessageType.TupleEqual(
                        "auto_rotate"))) != 0)
                    {
                      hv_Angle.Dispose();
                      HOperatorSet.GetMessageTuple(hv_MessageHandle, "angle", out hv_Angle);
                      hv_Pose.Dispose();
                      using (HDevDisposeHelper dh = new HDevDisposeHelper())
                      {
                      hv_Pose = new HTuple();
                      hv_Pose[0] = 0;
                      hv_Pose[1] = 0;
                      hv_Pose[2] = 0;
                      hv_Pose[3] = 0;
                      hv_Pose[4] = 0;
                      hv_Pose = hv_Pose.TupleConcat(hv_Angle);
                      hv_Pose = hv_Pose.TupleConcat(0);
                      }
                      {
                      HTuple ExpTmpOutVar_0;
                      HOperatorSet.PoseCompose(hv_Poses, hv_Pose, out ExpTmpOutVar_0);
                      hv_Poses.Dispose();
                      hv_Poses = ExpTmpOutVar_0;
                      }
                      HOperatorSet.SetScene3dInstancePose(hv_Scene3D, hv_AllInstances, 
                          hv_Poses);
                      hv_Redraw.Dispose();
                      hv_Redraw = 1;
                    }
                    else if ((int)(new HTuple(hv_MessageType.TupleEqual(
                        "set_pose"))) != 0)
                    {
                      hv_NewPoses.Dispose();
                      HOperatorSet.GetMessageTuple(hv_MessageHandle, "poses", out hv_NewPoses);
                      if ((int)(new HTuple((new HTuple(hv_NewPoses.TupleLength())).TupleEqual(
                          new HTuple(hv_Poses.TupleLength())))) != 0)
                      {
                        hv_NewPoses.Dispose();
                        hv_NewPoses = new HTuple(hv_Poses);
                      }
                      else if ((int)(new HTuple((new HTuple(hv_NewPoses.TupleLength()
                          )).TupleEqual(7))) != 0)
                      {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                        {
                        HTuple 
                          ExpTmpLocalVar_Poses = hv_NewPoses.TupleSelect(
                            HTuple.TupleGenSequence(0,(new HTuple(hv_Poses.TupleLength()
                            ))-1,1)%7);
                        hv_Poses.Dispose();
                        hv_Poses = ExpTmpLocalVar_Poses;
                        }
                        }
                      }
                      else
                      {
                        //use only first pose in NewPoses
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                        {
                        HTuple 
                          ExpTmpLocalVar_Poses = hv_NewPoses.TupleSelect(
                            HTuple.TupleGenSequence(0,(new HTuple(hv_Poses.TupleLength()
                            ))-1,1)%7);
                        hv_Poses.Dispose();
                        hv_Poses = ExpTmpLocalVar_Poses;
                        }
                        }
                      }
                      HOperatorSet.SetScene3dInstancePose(hv_Scene3D, hv_AllInstances, 
                          hv_Poses);
                      hv_Redraw.Dispose();
                      hv_Redraw = 1;
                    }
                    else if ((int)(new HTuple(hv_MessageType.TupleEqual(
                        "replace_object_model"))) != 0)
                    {
                      hv_Index.Dispose();
                      HOperatorSet.GetMessageTuple(hv_MessageHandle, "index", out hv_Index);
                      hv_Model.Dispose();
                      HOperatorSet.GetMessageTuple(hv_MessageHandle, "model", out hv_Model);
                      if (hv_ObjectModel3D_COPY_INP_TMP == null)
                        hv_ObjectModel3D_COPY_INP_TMP = new HTuple();
                      hv_ObjectModel3D_COPY_INP_TMP[hv_Index] = hv_Model;
                      hv_RecreateScene3D.Dispose();
                      hv_RecreateScene3D = 1;
                      hv_Redraw.Dispose();
                      hv_Redraw = 1;
                    }
                    else if ((int)(new HTuple(hv_MessageType.TupleEqual(
                        "force_redraw"))) != 0)
                    {
                      hv_Redraw.Dispose();
                      hv_Redraw = 1;
                    }
                    else if ((int)(new HTuple(hv_MessageType.TupleEqual(
                        "change_button_text"))) != 0)
                    {
                      hv_ButtonIndex.Dispose();
                      HOperatorSet.GetMessageTuple(hv_MessageHandle, "index", out hv_ButtonIndex);
                      hv_ButtonText.Dispose();
                      HOperatorSet.GetMessageTuple(hv_MessageHandle, "text", out hv_ButtonText);
                      if ((int)((new HTuple(hv_ButtonIndex.TupleGreaterEqual(0))).TupleAnd(
                          new HTuple(hv_ButtonIndex.TupleLess((new HTuple(hv_gButtons.TupleLength()
                          ))/5)))) != 0)
                      {
                        if (hv_gButtons == null)
                          hv_gButtons = new HTuple();
                        hv_gButtons[5*hv_ButtonIndex] = hv_ButtonText;
                        HOperatorSet.SetMessageTuple(hv_Parameters, "gButtons", hv_gButtons);
                      }
                      hv_Redraw.Dispose();
                      hv_Redraw = 1;
                    }
                    else if ((int)(new HTuple(hv_MessageType.TupleEqual(
                        "change_title"))) != 0)
                    {
                      hv_Title_COPY_INP_TMP.Dispose();
                      HOperatorSet.GetMessageTuple(hv_MessageHandle, "title", out hv_Title_COPY_INP_TMP);
                      hv_Redraw.Dispose();
                      hv_Redraw = 1;
                    }
                  }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException3)
                {
                  HDevExpDefaultException3.ToHTuple(out hv_Exception);
                  //Timeout in dequeue_message is OK
                  if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(
                      9400))) != 0)
                  {
                    throw new HalconException(hv_Exception);
                  }
                }
                if ((int)(hv_Redraw) != 0)
                {
                  break;
                }
                continue;
              }

              if ((int)(new HTuple(hv_GraphButton.TupleNotEqual(0))) != 0)
              {
                hv_FoundButton.Dispose();
                check_mouse_over_button(hv_Parameters, hv_GraphButtonRow, hv_GraphButtonColumn, 
                    out hv_FoundButton);
                hv_ButtonPressed.Dispose();
                hv_ButtonPressed = -1;
                if ((int)(new HTuple(hv_FoundButton.TupleGreaterEqual(0))) != 0)
                {
                  //Wait until the button has been released
                  while ((int)(1) != 0)
                  {
                    hv_GraphButtonRow.Dispose();hv_GraphButtonColumn.Dispose();hv_GraphButton.Dispose();
                    get_mouse_info(hv_WindowHandle, hv_MessageQueue, new HTuple(), 
                        out hv_GraphButtonRow, out hv_GraphButtonColumn, out hv_GraphButton);
                    if ((int)(new HTuple(hv_GraphButton.TupleEqual(0))) != 0)
                    {
                      hv_FoundButton2.Dispose();
                      check_mouse_over_button(hv_Parameters, hv_GraphButtonRow, hv_GraphButtonColumn, 
                          out hv_FoundButton2);
                      if ((int)(new HTuple(hv_FoundButton2.TupleEqual(hv_FoundButton))) != 0)
                      {
                        hv_ButtonPressed.Dispose();
                        hv_ButtonPressed = new HTuple(hv_FoundButton);
                      }
                      break;
                    }
                    //Keep waiting until mouse button is released or moved out of the window
                  }
                  if ((int)(new HTuple(hv_ButtonPressed.TupleGreaterEqual(0))) != 0)
                  {
                    if ((int)(new HTuple(hv_ButtonPressed.TupleEqual(hv_ExitButton))) != 0)
                    {
                      hv_Exit.Dispose();
                      hv_Exit = 1;
                      break;
                    }
                    else
                    {
                      hv_MessageHandle.Dispose();
                      HOperatorSet.CreateMessage(out hv_MessageHandle);
                      HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "button_pressed");
                      using (HDevDisposeHelper dh = new HDevDisposeHelper())
                      {
                      HOperatorSet.SetMessageTuple(hv_MessageHandle, "button", hv_ButtonPressed/5);
                      }
                      using (HDevDisposeHelper dh = new HDevDisposeHelper())
                      {
                      HOperatorSet.EnqueueMessage(hv_MessageQueue.TupleSelect(2), 
                          hv_MessageHandle, new HTuple(), new HTuple());
                      }
                    }
                  }
                }
                hv_GraphEvent.Dispose();
                hv_GraphEvent = 1;
                break;
              }
              else
              {
                hv_ButtonHold.Dispose();
                hv_ButtonHold = 0;
              }
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException2)
            {
              HDevExpDefaultException2.ToHTuple(out hv_Exception);
              //Keep waiting
            }
          }
          if ((int)(hv_GraphEvent) != 0)
          {
            {
            HTuple ExpTmpOutVar_0;HTuple ExpTmpOutVar_1;HTuple ExpTmpOutVar_2;HTuple ExpTmpOutVar_3;
            analyze_graph_event(ho_Image, hv_Parameters, hv_MouseMapping, hv_GraphButton, 
                hv_GraphButtonRow, hv_GraphButtonColumn, hv_WindowHandle, hv_WindowHandleBuffer, 
                hv_VirtualTrackball, hv_TrackballSize, hv_SelectedObject, hv_Scene3D, 
                hv_AlphaOrig, hv_ObjectModel3D_COPY_INP_TMP, hv_CamParam_COPY_INP_TMP, 
                hv_Label_COPY_INP_TMP, hv_Title_COPY_INP_TMP, hv_Information, hv_GenParamName_COPY_INP_TMP, 
                hv_GenParamValue_COPY_INP_TMP, hv_Poses, hv_ButtonHold, hv_TBCenter, 
                hv_TBSize, hv_WindowCenteredRotation, hv_MaxNumModels, hv_MessageQueue, 
                out ExpTmpOutVar_0, out ExpTmpOutVar_1, out ExpTmpOutVar_2, out ExpTmpOutVar_3);
            hv_Poses.Dispose();
            hv_Poses = ExpTmpOutVar_0;
            hv_SelectedObject.Dispose();
            hv_SelectedObject = ExpTmpOutVar_1;
            hv_ButtonHold.Dispose();
            hv_ButtonHold = ExpTmpOutVar_2;
            hv_WindowCenteredRotation.Dispose();
            hv_WindowCenteredRotation = ExpTmpOutVar_3;
            }
          }
          if ((int)(hv_RecreateScene3D) != 0)
          {
            break;
          }
        }
      }

      try
      {
        //
        //Display final state with persistence, if requested
        //Note that disp_object_model_3d must be used instead of the 3D scene
        if ((int)(new HTuple((new HTuple(hv_PersistenceParamName.TupleLength())).TupleGreater(
            0))) != 0)
        {
          try
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispObjectModel3d(hv_WindowHandle, hv_ObjectModel3D_COPY_INP_TMP, 
                hv_CamParam_COPY_INP_TMP, hv_Poses, ((new HTuple("disp_background")).TupleConcat(
                "alpha")).TupleConcat(hv_PersistenceParamName), ((new HTuple("true")).TupleConcat(
                0.0)).TupleConcat(hv_PersistenceParamValue));
            }
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException3)
          {
            HDevExpDefaultException3.ToHTuple(out hv_Exception);
            // stop(...); only in hdevelop
          }
        }
        //
        //Compute the output pose
        hv_gIsSinglePose.Dispose();
        HOperatorSet.GetMessageTuple(hv_Parameters, "gIsSinglePose", out hv_gIsSinglePose);
        if ((int)(hv_gIsSinglePose) != 0)
        {
          hv_PoseOut.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PoseOut = hv_Poses.TupleSelectRange(
              0,6);
          }
        }
        else
        {
          hv_PoseOut.Dispose();
          hv_PoseOut = new HTuple(hv_Poses);
        }
        //
        //Clean up
        HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
        // dev_set_preferences(...); only in hdevelop
        // dev_set_preferences(...); only in hdevelop
        dump_image_output(ho_Image, hv_Parameters, hv_WindowHandleBuffer, hv_Scene3D, 
            hv_AlphaOrig, hv_ObjectModel3D_COPY_INP_TMP, hv_GenParamName_COPY_INP_TMP, 
            hv_GenParamValue_COPY_INP_TMP, hv_CamParam_COPY_INP_TMP, hv_Poses, hv_ColorImage, 
            hv_Title_COPY_INP_TMP, new HTuple(), hv_Label_COPY_INP_TMP, 0, "false", 
            hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TBSize, hv_SelectedObject, 
            hv_WindowCenteredRotation, hv_TBCenter, hv_Type, hv_Message, hv_DispViewPoint, 
            hv_ViewPoint);
        ho_ImageDump.Dispose();
        HOperatorSet.DumpWindowImage(out ho_ImageDump, hv_WindowHandleBuffer);
        HDevWindowStack.SetActive(hv_WindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_ImageDump, HDevWindowStack.GetActive());
        }
        HOperatorSet.CloseWindow(hv_WindowHandleBuffer);
        HOperatorSet.SetPart(hv_WindowHandle, hv_WPRow1, hv_WPColumn1, hv_WPRow2, 
            hv_WPColumn2);

        //Notify listener that we have terminated
        if ((int)(new HTuple(hv_MessageQueue.TupleNotEqual(new HTuple()))) != 0)
        {
          hv_MessageHandle.Dispose();
          HOperatorSet.CreateMessage(out hv_MessageHandle);
          HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "done");
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.EnqueueMessage(hv_MessageQueue.TupleSelect(2), hv_MessageHandle, 
              new HTuple(), new HTuple());
          }
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException2)
      {
        HDevExpDefaultException2.ToHTuple(out hv_Exception);
        if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(2454))).TupleOr(
            new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(5100)))) != 0)
        {
          //Handle was already cleared -> indicates that the window was closed (by the user)
          //Abort gracefully.
          ho_Image.Dispose();
          ho_ImageDump.Dispose();

          hv_Buttons_COPY_INP_TMP.Dispose();
          hv_CamParam_COPY_INP_TMP.Dispose();
          hv_GenParamName_COPY_INP_TMP.Dispose();
          hv_GenParamValue_COPY_INP_TMP.Dispose();
          hv_Label_COPY_INP_TMP.Dispose();
          hv_ObjectModel3D_COPY_INP_TMP.Dispose();
          hv_PoseIn_COPY_INP_TMP.Dispose();
          hv_Title_COPY_INP_TMP.Dispose();
          hv_Parameters.Dispose();
          hv_Scene3DTest.Dispose();
          hv_Scene3D.Dispose();
          hv_WindowHandleBuffer.Dispose();
          hv_TrackballSize.Dispose();
          hv_VirtualTrackball.Dispose();
          hv_MouseMapping.Dispose();
          hv_gDispObjOffset.Dispose();
          hv_gInfoDecor.Dispose();
          hv_gLabelsDecor.Dispose();
          hv_gTitleDecor.Dispose();
          hv_gInfoPos.Dispose();
          hv_gTitlePos.Dispose();
          hv_gAlphaDeselected.Dispose();
          hv_ExitButton.Dispose();
          hv_MaxNumModels.Dispose();
          hv_WindowCenteredRotation.Dispose();
          hv_NumModels.Dispose();
          hv_SelectedObject.Dispose();
          hv_ButtonPressStatus.Dispose();
          hv_ClipRegion.Dispose();
          hv_CPLength.Dispose();
          hv_RowNotUsed.Dispose();
          hv_ColumnNotUsed.Dispose();
          hv_Width.Dispose();
          hv_Height.Dispose();
          hv_WPRow1.Dispose();
          hv_WPColumn1.Dispose();
          hv_WPRow2.Dispose();
          hv_WPColumn2.Dispose();
          hv_CamParamValue.Dispose();
          hv_CamWidth.Dispose();
          hv_CamHeight.Dispose();
          hv_Scale.Dispose();
          hv_Indices.Dispose();
          hv_DispBackground.Dispose();
          hv_Mask.Dispose();
          hv_Center.Dispose();
          hv_PoseEstimated.Dispose();
          hv_Poses.Dispose();
          hv_HomMat3Ds.Dispose();
          hv_Sequence.Dispose();
          hv_gIsSinglePose.Dispose();
          hv_Font.Dispose();
          hv_Exception.Dispose();
          hv_gUsesOpenGL.Dispose();
          hv_OpenGLInfo.Dispose();
          hv_DummyObjectModel3D.Dispose();
          hv_CameraIndexTest.Dispose();
          hv_PoseTest.Dispose();
          hv_InstanceIndexTest.Dispose();
          hv_MinImageSize.Dispose();
          hv_TrackballRadiusPixel.Dispose();
          hv_idx.Dispose();
          hv_MaxAscent.Dispose();
          hv_MaxDescent.Dispose();
          hv_MaxWidth.Dispose();
          hv_MaxHeight.Dispose();
          hv_Ascent.Dispose();
          hv_Descent.Dispose();
          hv_TextWidth.Dispose();
          hv_TextHeight.Dispose();
          hv_ButtonWidth.Dispose();
          hv_ButtonHeight.Dispose();
          hv_gButtons.Dispose();
          hv_NumChannels.Dispose();
          hv_ColorImage.Dispose();
          hv_OriginalGenParamName.Dispose();
          hv_OriginalGenParamValue.Dispose();
          hv_Exit.Dispose();
          hv_PreviousSentPose.Dispose();
          hv_CameraIndex.Dispose();
          hv_AllInstances.Dispose();
          hv_SetLight.Dispose();
          hv_LightParam.Dispose();
          hv_LightPosition.Dispose();
          hv_LightKind.Dispose();
          hv_LightIndex.Dispose();
          hv_PersistenceParamName.Dispose();
          hv_PersistenceParamValue.Dispose();
          hv_AlphaOrig.Dispose();
          hv_I.Dispose();
          hv_ParamName.Dispose();
          hv_ParamValue.Dispose();
          hv_ParamNameTrunk.Dispose();
          hv_Instance.Dispose();
          hv_HomMat3D.Dispose();
          hv_Qx.Dispose();
          hv_Qy.Dispose();
          hv_Qz.Dispose();
          hv_TBCenter.Dispose();
          hv_TBSize.Dispose();
          hv_ButtonHold.Dispose();
          hv_SupressUpdateMessage.Dispose();
          hv_VisualizeTB.Dispose();
          hv_MaxIndex.Dispose();
          hv_TrackballCenterRow.Dispose();
          hv_TrackballCenterCol.Dispose();
          hv_GraphEvent.Dispose();
          hv_Redraw.Dispose();
          hv_RecreateScene3D.Dispose();
          hv_GraphButtonRow.Dispose();
          hv_GraphButtonColumn.Dispose();
          hv_GraphButton.Dispose();
          hv_MessageHandle.Dispose();
          hv_MessageType.Dispose();
          hv_Pos.Dispose();
          hv_Angle.Dispose();
          hv_Pose.Dispose();
          hv_NewPoses.Dispose();
          hv_Index.Dispose();
          hv_Model.Dispose();
          hv_ButtonIndex.Dispose();
          hv_ButtonText.Dispose();
          hv_FoundButton.Dispose();
          hv_ButtonPressed.Dispose();
          hv_FoundButton2.Dispose();
          hv_PoseOut.Dispose();

          return;
        }
        else
        {
          //Unknown / Unexpected exception
          throw new HalconException(hv_Exception);
        }
      }
    }
    // catch (Exception) 
    catch (HalconException HDevExpDefaultException1)
    {
      HDevExpDefaultException1.ToHTuple(out hv_Exception);
      hv_MessageHandle.Dispose();
      HOperatorSet.CreateMessage(out hv_MessageHandle);
      HOperatorSet.SetMessageTuple(hv_MessageHandle, "type", "exception");
      HOperatorSet.SetMessageTuple(hv_MessageHandle, "exception", hv_Exception);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.EnqueueMessage(hv_MessageQueue.TupleSelect(2), hv_MessageHandle, 
          new HTuple(), new HTuple());
      }
    }
    ho_Image.Dispose();
    ho_ImageDump.Dispose();

    hv_Buttons_COPY_INP_TMP.Dispose();
    hv_CamParam_COPY_INP_TMP.Dispose();
    hv_GenParamName_COPY_INP_TMP.Dispose();
    hv_GenParamValue_COPY_INP_TMP.Dispose();
    hv_Label_COPY_INP_TMP.Dispose();
    hv_ObjectModel3D_COPY_INP_TMP.Dispose();
    hv_PoseIn_COPY_INP_TMP.Dispose();
    hv_Title_COPY_INP_TMP.Dispose();
    hv_Parameters.Dispose();
    hv_Scene3DTest.Dispose();
    hv_Scene3D.Dispose();
    hv_WindowHandleBuffer.Dispose();
    hv_TrackballSize.Dispose();
    hv_VirtualTrackball.Dispose();
    hv_MouseMapping.Dispose();
    hv_gDispObjOffset.Dispose();
    hv_gInfoDecor.Dispose();
    hv_gLabelsDecor.Dispose();
    hv_gTitleDecor.Dispose();
    hv_gInfoPos.Dispose();
    hv_gTitlePos.Dispose();
    hv_gAlphaDeselected.Dispose();
    hv_ExitButton.Dispose();
    hv_MaxNumModels.Dispose();
    hv_WindowCenteredRotation.Dispose();
    hv_NumModels.Dispose();
    hv_SelectedObject.Dispose();
    hv_ButtonPressStatus.Dispose();
    hv_ClipRegion.Dispose();
    hv_CPLength.Dispose();
    hv_RowNotUsed.Dispose();
    hv_ColumnNotUsed.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_WPRow1.Dispose();
    hv_WPColumn1.Dispose();
    hv_WPRow2.Dispose();
    hv_WPColumn2.Dispose();
    hv_CamParamValue.Dispose();
    hv_CamWidth.Dispose();
    hv_CamHeight.Dispose();
    hv_Scale.Dispose();
    hv_Indices.Dispose();
    hv_DispBackground.Dispose();
    hv_Mask.Dispose();
    hv_Center.Dispose();
    hv_PoseEstimated.Dispose();
    hv_Poses.Dispose();
    hv_HomMat3Ds.Dispose();
    hv_Sequence.Dispose();
    hv_gIsSinglePose.Dispose();
    hv_Font.Dispose();
    hv_Exception.Dispose();
    hv_gUsesOpenGL.Dispose();
    hv_OpenGLInfo.Dispose();
    hv_DummyObjectModel3D.Dispose();
    hv_CameraIndexTest.Dispose();
    hv_PoseTest.Dispose();
    hv_InstanceIndexTest.Dispose();
    hv_MinImageSize.Dispose();
    hv_TrackballRadiusPixel.Dispose();
    hv_idx.Dispose();
    hv_MaxAscent.Dispose();
    hv_MaxDescent.Dispose();
    hv_MaxWidth.Dispose();
    hv_MaxHeight.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_TextWidth.Dispose();
    hv_TextHeight.Dispose();
    hv_ButtonWidth.Dispose();
    hv_ButtonHeight.Dispose();
    hv_gButtons.Dispose();
    hv_NumChannels.Dispose();
    hv_ColorImage.Dispose();
    hv_OriginalGenParamName.Dispose();
    hv_OriginalGenParamValue.Dispose();
    hv_Exit.Dispose();
    hv_PreviousSentPose.Dispose();
    hv_CameraIndex.Dispose();
    hv_AllInstances.Dispose();
    hv_SetLight.Dispose();
    hv_LightParam.Dispose();
    hv_LightPosition.Dispose();
    hv_LightKind.Dispose();
    hv_LightIndex.Dispose();
    hv_PersistenceParamName.Dispose();
    hv_PersistenceParamValue.Dispose();
    hv_AlphaOrig.Dispose();
    hv_I.Dispose();
    hv_ParamName.Dispose();
    hv_ParamValue.Dispose();
    hv_ParamNameTrunk.Dispose();
    hv_Instance.Dispose();
    hv_HomMat3D.Dispose();
    hv_Qx.Dispose();
    hv_Qy.Dispose();
    hv_Qz.Dispose();
    hv_TBCenter.Dispose();
    hv_TBSize.Dispose();
    hv_ButtonHold.Dispose();
    hv_SupressUpdateMessage.Dispose();
    hv_VisualizeTB.Dispose();
    hv_MaxIndex.Dispose();
    hv_TrackballCenterRow.Dispose();
    hv_TrackballCenterCol.Dispose();
    hv_GraphEvent.Dispose();
    hv_Redraw.Dispose();
    hv_RecreateScene3D.Dispose();
    hv_GraphButtonRow.Dispose();
    hv_GraphButtonColumn.Dispose();
    hv_GraphButton.Dispose();
    hv_MessageHandle.Dispose();
    hv_MessageType.Dispose();
    hv_Pos.Dispose();
    hv_Angle.Dispose();
    hv_Pose.Dispose();
    hv_NewPoses.Dispose();
    hv_Index.Dispose();
    hv_Model.Dispose();
    hv_ButtonIndex.Dispose();
    hv_ButtonText.Dispose();
    hv_FoundButton.Dispose();
    hv_ButtonPressed.Dispose();
    hv_FoundButton2.Dispose();
    hv_PoseOut.Dispose();

    return;
  }

  // Short Description: Display continue button and wait for user to click it 
  public void wait_continue_button (HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
    HTuple hv_WinWidth = new HTuple(), hv_WinHeight = new HTuple();
    HTuple hv_Ascent1 = new HTuple(), hv_Descent1 = new HTuple();
    HTuple hv_TextWidth = new HTuple(), hv_TextHeight = new HTuple();
    HTuple hv_ButtonRow = new HTuple(), hv_ButtonCol = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Button = new HTuple(), hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    //Wait for the user to click the exit button
    hv_Row1.Dispose();hv_Column1.Dispose();hv_WinWidth.Dispose();hv_WinHeight.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row1, out hv_Column1, out hv_WinWidth, 
        out hv_WinHeight);
    hv_Ascent1.Dispose();hv_Descent1.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
    HOperatorSet.GetStringExtents(hv_WindowHandle, "Continue", out hv_Ascent1, out hv_Descent1, 
        out hv_TextWidth, out hv_TextHeight);
    hv_ButtonRow.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonRow = (hv_WinHeight-hv_TextHeight)-20;
    }
    hv_ButtonCol.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ButtonCol = (hv_WinWidth-hv_TextWidth)-30;
    }
    disp_text_button(hv_WindowHandle, "Continue", "window", hv_ButtonRow, hv_ButtonCol, 
        "black", "#f28f26");
    while ((int)(1) != 0)
    {
      try
      {
        hv_Row.Dispose();hv_Column.Dispose();hv_Button.Dispose();
        HOperatorSet.GetMposition(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Button);
        if ((int)((new HTuple((new HTuple(hv_Button.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Row.TupleGreaterEqual(
            hv_ButtonRow))))).TupleAnd(new HTuple(hv_Column.TupleGreaterEqual(hv_ButtonCol)))) != 0)
        {
          break;
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(2454))).TupleOr(
            new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(5100)))) != 0)
        {
          //Handle was already cleared -> indicates that the window was closed (by the user)
          //Abort gracefully.

          hv_Row1.Dispose();
          hv_Column1.Dispose();
          hv_WinWidth.Dispose();
          hv_WinHeight.Dispose();
          hv_Ascent1.Dispose();
          hv_Descent1.Dispose();
          hv_TextWidth.Dispose();
          hv_TextHeight.Dispose();
          hv_ButtonRow.Dispose();
          hv_ButtonCol.Dispose();
          hv_Row.Dispose();
          hv_Column.Dispose();
          hv_Button.Dispose();
          hv_Exception.Dispose();

          return;
        }
        else if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(
            5))) != 0)
        {
          //Ignore -> mouse outside of window
        }
        else
        {
          //Unknown / Unexpected exception
          //Ignore for now
        }
      }
      HOperatorSet.WaitSeconds(0.01);
    }

    hv_Row1.Dispose();
    hv_Column1.Dispose();
    hv_WinWidth.Dispose();
    hv_WinHeight.Dispose();
    hv_Ascent1.Dispose();
    hv_Descent1.Dispose();
    hv_TextWidth.Dispose();
    hv_TextHeight.Dispose();
    hv_ButtonRow.Dispose();
    hv_ButtonCol.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_Button.Dispose();
    hv_Exception.Dispose();

    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Write the dictionaries of the samples in DLSampleBatch to hdict files and store the paths in DLDataset. 
  public void write_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple hv_DLSampleBatch, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_RaiseErrorWriteDict = new HTuple();
    HTuple hv_IndexGenParam = new HTuple(), hv_DLSampleDirExists = new HTuple();
    HTuple hv_OutDir = new HTuple(), hv_DatasetSamples = new HTuple();
    HTuple hv_I = new HTuple(), hv_DLDatasetIndex = new HTuple();
    HTuple hv_DatasetSample = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_DatasetImageID = new HTuple(), hv_SampleImageID = new HTuple();
    HTuple hv_FileNameOut = new HTuple();
    // Initialize local and output iconic variables 
    //
    //This procedure writes all given DLSamples in DLSampleBatch to hdict files
    //and stores the file paths in the respective samples of the DLDataset.
    //The directory needs to be given in dlsample_dir, before calling this procedure.
    //
    //The output filename is created in the following way: image_id + '_dlsample.hdict'
    //
    //Set the default values.
    //Raise error when writing dictionary.
    hv_RaiseErrorWriteDict.Dispose();
    hv_RaiseErrorWriteDict = "true";
    //
    //Transfer generic parameters.
    if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleNotEqual(
        new HTuple(hv_GenParamValue.TupleLength())))) != 0)
    {
      throw new HalconException("GenParamName and GenParamValue have to be of equal length.");
    }
    //
    if ((int)(new HTuple(hv_GenParamName.TupleNotEqual(new HTuple()))) != 0)
    {
      for (hv_IndexGenParam=0; (int)hv_IndexGenParam<=(int)((new HTuple(hv_GenParamName.TupleLength()
          ))-1); hv_IndexGenParam = (int)hv_IndexGenParam + 1)
      {
        if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_IndexGenParam))).TupleEqual(
            "raise_error_if_content_not_serializable"))) != 0)
        {
          //Set 'raise_error_if_content_not_serializable' for writing write_dict.
          hv_RaiseErrorWriteDict.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_RaiseErrorWriteDict = hv_GenParamValue.TupleSelect(
              hv_IndexGenParam);
          }
        }
        else
        {
          throw new HalconException("Unknown GenParam key : "+(hv_GenParamName.TupleSelect(
              hv_IndexGenParam)));
        }
      }
    }
    //
    //Check the parameters.
    //Check that the base path is available in the DLDataset.
    hv_DLSampleDirExists.Dispose();
    HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "dlsample_dir", out hv_DLSampleDirExists);
    if ((int)(hv_DLSampleDirExists.TupleNot()) != 0)
    {
      throw new HalconException("The dataset needs to include the key 'dlsample_dir'.");

      hv_RaiseErrorWriteDict.Dispose();
      hv_IndexGenParam.Dispose();
      hv_DLSampleDirExists.Dispose();
      hv_OutDir.Dispose();
      hv_DatasetSamples.Dispose();
      hv_I.Dispose();
      hv_DLDatasetIndex.Dispose();
      hv_DatasetSample.Dispose();
      hv_DLSample.Dispose();
      hv_DatasetImageID.Dispose();
      hv_SampleImageID.Dispose();
      hv_FileNameOut.Dispose();

      return;
    }

    if ((int)(new HTuple((new HTuple(hv_DLSampleBatch.TupleLength())).TupleNotEqual(
        new HTuple(hv_SampleIndices.TupleLength())))) != 0)
    {
      throw new HalconException("The input tuples DLSampleBatch and SampleIndices need to match in length.");

      hv_RaiseErrorWriteDict.Dispose();
      hv_IndexGenParam.Dispose();
      hv_DLSampleDirExists.Dispose();
      hv_OutDir.Dispose();
      hv_DatasetSamples.Dispose();
      hv_I.Dispose();
      hv_DLDatasetIndex.Dispose();
      hv_DatasetSample.Dispose();
      hv_DLSample.Dispose();
      hv_DatasetImageID.Dispose();
      hv_SampleImageID.Dispose();
      hv_FileNameOut.Dispose();

      return;
    }
    //
    //Write preprocessed data.
    //
    //Get the base path for the outputs.
    hv_OutDir.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "dlsample_dir", out hv_OutDir);
    //
    //Get the samples.
    hv_DatasetSamples.Dispose();
    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DatasetSamples);
    //
    //Loop over all samples in the batch.
    for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_DLSampleBatch.TupleLength()))-1); hv_I = (int)hv_I + 1)
    {
      //Get the sample dictionaries.
      hv_DLDatasetIndex.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLDatasetIndex = hv_SampleIndices.TupleSelect(
          hv_I);
      }
      hv_DatasetSample.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DatasetSample = hv_DatasetSamples.TupleSelect(
          hv_DLDatasetIndex);
      }
      hv_DLSample.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLSample = hv_DLSampleBatch.TupleSelect(
          hv_I);
      }
      //
      //Check that image IDs match.
      hv_DatasetImageID.Dispose();
      HOperatorSet.GetDictTuple(hv_DatasetSample, "image_id", out hv_DatasetImageID);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SampleImageID.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSampleBatch.TupleSelect(hv_I), "image_id", out hv_SampleImageID);
      }
      if ((int)(new HTuple(hv_DatasetImageID.TupleNotEqual(hv_SampleImageID))) != 0)
      {
        throw new HalconException("Image IDs do not match. Please use correct indexing in input argument SampleIndices.");

        hv_RaiseErrorWriteDict.Dispose();
        hv_IndexGenParam.Dispose();
        hv_DLSampleDirExists.Dispose();
        hv_OutDir.Dispose();
        hv_DatasetSamples.Dispose();
        hv_I.Dispose();
        hv_DLDatasetIndex.Dispose();
        hv_DatasetSample.Dispose();
        hv_DLSample.Dispose();
        hv_DatasetImageID.Dispose();
        hv_SampleImageID.Dispose();
        hv_FileNameOut.Dispose();

        return;
      }
      //
      //Generate the output file name.
      hv_FileNameOut.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FileNameOut = hv_SampleImageID+"_dlsample.hdict";
      }
      //
      //Write output dictionary.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.WriteDict(hv_DLSample, (hv_OutDir+"/")+hv_FileNameOut, "raise_error_if_content_not_serializable", 
          hv_RaiseErrorWriteDict);
      }
      //Add output path to DLDataset sample dictionary.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_DatasetSamples.TupleSelect(hv_DLDatasetIndex), 
          "dlsample_file_name", hv_FileNameOut);
      }
      //
    }


    hv_RaiseErrorWriteDict.Dispose();
    hv_IndexGenParam.Dispose();
    hv_DLSampleDirExists.Dispose();
    hv_OutDir.Dispose();
    hv_DatasetSamples.Dispose();
    hv_I.Dispose();
    hv_DLDatasetIndex.Dispose();
    hv_DatasetSample.Dispose();
    hv_DLSample.Dispose();
    hv_DatasetImageID.Dispose();
    hv_SampleImageID.Dispose();
    hv_FileNameOut.Dispose();

    return;
  }

  public void write_note (HTuple hv_WindowHandle, HTuple hv_Type, HTuple hv_String)
  {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Strings = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_WinWidth = new HTuple();
            HTuple hv_WinHeight = new HTuple(), hv_Pos = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_SubStrings = new HTuple(), hv_Num = new HTuple();
            HTuple hv_CurrTestString = new HTuple(), hv_Index = new HTuple();
            HTuple   hv_String_COPY_INP_TMP = new HTuple(hv_String);

            // Initialize local and output iconic variables 
    hv_Strings.Dispose();
    hv_Strings = new HTuple();
    hv_Strings[0] = "              ";
    hv_Strings[1] = "[INSTRUCTION] ";
    hv_Strings[2] = "[OK         ] ";
    hv_Strings[3] = "[WARNING    ] ";
    hv_Strings[4] = "[INFO       ] ";
    hv_Strings[5] = "[ERROR      ] ";

    if ((int)(new HTuple(hv_Type.TupleEqual("Title"))) != 0)
    {

    }
    if ((int)(new HTuple(hv_Type.TupleEqual("none"))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.WriteString(hv_WindowHandle, hv_Strings.TupleSelect(0));
      }
      HOperatorSet.SetColor(hv_WindowHandle, "white");
    }
    else if ((int)(new HTuple(hv_Type.TupleEqual("instruction"))) != 0)
    {
      HOperatorSet.SetColor(hv_WindowHandle, "cornflower blue");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.WriteString(hv_WindowHandle, hv_Strings.TupleSelect(1));
      }
      HOperatorSet.SetColor(hv_WindowHandle, "light steel blue");
    }
    else if ((int)(new HTuple(hv_Type.TupleEqual("ok"))) != 0)
    {
      HOperatorSet.SetColor(hv_WindowHandle, "green");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.WriteString(hv_WindowHandle, hv_Strings.TupleSelect(2));
      }
      HOperatorSet.SetColor(hv_WindowHandle, "#AAFFAA");
    }
    else if ((int)(new HTuple(hv_Type.TupleEqual("warning"))) != 0)
    {
      HOperatorSet.SetColor(hv_WindowHandle, "yellow");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.WriteString(hv_WindowHandle, hv_Strings.TupleSelect(3));
      }
      HOperatorSet.SetColor(hv_WindowHandle, "#FFFF00");
    }
    else if ((int)(new HTuple(hv_Type.TupleEqual("info"))) != 0)
    {
      HOperatorSet.SetColor(hv_WindowHandle, "white");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.WriteString(hv_WindowHandle, hv_Strings.TupleSelect(4));
      }
    }
    else if ((int)(new HTuple(hv_Type.TupleEqual("error"))) != 0)
    {
      HOperatorSet.SetColor(hv_WindowHandle, "red");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.WriteString(hv_WindowHandle, hv_Strings.TupleSelect(5));
      }
      HOperatorSet.SetColor(hv_WindowHandle, "#FFAAAA");
    }
    else
    {
      // stop(...); only in hdevelop
    }

    //Break into lines such that
    //"[SomeInfo]  Text" does not overflow
    hv_Row.Dispose();hv_Column.Dispose();hv_WinWidth.Dispose();hv_WinHeight.Dispose();
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_WinWidth, 
        out hv_WinHeight);
    hv_Pos.Dispose();
    hv_Pos = 0;
    while ((int)(new HTuple(hv_Pos.TupleLess(new HTuple(hv_String_COPY_INP_TMP.TupleLength()
        )))) != 0)
    {
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ascent.Dispose();hv_Descent.Dispose();hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, (hv_Strings.TupleSelect(0))+(hv_String_COPY_INP_TMP.TupleSelect(
          hv_Pos)), out hv_Ascent, out hv_Descent, out hv_Width, out hv_Height);
      }
      if ((int)(new HTuple(hv_Width.TupleGreater(hv_WinWidth-20))) != 0)
      {
        //Break this line!
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SubStrings.Dispose();
        HOperatorSet.TupleSplit(hv_String_COPY_INP_TMP.TupleSelect(hv_Pos), " ", 
            out hv_SubStrings);
        }
        for (hv_Num=(new HTuple(hv_SubStrings.TupleLength()))-1; (int)hv_Num>=1; hv_Num = (int)hv_Num + -1)
        {
          hv_CurrTestString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrTestString = (((hv_SubStrings.TupleSelectRange(
              0,hv_Num-1))+" ")).TupleSum();
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Ascent.Dispose();hv_Descent.Dispose();hv_Width.Dispose();hv_Height.Dispose();
          HOperatorSet.GetStringExtents(hv_WindowHandle, (hv_Strings.TupleSelect(
              0))+hv_CurrTestString, out hv_Ascent, out hv_Descent, out hv_Width, 
              out hv_Height);
          }
          if ((int)(new HTuple(hv_Width.TupleGreater(hv_WinWidth-20))) != 0)
          {
            continue;
          }
          else
          {
            //Split the line here
            if (hv_String_COPY_INP_TMP == null)
              hv_String_COPY_INP_TMP = new HTuple();
            hv_String_COPY_INP_TMP[hv_Pos] = (((hv_SubStrings.TupleSelectRange(0,
                hv_Num-1))+" ")).TupleSum();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HTuple ExpTmpOutVar_0;
            HOperatorSet.TupleInsert(hv_String_COPY_INP_TMP, hv_Pos+1, (((hv_SubStrings.TupleSelectRange(
                hv_Num,(new HTuple(hv_SubStrings.TupleLength()))-1))+" ")).TupleSum()
                , out ExpTmpOutVar_0);
            hv_String_COPY_INP_TMP.Dispose();
            hv_String_COPY_INP_TMP = ExpTmpOutVar_0;
            }
            break;
          }
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Pos = hv_Pos+1;
      hv_Pos.Dispose();
      hv_Pos = ExpTmpLocalVar_Pos;
      }
      }
    }

    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      if ((int)(new HTuple(hv_Index.TupleGreater(0))) != 0)
      {
        HOperatorSet.NewLine(hv_WindowHandle);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.WriteString(hv_WindowHandle, hv_Strings.TupleSelect(0));
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
          hv_Index));
      }
    }

    HOperatorSet.NewLine(hv_WindowHandle);
    HOperatorSet.SetColor(hv_WindowHandle, "white");


    hv_String_COPY_INP_TMP.Dispose();
    hv_Strings.Dispose();
    hv_Row.Dispose();
    hv_Column.Dispose();
    hv_WinWidth.Dispose();
    hv_WinHeight.Dispose();
    hv_Pos.Dispose();
    hv_Ascent.Dispose();
    hv_Descent.Dispose();
    hv_Width.Dispose();
    hv_Height.Dispose();
    hv_SubStrings.Dispose();
    hv_Num.Dispose();
    hv_CurrTestString.Dispose();
    hv_Index.Dispose();

    return;
  }

  // Chapter: 3D Object Model / Transformations
  // Short Description: Transform 3D points from images to a 3D object model, and add extended attributes to the points of the object model. 
  public void xyz_attrib_to_object_model_3d (HObject ho_X, HObject ho_Y, HObject ho_Z, 
      HObject ho_AttribImage, HTuple hv_AttribName, out HTuple hv_ObjectModel3D)
  {




    // Local iconic variables 

    HObject ho_DomainX, ho_DomainY, ho_DomainZ;
    HObject ho_RegionIntersectionTmp, ho_RegionIntersection;
    HObject ho_Channel=null;

    // Local control variables 

    HTuple hv_Number = new HTuple(), hv_Channels = new HTuple();
    HTuple hv_WidthX = new HTuple(), hv_HeightX = new HTuple();
    HTuple hv_WidthY = new HTuple(), hv_HeightY = new HTuple();
    HTuple hv_WidthZ = new HTuple(), hv_HeightZ = new HTuple();
    HTuple hv_WidthA = new HTuple(), hv_HeightA = new HTuple();
    HTuple hv_AvailableAttributes = new HTuple(), hv_Selection = new HTuple();
    HTuple hv_Difference = new HTuple(), hv_InvalidParameters = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_AttribValues = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Rows = new HTuple();
    HTuple hv_Columns = new HTuple(), hv_AttribValuesTmp = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_DomainX);
    HOperatorSet.GenEmptyObj(out ho_DomainY);
    HOperatorSet.GenEmptyObj(out ho_DomainZ);
    HOperatorSet.GenEmptyObj(out ho_RegionIntersectionTmp);
    HOperatorSet.GenEmptyObj(out ho_RegionIntersection);
    HOperatorSet.GenEmptyObj(out ho_Channel);
    hv_ObjectModel3D = new HTuple();
    //
    //Consistency checks:
    hv_Number.Dispose();
    HOperatorSet.CountObj(ho_AttribImage, out hv_Number);
    if ((int)(new HTuple(hv_Number.TupleNotEqual(1))) != 0)
    {
      throw new HalconException(new HTuple("The attribute image must be an image array with exactly one object. If you want to set multiple attributes, use a multichannel image."));
    }
    //
    hv_Channels.Dispose();
    HOperatorSet.CountChannels(ho_AttribImage, out hv_Channels);
    if ((int)(new HTuple(hv_Channels.TupleNotEqual(new HTuple(hv_AttribName.TupleLength()
        )))) != 0)
    {
      throw new HalconException(((("The number of channels of the attribute image ("+hv_Channels)+") must be equal to the number of attribute names (")+(new HTuple(hv_AttribName.TupleLength()
          )))+").");
    }
    //
    hv_WidthX.Dispose();hv_HeightX.Dispose();
    HOperatorSet.GetImageSize(ho_X, out hv_WidthX, out hv_HeightX);
    hv_WidthY.Dispose();hv_HeightY.Dispose();
    HOperatorSet.GetImageSize(ho_Y, out hv_WidthY, out hv_HeightY);
    hv_WidthZ.Dispose();hv_HeightZ.Dispose();
    HOperatorSet.GetImageSize(ho_Z, out hv_WidthZ, out hv_HeightZ);
    hv_WidthA.Dispose();hv_HeightA.Dispose();
    HOperatorSet.GetImageSize(ho_AttribImage, out hv_WidthA, out hv_HeightA);
    if ((int)((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(hv_WidthX.TupleNotEqual(
        hv_WidthY))).TupleOr(new HTuple(hv_HeightX.TupleNotEqual(hv_HeightY))))).TupleOr(
        new HTuple(hv_WidthX.TupleNotEqual(hv_WidthZ))))).TupleOr(new HTuple(hv_HeightX.TupleNotEqual(
        hv_HeightZ))))).TupleOr(new HTuple(hv_WidthX.TupleNotEqual(hv_WidthA))))).TupleOr(
        new HTuple(hv_HeightX.TupleNotEqual(hv_HeightA)))) != 0)
    {
      throw new HalconException("Image sizes do not match. The size of all input images must be equal.");
    }
    //
    hv_AvailableAttributes.Dispose();
    HOperatorSet.GetParamInfo("set_object_model_3d_attrib_mod", "AttribName", "value_list", 
        out hv_AvailableAttributes);
    hv_Selection.Dispose();
    HOperatorSet.TupleRegexpSelect(hv_AvailableAttributes, "point_.*", out hv_Selection);
    hv_Difference.Dispose();
    HOperatorSet.TupleDifference(hv_AttribName, hv_Selection, out hv_Difference);
    hv_InvalidParameters.Dispose();
    HOperatorSet.TupleRegexpSelect(hv_Difference, "^[^&]", out hv_InvalidParameters);
    if ((int)(new HTuple((new HTuple(hv_InvalidParameters.TupleLength())).TupleGreater(
        0))) != 0)
    {
      hv_Exception.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Exception = ((("The following attribute names are invalid: "+(((hv_InvalidParameters+new HTuple(", "))).TupleSum()
          ))+new HTuple("please use a '&' prefix for extended attributes, e.g., '&"))+(hv_InvalidParameters.TupleSelect(
          0)))+new HTuple("', or a standard point attribute.");
      }
      throw new HalconException(hv_Exception);
    }
    //
    //Get the domain of the images containing the 3D points and get the region all
    //three of them share. This is because xyz_to_object_model_3d only uses points
    //in the intersecting domains of all three images.
    ho_DomainX.Dispose();
    HOperatorSet.GetDomain(ho_X, out ho_DomainX);
    ho_DomainY.Dispose();
    HOperatorSet.GetDomain(ho_Y, out ho_DomainY);
    ho_DomainZ.Dispose();
    HOperatorSet.GetDomain(ho_Z, out ho_DomainZ);
    ho_RegionIntersectionTmp.Dispose();
    HOperatorSet.Intersection(ho_DomainX, ho_DomainY, out ho_RegionIntersectionTmp
        );
    ho_RegionIntersection.Dispose();
    HOperatorSet.Intersection(ho_RegionIntersectionTmp, ho_DomainZ, out ho_RegionIntersection
        );
    //
    //Transform the images that contain the X, Y, and Z-coordinates to a 3D object model.
    hv_ObjectModel3D.Dispose();
    HOperatorSet.XyzToObjectModel3d(ho_X, ho_Y, ho_Z, out hv_ObjectModel3D);
    //
    //Loop through all channels and collect the corresponding attribute values
    hv_AttribValues.Dispose();
    hv_AttribValues = new HTuple();
    HTuple end_val43 = hv_Channels;
    HTuple step_val43 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val43, step_val43); hv_Index = hv_Index.TupleAdd(step_val43))
    {
      ho_Channel.Dispose();
      HOperatorSet.AccessChannel(ho_AttribImage, out ho_Channel, hv_Index);
      hv_Rows.Dispose();hv_Columns.Dispose();
      HOperatorSet.GetRegionPoints(ho_RegionIntersection, out hv_Rows, out hv_Columns);
      hv_AttribValuesTmp.Dispose();
      HOperatorSet.GetGrayval(ho_Channel, hv_Rows, hv_Columns, out hv_AttribValuesTmp);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_AttribValues = hv_AttribValues.TupleConcat(
          hv_AttribValuesTmp);
      hv_AttribValues.Dispose();
      hv_AttribValues = ExpTmpLocalVar_AttribValues;
      }
      }
    }
    //
    //Set the attributes
    HOperatorSet.SetObjectModel3dAttribMod(hv_ObjectModel3D, hv_AttribName, "points", 
        hv_AttribValues);
    ho_DomainX.Dispose();
    ho_DomainY.Dispose();
    ho_DomainZ.Dispose();
    ho_RegionIntersectionTmp.Dispose();
    ho_RegionIntersection.Dispose();
    ho_Channel.Dispose();

    hv_Number.Dispose();
    hv_Channels.Dispose();
    hv_WidthX.Dispose();
    hv_HeightX.Dispose();
    hv_WidthY.Dispose();
    hv_HeightY.Dispose();
    hv_WidthZ.Dispose();
    hv_HeightZ.Dispose();
    hv_WidthA.Dispose();
    hv_HeightA.Dispose();
    hv_AvailableAttributes.Dispose();
    hv_Selection.Dispose();
    hv_Difference.Dispose();
    hv_InvalidParameters.Dispose();
    hv_Exception.Dispose();
    hv_AttribValues.Dispose();
    hv_Index.Dispose();
    hv_Rows.Dispose();
    hv_Columns.Dispose();
    hv_AttribValuesTmp.Dispose();

    return;
  }



}
